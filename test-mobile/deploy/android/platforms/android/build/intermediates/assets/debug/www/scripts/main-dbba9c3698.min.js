/**
 * test-mobile UI Component
 * @version v0.0.0 - 21/09/2016
 * @author JJ
 * @copyright 2016(c) JJ
 * @license 
 */
!function(e){function r(e,r,o){return 4===arguments.length?t.apply(this,arguments):void n(e,{declarative:!0,deps:r,declare:o})}function t(e,r,t,o){n(e,{declarative:!1,deps:r,executingRequire:t,execute:o})}function n(e,r){r.name=e,e in p||(p[e]=r),r.normalizedDeps=r.deps}function o(e,r){if(r[e.groupIndex]=r[e.groupIndex]||[],-1==v.call(r[e.groupIndex],e)){r[e.groupIndex].push(e);for(var t=0,n=e.normalizedDeps.length;n>t;t++){var a=e.normalizedDeps[t],u=p[a];if(u&&!u.evaluated){var d=e.groupIndex+(u.declarative!=e.declarative);if(void 0===u.groupIndex||u.groupIndex<d){if(void 0!==u.groupIndex&&(r[u.groupIndex].splice(v.call(r[u.groupIndex],u),1),0==r[u.groupIndex].length))throw new TypeError("Mixed dependency cycle detected");u.groupIndex=d}o(u,r)}}}}function a(e){var r=p[e];r.groupIndex=0;var t=[];o(r,t);for(var n=!!r.declarative==t.length%2,a=t.length-1;a>=0;a--){for(var u=t[a],i=0;i<u.length;i++){var s=u[i];n?d(s):l(s)}n=!n}}function u(e){return x[e]||(x[e]={name:e,dependencies:[],exports:{},importers:[]})}function d(r){if(!r.module){var t=r.module=u(r.name),n=r.module.exports,o=r.declare.call(e,function(e,r){if(t.locked=!0,"object"==typeof e)for(var o in e)n[o]=e[o];else n[e]=r;for(var a=0,u=t.importers.length;u>a;a++){var d=t.importers[a];if(!d.locked)for(var i=0;i<d.dependencies.length;++i)d.dependencies[i]===t&&d.setters[i](n)}return t.locked=!1,r},r.name);t.setters=o.setters,t.execute=o.execute;for(var a=0,i=r.normalizedDeps.length;i>a;a++){var l,s=r.normalizedDeps[a],c=p[s],v=x[s];v?l=v.exports:c&&!c.declarative?l=c.esModule:c?(d(c),v=c.module,l=v.exports):l=f(s),v&&v.importers?(v.importers.push(t),t.dependencies.push(v)):t.dependencies.push(null),t.setters[a]&&t.setters[a](l)}}}function i(e){var r,t=p[e];if(t)t.declarative?c(e,[]):t.evaluated||l(t),r=t.module.exports;else if(r=f(e),!r)throw new Error("Unable to load dependency "+e+".");return(!t||t.declarative)&&r&&r.__useDefault?r["default"]:r}function l(r){if(!r.module){var t={},n=r.module={exports:t,id:r.name};if(!r.executingRequire)for(var o=0,a=r.normalizedDeps.length;a>o;o++){var u=r.normalizedDeps[o],d=p[u];d&&l(d)}r.evaluated=!0;var c=r.execute.call(e,function(e){for(var t=0,n=r.deps.length;n>t;t++)if(r.deps[t]==e)return i(r.normalizedDeps[t]);throw new TypeError("Module "+e+" not declared as a dependency.")},t,n);c&&(n.exports=c),t=n.exports,t&&t.__esModule?r.esModule=t:r.esModule=s(t)}}function s(r){if(r===e)return r;var t={};if("object"==typeof r||"function"==typeof r)if(g){var n;for(var o in r)(n=Object.getOwnPropertyDescriptor(r,o))&&h(t,o,n)}else{var a=r&&r.hasOwnProperty;for(var o in r)(!a||r.hasOwnProperty(o))&&(t[o]=r[o])}return t["default"]=r,h(t,"__useDefault",{value:!0}),t}function c(r,t){var n=p[r];if(n&&!n.evaluated&&n.declarative){t.push(r);for(var o=0,a=n.normalizedDeps.length;a>o;o++){var u=n.normalizedDeps[o];-1==v.call(t,u)&&(p[u]?c(u,t):f(u))}n.evaluated||(n.evaluated=!0,n.module.execute.call(e))}}function f(e){if(D[e])return D[e];if("@node/"==e.substr(0,6))return y(e.substr(6));var r=p[e];if(!r)throw"Module "+e+" not present.";return a(e),c(e,[]),p[e]=void 0,r.declarative&&h(r.module.exports,"__esModule",{value:!0}),D[e]=r.declarative?r.module.exports:r.esModule}var p={},v=Array.prototype.indexOf||function(e){for(var r=0,t=this.length;t>r;r++)if(this[r]===e)return r;return-1},g=!0;try{Object.getOwnPropertyDescriptor({a:0},"a")}catch(m){g=!1}var h;!function(){try{Object.defineProperty({},"a",{})&&(h=Object.defineProperty)}catch(e){h=function(e,r,t){try{e[r]=t.value||t.get.call(e)}catch(n){}}}}();var x={},y="undefined"!=typeof System&&System._nodeRequire||"undefined"!=typeof require&&require.resolve&&"undefined"!=typeof process&&require,D={"@empty":{}};return function(e,n,o){return function(a){a(function(a){for(var u={_nodeRequire:y,register:r,registerDynamic:t,get:f,set:function(e,r){D[e]=r},newModule:function(e){return e}},d=0;d<n.length;d++)(function(e,r){r&&r.__esModule?D[e]=r:D[e]=s(r)})(n[d],arguments[d]);o(u);var i=f(e[0]);if(e.length>1)for(var d=1;d<e.length;d++)f(e[d]);return i.__useDefault?i["default"]:i})}}}("undefined"!=typeof self?self:global)

(["1"], [], function($__System) {

!function(e){function r(e,r){for(var n=e.split(".");n.length;)r=r[n.shift()];return r}function n(n){if("string"==typeof n)return r(n,e);if(!(n instanceof Array))throw new Error("Global exports must be a string or array.");for(var t={},o=!0,f=0;f<n.length;f++){var i=r(n[f],e);o&&(t["default"]=i,o=!1),t[n[f].split(".").pop()]=i}return t}function t(r){if(Object.keys)Object.keys(e).forEach(r);else for(var n in e)a.call(e,n)&&r(n)}function o(r){t(function(n){if(-1==l.call(s,n)){try{var t=e[n]}catch(o){s.push(n)}r(n,t)}})}var f,i=$__System,a=Object.prototype.hasOwnProperty,l=Array.prototype.indexOf||function(e){for(var r=0,n=this.length;n>r;r++)if(this[r]===e)return r;return-1},s=["_g","sessionStorage","localStorage","clipboardData","frames","frameElement","external","mozAnimationStartTime","webkitStorageInfo","webkitIndexedDB","mozInnerScreenY","mozInnerScreenX"];i.set("@@global-helpers",i.newModule({prepareGlobal:function(r,t,i){var a=e.define;e.define=void 0;var l;if(i){l={};for(var s in i)l[s]=e[s],e[s]=i[s]}return t||(f={},o(function(e,r){f[e]=r})),function(){var r;if(t)r=n(t);else{r={};var i,s;o(function(e,n){f[e]!==n&&"undefined"!=typeof n&&(r[e]=n,"undefined"!=typeof i?s||i===n||(s=!0):i=n)}),r=s?r:i}if(l)for(var u in l)e[u]=l[u];return e.define=a,r}}}))}("undefined"!=typeof self?self:global);
!function(e){function n(e,n){e=e.replace(l,"");var r=e.match(u),t=(r[1].split(",")[n]||"require").replace(s,""),i=p[t]||(p[t]=new RegExp(a+t+f,"g"));i.lastIndex=0;for(var o,c=[];o=i.exec(e);)c.push(o[2]||o[3]);return c}function r(e,n,t,o){if("object"==typeof e&&!(e instanceof Array))return r.apply(null,Array.prototype.splice.call(arguments,1,arguments.length-1));if("string"==typeof e&&"function"==typeof n&&(e=[e]),!(e instanceof Array)){if("string"==typeof e){var l=i.get(e);return l.__useDefault?l["default"]:l}throw new TypeError("Invalid require")}for(var a=[],f=0;f<e.length;f++)a.push(i["import"](e[f],o));Promise.all(a).then(function(e){n&&n.apply(null,e)},t)}function t(t,l,a){"string"!=typeof t&&(a=l,l=t,t=null),l instanceof Array||(a=l,l=["require","exports","module"].splice(0,a.length)),"function"!=typeof a&&(a=function(e){return function(){return e}}(a)),void 0===l[l.length-1]&&l.pop();var f,u,s;-1!=(f=o.call(l,"require"))&&(l.splice(f,1),t||(l=l.concat(n(a.toString(),f)))),-1!=(u=o.call(l,"exports"))&&l.splice(u,1),-1!=(s=o.call(l,"module"))&&l.splice(s,1);var p={name:t,deps:l,execute:function(n,t,o){for(var p=[],c=0;c<l.length;c++)p.push(n(l[c]));o.uri=o.id,o.config=function(){},-1!=s&&p.splice(s,0,o),-1!=u&&p.splice(u,0,t),-1!=f&&p.splice(f,0,function(e,t,l){return"string"==typeof e&&"function"!=typeof t?n(e):r.call(i,e,t,l,o.id)});var d=a.apply(-1==u?e:t,p);return"undefined"==typeof d&&o&&(d=o.exports),"undefined"!=typeof d?d:void 0}};if(t)c.anonDefine||c.isBundle?c.anonDefine&&c.anonDefine.name&&(c.anonDefine=null):c.anonDefine=p,c.isBundle=!0,i.registerDynamic(p.name,p.deps,!1,p.execute);else{if(c.anonDefine&&!c.anonDefine.name)throw new Error("Multiple anonymous defines in module "+t);c.anonDefine=p}}var i=$__System,o=Array.prototype.indexOf||function(e){for(var n=0,r=this.length;r>n;n++)if(this[n]===e)return n;return-1},l=/(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/gm,a="(?:^|[^$_a-zA-Z\\xA0-\\uFFFF.])",f="\\s*\\(\\s*(\"([^\"]+)\"|'([^']+)')\\s*\\)",u=/\(([^\)]*)\)/,s=/^\s+|\s+$/g,p={};t.amd={};var c={isBundle:!1,anonDefine:null};i.amdDefine=t,i.amdRequire=r}("undefined"!=typeof self?self:global);
$__System.registerDynamic("2", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = {"config": {
      "apiRoute": "/api/",
      "uiLocalhostPort": "5012",
      "serverLocalhostPort": "3000",
      "variedIdName": false,
      "idName": "id",
      "tableNameStandard": "pascalCase",
      "columnNameStandard": "pascalCase",
      "columnMultiWorkStandard": null,
      "idCapitalizeStandard": "pascalCase",
      "routeLowercaseStandard": true,
      "environment": "prototype"
    }};
  return module.exports;
});

$__System.registerDynamic("3", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = {"config": {"environment": "localhost"}};
  return module.exports;
});

$__System.registerDynamic("4", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = "<div id=\"footer\">\r\n    <!--<div class=\"container-fluid text-center\">-->\r\n        <!--Copyright &copy; <span id=\"copyright-year\">{{::vm.copyrightDate | date:'yyyy'}}</span> <a href=\"\" target=\"_blank\"></a>. All rights reserved.-->\r\n        <!--&lt;!&ndash;<a href=\"javascript:void(0);\" mm-scroll-up=\"body\" class=\"pull-right btn-icon btn-circle btn-scroll-to-top fade in\" style=\"margin-top: 11px;\"><i class=\"fa fa-angle-up\"></i></a>&ndash;&gt;-->\r\n    <!--</div>-->\r\n</div>\r\n";
  return module.exports;
});

$__System.register('5', ['4', '6', '7'], function (_export) {
    var template, View, Component, _classCallCheck, Footer;

    return {
        setters: [function (_2) {
            template = _2['default'];
        }, function (_3) {
            View = _3.View;
            Component = _3.Component;
        }, function (_) {
            _classCallCheck = _['default'];
        }],
        execute: function () {
            // jshint unused: false

            //start-non-standard
            'use strict';

            //end-non-standard

            Footer = (function () {
                function Footer() {
                    _classCallCheck(this, _Footer);

                    this.copyrightDate = new Date();
                }

                var _Footer = Footer;
                Footer = View({
                    template: template
                })(Footer) || Footer;
                Footer = Component({
                    selector: 'footer'
                })(Footer) || Footer;
                return Footer;
            })();
        }
    };
});
$__System.registerDynamic("8", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = "<div id=\"header\">\r\n    <div id=\"header-toolbar\">\r\n        <div class=\"md-toolbar-tools\">\r\n            <span id=\"logo\" ng-click=\"vm.goHome()\"></span>\r\n            <span id=\"logo-text\">Scaffi</span>\r\n\r\n\r\n            <header-menu-bar class=\"pull-right\" ></header-menu-bar>\r\n        </div>\r\n\r\n\r\n    </div>\r\n    <div class=\"breadcrumbs\" ncy-breadcrumb></div>\r\n</div>\r\n";
  return module.exports;
});

$__System.register('9', ['6', '7', '8', 'a'], function (_export) {
	var View, Component, Inject, _classCallCheck, template, _createClass, Header;

	return {
		setters: [function (_3) {
			View = _3.View;
			Component = _3.Component;
			Inject = _3.Inject;
		}, function (_) {
			_classCallCheck = _['default'];
		}, function (_2) {
			template = _2['default'];
		}, function (_a) {
			_createClass = _a['default'];
		}],
		execute: function () {
			// jshint unused: false

			//start-non-standard
			'use strict';

			//end-non-standard

			Header = (function () {
				function Header($state, $location) {
					_classCallCheck(this, _Header);

					this.$state = $state;
					this.$location = $location;
				}

				_createClass(Header, [{
					key: 'goHome',
					value: function goHome() {

						this.$location.path('/');
					}
				}]);

				var _Header = Header;
				Header = View({
					template: template
				})(Header) || Header;
				Header = Component({
					selector: 'header'
				})(Header) || Header;
				return Header;
			})();

			_export('default', Header);
		}
	};
});
$__System.registerDynamic("b", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = "<div id=\"theme\" layout=\"column\">\r\n    <header></header>\r\n    <div id=\"theme-body\">\r\n        <routes-side-nav></routes-side-nav>\r\n        <ui-view id=\"layout\" autoscroll=\"true\"></ui-view>\r\n    </div>\r\n    <footer id=\"footer\"></footer>\r\n</div>\r\n\r\n";
  return module.exports;
});

$__System.registerDynamic("c", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = "<!--\r\n          The nav bar that will be updated as we navigate between views.\r\n        -->\r\n<ion-nav-bar class=\"bar-stable\">\r\n    <ion-nav-back-button>\r\n    </ion-nav-back-button>\r\n</ion-nav-bar>\r\n\r\n\r\n<ion-tabs class=\"tabs-icon-top tabs-color-active-positive\">\r\n\r\n    <!-- Dashboard Tab -->\r\n    <ion-tab title=\"Status\" icon-off=\"ion-ios-pulse\" icon-on=\"ion-ios-pulse-strong\" ui-sref=\"app\">\r\n\r\n    </ion-tab>\r\n\r\n    <!-- Account Tab -->\r\n    <ion-tab title=\"Account\" icon-off=\"ion-ios-gear-outline\" icon-on=\"ion-ios-gear\" ui-sref=\"app.account\">\r\n\r\n    </ion-tab>\r\n\r\n\r\n</ion-tabs>\r\n\r\n<!--\r\n  The views will be rendered in the <ion-nav-view> directive below\r\n  Templates are in the /templates folder (but you could also\r\n  have templates inline in this html file if you'd like).\r\n-->\r\n<ion-nav-view class=\"slide-left-right\"></ion-nav-view>\r\n";
  return module.exports;
});

$__System.register('d', ['6', '7', 'b', 'c'], function (_export) {
	var RouteConfig, _classCallCheck, template, templateMobile, Layout;

	return {
		setters: [function (_2) {
			RouteConfig = _2.RouteConfig;
		}, function (_) {
			_classCallCheck = _['default'];
		}, function (_b) {
			template = _b['default'];
		}, function (_c) {
			templateMobile = _c['default'];
		}],
		execute: function () {

			//start-non-standard
			// jshint unused: false
			'use strict';

			//end-non-standard

			Layout = (function () {
				function Layout($state) {
					_classCallCheck(this, _Layout);

					this.$state = $state;
				}

				var _Layout = Layout;
				Layout = RouteConfig('app', {
					url: '',
					abstract: true,
					template: templateMobile,
					redirectTo: "app.index",
					resolve: {}
				})(Layout) || Layout;
				return Layout;
			})();
		}
	};
});
$__System.registerDynamic("e", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = "<div class=\"container-fluid\">\r\n    <div class=\"error-page\">\r\n        <div class=\"error-code mb10\">{{vm.params.errorType}} <i class=\"fa fa-warning\" style=\"cursor: pointer;\" ng-click=\"vm.showStack = !vm.showStack\"></i></div>\r\n        <div class=\"error-content\">\r\n            <div class=\"error-message\">{{vm.params.message}}<br><br></div>\r\n            <pre class=\"error-desc mb20\" ng-if=\"vm.showStack\">\r\n                {{vm.params.stack}}\r\n            </pre>\r\n            <div ng-if=\"vm.params.statusCode < 400 || vm.params.statusCode > 499\">\r\n                <a href=\"/\" class=\"btn btn-success\">Go Back to Home Page</a>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</div>\r\n";
  return module.exports;
});

$__System.register('f', ['6', '7', '10', 'e'], function (_export) {
    var RouteConfig, _classCallCheck, _, templateError, Error;

    return {
        setters: [function (_3) {
            RouteConfig = _3.RouteConfig;
        }, function (_2) {
            _classCallCheck = _2['default'];
        }, function (_4) {
            _ = _4['default'];
        }, function (_e) {
            templateError = _e['default'];
        }],
        execute: function () {

            //start-non-standard
            // jshint unused: false
            'use strict';

            //end-non-standard

            Error = (function () {
                function Error($state) {
                    _classCallCheck(this, _Error);

                    this.params = $state.params;
                    this.params.errorType = _.startCase(this.params.errorType);
                    if (this.params.stack) {
                        this.params.stack = JSON.stringify(this.params.stack, null, '\t');
                    }
                }

                var _Error = Error;
                Error = RouteConfig('error', {
                    url: '/error',
                    template: templateError,
                    params: {
                        errorType: "error",
                        statusCode: 500,
                        stack: null,
                        message: "Unknown Error"
                    }
                })(Error) || Error;
                return Error;
            })();
        }
    };
});
$__System.registerDynamic("11", [], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {})();
  return _retrieveGlobal();
});

$__System.registerDynamic("12", [], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    "format global";
    (function() {
      window.ionic = window.ionic || {};
      window.ionic.views = {};
      window.ionic.version = '1.3.0';
      (function(ionic) {
        ionic.DelegateService = function(methodNames) {
          if (methodNames.indexOf('$getByHandle') > -1) {
            throw new Error("Method '$getByHandle' is implicitly added to each delegate service. Do not list it as a method.");
          }
          function trueFn() {
            return true;
          }
          return ['$log', function($log) {
            function DelegateInstance(instances, handle) {
              this._instances = instances;
              this.handle = handle;
            }
            methodNames.forEach(function(methodName) {
              DelegateInstance.prototype[methodName] = instanceMethodCaller(methodName);
            });
            function DelegateService() {
              this._instances = [];
            }
            DelegateService.prototype = DelegateInstance.prototype;
            DelegateService.prototype._registerInstance = function(instance, handle, filterFn) {
              var instances = this._instances;
              instance.$$delegateHandle = handle;
              instance.$$filterFn = filterFn || trueFn;
              instances.push(instance);
              return function deregister() {
                var index = instances.indexOf(instance);
                if (index !== -1) {
                  instances.splice(index, 1);
                }
              };
            };
            DelegateService.prototype.$getByHandle = function(handle) {
              return new DelegateInstance(this._instances, handle);
            };
            return new DelegateService();
            function instanceMethodCaller(methodName) {
              return function caller() {
                var handle = this.handle;
                var args = arguments;
                var foundInstancesCount = 0;
                var returnValue;
                this._instances.forEach(function(instance) {
                  if ((!handle || handle == instance.$$delegateHandle) && instance.$$filterFn(instance)) {
                    foundInstancesCount++;
                    var ret = instance[methodName].apply(instance, args);
                    if (foundInstancesCount === 1) {
                      returnValue = ret;
                    }
                  }
                });
                if (!foundInstancesCount && handle) {
                  return $log.warn('Delegate for handle "' + handle + '" could not find a ' + 'corresponding element with delegate-handle="' + handle + '"! ' + methodName + '() was not called!\n' + 'Possible cause: If you are calling ' + methodName + '() immediately, and ' + 'your element with delegate-handle="' + handle + '" is a child of your ' + 'controller, then your element may not be compiled yet. Put a $timeout ' + 'around your call to ' + methodName + '() and try again.');
                }
                return returnValue;
              };
            }
          }];
        };
      })(window.ionic);
      (function(window, document, ionic) {
        var readyCallbacks = [];
        var isDomReady = document.readyState === 'complete' || document.readyState === 'interactive';
        function domReady() {
          isDomReady = true;
          for (var x = 0; x < readyCallbacks.length; x++) {
            ionic.requestAnimationFrame(readyCallbacks[x]);
          }
          readyCallbacks = [];
          document.removeEventListener('DOMContentLoaded', domReady);
        }
        if (!isDomReady) {
          document.addEventListener('DOMContentLoaded', domReady);
        }
        window._rAF = (function() {
          return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback) {
            window.setTimeout(callback, 16);
          };
        })();
        var cancelAnimationFrame = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelRequestAnimationFrame;
        ionic.DomUtil = {
          requestAnimationFrame: function(cb) {
            return window._rAF(cb);
          },
          cancelAnimationFrame: function(requestId) {
            cancelAnimationFrame(requestId);
          },
          animationFrameThrottle: function(cb) {
            var args,
                isQueued,
                context;
            return function() {
              args = arguments;
              context = this;
              if (!isQueued) {
                isQueued = true;
                ionic.requestAnimationFrame(function() {
                  cb.apply(context, args);
                  isQueued = false;
                });
              }
            };
          },
          contains: function(parentNode, otherNode) {
            var current = otherNode;
            while (current) {
              if (current === parentNode)
                return true;
              current = current.parentNode;
            }
          },
          getPositionInParent: function(el) {
            return {
              left: el.offsetLeft,
              top: el.offsetTop
            };
          },
          getOffsetTop: function(el) {
            var curtop = 0;
            if (el.offsetParent) {
              do {
                curtop += el.offsetTop;
                el = el.offsetParent;
              } while (el);
              return curtop;
            }
          },
          ready: function(cb) {
            if (isDomReady) {
              ionic.requestAnimationFrame(cb);
            } else {
              readyCallbacks.push(cb);
            }
          },
          getTextBounds: function(textNode) {
            if (document.createRange) {
              var range = document.createRange();
              range.selectNodeContents(textNode);
              if (range.getBoundingClientRect) {
                var rect = range.getBoundingClientRect();
                if (rect) {
                  var sx = window.scrollX;
                  var sy = window.scrollY;
                  return {
                    top: rect.top + sy,
                    left: rect.left + sx,
                    right: rect.left + sx + rect.width,
                    bottom: rect.top + sy + rect.height,
                    width: rect.width,
                    height: rect.height
                  };
                }
              }
            }
            return null;
          },
          getChildIndex: function(element, type) {
            if (type) {
              var ch = element.parentNode.children;
              var c;
              for (var i = 0,
                  k = 0,
                  j = ch.length; i < j; i++) {
                c = ch[i];
                if (c.nodeName && c.nodeName.toLowerCase() == type) {
                  if (c == element) {
                    return k;
                  }
                  k++;
                }
              }
            }
            return Array.prototype.slice.call(element.parentNode.children).indexOf(element);
          },
          swapNodes: function(src, dest) {
            dest.parentNode.insertBefore(src, dest);
          },
          elementIsDescendant: function(el, parent, stopAt) {
            var current = el;
            do {
              if (current === parent)
                return true;
              current = current.parentNode;
            } while (current && current !== stopAt);
            return false;
          },
          getParentWithClass: function(e, className, depth) {
            depth = depth || 10;
            while (e.parentNode && depth--) {
              if (e.parentNode.classList && e.parentNode.classList.contains(className)) {
                return e.parentNode;
              }
              e = e.parentNode;
            }
            return null;
          },
          getParentOrSelfWithClass: function(e, className, depth) {
            depth = depth || 10;
            while (e && depth--) {
              if (e.classList && e.classList.contains(className)) {
                return e;
              }
              e = e.parentNode;
            }
            return null;
          },
          rectContains: function(x, y, x1, y1, x2, y2) {
            if (x < x1 || x > x2)
              return false;
            if (y < y1 || y > y2)
              return false;
            return true;
          },
          blurAll: function() {
            if (document.activeElement && document.activeElement != document.body) {
              document.activeElement.blur();
              return document.activeElement;
            }
            return null;
          },
          cachedAttr: function(ele, key, value) {
            ele = ele && ele.length && ele[0] || ele;
            if (ele && ele.setAttribute) {
              var dataKey = '$attr-' + key;
              if (arguments.length > 2) {
                if (ele[dataKey] !== value) {
                  ele.setAttribute(key, value);
                  ele[dataKey] = value;
                }
              } else if (typeof ele[dataKey] == 'undefined') {
                ele[dataKey] = ele.getAttribute(key);
              }
              return ele[dataKey];
            }
          },
          cachedStyles: function(ele, styles) {
            ele = ele && ele.length && ele[0] || ele;
            if (ele && ele.style) {
              for (var prop in styles) {
                if (ele['$style-' + prop] !== styles[prop]) {
                  ele.style[prop] = ele['$style-' + prop] = styles[prop];
                }
              }
            }
          }
        };
        ionic.requestAnimationFrame = ionic.DomUtil.requestAnimationFrame;
        ionic.cancelAnimationFrame = ionic.DomUtil.cancelAnimationFrame;
        ionic.animationFrameThrottle = ionic.DomUtil.animationFrameThrottle;
      })(window, document, ionic);
      (function(ionic) {
        ionic.CustomEvent = (function() {
          if (typeof window.CustomEvent === 'function')
            return CustomEvent;
          var customEvent = function(event, params) {
            var evt;
            params = params || {
              bubbles: false,
              cancelable: false,
              detail: undefined
            };
            try {
              evt = document.createEvent("CustomEvent");
              evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
            } catch (error) {
              evt = document.createEvent("Event");
              for (var param in params) {
                evt[param] = params[param];
              }
              evt.initEvent(event, params.bubbles, params.cancelable);
            }
            return evt;
          };
          customEvent.prototype = window.Event.prototype;
          return customEvent;
        })();
        ionic.EventController = {
          VIRTUALIZED_EVENTS: ['tap', 'swipe', 'swiperight', 'swipeleft', 'drag', 'hold', 'release'],
          trigger: function(eventType, data, bubbles, cancelable) {
            var event = new ionic.CustomEvent(eventType, {
              detail: data,
              bubbles: !!bubbles,
              cancelable: !!cancelable
            });
            data && data.target && data.target.dispatchEvent && data.target.dispatchEvent(event) || window.dispatchEvent(event);
          },
          on: function(type, callback, element) {
            var e = element || window;
            for (var i = 0,
                j = this.VIRTUALIZED_EVENTS.length; i < j; i++) {
              if (type == this.VIRTUALIZED_EVENTS[i]) {
                var gesture = new ionic.Gesture(element);
                gesture.on(type, callback);
                return gesture;
              }
            }
            e.addEventListener(type, callback);
          },
          off: function(type, callback, element) {
            element.removeEventListener(type, callback);
          },
          onGesture: function(type, callback, element, options) {
            var gesture = new ionic.Gesture(element, options);
            gesture.on(type, callback);
            return gesture;
          },
          offGesture: function(gesture, type, callback) {
            gesture && gesture.off(type, callback);
          },
          handlePopState: function() {}
        };
        ionic.on = function() {
          ionic.EventController.on.apply(ionic.EventController, arguments);
        };
        ionic.off = function() {
          ionic.EventController.off.apply(ionic.EventController, arguments);
        };
        ionic.trigger = ionic.EventController.trigger;
        ionic.onGesture = function() {
          return ionic.EventController.onGesture.apply(ionic.EventController.onGesture, arguments);
        };
        ionic.offGesture = function() {
          return ionic.EventController.offGesture.apply(ionic.EventController.offGesture, arguments);
        };
      })(window.ionic);
      (function(ionic) {
        ionic.Gesture = function(element, options) {
          return new ionic.Gestures.Instance(element, options || {});
        };
        ionic.Gestures = {};
        ionic.Gestures.defaults = {stop_browser_behavior: 'disable-user-behavior'};
        ionic.Gestures.HAS_POINTEREVENTS = window.navigator.pointerEnabled || window.navigator.msPointerEnabled;
        ionic.Gestures.HAS_TOUCHEVENTS = ('ontouchstart' in window);
        ionic.Gestures.MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android|silk/i;
        ionic.Gestures.NO_MOUSEEVENTS = ionic.Gestures.HAS_TOUCHEVENTS && window.navigator.userAgent.match(ionic.Gestures.MOBILE_REGEX);
        ionic.Gestures.EVENT_TYPES = {};
        ionic.Gestures.DIRECTION_DOWN = 'down';
        ionic.Gestures.DIRECTION_LEFT = 'left';
        ionic.Gestures.DIRECTION_UP = 'up';
        ionic.Gestures.DIRECTION_RIGHT = 'right';
        ionic.Gestures.POINTER_MOUSE = 'mouse';
        ionic.Gestures.POINTER_TOUCH = 'touch';
        ionic.Gestures.POINTER_PEN = 'pen';
        ionic.Gestures.EVENT_START = 'start';
        ionic.Gestures.EVENT_MOVE = 'move';
        ionic.Gestures.EVENT_END = 'end';
        ionic.Gestures.DOCUMENT = window.document;
        ionic.Gestures.plugins = {};
        ionic.Gestures.READY = false;
        function setup() {
          if (ionic.Gestures.READY) {
            return;
          }
          ionic.Gestures.event.determineEventTypes();
          for (var name in ionic.Gestures.gestures) {
            if (ionic.Gestures.gestures.hasOwnProperty(name)) {
              ionic.Gestures.detection.register(ionic.Gestures.gestures[name]);
            }
          }
          ionic.Gestures.event.onTouch(ionic.Gestures.DOCUMENT, ionic.Gestures.EVENT_MOVE, ionic.Gestures.detection.detect);
          ionic.Gestures.event.onTouch(ionic.Gestures.DOCUMENT, ionic.Gestures.EVENT_END, ionic.Gestures.detection.detect);
          ionic.Gestures.READY = true;
        }
        ionic.Gestures.Instance = function(element, options) {
          var self = this;
          if (element === null) {
            void 0;
            return this;
          }
          setup();
          this.element = element;
          this.enabled = true;
          this.options = ionic.Gestures.utils.extend(ionic.Gestures.utils.extend({}, ionic.Gestures.defaults), options || {});
          if (this.options.stop_browser_behavior) {
            ionic.Gestures.utils.stopDefaultBrowserBehavior(this.element, this.options.stop_browser_behavior);
          }
          ionic.Gestures.event.onTouch(element, ionic.Gestures.EVENT_START, function(ev) {
            if (self.enabled) {
              ionic.Gestures.detection.startDetect(self, ev);
            }
          });
          return this;
        };
        ionic.Gestures.Instance.prototype = {
          on: function onEvent(gesture, handler) {
            var gestures = gesture.split(' ');
            for (var t = 0; t < gestures.length; t++) {
              this.element.addEventListener(gestures[t], handler, false);
            }
            return this;
          },
          off: function offEvent(gesture, handler) {
            var gestures = gesture.split(' ');
            for (var t = 0; t < gestures.length; t++) {
              this.element.removeEventListener(gestures[t], handler, false);
            }
            return this;
          },
          trigger: function triggerEvent(gesture, eventData) {
            var event = ionic.Gestures.DOCUMENT.createEvent('Event');
            event.initEvent(gesture, true, true);
            event.gesture = eventData;
            var element = this.element;
            if (ionic.Gestures.utils.hasParent(eventData.target, element)) {
              element = eventData.target;
            }
            element.dispatchEvent(event);
            return this;
          },
          enable: function enable(state) {
            this.enabled = state;
            return this;
          }
        };
        var last_move_event = null;
        var enable_detect = false;
        var touch_triggered = false;
        ionic.Gestures.event = {
          bindDom: function(element, type, handler) {
            var types = type.split(' ');
            for (var t = 0; t < types.length; t++) {
              element.addEventListener(types[t], handler, false);
            }
          },
          onTouch: function onTouch(element, eventType, handler) {
            var self = this;
            this.bindDom(element, ionic.Gestures.EVENT_TYPES[eventType], function bindDomOnTouch(ev) {
              var sourceEventType = ev.type.toLowerCase();
              if (sourceEventType.match(/mouse/) && touch_triggered) {
                return;
              } else if (sourceEventType.match(/touch/) || sourceEventType.match(/pointerdown/) || (sourceEventType.match(/mouse/) && ev.which === 1)) {
                enable_detect = true;
              } else if (sourceEventType.match(/mouse/) && ev.which !== 1) {
                enable_detect = false;
              }
              if (sourceEventType.match(/touch|pointer/)) {
                touch_triggered = true;
              }
              var count_touches = 0;
              if (enable_detect) {
                if (ionic.Gestures.HAS_POINTEREVENTS && eventType != ionic.Gestures.EVENT_END) {
                  count_touches = ionic.Gestures.PointerEvent.updatePointer(eventType, ev);
                } else if (sourceEventType.match(/touch/)) {
                  count_touches = ev.touches.length;
                } else if (!touch_triggered) {
                  count_touches = sourceEventType.match(/up/) ? 0 : 1;
                }
                if (count_touches > 0 && eventType == ionic.Gestures.EVENT_END) {
                  eventType = ionic.Gestures.EVENT_MOVE;
                } else if (!count_touches) {
                  eventType = ionic.Gestures.EVENT_END;
                }
                if (count_touches || last_move_event === null) {
                  last_move_event = ev;
                }
                handler.call(ionic.Gestures.detection, self.collectEventData(element, eventType, self.getTouchList(last_move_event, eventType), ev));
                if (ionic.Gestures.HAS_POINTEREVENTS && eventType == ionic.Gestures.EVENT_END) {
                  count_touches = ionic.Gestures.PointerEvent.updatePointer(eventType, ev);
                }
              }
              if (!count_touches) {
                last_move_event = null;
                enable_detect = false;
                touch_triggered = false;
                ionic.Gestures.PointerEvent.reset();
              }
            });
          },
          determineEventTypes: function determineEventTypes() {
            var types;
            if (ionic.Gestures.HAS_POINTEREVENTS) {
              types = ionic.Gestures.PointerEvent.getEvents();
            } else if (ionic.Gestures.NO_MOUSEEVENTS) {
              types = ['touchstart', 'touchmove', 'touchend touchcancel'];
            } else {
              types = ['touchstart mousedown', 'touchmove mousemove', 'touchend touchcancel mouseup'];
            }
            ionic.Gestures.EVENT_TYPES[ionic.Gestures.EVENT_START] = types[0];
            ionic.Gestures.EVENT_TYPES[ionic.Gestures.EVENT_MOVE] = types[1];
            ionic.Gestures.EVENT_TYPES[ionic.Gestures.EVENT_END] = types[2];
          },
          getTouchList: function getTouchList(ev) {
            if (ionic.Gestures.HAS_POINTEREVENTS) {
              return ionic.Gestures.PointerEvent.getTouchList();
            } else if (ev.touches) {
              return ev.touches;
            } else {
              ev.identifier = 1;
              return [ev];
            }
          },
          collectEventData: function collectEventData(element, eventType, touches, ev) {
            var pointerType = ionic.Gestures.POINTER_TOUCH;
            if (ev.type.match(/mouse/) || ionic.Gestures.PointerEvent.matchType(ionic.Gestures.POINTER_MOUSE, ev)) {
              pointerType = ionic.Gestures.POINTER_MOUSE;
            }
            return {
              center: ionic.Gestures.utils.getCenter(touches),
              timeStamp: new Date().getTime(),
              target: ev.target,
              touches: touches,
              eventType: eventType,
              pointerType: pointerType,
              srcEvent: ev,
              preventDefault: function() {
                if (this.srcEvent.preventManipulation) {
                  this.srcEvent.preventManipulation();
                }
                if (this.srcEvent.preventDefault) {}
              },
              stopPropagation: function() {
                this.srcEvent.stopPropagation();
              },
              stopDetect: function() {
                return ionic.Gestures.detection.stopDetect();
              }
            };
          }
        };
        ionic.Gestures.PointerEvent = {
          pointers: {},
          getTouchList: function() {
            var self = this;
            var touchlist = [];
            Object.keys(self.pointers).sort().forEach(function(id) {
              touchlist.push(self.pointers[id]);
            });
            return touchlist;
          },
          updatePointer: function(type, pointerEvent) {
            if (type == ionic.Gestures.EVENT_END) {
              this.pointers = {};
            } else {
              pointerEvent.identifier = pointerEvent.pointerId;
              this.pointers[pointerEvent.pointerId] = pointerEvent;
            }
            return Object.keys(this.pointers).length;
          },
          matchType: function(pointerType, ev) {
            if (!ev.pointerType) {
              return false;
            }
            var types = {};
            types[ionic.Gestures.POINTER_MOUSE] = (ev.pointerType == ev.MSPOINTER_TYPE_MOUSE || ev.pointerType == ionic.Gestures.POINTER_MOUSE);
            types[ionic.Gestures.POINTER_TOUCH] = (ev.pointerType == ev.MSPOINTER_TYPE_TOUCH || ev.pointerType == ionic.Gestures.POINTER_TOUCH);
            types[ionic.Gestures.POINTER_PEN] = (ev.pointerType == ev.MSPOINTER_TYPE_PEN || ev.pointerType == ionic.Gestures.POINTER_PEN);
            return types[pointerType];
          },
          getEvents: function() {
            return ['pointerdown MSPointerDown', 'pointermove MSPointerMove', 'pointerup pointercancel MSPointerUp MSPointerCancel'];
          },
          reset: function() {
            this.pointers = {};
          }
        };
        ionic.Gestures.utils = {
          extend: function extend(dest, src, merge) {
            for (var key in src) {
              if (dest[key] !== undefined && merge) {
                continue;
              }
              dest[key] = src[key];
            }
            return dest;
          },
          hasParent: function(node, parent) {
            while (node) {
              if (node == parent) {
                return true;
              }
              node = node.parentNode;
            }
            return false;
          },
          getCenter: function getCenter(touches) {
            var valuesX = [],
                valuesY = [];
            for (var t = 0,
                len = touches.length; t < len; t++) {
              valuesX.push(touches[t].pageX);
              valuesY.push(touches[t].pageY);
            }
            return {
              pageX: ((Math.min.apply(Math, valuesX) + Math.max.apply(Math, valuesX)) / 2),
              pageY: ((Math.min.apply(Math, valuesY) + Math.max.apply(Math, valuesY)) / 2)
            };
          },
          getVelocity: function getVelocity(delta_time, delta_x, delta_y) {
            return {
              x: Math.abs(delta_x / delta_time) || 0,
              y: Math.abs(delta_y / delta_time) || 0
            };
          },
          getAngle: function getAngle(touch1, touch2) {
            var y = touch2.pageY - touch1.pageY,
                x = touch2.pageX - touch1.pageX;
            return Math.atan2(y, x) * 180 / Math.PI;
          },
          getDirection: function getDirection(touch1, touch2) {
            var x = Math.abs(touch1.pageX - touch2.pageX),
                y = Math.abs(touch1.pageY - touch2.pageY);
            if (x >= y) {
              return touch1.pageX - touch2.pageX > 0 ? ionic.Gestures.DIRECTION_LEFT : ionic.Gestures.DIRECTION_RIGHT;
            } else {
              return touch1.pageY - touch2.pageY > 0 ? ionic.Gestures.DIRECTION_UP : ionic.Gestures.DIRECTION_DOWN;
            }
          },
          getDistance: function getDistance(touch1, touch2) {
            var x = touch2.pageX - touch1.pageX,
                y = touch2.pageY - touch1.pageY;
            return Math.sqrt((x * x) + (y * y));
          },
          getScale: function getScale(start, end) {
            if (start.length >= 2 && end.length >= 2) {
              return this.getDistance(end[0], end[1]) / this.getDistance(start[0], start[1]);
            }
            return 1;
          },
          getRotation: function getRotation(start, end) {
            if (start.length >= 2 && end.length >= 2) {
              return this.getAngle(end[1], end[0]) - this.getAngle(start[1], start[0]);
            }
            return 0;
          },
          isVertical: function isVertical(direction) {
            return (direction == ionic.Gestures.DIRECTION_UP || direction == ionic.Gestures.DIRECTION_DOWN);
          },
          stopDefaultBrowserBehavior: function stopDefaultBrowserBehavior(element, css_class) {
            if (element && element.classList) {
              element.classList.add(css_class);
              element.onselectstart = function() {
                return false;
              };
            }
          }
        };
        ionic.Gestures.detection = {
          gestures: [],
          current: null,
          previous: null,
          stopped: false,
          startDetect: function startDetect(inst, eventData) {
            if (this.current) {
              return;
            }
            this.stopped = false;
            this.current = {
              inst: inst,
              startEvent: ionic.Gestures.utils.extend({}, eventData),
              lastEvent: false,
              name: ''
            };
            this.detect(eventData);
          },
          detect: function detect(eventData) {
            if (!this.current || this.stopped) {
              return null;
            }
            eventData = this.extendEventData(eventData);
            var inst_options = this.current.inst.options;
            for (var g = 0,
                len = this.gestures.length; g < len; g++) {
              var gesture = this.gestures[g];
              if (!this.stopped && inst_options[gesture.name] !== false) {
                if (gesture.handler.call(gesture, eventData, this.current.inst) === false) {
                  this.stopDetect();
                  break;
                }
              }
            }
            if (this.current) {
              this.current.lastEvent = eventData;
            }
            if (eventData.eventType == ionic.Gestures.EVENT_END && !eventData.touches.length - 1) {
              this.stopDetect();
            }
            return eventData;
          },
          stopDetect: function stopDetect() {
            this.previous = ionic.Gestures.utils.extend({}, this.current);
            this.current = null;
            this.stopped = true;
          },
          extendEventData: function extendEventData(ev) {
            var startEv = this.current.startEvent;
            if (startEv && (ev.touches.length != startEv.touches.length || ev.touches === startEv.touches)) {
              startEv.touches = [];
              for (var i = 0,
                  len = ev.touches.length; i < len; i++) {
                startEv.touches.push(ionic.Gestures.utils.extend({}, ev.touches[i]));
              }
            }
            var delta_time = ev.timeStamp - startEv.timeStamp,
                delta_x = ev.center.pageX - startEv.center.pageX,
                delta_y = ev.center.pageY - startEv.center.pageY,
                velocity = ionic.Gestures.utils.getVelocity(delta_time, delta_x, delta_y);
            ionic.Gestures.utils.extend(ev, {
              deltaTime: delta_time,
              deltaX: delta_x,
              deltaY: delta_y,
              velocityX: velocity.x,
              velocityY: velocity.y,
              distance: ionic.Gestures.utils.getDistance(startEv.center, ev.center),
              angle: ionic.Gestures.utils.getAngle(startEv.center, ev.center),
              direction: ionic.Gestures.utils.getDirection(startEv.center, ev.center),
              scale: ionic.Gestures.utils.getScale(startEv.touches, ev.touches),
              rotation: ionic.Gestures.utils.getRotation(startEv.touches, ev.touches),
              startEvent: startEv
            });
            return ev;
          },
          register: function register(gesture) {
            var options = gesture.defaults || {};
            if (options[gesture.name] === undefined) {
              options[gesture.name] = true;
            }
            ionic.Gestures.utils.extend(ionic.Gestures.defaults, options, true);
            gesture.index = gesture.index || 1000;
            this.gestures.push(gesture);
            this.gestures.sort(function(a, b) {
              if (a.index < b.index) {
                return -1;
              }
              if (a.index > b.index) {
                return 1;
              }
              return 0;
            });
            return this.gestures;
          }
        };
        ionic.Gestures.gestures = ionic.Gestures.gestures || {};
        ionic.Gestures.gestures.Hold = {
          name: 'hold',
          index: 10,
          defaults: {
            hold_timeout: 500,
            hold_threshold: 9
          },
          timer: null,
          handler: function holdGesture(ev, inst) {
            switch (ev.eventType) {
              case ionic.Gestures.EVENT_START:
                clearTimeout(this.timer);
                ionic.Gestures.detection.current.name = this.name;
                this.timer = setTimeout(function() {
                  if (ionic.Gestures.detection.current.name == 'hold') {
                    ionic.tap.cancelClick();
                    inst.trigger('hold', ev);
                  }
                }, inst.options.hold_timeout);
                break;
              case ionic.Gestures.EVENT_MOVE:
                if (ev.distance > inst.options.hold_threshold) {
                  clearTimeout(this.timer);
                }
                break;
              case ionic.Gestures.EVENT_END:
                clearTimeout(this.timer);
                break;
            }
          }
        };
        ionic.Gestures.gestures.Tap = {
          name: 'tap',
          index: 100,
          defaults: {
            tap_max_touchtime: 250,
            tap_max_distance: 10,
            tap_always: true,
            doubletap_distance: 20,
            doubletap_interval: 300
          },
          handler: function tapGesture(ev, inst) {
            if (ev.eventType == ionic.Gestures.EVENT_END && ev.srcEvent.type != 'touchcancel') {
              var prev = ionic.Gestures.detection.previous,
                  did_doubletap = false;
              if (ev.deltaTime > inst.options.tap_max_touchtime || ev.distance > inst.options.tap_max_distance) {
                return;
              }
              if (prev && prev.name == 'tap' && (ev.timeStamp - prev.lastEvent.timeStamp) < inst.options.doubletap_interval && ev.distance < inst.options.doubletap_distance) {
                inst.trigger('doubletap', ev);
                did_doubletap = true;
              }
              if (!did_doubletap || inst.options.tap_always) {
                ionic.Gestures.detection.current.name = 'tap';
                inst.trigger('tap', ev);
              }
            }
          }
        };
        ionic.Gestures.gestures.Swipe = {
          name: 'swipe',
          index: 40,
          defaults: {
            swipe_max_touches: 1,
            swipe_velocity: 0.4
          },
          handler: function swipeGesture(ev, inst) {
            if (ev.eventType == ionic.Gestures.EVENT_END) {
              if (inst.options.swipe_max_touches > 0 && ev.touches.length > inst.options.swipe_max_touches) {
                return;
              }
              if (ev.velocityX > inst.options.swipe_velocity || ev.velocityY > inst.options.swipe_velocity) {
                inst.trigger(this.name, ev);
                inst.trigger(this.name + ev.direction, ev);
              }
            }
          }
        };
        ionic.Gestures.gestures.Drag = {
          name: 'drag',
          index: 50,
          defaults: {
            drag_min_distance: 10,
            correct_for_drag_min_distance: true,
            drag_max_touches: 1,
            drag_block_horizontal: true,
            drag_block_vertical: true,
            drag_lock_to_axis: false,
            drag_lock_min_distance: 25,
            prevent_default_directions: []
          },
          triggered: false,
          handler: function dragGesture(ev, inst) {
            if (ev.srcEvent.type == 'touchstart' || ev.srcEvent.type == 'touchend') {
              this.preventedFirstMove = false;
            } else if (!this.preventedFirstMove && ev.srcEvent.type == 'touchmove') {
              if (inst.options.prevent_default_directions.length > 0 && inst.options.prevent_default_directions.indexOf(ev.direction) != -1) {
                ev.srcEvent.preventDefault();
              }
              this.preventedFirstMove = true;
            }
            if (ionic.Gestures.detection.current.name != this.name && this.triggered) {
              inst.trigger(this.name + 'end', ev);
              this.triggered = false;
              return;
            }
            if (inst.options.drag_max_touches > 0 && ev.touches.length > inst.options.drag_max_touches) {
              return;
            }
            switch (ev.eventType) {
              case ionic.Gestures.EVENT_START:
                this.triggered = false;
                break;
              case ionic.Gestures.EVENT_MOVE:
                if (ev.distance < inst.options.drag_min_distance && ionic.Gestures.detection.current.name != this.name) {
                  return;
                }
                if (ionic.Gestures.detection.current.name != this.name) {
                  ionic.Gestures.detection.current.name = this.name;
                  if (inst.options.correct_for_drag_min_distance) {
                    var factor = Math.abs(inst.options.drag_min_distance / ev.distance);
                    ionic.Gestures.detection.current.startEvent.center.pageX += ev.deltaX * factor;
                    ionic.Gestures.detection.current.startEvent.center.pageY += ev.deltaY * factor;
                    ev = ionic.Gestures.detection.extendEventData(ev);
                  }
                }
                if (ionic.Gestures.detection.current.lastEvent.drag_locked_to_axis || (inst.options.drag_lock_to_axis && inst.options.drag_lock_min_distance <= ev.distance)) {
                  ev.drag_locked_to_axis = true;
                }
                var last_direction = ionic.Gestures.detection.current.lastEvent.direction;
                if (ev.drag_locked_to_axis && last_direction !== ev.direction) {
                  if (ionic.Gestures.utils.isVertical(last_direction)) {
                    ev.direction = (ev.deltaY < 0) ? ionic.Gestures.DIRECTION_UP : ionic.Gestures.DIRECTION_DOWN;
                  } else {
                    ev.direction = (ev.deltaX < 0) ? ionic.Gestures.DIRECTION_LEFT : ionic.Gestures.DIRECTION_RIGHT;
                  }
                }
                if (!this.triggered) {
                  inst.trigger(this.name + 'start', ev);
                  this.triggered = true;
                }
                inst.trigger(this.name, ev);
                inst.trigger(this.name + ev.direction, ev);
                if ((inst.options.drag_block_vertical && ionic.Gestures.utils.isVertical(ev.direction)) || (inst.options.drag_block_horizontal && !ionic.Gestures.utils.isVertical(ev.direction))) {
                  ev.preventDefault();
                }
                break;
              case ionic.Gestures.EVENT_END:
                if (this.triggered) {
                  inst.trigger(this.name + 'end', ev);
                }
                this.triggered = false;
                break;
            }
          }
        };
        ionic.Gestures.gestures.Transform = {
          name: 'transform',
          index: 45,
          defaults: {
            transform_min_scale: 0.01,
            transform_min_rotation: 1,
            transform_always_block: false
          },
          triggered: false,
          handler: function transformGesture(ev, inst) {
            if (ionic.Gestures.detection.current.name != this.name && this.triggered) {
              inst.trigger(this.name + 'end', ev);
              this.triggered = false;
              return;
            }
            if (ev.touches.length < 2) {
              return;
            }
            if (inst.options.transform_always_block) {
              ev.preventDefault();
            }
            switch (ev.eventType) {
              case ionic.Gestures.EVENT_START:
                this.triggered = false;
                break;
              case ionic.Gestures.EVENT_MOVE:
                var scale_threshold = Math.abs(1 - ev.scale);
                var rotation_threshold = Math.abs(ev.rotation);
                if (scale_threshold < inst.options.transform_min_scale && rotation_threshold < inst.options.transform_min_rotation) {
                  return;
                }
                ionic.Gestures.detection.current.name = this.name;
                if (!this.triggered) {
                  inst.trigger(this.name + 'start', ev);
                  this.triggered = true;
                }
                inst.trigger(this.name, ev);
                if (rotation_threshold > inst.options.transform_min_rotation) {
                  inst.trigger('rotate', ev);
                }
                if (scale_threshold > inst.options.transform_min_scale) {
                  inst.trigger('pinch', ev);
                  inst.trigger('pinch' + ((ev.scale < 1) ? 'in' : 'out'), ev);
                }
                break;
              case ionic.Gestures.EVENT_END:
                if (this.triggered) {
                  inst.trigger(this.name + 'end', ev);
                }
                this.triggered = false;
                break;
            }
          }
        };
        ionic.Gestures.gestures.Touch = {
          name: 'touch',
          index: -Infinity,
          defaults: {
            prevent_default: false,
            prevent_mouseevents: false
          },
          handler: function touchGesture(ev, inst) {
            if (inst.options.prevent_mouseevents && ev.pointerType == ionic.Gestures.POINTER_MOUSE) {
              ev.stopDetect();
              return;
            }
            if (inst.options.prevent_default) {
              ev.preventDefault();
            }
            if (ev.eventType == ionic.Gestures.EVENT_START) {
              inst.trigger(this.name, ev);
            }
          }
        };
        ionic.Gestures.gestures.Release = {
          name: 'release',
          index: Infinity,
          handler: function releaseGesture(ev, inst) {
            if (ev.eventType == ionic.Gestures.EVENT_END) {
              inst.trigger(this.name, ev);
            }
          }
        };
      })(window.ionic);
      (function(window, document, ionic) {
        function getParameterByName(name) {
          name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
          var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"),
              results = regex.exec(location.search);
          return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
        }
        var IOS = 'ios';
        var ANDROID = 'android';
        var WINDOWS_PHONE = 'windowsphone';
        var EDGE = 'edge';
        var CROSSWALK = 'crosswalk';
        var requestAnimationFrame = ionic.requestAnimationFrame;
        var self = ionic.Platform = {
          navigator: window.navigator,
          isReady: false,
          isFullScreen: false,
          platforms: null,
          grade: null,
          ua: navigator.userAgent,
          ready: function(cb) {
            if (self.isReady) {
              cb();
            } else {
              readyCallbacks.push(cb);
            }
          },
          detect: function() {
            self._checkPlatforms();
            requestAnimationFrame(function() {
              for (var i = 0; i < self.platforms.length; i++) {
                document.body.classList.add('platform-' + self.platforms[i]);
              }
            });
          },
          setGrade: function(grade) {
            var oldGrade = self.grade;
            self.grade = grade;
            requestAnimationFrame(function() {
              if (oldGrade) {
                document.body.classList.remove('grade-' + oldGrade);
              }
              document.body.classList.add('grade-' + grade);
            });
          },
          device: function() {
            return window.device || {};
          },
          _checkPlatforms: function() {
            self.platforms = [];
            var grade = 'a';
            if (self.isWebView()) {
              self.platforms.push('webview');
              if (!(!window.cordova && !window.PhoneGap && !window.phonegap)) {
                self.platforms.push('cordova');
              } else if (typeof window.forge === 'object') {
                self.platforms.push('trigger');
              }
            } else {
              self.platforms.push('browser');
            }
            if (self.isIPad())
              self.platforms.push('ipad');
            var platform = self.platform();
            if (platform) {
              self.platforms.push(platform);
              var version = self.version();
              if (version) {
                var v = version.toString();
                if (v.indexOf('.') > 0) {
                  v = v.replace('.', '_');
                } else {
                  v += '_0';
                }
                self.platforms.push(platform + v.split('_')[0]);
                self.platforms.push(platform + v);
                if (self.isAndroid() && version < 4.4) {
                  grade = (version < 4 ? 'c' : 'b');
                } else if (self.isWindowsPhone()) {
                  grade = 'b';
                }
              }
            }
            self.setGrade(grade);
          },
          isWebView: function() {
            return !(!window.cordova && !window.PhoneGap && !window.phonegap && window.forge !== 'object');
          },
          isIPad: function() {
            if (/iPad/i.test(self.navigator.platform)) {
              return true;
            }
            return /iPad/i.test(self.ua);
          },
          isIOS: function() {
            return self.is(IOS);
          },
          isAndroid: function() {
            return self.is(ANDROID);
          },
          isWindowsPhone: function() {
            return self.is(WINDOWS_PHONE);
          },
          isEdge: function() {
            return self.is(EDGE);
          },
          isCrosswalk: function() {
            return self.is(CROSSWALK);
          },
          platform: function() {
            if (platformName === null)
              self.setPlatform(self.device().platform);
            return platformName;
          },
          setPlatform: function(n) {
            if (typeof n != 'undefined' && n !== null && n.length) {
              platformName = n.toLowerCase();
            } else if (getParameterByName('ionicplatform')) {
              platformName = getParameterByName('ionicplatform');
            } else if (self.ua.indexOf('Edge') > -1) {
              platformName = EDGE;
            } else if (self.ua.indexOf('Windows Phone') > -1) {
              platformName = WINDOWS_PHONE;
            } else if (self.ua.indexOf('Android') > 0) {
              platformName = ANDROID;
            } else if (/iPhone|iPad|iPod/.test(self.ua)) {
              platformName = IOS;
            } else {
              platformName = self.navigator.platform && navigator.platform.toLowerCase().split(' ')[0] || '';
            }
          },
          version: function() {
            if (platformVersion === null)
              self.setVersion(self.device().version);
            return platformVersion;
          },
          setVersion: function(v) {
            if (typeof v != 'undefined' && v !== null) {
              v = v.split('.');
              v = parseFloat(v[0] + '.' + (v.length > 1 ? v[1] : 0));
              if (!isNaN(v)) {
                platformVersion = v;
                return;
              }
            }
            platformVersion = 0;
            var pName = self.platform();
            var versionMatch = {
              'android': /Android (\d+).(\d+)?/,
              'ios': /OS (\d+)_(\d+)?/,
              'windowsphone': /Windows Phone (\d+).(\d+)?/
            };
            if (versionMatch[pName]) {
              v = self.ua.match(versionMatch[pName]);
              if (v && v.length > 2) {
                platformVersion = parseFloat(v[1] + '.' + v[2]);
              }
            }
          },
          is: function(type) {
            type = type.toLowerCase();
            if (self.platforms) {
              for (var x = 0; x < self.platforms.length; x++) {
                if (self.platforms[x] === type)
                  return true;
              }
            }
            var pName = self.platform();
            if (pName) {
              return pName === type.toLowerCase();
            }
            return self.ua.toLowerCase().indexOf(type) >= 0;
          },
          exitApp: function() {
            self.ready(function() {
              navigator.app && navigator.app.exitApp && navigator.app.exitApp();
            });
          },
          showStatusBar: function(val) {
            self._showStatusBar = val;
            self.ready(function() {
              requestAnimationFrame(function() {
                if (self._showStatusBar) {
                  window.StatusBar && window.StatusBar.show();
                  document.body.classList.remove('status-bar-hide');
                } else {
                  window.StatusBar && window.StatusBar.hide();
                  document.body.classList.add('status-bar-hide');
                }
              });
            });
          },
          fullScreen: function(showFullScreen, showStatusBar) {
            self.isFullScreen = (showFullScreen !== false);
            ionic.DomUtil.ready(function() {
              requestAnimationFrame(function() {
                if (self.isFullScreen) {
                  document.body.classList.add('fullscreen');
                } else {
                  document.body.classList.remove('fullscreen');
                }
              });
              self.showStatusBar((showStatusBar === true));
            });
          }
        };
        var platformName = null,
            platformVersion = null,
            readyCallbacks = [],
            windowLoadListenderAttached,
            platformReadyTimer = 2000;
        verifyPlatformReady();
        function verifyPlatformReady() {
          setTimeout(function() {
            if (!self.isReady && self.isWebView()) {
              void 0;
            }
          }, platformReadyTimer);
        }
        function onWindowLoad() {
          if (self.isWebView()) {
            document.addEventListener("deviceready", onPlatformReady, false);
          } else {
            onPlatformReady();
          }
          if (windowLoadListenderAttached) {
            window.removeEventListener("load", onWindowLoad, false);
          }
        }
        if (document.readyState === 'complete') {
          onWindowLoad();
        } else {
          windowLoadListenderAttached = true;
          window.addEventListener("load", onWindowLoad, false);
        }
        function onPlatformReady() {
          self.isReady = true;
          self.detect();
          for (var x = 0; x < readyCallbacks.length; x++) {
            readyCallbacks[x]();
          }
          readyCallbacks = [];
          ionic.trigger('platformready', {target: document});
          requestAnimationFrame(function() {
            document.body.classList.add('platform-ready');
          });
        }
      })(window, document, ionic);
      (function(document, ionic) {
        'use strict';
        ionic.CSS = {};
        ionic.CSS.TRANSITION = [];
        ionic.CSS.TRANSFORM = [];
        ionic.EVENTS = {};
        (function() {
          var i,
              keys = ['webkitTransform', 'transform', '-webkit-transform', 'webkit-transform', '-moz-transform', 'moz-transform', 'MozTransform', 'mozTransform', 'msTransform'];
          for (i = 0; i < keys.length; i++) {
            if (document.documentElement.style[keys[i]] !== undefined) {
              ionic.CSS.TRANSFORM = keys[i];
              break;
            }
          }
          keys = ['webkitTransition', 'mozTransition', 'msTransition', 'transition'];
          for (i = 0; i < keys.length; i++) {
            if (document.documentElement.style[keys[i]] !== undefined) {
              ionic.CSS.TRANSITION = keys[i];
              break;
            }
          }
          ionic.CSS.TRANSITION = ionic.CSS.TRANSITION || 'transition';
          var isWebkit = ionic.CSS.TRANSITION.indexOf('webkit') > -1;
          ionic.CSS.TRANSITION_DURATION = (isWebkit ? '-webkit-' : '') + 'transition-duration';
          ionic.CSS.TRANSITIONEND = (isWebkit ? 'webkitTransitionEnd ' : '') + 'transitionend';
        })();
        (function() {
          var touchStartEvent = 'touchstart';
          var touchMoveEvent = 'touchmove';
          var touchEndEvent = 'touchend';
          var touchCancelEvent = 'touchcancel';
          if (window.navigator.pointerEnabled) {
            touchStartEvent = 'pointerdown';
            touchMoveEvent = 'pointermove';
            touchEndEvent = 'pointerup';
            touchCancelEvent = 'pointercancel';
          } else if (window.navigator.msPointerEnabled) {
            touchStartEvent = 'MSPointerDown';
            touchMoveEvent = 'MSPointerMove';
            touchEndEvent = 'MSPointerUp';
            touchCancelEvent = 'MSPointerCancel';
          }
          ionic.EVENTS.touchstart = touchStartEvent;
          ionic.EVENTS.touchmove = touchMoveEvent;
          ionic.EVENTS.touchend = touchEndEvent;
          ionic.EVENTS.touchcancel = touchCancelEvent;
        })();
        if (!("classList" in document.documentElement) && Object.defineProperty && typeof HTMLElement !== 'undefined') {
          Object.defineProperty(HTMLElement.prototype, 'classList', {get: function() {
              var self = this;
              function update(fn) {
                return function() {
                  var x,
                      classes = self.className.split(/\s+/);
                  for (x = 0; x < arguments.length; x++) {
                    fn(classes, classes.indexOf(arguments[x]), arguments[x]);
                  }
                  self.className = classes.join(" ");
                };
              }
              return {
                add: update(function(classes, index, value) {
                  ~index || classes.push(value);
                }),
                remove: update(function(classes, index) {
                  ~index && classes.splice(index, 1);
                }),
                toggle: update(function(classes, index, value) {
                  ~index ? classes.splice(index, 1) : classes.push(value);
                }),
                contains: function(value) {
                  return !!~self.className.split(/\s+/).indexOf(value);
                },
                item: function(i) {
                  return self.className.split(/\s+/)[i] || null;
                }
              };
            }});
        }
      })(document, ionic);
      var tapDoc;
      var tapActiveEle;
      var tapEnabledTouchEvents;
      var tapMouseResetTimer;
      var tapPointerMoved;
      var tapPointerStart;
      var tapTouchFocusedInput;
      var tapLastTouchTarget;
      var tapTouchMoveListener = 'touchmove';
      var TAP_RELEASE_TOLERANCE = 12;
      var TAP_RELEASE_BUTTON_TOLERANCE = 50;
      var tapEventListeners = {
        'click': tapClickGateKeeper,
        'mousedown': tapMouseDown,
        'mouseup': tapMouseUp,
        'mousemove': tapMouseMove,
        'touchstart': tapTouchStart,
        'touchend': tapTouchEnd,
        'touchcancel': tapTouchCancel,
        'touchmove': tapTouchMove,
        'pointerdown': tapTouchStart,
        'pointerup': tapTouchEnd,
        'pointercancel': tapTouchCancel,
        'pointermove': tapTouchMove,
        'MSPointerDown': tapTouchStart,
        'MSPointerUp': tapTouchEnd,
        'MSPointerCancel': tapTouchCancel,
        'MSPointerMove': tapTouchMove,
        'focusin': tapFocusIn,
        'focusout': tapFocusOut
      };
      ionic.tap = {
        register: function(ele) {
          tapDoc = ele;
          tapEventListener('click', true, true);
          tapEventListener('mouseup');
          tapEventListener('mousedown');
          if (window.navigator.pointerEnabled) {
            tapEventListener('pointerdown');
            tapEventListener('pointerup');
            tapEventListener('pointercancel');
            tapTouchMoveListener = 'pointermove';
          } else if (window.navigator.msPointerEnabled) {
            tapEventListener('MSPointerDown');
            tapEventListener('MSPointerUp');
            tapEventListener('MSPointerCancel');
            tapTouchMoveListener = 'MSPointerMove';
          } else {
            tapEventListener('touchstart');
            tapEventListener('touchend');
            tapEventListener('touchcancel');
          }
          tapEventListener('focusin');
          tapEventListener('focusout');
          return function() {
            for (var type in tapEventListeners) {
              tapEventListener(type, false);
            }
            tapDoc = null;
            tapActiveEle = null;
            tapEnabledTouchEvents = false;
            tapPointerMoved = false;
            tapPointerStart = null;
          };
        },
        ignoreScrollStart: function(e) {
          return (e.defaultPrevented) || (/^(file|range)$/i).test(e.target.type) || (e.target.dataset ? e.target.dataset.preventScroll : e.target.getAttribute('data-prevent-scroll')) == 'true' || (!!(/^(object|embed)$/i).test(e.target.tagName)) || ionic.tap.isElementTapDisabled(e.target);
        },
        isTextInput: function(ele) {
          return !!ele && (ele.tagName == 'TEXTAREA' || ele.contentEditable === 'true' || (ele.tagName == 'INPUT' && !(/^(radio|checkbox|range|file|submit|reset|color|image|button)$/i).test(ele.type)));
        },
        isDateInput: function(ele) {
          return !!ele && (ele.tagName == 'INPUT' && (/^(date|time|datetime-local|month|week)$/i).test(ele.type));
        },
        isVideo: function(ele) {
          return !!ele && (ele.tagName == 'VIDEO');
        },
        isKeyboardElement: function(ele) {
          if (!ionic.Platform.isIOS() || ionic.Platform.isIPad()) {
            return ionic.tap.isTextInput(ele) && !ionic.tap.isDateInput(ele);
          } else {
            return ionic.tap.isTextInput(ele) || (!!ele && ele.tagName == "SELECT");
          }
        },
        isLabelWithTextInput: function(ele) {
          var container = tapContainingElement(ele, false);
          return !!container && ionic.tap.isTextInput(tapTargetElement(container));
        },
        containsOrIsTextInput: function(ele) {
          return ionic.tap.isTextInput(ele) || ionic.tap.isLabelWithTextInput(ele);
        },
        cloneFocusedInput: function(container) {
          if (ionic.tap.hasCheckedClone)
            return;
          ionic.tap.hasCheckedClone = true;
          ionic.requestAnimationFrame(function() {
            var focusInput = container.querySelector(':focus');
            if (ionic.tap.isTextInput(focusInput) && !ionic.tap.isDateInput(focusInput)) {
              var clonedInput = focusInput.cloneNode(true);
              clonedInput.value = focusInput.value;
              clonedInput.classList.add('cloned-text-input');
              clonedInput.readOnly = true;
              if (focusInput.isContentEditable) {
                clonedInput.contentEditable = focusInput.contentEditable;
                clonedInput.innerHTML = focusInput.innerHTML;
              }
              focusInput.parentElement.insertBefore(clonedInput, focusInput);
              focusInput.classList.add('previous-input-focus');
              clonedInput.scrollTop = focusInput.scrollTop;
            }
          });
        },
        hasCheckedClone: false,
        removeClonedInputs: function(container) {
          ionic.tap.hasCheckedClone = false;
          ionic.requestAnimationFrame(function() {
            var clonedInputs = container.querySelectorAll('.cloned-text-input');
            var previousInputFocus = container.querySelectorAll('.previous-input-focus');
            var x;
            for (x = 0; x < clonedInputs.length; x++) {
              clonedInputs[x].parentElement.removeChild(clonedInputs[x]);
            }
            for (x = 0; x < previousInputFocus.length; x++) {
              previousInputFocus[x].classList.remove('previous-input-focus');
              previousInputFocus[x].style.top = '';
              if (ionic.keyboard.isOpen && !ionic.keyboard.isClosing)
                previousInputFocus[x].focus();
            }
          });
        },
        requiresNativeClick: function(ele) {
          if (ionic.Platform.isWindowsPhone() && (ele.tagName == 'A' || ele.tagName == 'BUTTON' || ele.hasAttribute('ng-click') || (ele.tagName == 'INPUT' && (ele.type == 'button' || ele.type == 'submit')))) {
            return true;
          }
          if (!ele || ele.disabled || (/^(file|range)$/i).test(ele.type) || (/^(object|video)$/i).test(ele.tagName) || ionic.tap.isLabelContainingFileInput(ele)) {
            return true;
          }
          return ionic.tap.isElementTapDisabled(ele);
        },
        isLabelContainingFileInput: function(ele) {
          var lbl = tapContainingElement(ele);
          if (lbl.tagName !== 'LABEL')
            return false;
          var fileInput = lbl.querySelector('input[type=file]');
          if (fileInput && fileInput.disabled === false)
            return true;
          return false;
        },
        isElementTapDisabled: function(ele) {
          if (ele && ele.nodeType === 1) {
            var element = ele;
            while (element) {
              if ((element.dataset ? element.dataset.tapDisabled : element.getAttribute && element.getAttribute('data-tap-disabled')) == 'true') {
                return true;
              }
              element = element.parentElement;
            }
          }
          return false;
        },
        setTolerance: function(releaseTolerance, releaseButtonTolerance) {
          TAP_RELEASE_TOLERANCE = releaseTolerance;
          TAP_RELEASE_BUTTON_TOLERANCE = releaseButtonTolerance;
        },
        cancelClick: function() {
          tapPointerMoved = true;
        },
        pointerCoord: function(event) {
          var c = {
            x: 0,
            y: 0
          };
          if (event) {
            var touches = event.touches && event.touches.length ? event.touches : [event];
            var e = (event.changedTouches && event.changedTouches[0]) || touches[0];
            if (e) {
              c.x = e.clientX || e.pageX || 0;
              c.y = e.clientY || e.pageY || 0;
            }
          }
          return c;
        }
      };
      function tapEventListener(type, enable, useCapture) {
        if (enable !== false) {
          tapDoc.addEventListener(type, tapEventListeners[type], useCapture);
        } else {
          tapDoc.removeEventListener(type, tapEventListeners[type]);
        }
      }
      function tapClick(e) {
        var container = tapContainingElement(e.target);
        var ele = tapTargetElement(container);
        if (ionic.tap.requiresNativeClick(ele) || tapPointerMoved)
          return false;
        var c = ionic.tap.pointerCoord(e);
        triggerMouseEvent('click', ele, c.x, c.y);
        tapHandleFocus(ele);
      }
      function triggerMouseEvent(type, ele, x, y) {
        var clickEvent = document.createEvent("MouseEvents");
        clickEvent.initMouseEvent(type, true, true, window, 1, 0, 0, x, y, false, false, false, false, 0, null);
        clickEvent.isIonicTap = true;
        ele.dispatchEvent(clickEvent);
      }
      function tapClickGateKeeper(e) {
        if (e.target.type == 'submit' && e.detail === 0) {
          return null;
        }
        if ((ionic.scroll.isScrolling && ionic.tap.containsOrIsTextInput(e.target)) || (!e.isIonicTap && !ionic.tap.requiresNativeClick(e.target))) {
          e.stopPropagation();
          if (!ionic.tap.isLabelWithTextInput(e.target)) {
            e.preventDefault();
          }
          return false;
        }
      }
      function tapMouseDown(e) {
        if (e.isIonicTap || tapIgnoreEvent(e))
          return null;
        if (tapEnabledTouchEvents) {
          e.stopPropagation();
          if (!ionic.Platform.isEdge() && (!ionic.tap.isTextInput(e.target) || tapLastTouchTarget !== e.target) && !isSelectOrOption(e.target.tagName) && !ionic.tap.isVideo(e.target)) {
            e.preventDefault();
          }
          return false;
        }
        tapPointerMoved = false;
        tapPointerStart = ionic.tap.pointerCoord(e);
        tapEventListener('mousemove');
        ionic.activator.start(e);
      }
      function tapMouseUp(e) {
        if (tapEnabledTouchEvents) {
          e.stopPropagation();
          e.preventDefault();
          return false;
        }
        if (tapIgnoreEvent(e) || isSelectOrOption(e.target.tagName))
          return false;
        if (!tapHasPointerMoved(e)) {
          tapClick(e);
        }
        tapEventListener('mousemove', false);
        ionic.activator.end();
        tapPointerMoved = false;
      }
      function tapMouseMove(e) {
        if (tapHasPointerMoved(e)) {
          tapEventListener('mousemove', false);
          ionic.activator.end();
          tapPointerMoved = true;
          return false;
        }
      }
      function tapTouchStart(e) {
        if (tapIgnoreEvent(e))
          return;
        tapPointerMoved = false;
        tapEnableTouchEvents();
        tapPointerStart = ionic.tap.pointerCoord(e);
        tapEventListener(tapTouchMoveListener);
        ionic.activator.start(e);
        if (ionic.Platform.isIOS() && ionic.tap.isLabelWithTextInput(e.target)) {
          var textInput = tapTargetElement(tapContainingElement(e.target));
          if (textInput !== tapActiveEle) {
            e.preventDefault();
          }
        }
      }
      function tapTouchEnd(e) {
        if (tapIgnoreEvent(e))
          return;
        tapEnableTouchEvents();
        if (!tapHasPointerMoved(e)) {
          tapClick(e);
          if (isSelectOrOption(e.target.tagName)) {
            e.preventDefault();
          }
        }
        tapLastTouchTarget = e.target;
        tapTouchCancel();
      }
      function tapTouchMove(e) {
        if (tapHasPointerMoved(e)) {
          tapPointerMoved = true;
          tapEventListener(tapTouchMoveListener, false);
          ionic.activator.end();
          return false;
        }
      }
      function tapTouchCancel() {
        tapEventListener(tapTouchMoveListener, false);
        ionic.activator.end();
        tapPointerMoved = false;
      }
      function tapEnableTouchEvents() {
        tapEnabledTouchEvents = true;
        clearTimeout(tapMouseResetTimer);
        tapMouseResetTimer = setTimeout(function() {
          tapEnabledTouchEvents = false;
        }, 600);
      }
      function tapIgnoreEvent(e) {
        if (e.isTapHandled)
          return true;
        e.isTapHandled = true;
        if (ionic.tap.isElementTapDisabled(e.target)) {
          return true;
        }
        if (ionic.scroll.isScrolling && ionic.tap.containsOrIsTextInput(e.target)) {
          e.preventDefault();
          return true;
        }
      }
      function tapHandleFocus(ele) {
        tapTouchFocusedInput = null;
        var triggerFocusIn = false;
        if (ele.tagName == 'SELECT') {
          triggerMouseEvent('mousedown', ele, 0, 0);
          ele.focus && ele.focus();
          triggerFocusIn = true;
        } else if (tapActiveElement() === ele) {
          triggerFocusIn = true;
        } else if ((/^(input|textarea|ion-label)$/i).test(ele.tagName) || ele.isContentEditable) {
          triggerFocusIn = true;
          ele.focus && ele.focus();
          ele.value = ele.value;
          if (tapEnabledTouchEvents) {
            tapTouchFocusedInput = ele;
          }
        } else {
          tapFocusOutActive();
        }
        if (triggerFocusIn) {
          tapActiveElement(ele);
          ionic.trigger('ionic.focusin', {target: ele}, true);
        }
      }
      function tapFocusOutActive() {
        var ele = tapActiveElement();
        if (ele && ((/^(input|textarea|select)$/i).test(ele.tagName) || ele.isContentEditable)) {
          ele.blur();
        }
        tapActiveElement(null);
      }
      function tapFocusIn(e) {
        if (tapEnabledTouchEvents && ionic.tap.isTextInput(tapActiveElement()) && ionic.tap.isTextInput(tapTouchFocusedInput) && tapTouchFocusedInput !== e.target) {
          tapTouchFocusedInput.focus();
          tapTouchFocusedInput = null;
        }
        ionic.scroll.isScrolling = false;
      }
      function tapFocusOut() {
        tapActiveElement(null);
      }
      function tapActiveElement(ele) {
        if (arguments.length) {
          tapActiveEle = ele;
        }
        return tapActiveEle || document.activeElement;
      }
      function tapHasPointerMoved(endEvent) {
        if (!endEvent || endEvent.target.nodeType !== 1 || !tapPointerStart || (tapPointerStart.x === 0 && tapPointerStart.y === 0)) {
          return false;
        }
        var endCoordinates = ionic.tap.pointerCoord(endEvent);
        var hasClassList = !!(endEvent.target.classList && endEvent.target.classList.contains && typeof endEvent.target.classList.contains === 'function');
        var releaseTolerance = hasClassList && endEvent.target.classList.contains('button') ? TAP_RELEASE_BUTTON_TOLERANCE : TAP_RELEASE_TOLERANCE;
        return Math.abs(tapPointerStart.x - endCoordinates.x) > releaseTolerance || Math.abs(tapPointerStart.y - endCoordinates.y) > releaseTolerance;
      }
      function tapContainingElement(ele, allowSelf) {
        var climbEle = ele;
        for (var x = 0; x < 6; x++) {
          if (!climbEle)
            break;
          if (climbEle.tagName === 'LABEL')
            return climbEle;
          climbEle = climbEle.parentElement;
        }
        if (allowSelf !== false)
          return ele;
      }
      function tapTargetElement(ele) {
        if (ele && ele.tagName === 'LABEL') {
          if (ele.control)
            return ele.control;
          if (ele.querySelector) {
            var control = ele.querySelector('input,textarea,select');
            if (control)
              return control;
          }
        }
        return ele;
      }
      function isSelectOrOption(tagName) {
        return (/^(select|option)$/i).test(tagName);
      }
      ionic.DomUtil.ready(function() {
        var ng = typeof angular !== 'undefined' ? angular : null;
        if (!ng || (ng && !ng.scenario)) {
          ionic.tap.register(document);
        }
      });
      (function(document, ionic) {
        'use strict';
        var queueElements = {};
        var activeElements = {};
        var keyId = 0;
        var ACTIVATED_CLASS = 'activated';
        ionic.activator = {
          start: function(e) {
            var hitX = ionic.tap.pointerCoord(e).x;
            if (hitX > 0 && hitX < 30) {
              return;
            }
            ionic.requestAnimationFrame(function() {
              if ((ionic.scroll && ionic.scroll.isScrolling) || ionic.tap.requiresNativeClick(e.target))
                return;
              var ele = e.target;
              var eleToActivate;
              for (var x = 0; x < 6; x++) {
                if (!ele || ele.nodeType !== 1)
                  break;
                if (eleToActivate && ele.classList && ele.classList.contains('item')) {
                  eleToActivate = ele;
                  break;
                }
                if (ele.tagName == 'A' || ele.tagName == 'BUTTON' || ele.hasAttribute('ng-click')) {
                  eleToActivate = ele;
                  break;
                }
                if (ele.classList && ele.classList.contains('button')) {
                  eleToActivate = ele;
                  break;
                }
                if (ele.tagName == 'ION-CONTENT' || (ele.classList && ele.classList.contains('pane')) || ele.tagName == 'BODY') {
                  break;
                }
                ele = ele.parentElement;
              }
              if (eleToActivate) {
                queueElements[keyId] = eleToActivate;
                ionic.requestAnimationFrame(activateElements);
                keyId = (keyId > 29 ? 0 : keyId + 1);
              }
            });
          },
          end: function() {
            setTimeout(clear, 200);
          }
        };
        function clear() {
          queueElements = {};
          ionic.requestAnimationFrame(deactivateElements);
        }
        function activateElements() {
          for (var key in queueElements) {
            if (queueElements[key]) {
              queueElements[key].classList.add(ACTIVATED_CLASS);
              activeElements[key] = queueElements[key];
            }
          }
          queueElements = {};
        }
        function deactivateElements() {
          if (ionic.transition && ionic.transition.isActive) {
            setTimeout(deactivateElements, 400);
            return;
          }
          for (var key in activeElements) {
            if (activeElements[key]) {
              activeElements[key].classList.remove(ACTIVATED_CLASS);
              delete activeElements[key];
            }
          }
        }
      })(document, ionic);
      (function(ionic) {
        var nextId = 0;
        ionic.Utils = {
          arrayMove: function(arr, oldIndex, newIndex) {
            if (newIndex >= arr.length) {
              var k = newIndex - arr.length;
              while ((k--) + 1) {
                arr.push(undefined);
              }
            }
            arr.splice(newIndex, 0, arr.splice(oldIndex, 1)[0]);
            return arr;
          },
          proxy: function(func, context) {
            var args = Array.prototype.slice.call(arguments, 2);
            return function() {
              return func.apply(context, args.concat(Array.prototype.slice.call(arguments)));
            };
          },
          debounce: function(func, wait, immediate) {
            var timeout,
                args,
                context,
                timestamp,
                result;
            return function() {
              context = this;
              args = arguments;
              timestamp = new Date();
              var later = function() {
                var last = (new Date()) - timestamp;
                if (last < wait) {
                  timeout = setTimeout(later, wait - last);
                } else {
                  timeout = null;
                  if (!immediate)
                    result = func.apply(context, args);
                }
              };
              var callNow = immediate && !timeout;
              if (!timeout) {
                timeout = setTimeout(later, wait);
              }
              if (callNow)
                result = func.apply(context, args);
              return result;
            };
          },
          throttle: function(func, wait, options) {
            var context,
                args,
                result;
            var timeout = null;
            var previous = 0;
            options || (options = {});
            var later = function() {
              previous = options.leading === false ? 0 : Date.now();
              timeout = null;
              result = func.apply(context, args);
            };
            return function() {
              var now = Date.now();
              if (!previous && options.leading === false)
                previous = now;
              var remaining = wait - (now - previous);
              context = this;
              args = arguments;
              if (remaining <= 0) {
                clearTimeout(timeout);
                timeout = null;
                previous = now;
                result = func.apply(context, args);
              } else if (!timeout && options.trailing !== false) {
                timeout = setTimeout(later, remaining);
              }
              return result;
            };
          },
          inherit: function(protoProps, staticProps) {
            var parent = this;
            var child;
            if (protoProps && protoProps.hasOwnProperty('constructor')) {
              child = protoProps.constructor;
            } else {
              child = function() {
                return parent.apply(this, arguments);
              };
            }
            ionic.extend(child, parent, staticProps);
            var Surrogate = function() {
              this.constructor = child;
            };
            Surrogate.prototype = parent.prototype;
            child.prototype = new Surrogate();
            if (protoProps)
              ionic.extend(child.prototype, protoProps);
            child.__super__ = parent.prototype;
            return child;
          },
          extend: function(obj) {
            var args = Array.prototype.slice.call(arguments, 1);
            for (var i = 0; i < args.length; i++) {
              var source = args[i];
              if (source) {
                for (var prop in source) {
                  obj[prop] = source[prop];
                }
              }
            }
            return obj;
          },
          nextUid: function() {
            return 'ion' + (nextId++);
          },
          disconnectScope: function disconnectScope(scope) {
            if (!scope)
              return;
            if (scope.$root === scope) {
              return;
            }
            var parent = scope.$parent;
            scope.$$disconnected = true;
            scope.$broadcast('$ionic.disconnectScope', scope);
            if (parent.$$childHead === scope) {
              parent.$$childHead = scope.$$nextSibling;
            }
            if (parent.$$childTail === scope) {
              parent.$$childTail = scope.$$prevSibling;
            }
            if (scope.$$prevSibling) {
              scope.$$prevSibling.$$nextSibling = scope.$$nextSibling;
            }
            if (scope.$$nextSibling) {
              scope.$$nextSibling.$$prevSibling = scope.$$prevSibling;
            }
            scope.$$nextSibling = scope.$$prevSibling = null;
          },
          reconnectScope: function reconnectScope(scope) {
            if (!scope)
              return;
            if (scope.$root === scope) {
              return;
            }
            if (!scope.$$disconnected) {
              return;
            }
            var parent = scope.$parent;
            scope.$$disconnected = false;
            scope.$broadcast('$ionic.reconnectScope', scope);
            scope.$$prevSibling = parent.$$childTail;
            if (parent.$$childHead) {
              parent.$$childTail.$$nextSibling = scope;
              parent.$$childTail = scope;
            } else {
              parent.$$childHead = parent.$$childTail = scope;
            }
          },
          isScopeDisconnected: function(scope) {
            var climbScope = scope;
            while (climbScope) {
              if (climbScope.$$disconnected)
                return true;
              climbScope = climbScope.$parent;
            }
            return false;
          }
        };
        ionic.inherit = ionic.Utils.inherit;
        ionic.extend = ionic.Utils.extend;
        ionic.throttle = ionic.Utils.throttle;
        ionic.proxy = ionic.Utils.proxy;
        ionic.debounce = ionic.Utils.debounce;
      })(window.ionic);
      var keyboardCurrentViewportHeight = 0;
      var keyboardPortraitViewportHeight = 0;
      var keyboardLandscapeViewportHeight = 0;
      var keyboardActiveElement;
      var lastKeyboardActiveElement;
      var scrollView;
      var waitForResizeTimer;
      var keyboardFocusOutTimer;
      var wasOrientationChange = false;
      var KEYBOARD_OPEN_CSS = 'keyboard-open';
      var SCROLL_CONTAINER_CSS = 'scroll-content';
      var debouncedKeyboardFocusIn = ionic.debounce(keyboardFocusIn, 200, true);
      var debouncedKeyboardNativeShow = ionic.debounce(keyboardNativeShow, 100, true);
      ionic.keyboard = {
        isOpen: false,
        isClosing: false,
        isOpening: false,
        height: 0,
        isLandscape: false,
        isInitialized: false,
        hide: function() {
          if (keyboardHasPlugin()) {
            cordova.plugins.Keyboard.close();
          }
          keyboardActiveElement && keyboardActiveElement.blur();
        },
        show: function() {
          if (keyboardHasPlugin()) {
            cordova.plugins.Keyboard.show();
          }
        },
        disable: function() {
          if (keyboardHasPlugin()) {
            window.removeEventListener('native.keyboardshow', debouncedKeyboardNativeShow);
            window.removeEventListener('native.keyboardhide', keyboardFocusOut);
          } else {
            document.body.removeEventListener('focusout', keyboardFocusOut);
          }
          document.body.removeEventListener('ionic.focusin', debouncedKeyboardFocusIn);
          document.body.removeEventListener('focusin', debouncedKeyboardFocusIn);
          window.removeEventListener('orientationchange', keyboardOrientationChange);
          if (window.navigator.msPointerEnabled) {
            document.removeEventListener("MSPointerDown", keyboardInit);
          } else {
            document.removeEventListener('touchstart', keyboardInit);
          }
          ionic.keyboard.isInitialized = false;
        },
        enable: function() {
          keyboardInit();
        }
      };
      keyboardCurrentViewportHeight = getViewportHeight();
      function keyboardInit() {
        if (ionic.keyboard.isInitialized)
          return;
        if (keyboardHasPlugin()) {
          window.addEventListener('native.keyboardshow', debouncedKeyboardNativeShow);
          window.addEventListener('native.keyboardhide', keyboardFocusOut);
        } else {
          document.body.addEventListener('focusout', keyboardFocusOut);
        }
        document.body.addEventListener('ionic.focusin', debouncedKeyboardFocusIn);
        document.body.addEventListener('focusin', debouncedKeyboardFocusIn);
        if (window.navigator.msPointerEnabled) {
          document.removeEventListener("MSPointerDown", keyboardInit);
        } else {
          document.removeEventListener('touchstart', keyboardInit);
        }
        ionic.keyboard.isInitialized = true;
      }
      function keyboardNativeShow(e) {
        clearTimeout(keyboardFocusOutTimer);
        if (!ionic.keyboard.isOpen || ionic.keyboard.isClosing) {
          ionic.keyboard.isOpening = true;
          ionic.keyboard.isClosing = false;
        }
        ionic.keyboard.height = e.keyboardHeight;
        if (wasOrientationChange) {
          keyboardWaitForResize(keyboardUpdateViewportHeight, true);
        } else {
          keyboardWaitForResize(keyboardShow, true);
        }
      }
      function keyboardFocusIn(e) {
        clearTimeout(keyboardFocusOutTimer);
        if (!e.target || e.target.readOnly || !ionic.tap.isKeyboardElement(e.target) || !(scrollView = ionic.DomUtil.getParentWithClass(e.target, SCROLL_CONTAINER_CSS))) {
          if (keyboardActiveElement) {
            lastKeyboardActiveElement = keyboardActiveElement;
          }
          keyboardActiveElement = null;
          return;
        }
        keyboardActiveElement = e.target;
        if (!scrollView.classList.contains("overflow-scroll")) {
          document.body.scrollTop = 0;
          scrollView.scrollTop = 0;
          ionic.requestAnimationFrame(function() {
            document.body.scrollTop = 0;
            scrollView.scrollTop = 0;
          });
          if (window.navigator.msPointerEnabled) {
            document.addEventListener("MSPointerMove", keyboardPreventDefault, false);
          } else {
            document.addEventListener('touchmove', keyboardPreventDefault, false);
          }
        }
        if (!ionic.keyboard.isOpen || ionic.keyboard.isClosing) {
          ionic.keyboard.isOpening = true;
          ionic.keyboard.isClosing = false;
        }
        document.addEventListener('keydown', keyboardOnKeyDown, false);
        if (!ionic.keyboard.isOpen && !keyboardHasPlugin()) {
          keyboardWaitForResize(keyboardShow, true);
        } else if (ionic.keyboard.isOpen) {
          keyboardShow();
        }
      }
      function keyboardFocusOut() {
        clearTimeout(keyboardFocusOutTimer);
        if (ionic.keyboard.isOpen || ionic.keyboard.isOpening) {
          ionic.keyboard.isClosing = true;
          ionic.keyboard.isOpening = false;
        }
        keyboardFocusOutTimer = setTimeout(function() {
          ionic.requestAnimationFrame(function() {
            if (wasOrientationChange) {
              keyboardWaitForResize(function() {
                keyboardUpdateViewportHeight();
                keyboardHide();
              }, false);
            } else {
              keyboardWaitForResize(keyboardHide, false);
            }
          });
        }, 50);
      }
      function keyboardOrientationChange() {
        ionic.keyboard.isLandscape = !ionic.keyboard.isLandscape;
        if (ionic.Platform.isIOS()) {
          keyboardUpdateViewportHeight();
        }
        if (ionic.Platform.isAndroid()) {
          if (!ionic.keyboard.isOpen || !keyboardHasPlugin()) {
            keyboardWaitForResize(keyboardUpdateViewportHeight, false);
          } else {
            wasOrientationChange = true;
          }
        }
      }
      function keyboardOnKeyDown(e) {
        if (ionic.scroll.isScrolling) {
          keyboardPreventDefault(e);
        }
      }
      function keyboardPreventDefault(e) {
        if (e.target.tagName !== 'TEXTAREA') {
          e.preventDefault();
        }
      }
      function keyboardWaitForResize(callback, isOpening) {
        clearInterval(waitForResizeTimer);
        var count = 0;
        var maxCount;
        var initialHeight = getViewportHeight();
        var viewportHeight = initialHeight;
        if (ionic.Platform.isAndroid() && ionic.Platform.version() < 4.4) {
          maxCount = 30;
        } else if (ionic.Platform.isAndroid()) {
          maxCount = 10;
        } else {
          maxCount = 1;
        }
        waitForResizeTimer = setInterval(function() {
          viewportHeight = getViewportHeight();
          if (++count < maxCount && ((!isPortraitViewportHeight(viewportHeight) && !isLandscapeViewportHeight(viewportHeight)) || !ionic.keyboard.height)) {
            return;
          }
          if (!keyboardHasPlugin()) {
            ionic.keyboard.height = Math.abs(initialHeight - window.innerHeight);
          }
          ionic.keyboard.isOpen = isOpening;
          clearInterval(waitForResizeTimer);
          callback();
        }, 50);
        return maxCount;
      }
      function keyboardHide() {
        clearTimeout(keyboardFocusOutTimer);
        ionic.keyboard.isOpen = false;
        ionic.keyboard.isClosing = false;
        if (keyboardActiveElement || lastKeyboardActiveElement) {
          ionic.trigger('resetScrollView', {target: keyboardActiveElement || lastKeyboardActiveElement}, true);
        }
        ionic.requestAnimationFrame(function() {
          document.body.classList.remove(KEYBOARD_OPEN_CSS);
        });
        if (window.navigator.msPointerEnabled) {
          document.removeEventListener("MSPointerMove", keyboardPreventDefault);
        } else {
          document.removeEventListener('touchmove', keyboardPreventDefault);
        }
        document.removeEventListener('keydown', keyboardOnKeyDown);
        if (ionic.Platform.isAndroid()) {
          if (keyboardHasPlugin())
            cordova.plugins.Keyboard.close();
          keyboardActiveElement && keyboardActiveElement.blur();
        }
        keyboardActiveElement = null;
        lastKeyboardActiveElement = null;
      }
      function keyboardShow() {
        ionic.keyboard.isOpen = true;
        ionic.keyboard.isOpening = false;
        var details = {
          keyboardHeight: keyboardGetHeight(),
          viewportHeight: keyboardCurrentViewportHeight
        };
        if (keyboardActiveElement) {
          details.target = keyboardActiveElement;
          var elementBounds = keyboardActiveElement.getBoundingClientRect();
          details.elementTop = Math.round(elementBounds.top);
          details.elementBottom = Math.round(elementBounds.bottom);
          details.windowHeight = details.viewportHeight - details.keyboardHeight;
          details.isElementUnderKeyboard = (details.elementBottom > details.windowHeight);
          ionic.trigger('scrollChildIntoView', details, true);
        }
        setTimeout(function() {
          document.body.classList.add(KEYBOARD_OPEN_CSS);
        }, 400);
        return details;
      }
      function keyboardGetHeight() {
        if (ionic.keyboard.height) {
          return ionic.keyboard.height;
        }
        if (ionic.Platform.isAndroid()) {
          if (ionic.Platform.isFullScreen) {
            return 275;
          }
          var contentHeight = window.innerHeight;
          if (contentHeight < keyboardCurrentViewportHeight) {
            return keyboardCurrentViewportHeight - contentHeight;
          } else {
            return 0;
          }
        }
        if (ionic.Platform.isIOS()) {
          if (ionic.keyboard.isLandscape) {
            return 206;
          }
          if (!ionic.Platform.isWebView()) {
            return 216;
          }
          return 260;
        }
        return 275;
      }
      function isPortraitViewportHeight(viewportHeight) {
        return !!(!ionic.keyboard.isLandscape && keyboardPortraitViewportHeight && (Math.abs(keyboardPortraitViewportHeight - viewportHeight) < 2));
      }
      function isLandscapeViewportHeight(viewportHeight) {
        return !!(ionic.keyboard.isLandscape && keyboardLandscapeViewportHeight && (Math.abs(keyboardLandscapeViewportHeight - viewportHeight) < 2));
      }
      function keyboardUpdateViewportHeight() {
        wasOrientationChange = false;
        keyboardCurrentViewportHeight = getViewportHeight();
        if (ionic.keyboard.isLandscape && !keyboardLandscapeViewportHeight) {
          keyboardLandscapeViewportHeight = keyboardCurrentViewportHeight;
        } else if (!ionic.keyboard.isLandscape && !keyboardPortraitViewportHeight) {
          keyboardPortraitViewportHeight = keyboardCurrentViewportHeight;
        }
        if (keyboardActiveElement) {
          ionic.trigger('resetScrollView', {target: keyboardActiveElement}, true);
        }
        if (ionic.keyboard.isOpen && ionic.tap.isTextInput(keyboardActiveElement)) {
          keyboardShow();
        }
      }
      function keyboardInitViewportHeight() {
        var viewportHeight = getViewportHeight();
        if ((viewportHeight / window.innerWidth) < 1) {
          ionic.keyboard.isLandscape = true;
        }
        keyboardCurrentViewportHeight = viewportHeight;
        if (ionic.keyboard.isLandscape && !keyboardLandscapeViewportHeight) {
          keyboardLandscapeViewportHeight = keyboardCurrentViewportHeight;
        } else if (!ionic.keyboard.isLandscape && !keyboardPortraitViewportHeight) {
          keyboardPortraitViewportHeight = keyboardCurrentViewportHeight;
        }
      }
      function getViewportHeight() {
        var windowHeight = window.innerHeight;
        if (!(ionic.Platform.isAndroid() && ionic.Platform.isFullScreen) && (ionic.keyboard.isOpen || ionic.keyboard.isOpening) && !ionic.keyboard.isClosing) {
          return windowHeight + keyboardGetHeight();
        }
        return windowHeight;
      }
      function keyboardHasPlugin() {
        return !!(window.cordova && cordova.plugins && cordova.plugins.Keyboard);
      }
      ionic.Platform.ready(function() {
        keyboardInitViewportHeight();
        window.addEventListener('orientationchange', keyboardOrientationChange);
        setTimeout(keyboardInitViewportHeight, 999);
        if (window.navigator.msPointerEnabled) {
          document.addEventListener("MSPointerDown", keyboardInit, false);
        } else {
          document.addEventListener('touchstart', keyboardInit, false);
        }
      });
      var viewportTag;
      var viewportProperties = {};
      ionic.viewport = {orientation: function() {
          return (window.innerWidth > window.innerHeight ? 90 : 0);
        }};
      function viewportLoadTag() {
        var x;
        for (x = 0; x < document.head.children.length; x++) {
          if (document.head.children[x].name == 'viewport') {
            viewportTag = document.head.children[x];
            break;
          }
        }
        if (viewportTag) {
          var props = viewportTag.content.toLowerCase().replace(/\s+/g, '').split(',');
          var keyValue;
          for (x = 0; x < props.length; x++) {
            if (props[x]) {
              keyValue = props[x].split('=');
              viewportProperties[keyValue[0]] = (keyValue.length > 1 ? keyValue[1] : '_');
            }
          }
          viewportUpdate();
        }
      }
      function viewportUpdate() {
        var initWidth = viewportProperties.width;
        var initHeight = viewportProperties.height;
        var p = ionic.Platform;
        var version = p.version();
        var DEVICE_WIDTH = 'device-width';
        var DEVICE_HEIGHT = 'device-height';
        var orientation = ionic.viewport.orientation();
        delete viewportProperties.height;
        viewportProperties.width = DEVICE_WIDTH;
        if (p.isIPad()) {
          if (version > 7) {
            delete viewportProperties.width;
          } else {
            if (p.isWebView()) {
              if (orientation == 90) {
                viewportProperties.height = '0';
              } else if (version == 7) {
                viewportProperties.height = DEVICE_HEIGHT;
              }
            } else {
              if (version < 7) {
                viewportProperties.height = '0';
              }
            }
          }
        } else if (p.isIOS()) {
          if (p.isWebView()) {
            if (version > 7) {
              delete viewportProperties.width;
            } else if (version < 7) {
              if (initHeight)
                viewportProperties.height = '0';
            } else if (version == 7) {
              viewportProperties.height = DEVICE_HEIGHT;
            }
          } else {
            if (version < 7) {
              if (initHeight)
                viewportProperties.height = '0';
            }
          }
        }
        if (initWidth !== viewportProperties.width || initHeight !== viewportProperties.height) {
          viewportTagUpdate();
        }
      }
      function viewportTagUpdate() {
        var key,
            props = [];
        for (key in viewportProperties) {
          if (viewportProperties[key]) {
            props.push(key + (viewportProperties[key] == '_' ? '' : '=' + viewportProperties[key]));
          }
        }
        viewportTag.content = props.join(', ');
      }
      ionic.Platform.ready(function() {
        viewportLoadTag();
        window.addEventListener("orientationchange", function() {
          setTimeout(viewportUpdate, 1000);
        }, false);
      });
      (function(ionic) {
        'use strict';
        ionic.views.View = function() {
          this.initialize.apply(this, arguments);
        };
        ionic.views.View.inherit = ionic.inherit;
        ionic.extend(ionic.views.View.prototype, {initialize: function() {}});
      })(window.ionic);
      var zyngaCore = {effect: {}};
      (function(global) {
        var time = Date.now || function() {
          return +new Date();
        };
        var desiredFrames = 60;
        var millisecondsPerSecond = 1000;
        var running = {};
        var counter = 1;
        zyngaCore.effect.Animate = {
          requestAnimationFrame: (function() {
            var requestFrame = global.requestAnimationFrame || global.webkitRequestAnimationFrame || global.mozRequestAnimationFrame || global.oRequestAnimationFrame;
            var isNative = !!requestFrame;
            if (requestFrame && !/requestAnimationFrame\(\)\s*\{\s*\[native code\]\s*\}/i.test(requestFrame.toString())) {
              isNative = false;
            }
            if (isNative) {
              return function(callback, root) {
                requestFrame(callback, root);
              };
            }
            var TARGET_FPS = 60;
            var requests = {};
            var requestCount = 0;
            var rafHandle = 1;
            var intervalHandle = null;
            var lastActive = +new Date();
            return function(callback) {
              var callbackHandle = rafHandle++;
              requests[callbackHandle] = callback;
              requestCount++;
              if (intervalHandle === null) {
                intervalHandle = setInterval(function() {
                  var time = +new Date();
                  var currentRequests = requests;
                  requests = {};
                  requestCount = 0;
                  for (var key in currentRequests) {
                    if (currentRequests.hasOwnProperty(key)) {
                      currentRequests[key](time);
                      lastActive = time;
                    }
                  }
                  if (time - lastActive > 2500) {
                    clearInterval(intervalHandle);
                    intervalHandle = null;
                  }
                }, 1000 / TARGET_FPS);
              }
              return callbackHandle;
            };
          })(),
          stop: function(id) {
            var cleared = running[id] != null;
            if (cleared) {
              running[id] = null;
            }
            return cleared;
          },
          isRunning: function(id) {
            return running[id] != null;
          },
          start: function(stepCallback, verifyCallback, completedCallback, duration, easingMethod, root) {
            var start = time();
            var lastFrame = start;
            var percent = 0;
            var dropCounter = 0;
            var id = counter++;
            if (!root) {
              root = document.body;
            }
            if (id % 20 === 0) {
              var newRunning = {};
              for (var usedId in running) {
                newRunning[usedId] = true;
              }
              running = newRunning;
            }
            var step = function(virtual) {
              var render = virtual !== true;
              var now = time();
              if (!running[id] || (verifyCallback && !verifyCallback(id))) {
                running[id] = null;
                completedCallback && completedCallback(desiredFrames - (dropCounter / ((now - start) / millisecondsPerSecond)), id, false);
                return;
              }
              if (render) {
                var droppedFrames = Math.round((now - lastFrame) / (millisecondsPerSecond / desiredFrames)) - 1;
                for (var j = 0; j < Math.min(droppedFrames, 4); j++) {
                  step(true);
                  dropCounter++;
                }
              }
              if (duration) {
                percent = (now - start) / duration;
                if (percent > 1) {
                  percent = 1;
                }
              }
              var value = easingMethod ? easingMethod(percent) : percent;
              if ((stepCallback(value, now, render) === false || percent === 1) && render) {
                running[id] = null;
                completedCallback && completedCallback(desiredFrames - (dropCounter / ((now - start) / millisecondsPerSecond)), id, percent === 1 || duration == null);
              } else if (render) {
                lastFrame = now;
                zyngaCore.effect.Animate.requestAnimationFrame(step, root);
              }
            };
            running[id] = true;
            zyngaCore.effect.Animate.requestAnimationFrame(step, root);
            return id;
          }
        };
      })(window);
      (function(ionic) {
        var NOOP = function() {};
        var easeOutCubic = function(pos) {
          return (Math.pow((pos - 1), 3) + 1);
        };
        var easeInOutCubic = function(pos) {
          if ((pos /= 0.5) < 1) {
            return 0.5 * Math.pow(pos, 3);
          }
          return 0.5 * (Math.pow((pos - 2), 3) + 2);
        };
        ionic.views.Scroll = ionic.views.View.inherit({
          initialize: function(options) {
            var self = this;
            self.__container = options.el;
            self.__content = options.el.firstElementChild;
            setTimeout(function() {
              if (self.__container && self.__content) {
                self.__container.scrollTop = 0;
                self.__content.scrollTop = 0;
              }
            });
            self.options = {
              scrollingX: false,
              scrollbarX: true,
              scrollingY: true,
              scrollbarY: true,
              startX: 0,
              startY: 0,
              wheelDampen: 6,
              minScrollbarSizeX: 5,
              minScrollbarSizeY: 5,
              scrollbarsFade: true,
              scrollbarFadeDelay: 300,
              scrollbarResizeFadeDelay: 1000,
              animating: true,
              animationDuration: 250,
              decelVelocityThreshold: 4,
              decelVelocityThresholdPaging: 4,
              bouncing: true,
              locking: true,
              paging: false,
              snapping: false,
              zooming: false,
              minZoom: 0.5,
              maxZoom: 3,
              speedMultiplier: 1,
              deceleration: 0.97,
              preventDefault: false,
              scrollingComplete: NOOP,
              penetrationDeceleration: 0.03,
              penetrationAcceleration: 0.08,
              scrollEventInterval: 10,
              freeze: false,
              getContentWidth: function() {
                return Math.max(self.__content.scrollWidth, self.__content.offsetWidth);
              },
              getContentHeight: function() {
                return Math.max(self.__content.scrollHeight, self.__content.offsetHeight + (self.__content.offsetTop * 2));
              }
            };
            for (var key in options) {
              self.options[key] = options[key];
            }
            self.hintResize = ionic.debounce(function() {
              self.resize();
            }, 1000, true);
            self.onScroll = function() {
              if (!ionic.scroll.isScrolling) {
                setTimeout(self.setScrollStart, 50);
              } else {
                clearTimeout(self.scrollTimer);
                self.scrollTimer = setTimeout(self.setScrollStop, 80);
              }
            };
            self.freeze = function(shouldFreeze) {
              if (arguments.length) {
                self.options.freeze = shouldFreeze;
              }
              return self.options.freeze;
            };
            self.freezeShut = self.freeze;
            self.setScrollStart = function() {
              ionic.scroll.isScrolling = Math.abs(ionic.scroll.lastTop - self.__scrollTop) > 1;
              clearTimeout(self.scrollTimer);
              self.scrollTimer = setTimeout(self.setScrollStop, 80);
            };
            self.setScrollStop = function() {
              ionic.scroll.isScrolling = false;
              ionic.scroll.lastTop = self.__scrollTop;
            };
            self.triggerScrollEvent = ionic.throttle(function() {
              self.onScroll();
              ionic.trigger('scroll', {
                scrollTop: self.__scrollTop,
                scrollLeft: self.__scrollLeft,
                target: self.__container
              });
            }, self.options.scrollEventInterval);
            self.triggerScrollEndEvent = function() {
              ionic.trigger('scrollend', {
                scrollTop: self.__scrollTop,
                scrollLeft: self.__scrollLeft,
                target: self.__container
              });
            };
            self.__scrollLeft = self.options.startX;
            self.__scrollTop = self.options.startY;
            self.__callback = self.getRenderFn();
            self.__initEventHandlers();
            self.__createScrollbars();
          },
          run: function() {
            this.resize();
            this.__fadeScrollbars('out', this.options.scrollbarResizeFadeDelay);
          },
          __isSingleTouch: false,
          __isTracking: false,
          __didDecelerationComplete: false,
          __isGesturing: false,
          __isDragging: false,
          __isDecelerating: false,
          __isAnimating: false,
          __clientLeft: 0,
          __clientTop: 0,
          __clientWidth: 0,
          __clientHeight: 0,
          __contentWidth: 0,
          __contentHeight: 0,
          __snapWidth: 100,
          __snapHeight: 100,
          __refreshHeight: null,
          __refreshActive: false,
          __refreshActivate: null,
          __refreshDeactivate: null,
          __refreshStart: null,
          __zoomLevel: 1,
          __scrollLeft: 0,
          __scrollTop: 0,
          __maxScrollLeft: 0,
          __maxScrollTop: 0,
          __scheduledLeft: 0,
          __scheduledTop: 0,
          __scheduledZoom: 0,
          __lastTouchLeft: null,
          __lastTouchTop: null,
          __lastTouchMove: null,
          __positions: null,
          __minDecelerationScrollLeft: null,
          __minDecelerationScrollTop: null,
          __maxDecelerationScrollLeft: null,
          __maxDecelerationScrollTop: null,
          __decelerationVelocityX: null,
          __decelerationVelocityY: null,
          __transformProperty: null,
          __perspectiveProperty: null,
          __indicatorX: null,
          __indicatorY: null,
          __scrollbarFadeTimeout: null,
          __didWaitForSize: null,
          __sizerTimeout: null,
          __initEventHandlers: function() {
            var self = this;
            var container = self.__container;
            var scrollViewOffsetHeight;
            self.scrollChildIntoView = function(e) {
              var scrollBottomOffsetToTop = container.getBoundingClientRect().bottom;
              scrollViewOffsetHeight = container.offsetHeight;
              var alreadyShrunk = self.isShrunkForKeyboard;
              var isModal = container.parentNode.classList.contains('modal');
              var isInsetModal = isModal && window.innerWidth >= 680;
              if (!alreadyShrunk) {
                if (ionic.Platform.isIOS() || ionic.Platform.isFullScreen || isInsetModal) {
                  var scrollBottomOffsetToBottom = e.detail.viewportHeight - scrollBottomOffsetToTop;
                  var keyboardOffset = Math.max(0, e.detail.keyboardHeight - scrollBottomOffsetToBottom);
                  ionic.requestAnimationFrame(function() {
                    scrollViewOffsetHeight = scrollViewOffsetHeight - keyboardOffset;
                    container.style.height = scrollViewOffsetHeight + "px";
                    container.style.overflow = "visible";
                    self.resize();
                  });
                }
                self.isShrunkForKeyboard = true;
              }
              if (e.detail.isElementUnderKeyboard) {
                ionic.requestAnimationFrame(function() {
                  container.scrollTop = 0;
                  if (self.isShrunkForKeyboard && !alreadyShrunk) {
                    scrollBottomOffsetToTop = container.getBoundingClientRect().bottom;
                  }
                  var scrollMidpointOffset = scrollViewOffsetHeight * 0.5;
                  var inputMidpoint = ((e.detail.elementBottom + e.detail.elementTop) / 2);
                  var inputMidpointOffsetToScrollBottom = inputMidpoint - scrollBottomOffsetToTop;
                  var scrollTop = inputMidpointOffsetToScrollBottom + scrollMidpointOffset;
                  if (scrollTop > 0) {
                    if (ionic.Platform.isIOS())
                      ionic.tap.cloneFocusedInput(container, self);
                    self.scrollBy(0, scrollTop, true);
                    self.onScroll();
                  }
                });
              }
              e.stopPropagation();
            };
            self.resetScrollView = function() {
              if (self.isShrunkForKeyboard) {
                self.isShrunkForKeyboard = false;
                container.style.height = "";
                container.style.overflow = "";
              }
              self.resize();
            };
            container.addEventListener('scrollChildIntoView', self.scrollChildIntoView);
            document.addEventListener('resetScrollView', self.resetScrollView);
            function getEventTouches(e) {
              return e.touches && e.touches.length ? e.touches : [{
                pageX: e.pageX,
                pageY: e.pageY
              }];
            }
            self.touchStart = function(e) {
              self.startCoordinates = ionic.tap.pointerCoord(e);
              if (ionic.tap.ignoreScrollStart(e)) {
                return;
              }
              self.__isDown = true;
              if (ionic.tap.containsOrIsTextInput(e.target) || e.target.tagName === 'SELECT') {
                self.__hasStarted = false;
                return;
              }
              self.__isSelectable = true;
              self.__enableScrollY = true;
              self.__hasStarted = true;
              self.doTouchStart(getEventTouches(e), e.timeStamp);
              e.preventDefault();
            };
            self.touchMove = function(e) {
              if (self.options.freeze || !self.__isDown || (!self.__isDown && e.defaultPrevented) || (e.target.tagName === 'TEXTAREA' && e.target.parentElement.querySelector(':focus'))) {
                return;
              }
              if (!self.__hasStarted && (ionic.tap.containsOrIsTextInput(e.target) || e.target.tagName === 'SELECT')) {
                self.__hasStarted = true;
                self.doTouchStart(getEventTouches(e), e.timeStamp);
                e.preventDefault();
                return;
              }
              if (self.startCoordinates) {
                var currentCoordinates = ionic.tap.pointerCoord(e);
                if (self.__isSelectable && ionic.tap.isTextInput(e.target) && Math.abs(self.startCoordinates.x - currentCoordinates.x) > 20) {
                  self.__enableScrollY = false;
                  self.__isSelectable = true;
                }
                if (self.__enableScrollY && Math.abs(self.startCoordinates.y - currentCoordinates.y) > 10) {
                  self.__isSelectable = false;
                  ionic.tap.cloneFocusedInput(container, self);
                }
              }
              self.doTouchMove(getEventTouches(e), e.timeStamp, e.scale);
              self.__isDown = true;
            };
            self.touchMoveBubble = function(e) {
              if (self.__isDown && self.options.preventDefault) {
                e.preventDefault();
              }
            };
            self.touchEnd = function(e) {
              if (!self.__isDown)
                return;
              self.doTouchEnd(e, e.timeStamp);
              self.__isDown = false;
              self.__hasStarted = false;
              self.__isSelectable = true;
              self.__enableScrollY = true;
              if (!self.__isDragging && !self.__isDecelerating && !self.__isAnimating) {
                ionic.tap.removeClonedInputs(container, self);
              }
            };
            self.mouseWheel = ionic.animationFrameThrottle(function(e) {
              var scrollParent = ionic.DomUtil.getParentOrSelfWithClass(e.target, 'ionic-scroll');
              if (!self.options.freeze && scrollParent === self.__container) {
                self.hintResize();
                self.scrollBy((e.wheelDeltaX || e.deltaX || 0) / self.options.wheelDampen, (-e.wheelDeltaY || e.deltaY || 0) / self.options.wheelDampen);
                self.__fadeScrollbars('in');
                clearTimeout(self.__wheelHideBarTimeout);
                self.__wheelHideBarTimeout = setTimeout(function() {
                  self.__fadeScrollbars('out');
                }, 100);
              }
            });
            if ('ontouchstart' in window) {
              container.addEventListener("touchstart", self.touchStart, false);
              if (self.options.preventDefault)
                container.addEventListener("touchmove", self.touchMoveBubble, false);
              document.addEventListener("touchmove", self.touchMove, false);
              document.addEventListener("touchend", self.touchEnd, false);
              document.addEventListener("touchcancel", self.touchEnd, false);
              document.addEventListener("wheel", self.mouseWheel, false);
            } else if (window.navigator.pointerEnabled) {
              container.addEventListener("pointerdown", self.touchStart, false);
              if (self.options.preventDefault)
                container.addEventListener("pointermove", self.touchMoveBubble, false);
              document.addEventListener("pointermove", self.touchMove, false);
              document.addEventListener("pointerup", self.touchEnd, false);
              document.addEventListener("pointercancel", self.touchEnd, false);
              document.addEventListener("wheel", self.mouseWheel, false);
            } else if (window.navigator.msPointerEnabled) {
              container.addEventListener("MSPointerDown", self.touchStart, false);
              if (self.options.preventDefault)
                container.addEventListener("MSPointerMove", self.touchMoveBubble, false);
              document.addEventListener("MSPointerMove", self.touchMove, false);
              document.addEventListener("MSPointerUp", self.touchEnd, false);
              document.addEventListener("MSPointerCancel", self.touchEnd, false);
              document.addEventListener("wheel", self.mouseWheel, false);
            } else {
              var mousedown = false;
              self.mouseDown = function(e) {
                if (ionic.tap.ignoreScrollStart(e) || e.target.tagName === 'SELECT') {
                  return;
                }
                self.doTouchStart(getEventTouches(e), e.timeStamp);
                if (!ionic.tap.isTextInput(e.target)) {
                  e.preventDefault();
                }
                mousedown = true;
              };
              self.mouseMove = function(e) {
                if (self.options.freeze || !mousedown || (!mousedown && e.defaultPrevented)) {
                  return;
                }
                self.doTouchMove(getEventTouches(e), e.timeStamp);
                mousedown = true;
              };
              self.mouseMoveBubble = function(e) {
                if (mousedown && self.options.preventDefault) {
                  e.preventDefault();
                }
              };
              self.mouseUp = function(e) {
                if (!mousedown) {
                  return;
                }
                self.doTouchEnd(e, e.timeStamp);
                mousedown = false;
              };
              container.addEventListener("mousedown", self.mouseDown, false);
              if (self.options.preventDefault)
                container.addEventListener("mousemove", self.mouseMoveBubble, false);
              document.addEventListener("mousemove", self.mouseMove, false);
              document.addEventListener("mouseup", self.mouseUp, false);
              document.addEventListener('mousewheel', self.mouseWheel, false);
              document.addEventListener('wheel', self.mouseWheel, false);
            }
          },
          __cleanup: function() {
            var self = this;
            var container = self.__container;
            container.removeEventListener('touchstart', self.touchStart);
            container.removeEventListener('touchmove', self.touchMoveBubble);
            document.removeEventListener('touchmove', self.touchMove);
            document.removeEventListener('touchend', self.touchEnd);
            document.removeEventListener('touchcancel', self.touchEnd);
            container.removeEventListener("pointerdown", self.touchStart);
            container.removeEventListener("pointermove", self.touchMoveBubble);
            document.removeEventListener("pointermove", self.touchMove);
            document.removeEventListener("pointerup", self.touchEnd);
            document.removeEventListener("pointercancel", self.touchEnd);
            container.removeEventListener("MSPointerDown", self.touchStart);
            container.removeEventListener("MSPointerMove", self.touchMoveBubble);
            document.removeEventListener("MSPointerMove", self.touchMove);
            document.removeEventListener("MSPointerUp", self.touchEnd);
            document.removeEventListener("MSPointerCancel", self.touchEnd);
            container.removeEventListener("mousedown", self.mouseDown);
            container.removeEventListener("mousemove", self.mouseMoveBubble);
            document.removeEventListener("mousemove", self.mouseMove);
            document.removeEventListener("mouseup", self.mouseUp);
            document.removeEventListener('mousewheel', self.mouseWheel);
            document.removeEventListener('wheel', self.mouseWheel);
            container.removeEventListener('scrollChildIntoView', self.scrollChildIntoView);
            document.removeEventListener('resetScrollView', self.resetScrollView);
            ionic.tap.removeClonedInputs(container, self);
            delete self.__container;
            delete self.__content;
            delete self.__indicatorX;
            delete self.__indicatorY;
            delete self.options.el;
            self.__callback = self.scrollChildIntoView = self.resetScrollView = NOOP;
            self.mouseMove = self.mouseDown = self.mouseUp = self.mouseWheel = self.touchStart = self.touchMove = self.touchEnd = self.touchCancel = NOOP;
            self.resize = self.scrollTo = self.zoomTo = self.__scrollingComplete = NOOP;
            container = null;
          },
          __createScrollbar: function(direction) {
            var bar = document.createElement('div'),
                indicator = document.createElement('div');
            indicator.className = 'scroll-bar-indicator scroll-bar-fade-out';
            if (direction == 'h') {
              bar.className = 'scroll-bar scroll-bar-h';
            } else {
              bar.className = 'scroll-bar scroll-bar-v';
            }
            bar.appendChild(indicator);
            return bar;
          },
          __createScrollbars: function() {
            var self = this;
            var indicatorX,
                indicatorY;
            if (self.options.scrollingX) {
              indicatorX = {
                el: self.__createScrollbar('h'),
                sizeRatio: 1
              };
              indicatorX.indicator = indicatorX.el.children[0];
              if (self.options.scrollbarX) {
                self.__container.appendChild(indicatorX.el);
              }
              self.__indicatorX = indicatorX;
            }
            if (self.options.scrollingY) {
              indicatorY = {
                el: self.__createScrollbar('v'),
                sizeRatio: 1
              };
              indicatorY.indicator = indicatorY.el.children[0];
              if (self.options.scrollbarY) {
                self.__container.appendChild(indicatorY.el);
              }
              self.__indicatorY = indicatorY;
            }
          },
          __resizeScrollbars: function() {
            var self = this;
            if (self.__indicatorX) {
              var width = Math.max(Math.round(self.__clientWidth * self.__clientWidth / (self.__contentWidth)), 20);
              if (width > self.__contentWidth) {
                width = 0;
              }
              if (width !== self.__indicatorX.size) {
                ionic.requestAnimationFrame(function() {
                  self.__indicatorX.indicator.style.width = width + 'px';
                });
              }
              self.__indicatorX.size = width;
              self.__indicatorX.minScale = self.options.minScrollbarSizeX / width;
              self.__indicatorX.maxPos = self.__clientWidth - width;
              self.__indicatorX.sizeRatio = self.__maxScrollLeft ? self.__indicatorX.maxPos / self.__maxScrollLeft : 1;
            }
            if (self.__indicatorY) {
              var height = Math.max(Math.round(self.__clientHeight * self.__clientHeight / (self.__contentHeight)), 20);
              if (height > self.__contentHeight) {
                height = 0;
              }
              if (height !== self.__indicatorY.size) {
                ionic.requestAnimationFrame(function() {
                  self.__indicatorY && (self.__indicatorY.indicator.style.height = height + 'px');
                });
              }
              self.__indicatorY.size = height;
              self.__indicatorY.minScale = self.options.minScrollbarSizeY / height;
              self.__indicatorY.maxPos = self.__clientHeight - height;
              self.__indicatorY.sizeRatio = self.__maxScrollTop ? self.__indicatorY.maxPos / self.__maxScrollTop : 1;
            }
          },
          __repositionScrollbars: function() {
            var self = this,
                heightScale,
                widthScale,
                widthDiff,
                heightDiff,
                x,
                y,
                xstop = 0,
                ystop = 0;
            if (self.__indicatorX) {
              if (self.__indicatorY)
                xstop = 10;
              x = Math.round(self.__indicatorX.sizeRatio * self.__scrollLeft) || 0;
              widthDiff = self.__scrollLeft - (self.__maxScrollLeft - xstop);
              if (self.__scrollLeft < 0) {
                widthScale = Math.max(self.__indicatorX.minScale, (self.__indicatorX.size - Math.abs(self.__scrollLeft)) / self.__indicatorX.size);
                x = 0;
                self.__indicatorX.indicator.style[self.__transformOriginProperty] = 'left center';
              } else if (widthDiff > 0) {
                widthScale = Math.max(self.__indicatorX.minScale, (self.__indicatorX.size - widthDiff) / self.__indicatorX.size);
                x = self.__indicatorX.maxPos - xstop;
                self.__indicatorX.indicator.style[self.__transformOriginProperty] = 'right center';
              } else {
                x = Math.min(self.__maxScrollLeft, Math.max(0, x));
                widthScale = 1;
              }
              var translate3dX = 'translate3d(' + x + 'px, 0, 0) scaleX(' + widthScale + ')';
              if (self.__indicatorX.transformProp !== translate3dX) {
                self.__indicatorX.indicator.style[self.__transformProperty] = translate3dX;
                self.__indicatorX.transformProp = translate3dX;
              }
            }
            if (self.__indicatorY) {
              y = Math.round(self.__indicatorY.sizeRatio * self.__scrollTop) || 0;
              if (self.__indicatorX)
                ystop = 10;
              heightDiff = self.__scrollTop - (self.__maxScrollTop - ystop);
              if (self.__scrollTop < 0) {
                heightScale = Math.max(self.__indicatorY.minScale, (self.__indicatorY.size - Math.abs(self.__scrollTop)) / self.__indicatorY.size);
                y = 0;
                if (self.__indicatorY.originProp !== 'center top') {
                  self.__indicatorY.indicator.style[self.__transformOriginProperty] = 'center top';
                  self.__indicatorY.originProp = 'center top';
                }
              } else if (heightDiff > 0) {
                heightScale = Math.max(self.__indicatorY.minScale, (self.__indicatorY.size - heightDiff) / self.__indicatorY.size);
                y = self.__indicatorY.maxPos - ystop;
                if (self.__indicatorY.originProp !== 'center bottom') {
                  self.__indicatorY.indicator.style[self.__transformOriginProperty] = 'center bottom';
                  self.__indicatorY.originProp = 'center bottom';
                }
              } else {
                y = Math.min(self.__maxScrollTop, Math.max(0, y));
                heightScale = 1;
              }
              var translate3dY = 'translate3d(0,' + y + 'px, 0) scaleY(' + heightScale + ')';
              if (self.__indicatorY.transformProp !== translate3dY) {
                self.__indicatorY.indicator.style[self.__transformProperty] = translate3dY;
                self.__indicatorY.transformProp = translate3dY;
              }
            }
          },
          __fadeScrollbars: function(direction, delay) {
            var self = this;
            if (!self.options.scrollbarsFade) {
              return;
            }
            var className = 'scroll-bar-fade-out';
            if (self.options.scrollbarsFade === true) {
              clearTimeout(self.__scrollbarFadeTimeout);
              if (direction == 'in') {
                if (self.__indicatorX) {
                  self.__indicatorX.indicator.classList.remove(className);
                }
                if (self.__indicatorY) {
                  self.__indicatorY.indicator.classList.remove(className);
                }
              } else {
                self.__scrollbarFadeTimeout = setTimeout(function() {
                  if (self.__indicatorX) {
                    self.__indicatorX.indicator.classList.add(className);
                  }
                  if (self.__indicatorY) {
                    self.__indicatorY.indicator.classList.add(className);
                  }
                }, delay || self.options.scrollbarFadeDelay);
              }
            }
          },
          __scrollingComplete: function() {
            this.options.scrollingComplete();
            ionic.tap.removeClonedInputs(this.__container, this);
            this.__fadeScrollbars('out');
          },
          resize: function(continueScrolling) {
            var self = this;
            if (!self.__container || !self.options)
              return;
            self.setDimensions(self.__container.clientWidth, self.__container.clientHeight, self.options.getContentWidth(), self.options.getContentHeight(), continueScrolling);
          },
          getRenderFn: function() {
            var self = this;
            var content = self.__content;
            var docStyle = document.documentElement.style;
            var engine;
            if ('MozAppearance' in docStyle) {
              engine = 'gecko';
            } else if ('WebkitAppearance' in docStyle) {
              engine = 'webkit';
            } else if (typeof navigator.cpuClass === 'string') {
              engine = 'trident';
            }
            var vendorPrefix = {
              trident: 'ms',
              gecko: 'Moz',
              webkit: 'Webkit',
              presto: 'O'
            }[engine];
            var helperElem = document.createElement("div");
            var undef;
            var perspectiveProperty = vendorPrefix + "Perspective";
            var transformProperty = vendorPrefix + "Transform";
            var transformOriginProperty = vendorPrefix + 'TransformOrigin';
            self.__perspectiveProperty = transformProperty;
            self.__transformProperty = transformProperty;
            self.__transformOriginProperty = transformOriginProperty;
            if (helperElem.style[perspectiveProperty] !== undef) {
              return function(left, top, zoom, wasResize) {
                var translate3d = 'translate3d(' + (-left) + 'px,' + (-top) + 'px,0) scale(' + zoom + ')';
                if (translate3d !== self.contentTransform) {
                  content.style[transformProperty] = translate3d;
                  self.contentTransform = translate3d;
                }
                self.__repositionScrollbars();
                if (!wasResize) {
                  self.triggerScrollEvent();
                }
              };
            } else if (helperElem.style[transformProperty] !== undef) {
              return function(left, top, zoom, wasResize) {
                content.style[transformProperty] = 'translate(' + (-left) + 'px,' + (-top) + 'px) scale(' + zoom + ')';
                self.__repositionScrollbars();
                if (!wasResize) {
                  self.triggerScrollEvent();
                }
              };
            } else {
              return function(left, top, zoom, wasResize) {
                content.style.marginLeft = left ? (-left / zoom) + 'px' : '';
                content.style.marginTop = top ? (-top / zoom) + 'px' : '';
                content.style.zoom = zoom || '';
                self.__repositionScrollbars();
                if (!wasResize) {
                  self.triggerScrollEvent();
                }
              };
            }
          },
          setDimensions: function(clientWidth, clientHeight, contentWidth, contentHeight, continueScrolling) {
            var self = this;
            if (!clientWidth && !clientHeight && !contentWidth && !contentHeight) {
              return;
            }
            if (clientWidth === +clientWidth) {
              self.__clientWidth = clientWidth;
            }
            if (clientHeight === +clientHeight) {
              self.__clientHeight = clientHeight;
            }
            if (contentWidth === +contentWidth) {
              self.__contentWidth = contentWidth;
            }
            if (contentHeight === +contentHeight) {
              self.__contentHeight = contentHeight;
            }
            self.__computeScrollMax();
            self.__resizeScrollbars();
            if (!continueScrolling) {
              self.scrollTo(self.__scrollLeft, self.__scrollTop, true, null, true);
            }
          },
          setPosition: function(left, top) {
            this.__clientLeft = left || 0;
            this.__clientTop = top || 0;
          },
          setSnapSize: function(width, height) {
            this.__snapWidth = width;
            this.__snapHeight = height;
          },
          activatePullToRefresh: function(height, refresherMethods) {
            var self = this;
            self.__refreshHeight = height;
            self.__refreshActivate = function() {
              ionic.requestAnimationFrame(refresherMethods.activate);
            };
            self.__refreshDeactivate = function() {
              ionic.requestAnimationFrame(refresherMethods.deactivate);
            };
            self.__refreshStart = function() {
              ionic.requestAnimationFrame(refresherMethods.start);
            };
            self.__refreshShow = function() {
              ionic.requestAnimationFrame(refresherMethods.show);
            };
            self.__refreshHide = function() {
              ionic.requestAnimationFrame(refresherMethods.hide);
            };
            self.__refreshTail = function() {
              ionic.requestAnimationFrame(refresherMethods.tail);
            };
            self.__refreshTailTime = 100;
            self.__minSpinTime = 600;
          },
          triggerPullToRefresh: function() {
            this.__publish(this.__scrollLeft, -this.__refreshHeight, this.__zoomLevel, true);
            var d = new Date();
            this.refreshStartTime = d.getTime();
            if (this.__refreshStart) {
              this.__refreshStart();
            }
          },
          finishPullToRefresh: function() {
            var self = this;
            var d = new Date();
            var delay = 0;
            if (self.refreshStartTime + self.__minSpinTime > d.getTime()) {
              delay = self.refreshStartTime + self.__minSpinTime - d.getTime();
            }
            setTimeout(function() {
              if (self.__refreshTail) {
                self.__refreshTail();
              }
              setTimeout(function() {
                self.__refreshActive = false;
                if (self.__refreshDeactivate) {
                  self.__refreshDeactivate();
                }
                if (self.__refreshHide) {
                  self.__refreshHide();
                }
                self.scrollTo(self.__scrollLeft, self.__scrollTop, true);
              }, self.__refreshTailTime);
            }, delay);
          },
          getValues: function() {
            return {
              left: this.__scrollLeft,
              top: this.__scrollTop,
              zoom: this.__zoomLevel
            };
          },
          getScrollMax: function() {
            return {
              left: this.__maxScrollLeft,
              top: this.__maxScrollTop
            };
          },
          zoomTo: function(level, animate, originLeft, originTop) {
            var self = this;
            if (!self.options.zooming) {
              throw new Error("Zooming is not enabled!");
            }
            if (self.__isDecelerating) {
              zyngaCore.effect.Animate.stop(self.__isDecelerating);
              self.__isDecelerating = false;
            }
            var oldLevel = self.__zoomLevel;
            if (originLeft == null) {
              originLeft = self.__clientWidth / 2;
            }
            if (originTop == null) {
              originTop = self.__clientHeight / 2;
            }
            level = Math.max(Math.min(level, self.options.maxZoom), self.options.minZoom);
            self.__computeScrollMax(level);
            var left = ((originLeft + self.__scrollLeft) * level / oldLevel) - originLeft;
            var top = ((originTop + self.__scrollTop) * level / oldLevel) - originTop;
            if (left > self.__maxScrollLeft) {
              left = self.__maxScrollLeft;
            } else if (left < 0) {
              left = 0;
            }
            if (top > self.__maxScrollTop) {
              top = self.__maxScrollTop;
            } else if (top < 0) {
              top = 0;
            }
            self.__publish(left, top, level, animate);
          },
          zoomBy: function(factor, animate, originLeft, originTop) {
            this.zoomTo(this.__zoomLevel * factor, animate, originLeft, originTop);
          },
          scrollTo: function(left, top, animate, zoom, wasResize) {
            var self = this;
            if (self.__isDecelerating) {
              zyngaCore.effect.Animate.stop(self.__isDecelerating);
              self.__isDecelerating = false;
            }
            if (zoom != null && zoom !== self.__zoomLevel) {
              if (!self.options.zooming) {
                throw new Error("Zooming is not enabled!");
              }
              left *= zoom;
              top *= zoom;
              self.__computeScrollMax(zoom);
            } else {
              zoom = self.__zoomLevel;
            }
            if (!self.options.scrollingX) {
              left = self.__scrollLeft;
            } else {
              if (self.options.paging) {
                left = Math.round(left / self.__clientWidth) * self.__clientWidth;
              } else if (self.options.snapping) {
                left = Math.round(left / self.__snapWidth) * self.__snapWidth;
              }
            }
            if (!self.options.scrollingY) {
              top = self.__scrollTop;
            } else {
              if (self.options.paging) {
                top = Math.round(top / self.__clientHeight) * self.__clientHeight;
              } else if (self.options.snapping) {
                top = Math.round(top / self.__snapHeight) * self.__snapHeight;
              }
            }
            left = Math.max(Math.min(self.__maxScrollLeft, left), 0);
            top = Math.max(Math.min(self.__maxScrollTop, top), 0);
            if (left === self.__scrollLeft && top === self.__scrollTop) {
              animate = false;
            }
            self.__publish(left, top, zoom, animate, wasResize);
          },
          scrollBy: function(left, top, animate) {
            var self = this;
            var startLeft = self.__isAnimating ? self.__scheduledLeft : self.__scrollLeft;
            var startTop = self.__isAnimating ? self.__scheduledTop : self.__scrollTop;
            self.scrollTo(startLeft + (left || 0), startTop + (top || 0), animate);
          },
          doMouseZoom: function(wheelDelta, timeStamp, pageX, pageY) {
            var change = wheelDelta > 0 ? 0.97 : 1.03;
            return this.zoomTo(this.__zoomLevel * change, false, pageX - this.__clientLeft, pageY - this.__clientTop);
          },
          doTouchStart: function(touches, timeStamp) {
            var self = this;
            self.__decStopped = !!(self.__isDecelerating || self.__isAnimating);
            self.hintResize();
            if (timeStamp instanceof Date) {
              timeStamp = timeStamp.valueOf();
            }
            if (typeof timeStamp !== "number") {
              timeStamp = Date.now();
            }
            self.__interruptedAnimation = true;
            if (self.__isDecelerating) {
              zyngaCore.effect.Animate.stop(self.__isDecelerating);
              self.__isDecelerating = false;
              self.__interruptedAnimation = true;
            }
            if (self.__isAnimating) {
              zyngaCore.effect.Animate.stop(self.__isAnimating);
              self.__isAnimating = false;
              self.__interruptedAnimation = true;
            }
            var currentTouchLeft,
                currentTouchTop;
            var isSingleTouch = touches.length === 1;
            if (isSingleTouch) {
              currentTouchLeft = touches[0].pageX;
              currentTouchTop = touches[0].pageY;
            } else {
              currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;
              currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;
            }
            self.__initialTouchLeft = currentTouchLeft;
            self.__initialTouchTop = currentTouchTop;
            self.__initialTouches = touches;
            self.__zoomLevelStart = self.__zoomLevel;
            self.__lastTouchLeft = currentTouchLeft;
            self.__lastTouchTop = currentTouchTop;
            self.__lastTouchMove = timeStamp;
            self.__lastScale = 1;
            self.__enableScrollX = !isSingleTouch && self.options.scrollingX;
            self.__enableScrollY = !isSingleTouch && self.options.scrollingY;
            self.__isTracking = true;
            self.__didDecelerationComplete = false;
            self.__isDragging = !isSingleTouch;
            self.__isSingleTouch = isSingleTouch;
            self.__positions = [];
          },
          doTouchMove: function(touches, timeStamp, scale) {
            if (timeStamp instanceof Date) {
              timeStamp = timeStamp.valueOf();
            }
            if (typeof timeStamp !== "number") {
              timeStamp = Date.now();
            }
            var self = this;
            if (!self.__isTracking) {
              return;
            }
            var currentTouchLeft,
                currentTouchTop;
            if (touches.length === 2) {
              currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;
              currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;
              if (!scale && self.options.zooming) {
                scale = self.__getScale(self.__initialTouches, touches);
              }
            } else {
              currentTouchLeft = touches[0].pageX;
              currentTouchTop = touches[0].pageY;
            }
            var positions = self.__positions;
            if (self.__isDragging) {
              self.__decStopped = false;
              var moveX = currentTouchLeft - self.__lastTouchLeft;
              var moveY = currentTouchTop - self.__lastTouchTop;
              var scrollLeft = self.__scrollLeft;
              var scrollTop = self.__scrollTop;
              var level = self.__zoomLevel;
              if (scale != null && self.options.zooming) {
                var oldLevel = level;
                level = level / self.__lastScale * scale;
                level = Math.max(Math.min(level, self.options.maxZoom), self.options.minZoom);
                if (oldLevel !== level) {
                  var currentTouchLeftRel = currentTouchLeft - self.__clientLeft;
                  var currentTouchTopRel = currentTouchTop - self.__clientTop;
                  scrollLeft = ((currentTouchLeftRel + scrollLeft) * level / oldLevel) - currentTouchLeftRel;
                  scrollTop = ((currentTouchTopRel + scrollTop) * level / oldLevel) - currentTouchTopRel;
                  self.__computeScrollMax(level);
                }
              }
              if (self.__enableScrollX) {
                scrollLeft -= moveX * self.options.speedMultiplier;
                var maxScrollLeft = self.__maxScrollLeft;
                if (scrollLeft > maxScrollLeft || scrollLeft < 0) {
                  if (self.options.bouncing) {
                    scrollLeft += (moveX / 2 * self.options.speedMultiplier);
                  } else if (scrollLeft > maxScrollLeft) {
                    scrollLeft = maxScrollLeft;
                  } else {
                    scrollLeft = 0;
                  }
                }
              }
              if (self.__enableScrollY) {
                scrollTop -= moveY * self.options.speedMultiplier;
                var maxScrollTop = self.__maxScrollTop;
                if (scrollTop > maxScrollTop || scrollTop < 0) {
                  if (self.options.bouncing || (self.__refreshHeight && scrollTop < 0)) {
                    scrollTop += (moveY / 2 * self.options.speedMultiplier);
                    if (!self.__enableScrollX && self.__refreshHeight != null) {
                      if (scrollTop < 0) {
                        self.__refreshHidden = false;
                        self.__refreshShow();
                      } else {
                        self.__refreshHide();
                        self.__refreshHidden = true;
                      }
                      if (!self.__refreshActive && scrollTop <= -self.__refreshHeight) {
                        self.__refreshActive = true;
                        if (self.__refreshActivate) {
                          self.__refreshActivate();
                        }
                      } else if (self.__refreshActive && scrollTop > -self.__refreshHeight) {
                        self.__refreshActive = false;
                        if (self.__refreshDeactivate) {
                          self.__refreshDeactivate();
                        }
                      }
                    }
                  } else if (scrollTop > maxScrollTop) {
                    scrollTop = maxScrollTop;
                  } else {
                    scrollTop = 0;
                  }
                } else if (self.__refreshHeight && !self.__refreshHidden) {
                  self.__refreshHide();
                  self.__refreshHidden = true;
                }
              }
              if (positions.length > 60) {
                positions.splice(0, 30);
              }
              positions.push(scrollLeft, scrollTop, timeStamp);
              self.__publish(scrollLeft, scrollTop, level);
            } else {
              var minimumTrackingForScroll = self.options.locking ? 3 : 0;
              var minimumTrackingForDrag = 5;
              var distanceX = Math.abs(currentTouchLeft - self.__initialTouchLeft);
              var distanceY = Math.abs(currentTouchTop - self.__initialTouchTop);
              self.__enableScrollX = self.options.scrollingX && distanceX >= minimumTrackingForScroll;
              self.__enableScrollY = self.options.scrollingY && distanceY >= minimumTrackingForScroll;
              positions.push(self.__scrollLeft, self.__scrollTop, timeStamp);
              self.__isDragging = (self.__enableScrollX || self.__enableScrollY) && (distanceX >= minimumTrackingForDrag || distanceY >= minimumTrackingForDrag);
              if (self.__isDragging) {
                self.__interruptedAnimation = false;
                self.__fadeScrollbars('in');
              }
            }
            self.__lastTouchLeft = currentTouchLeft;
            self.__lastTouchTop = currentTouchTop;
            self.__lastTouchMove = timeStamp;
            self.__lastScale = scale;
          },
          doTouchEnd: function(e, timeStamp) {
            if (timeStamp instanceof Date) {
              timeStamp = timeStamp.valueOf();
            }
            if (typeof timeStamp !== "number") {
              timeStamp = Date.now();
            }
            var self = this;
            if (!self.__isTracking) {
              return;
            }
            self.__isTracking = false;
            if (self.__isDragging) {
              self.__isDragging = false;
              if (self.__isSingleTouch && self.options.animating && (timeStamp - self.__lastTouchMove) <= 100) {
                var positions = self.__positions;
                var endPos = positions.length - 1;
                var startPos = endPos;
                for (var i = endPos; i > 0 && positions[i] > (self.__lastTouchMove - 100); i -= 3) {
                  startPos = i;
                }
                if (startPos !== endPos) {
                  var timeOffset = positions[endPos] - positions[startPos];
                  var movedLeft = self.__scrollLeft - positions[startPos - 2];
                  var movedTop = self.__scrollTop - positions[startPos - 1];
                  self.__decelerationVelocityX = movedLeft / timeOffset * (1000 / 60);
                  self.__decelerationVelocityY = movedTop / timeOffset * (1000 / 60);
                  var minVelocityToStartDeceleration = self.options.paging || self.options.snapping ? self.options.decelVelocityThresholdPaging : self.options.decelVelocityThreshold;
                  if (Math.abs(self.__decelerationVelocityX) > minVelocityToStartDeceleration || Math.abs(self.__decelerationVelocityY) > minVelocityToStartDeceleration) {
                    if (!self.__refreshActive) {
                      self.__startDeceleration(timeStamp);
                    }
                  }
                } else {
                  self.__scrollingComplete();
                }
              } else if ((timeStamp - self.__lastTouchMove) > 100) {
                self.__scrollingComplete();
              }
            } else if (self.__decStopped) {
              e.isTapHandled = true;
              self.__decStopped = false;
            }
            if (!self.__isDecelerating) {
              if (self.__refreshActive && self.__refreshStart) {
                self.__publish(self.__scrollLeft, -self.__refreshHeight, self.__zoomLevel, true);
                var d = new Date();
                self.refreshStartTime = d.getTime();
                if (self.__refreshStart) {
                  self.__refreshStart();
                }
                if (!ionic.Platform.isAndroid())
                  self.__startDeceleration();
              } else {
                if (self.__interruptedAnimation || self.__isDragging) {
                  self.__scrollingComplete();
                }
                self.scrollTo(self.__scrollLeft, self.__scrollTop, true, self.__zoomLevel);
                if (self.__refreshActive) {
                  self.__refreshActive = false;
                  if (self.__refreshDeactivate) {
                    self.__refreshDeactivate();
                  }
                }
              }
            }
            self.__positions.length = 0;
          },
          __publish: function(left, top, zoom, animate, wasResize) {
            var self = this;
            var wasAnimating = self.__isAnimating;
            if (wasAnimating) {
              zyngaCore.effect.Animate.stop(wasAnimating);
              self.__isAnimating = false;
            }
            if (animate && self.options.animating) {
              self.__scheduledLeft = left;
              self.__scheduledTop = top;
              self.__scheduledZoom = zoom;
              var oldLeft = self.__scrollLeft;
              var oldTop = self.__scrollTop;
              var oldZoom = self.__zoomLevel;
              var diffLeft = left - oldLeft;
              var diffTop = top - oldTop;
              var diffZoom = zoom - oldZoom;
              var step = function(percent, now, render) {
                if (render) {
                  self.__scrollLeft = oldLeft + (diffLeft * percent);
                  self.__scrollTop = oldTop + (diffTop * percent);
                  self.__zoomLevel = oldZoom + (diffZoom * percent);
                  if (self.__callback) {
                    self.__callback(self.__scrollLeft, self.__scrollTop, self.__zoomLevel, wasResize);
                  }
                }
              };
              var verify = function(id) {
                return self.__isAnimating === id;
              };
              var completed = function(renderedFramesPerSecond, animationId, wasFinished) {
                if (animationId === self.__isAnimating) {
                  self.__isAnimating = false;
                }
                if (self.__didDecelerationComplete || wasFinished) {
                  self.__scrollingComplete();
                }
                if (self.options.zooming) {
                  self.__computeScrollMax();
                }
              };
              self.__isAnimating = zyngaCore.effect.Animate.start(step, verify, completed, self.options.animationDuration, wasAnimating ? easeOutCubic : easeInOutCubic);
            } else {
              self.__scheduledLeft = self.__scrollLeft = left;
              self.__scheduledTop = self.__scrollTop = top;
              self.__scheduledZoom = self.__zoomLevel = zoom;
              if (self.__callback) {
                self.__callback(left, top, zoom, wasResize);
              }
              if (self.options.zooming) {
                self.__computeScrollMax();
              }
            }
          },
          __computeScrollMax: function(zoomLevel) {
            var self = this;
            if (zoomLevel == null) {
              zoomLevel = self.__zoomLevel;
            }
            self.__maxScrollLeft = Math.max((self.__contentWidth * zoomLevel) - self.__clientWidth, 0);
            self.__maxScrollTop = Math.max((self.__contentHeight * zoomLevel) - self.__clientHeight, 0);
            if (!self.__didWaitForSize && !self.__maxScrollLeft && !self.__maxScrollTop) {
              self.__didWaitForSize = true;
              self.__waitForSize();
            }
          },
          __waitForSize: function() {
            var self = this;
            clearTimeout(self.__sizerTimeout);
            var sizer = function() {
              self.resize(true);
            };
            sizer();
            self.__sizerTimeout = setTimeout(sizer, 500);
          },
          __startDeceleration: function() {
            var self = this;
            if (self.options.paging) {
              var scrollLeft = Math.max(Math.min(self.__scrollLeft, self.__maxScrollLeft), 0);
              var scrollTop = Math.max(Math.min(self.__scrollTop, self.__maxScrollTop), 0);
              var clientWidth = self.__clientWidth;
              var clientHeight = self.__clientHeight;
              self.__minDecelerationScrollLeft = Math.floor(scrollLeft / clientWidth) * clientWidth;
              self.__minDecelerationScrollTop = Math.floor(scrollTop / clientHeight) * clientHeight;
              self.__maxDecelerationScrollLeft = Math.ceil(scrollLeft / clientWidth) * clientWidth;
              self.__maxDecelerationScrollTop = Math.ceil(scrollTop / clientHeight) * clientHeight;
            } else {
              self.__minDecelerationScrollLeft = 0;
              self.__minDecelerationScrollTop = 0;
              self.__maxDecelerationScrollLeft = self.__maxScrollLeft;
              self.__maxDecelerationScrollTop = self.__maxScrollTop;
              if (self.__refreshActive)
                self.__minDecelerationScrollTop = self.__refreshHeight * -1;
            }
            var step = function(percent, now, render) {
              self.__stepThroughDeceleration(render);
            };
            self.__minVelocityToKeepDecelerating = self.options.snapping ? 4 : 0.1;
            var verify = function() {
              var shouldContinue = Math.abs(self.__decelerationVelocityX) >= self.__minVelocityToKeepDecelerating || Math.abs(self.__decelerationVelocityY) >= self.__minVelocityToKeepDecelerating;
              if (!shouldContinue) {
                self.__didDecelerationComplete = true;
                if (self.options.bouncing && !self.__refreshActive) {
                  self.scrollTo(Math.min(Math.max(self.__scrollLeft, 0), self.__maxScrollLeft), Math.min(Math.max(self.__scrollTop, 0), self.__maxScrollTop), self.__refreshActive);
                }
              }
              return shouldContinue;
            };
            var completed = function() {
              self.__isDecelerating = false;
              if (self.__didDecelerationComplete) {
                self.__scrollingComplete();
              }
              if (self.options.paging) {
                self.scrollTo(self.__scrollLeft, self.__scrollTop, self.options.snapping);
              }
            };
            self.__isDecelerating = zyngaCore.effect.Animate.start(step, verify, completed);
          },
          __stepThroughDeceleration: function(render) {
            var self = this;
            var scrollLeft = self.__scrollLeft + self.__decelerationVelocityX;
            var scrollTop = self.__scrollTop + self.__decelerationVelocityY;
            if (!self.options.bouncing) {
              var scrollLeftFixed = Math.max(Math.min(self.__maxDecelerationScrollLeft, scrollLeft), self.__minDecelerationScrollLeft);
              if (scrollLeftFixed !== scrollLeft) {
                scrollLeft = scrollLeftFixed;
                self.__decelerationVelocityX = 0;
              }
              var scrollTopFixed = Math.max(Math.min(self.__maxDecelerationScrollTop, scrollTop), self.__minDecelerationScrollTop);
              if (scrollTopFixed !== scrollTop) {
                scrollTop = scrollTopFixed;
                self.__decelerationVelocityY = 0;
              }
            }
            if (render) {
              self.__publish(scrollLeft, scrollTop, self.__zoomLevel);
            } else {
              self.__scrollLeft = scrollLeft;
              self.__scrollTop = scrollTop;
            }
            if (!self.options.paging) {
              var frictionFactor = self.options.deceleration;
              self.__decelerationVelocityX *= frictionFactor;
              self.__decelerationVelocityY *= frictionFactor;
            }
            if (self.options.bouncing) {
              var scrollOutsideX = 0;
              var scrollOutsideY = 0;
              var penetrationDeceleration = self.options.penetrationDeceleration;
              var penetrationAcceleration = self.options.penetrationAcceleration;
              if (scrollLeft < self.__minDecelerationScrollLeft) {
                scrollOutsideX = self.__minDecelerationScrollLeft - scrollLeft;
              } else if (scrollLeft > self.__maxDecelerationScrollLeft) {
                scrollOutsideX = self.__maxDecelerationScrollLeft - scrollLeft;
              }
              if (scrollTop < self.__minDecelerationScrollTop) {
                scrollOutsideY = self.__minDecelerationScrollTop - scrollTop;
              } else if (scrollTop > self.__maxDecelerationScrollTop) {
                scrollOutsideY = self.__maxDecelerationScrollTop - scrollTop;
              }
              if (scrollOutsideX !== 0) {
                var isHeadingOutwardsX = scrollOutsideX * self.__decelerationVelocityX <= self.__minDecelerationScrollLeft;
                if (isHeadingOutwardsX) {
                  self.__decelerationVelocityX += scrollOutsideX * penetrationDeceleration;
                }
                var isStoppedX = Math.abs(self.__decelerationVelocityX) <= self.__minVelocityToKeepDecelerating;
                if (!isHeadingOutwardsX || isStoppedX) {
                  self.__decelerationVelocityX = scrollOutsideX * penetrationAcceleration;
                }
              }
              if (scrollOutsideY !== 0) {
                var isHeadingOutwardsY = scrollOutsideY * self.__decelerationVelocityY <= self.__minDecelerationScrollTop;
                if (isHeadingOutwardsY) {
                  self.__decelerationVelocityY += scrollOutsideY * penetrationDeceleration;
                }
                var isStoppedY = Math.abs(self.__decelerationVelocityY) <= self.__minVelocityToKeepDecelerating;
                if (!isHeadingOutwardsY || isStoppedY) {
                  self.__decelerationVelocityY = scrollOutsideY * penetrationAcceleration;
                }
              }
            }
          },
          __getDistance: function getDistance(touch1, touch2) {
            var x = touch2.pageX - touch1.pageX,
                y = touch2.pageY - touch1.pageY;
            return Math.sqrt((x * x) + (y * y));
          },
          __getScale: function getScale(start, end) {
            if (start.length >= 2 && end.length >= 2) {
              return this.__getDistance(end[0], end[1]) / this.__getDistance(start[0], start[1]);
            }
            return 1;
          }
        });
        ionic.scroll = {
          isScrolling: false,
          lastTop: 0
        };
      })(ionic);
      (function(ionic) {
        var NOOP = function() {};
        var deprecated = function(name) {
          void 0;
        };
        ionic.views.ScrollNative = ionic.views.View.inherit({
          initialize: function(options) {
            var self = this;
            self.__container = self.el = options.el;
            self.__content = options.el.firstElementChild;
            self.__frozen = false;
            self.isNative = true;
            self.__scrollTop = self.el.scrollTop;
            self.__scrollLeft = self.el.scrollLeft;
            self.__clientHeight = self.__content.clientHeight;
            self.__clientWidth = self.__content.clientWidth;
            self.__maxScrollTop = Math.max((self.__contentHeight) - self.__clientHeight, 0);
            self.__maxScrollLeft = Math.max((self.__contentWidth) - self.__clientWidth, 0);
            if (options.startY >= 0 || options.startX >= 0) {
              ionic.requestAnimationFrame(function() {
                self.el.scrollTop = options.startY || 0;
                self.el.scrollLeft = options.startX || 0;
                self.__scrollTop = self.el.scrollTop;
                self.__scrollLeft = self.el.scrollLeft;
              });
            }
            self.options = {
              freeze: false,
              getContentWidth: function() {
                return Math.max(self.__content.scrollWidth, self.__content.offsetWidth);
              },
              getContentHeight: function() {
                return Math.max(self.__content.scrollHeight, self.__content.offsetHeight + (self.__content.offsetTop * 2));
              }
            };
            for (var key in options) {
              self.options[key] = options[key];
            }
            self.onScroll = function() {
              if (!ionic.scroll.isScrolling) {
                ionic.scroll.isScrolling = true;
              }
              clearTimeout(self.scrollTimer);
              self.scrollTimer = setTimeout(function() {
                ionic.scroll.isScrolling = false;
              }, 80);
            };
            self.freeze = function(shouldFreeze) {
              self.__frozen = shouldFreeze;
            };
            self.freezeShut = function(shouldFreezeShut) {
              self.__frozenShut = shouldFreezeShut;
            };
            self.__initEventHandlers();
          },
          __callback: function() {
            deprecated('__callback');
          },
          zoomTo: function() {
            deprecated('zoomTo');
          },
          zoomBy: function() {
            deprecated('zoomBy');
          },
          activatePullToRefresh: function() {
            deprecated('activatePullToRefresh');
          },
          resize: function(continueScrolling) {
            var self = this;
            if (!self.__container || !self.options)
              return;
            self.setDimensions(self.__container.clientWidth, self.__container.clientHeight, self.options.getContentWidth(), self.options.getContentHeight(), continueScrolling);
          },
          run: function() {
            this.resize();
          },
          getValues: function() {
            var self = this;
            self.update();
            return {
              left: self.__scrollLeft,
              top: self.__scrollTop,
              zoom: 1
            };
          },
          update: function() {
            var self = this;
            self.__scrollLeft = self.el.scrollLeft;
            self.__scrollTop = self.el.scrollTop;
          },
          setDimensions: function(clientWidth, clientHeight, contentWidth, contentHeight) {
            var self = this;
            if (!clientWidth && !clientHeight && !contentWidth && !contentHeight) {
              return;
            }
            if (clientWidth === +clientWidth) {
              self.__clientWidth = clientWidth;
            }
            if (clientHeight === +clientHeight) {
              self.__clientHeight = clientHeight;
            }
            if (contentWidth === +contentWidth) {
              self.__contentWidth = contentWidth;
            }
            if (contentHeight === +contentHeight) {
              self.__contentHeight = contentHeight;
            }
            self.__computeScrollMax();
          },
          getScrollMax: function() {
            return {
              left: this.__maxScrollLeft,
              top: this.__maxScrollTop
            };
          },
          scrollBy: function(left, top, animate) {
            var self = this;
            self.update();
            var startLeft = self.__isAnimating ? self.__scheduledLeft : self.__scrollLeft;
            var startTop = self.__isAnimating ? self.__scheduledTop : self.__scrollTop;
            self.scrollTo(startLeft + (left || 0), startTop + (top || 0), animate);
          },
          scrollTo: function(left, top, animate) {
            var self = this;
            if (!animate) {
              self.el.scrollTop = top;
              self.el.scrollLeft = left;
              self.resize();
              return;
            }
            var oldOverflowX = self.el.style.overflowX;
            var oldOverflowY = self.el.style.overflowY;
            clearTimeout(self.__scrollToCleanupTimeout);
            self.__scrollToCleanupTimeout = setTimeout(function() {
              self.el.style.overflowX = oldOverflowX;
              self.el.style.overflowY = oldOverflowY;
            }, 500);
            self.el.style.overflowY = 'hidden';
            self.el.style.overflowX = 'hidden';
            animateScroll(top, left);
            function animateScroll(Y, X) {
              var start = Date.now(),
                  duration = 250,
                  fromY = self.el.scrollTop,
                  fromX = self.el.scrollLeft;
              if (fromY === Y && fromX === X) {
                self.el.style.overflowX = oldOverflowX;
                self.el.style.overflowY = oldOverflowY;
                self.resize();
                return;
              }
              function easeOutCubic(t) {
                return (--t) * t * t + 1;
              }
              function animateScrollStep() {
                var currentTime = Date.now(),
                    time = Math.min(1, ((currentTime - start) / duration)),
                    easedT = easeOutCubic(time);
                if (fromY != Y) {
                  self.el.scrollTop = parseInt((easedT * (Y - fromY)) + fromY, 10);
                }
                if (fromX != X) {
                  self.el.scrollLeft = parseInt((easedT * (X - fromX)) + fromX, 10);
                }
                if (time < 1) {
                  ionic.requestAnimationFrame(animateScrollStep);
                } else {
                  ionic.tap.removeClonedInputs(self.__container, self);
                  self.el.style.overflowX = oldOverflowX;
                  self.el.style.overflowY = oldOverflowY;
                  self.resize();
                }
              }
              ionic.requestAnimationFrame(animateScrollStep);
            }
          },
          __waitForSize: function() {
            var self = this;
            clearTimeout(self.__sizerTimeout);
            var sizer = function() {
              self.resize(true);
            };
            sizer();
            self.__sizerTimeout = setTimeout(sizer, 500);
          },
          __computeScrollMax: function() {
            var self = this;
            self.__maxScrollLeft = Math.max((self.__contentWidth) - self.__clientWidth, 0);
            self.__maxScrollTop = Math.max((self.__contentHeight) - self.__clientHeight, 0);
            if (!self.__didWaitForSize && !self.__maxScrollLeft && !self.__maxScrollTop) {
              self.__didWaitForSize = true;
              self.__waitForSize();
            }
          },
          __initEventHandlers: function() {
            var self = this;
            var container = self.__container;
            var scrollViewOffsetHeight;
            var lastKeyboardHeight;
            self.scrollChildIntoView = function(e) {
              var rect = container.getBoundingClientRect();
              if (!self.__originalContainerHeight) {
                self.__originalContainerHeight = rect.height;
              }
              scrollViewOffsetHeight = self.__originalContainerHeight;
              var alreadyShrunk = self.isShrunkForKeyboard;
              var isModal = container.parentNode.classList.contains('modal');
              var isPopover = container.parentNode.classList.contains('popover');
              var isInsetModal = isModal && window.innerWidth >= 680;
              var changedKeyboardHeight = lastKeyboardHeight && (lastKeyboardHeight !== e.detail.keyboardHeight);
              if (!alreadyShrunk || changedKeyboardHeight) {
                if (!isPopover && (ionic.Platform.isIOS() || ionic.Platform.isFullScreen || isInsetModal)) {
                  ionic.requestAnimationFrame(function() {
                    scrollViewOffsetHeight = Math.max(0, Math.min(self.__originalContainerHeight, self.__originalContainerHeight - (e.detail.keyboardHeight - 43)));
                    container.style.height = scrollViewOffsetHeight + "px";
                    container.classList.add('keyboard-up');
                    self.resize();
                  });
                }
                self.isShrunkForKeyboard = true;
              }
              lastKeyboardHeight = e.detail.keyboardHeight;
              if (e.detail.isElementUnderKeyboard) {
                ionic.requestAnimationFrame(function() {
                  var pos = ionic.DomUtil.getOffsetTop(e.detail.target);
                  setTimeout(function() {
                    if (ionic.Platform.isIOS()) {
                      ionic.tap.cloneFocusedInput(container, self);
                    }
                    self.scrollTo(0, pos - (rect.top + 100), true);
                    self.onScroll();
                  }, 32);
                });
              }
              e.stopPropagation();
            };
            self.resetScrollView = function() {
              if (self.isShrunkForKeyboard) {
                self.isShrunkForKeyboard = false;
                container.style.height = "";
                self.__originalContainerHeight = container.getBoundingClientRect().height;
                if (ionic.Platform.isIOS()) {
                  ionic.requestAnimationFrame(function() {
                    container.classList.remove('keyboard-up');
                  });
                }
              }
              self.resize();
            };
            self.handleTouchMove = function(e) {
              if (self.__frozenShut) {
                e.preventDefault();
                e.stopPropagation();
                return false;
              } else if (self.__frozen) {
                e.preventDefault();
                return false;
              }
              return true;
            };
            container.addEventListener('scroll', self.onScroll);
            container.addEventListener('scrollChildIntoView', self.scrollChildIntoView);
            container.addEventListener(ionic.EVENTS.touchstart, self.handleTouchMove);
            container.addEventListener(ionic.EVENTS.touchmove, self.handleTouchMove);
            document.addEventListener('resetScrollView', self.resetScrollView);
          },
          __cleanup: function() {
            var self = this;
            var container = self.__container;
            container.removeEventListener('resetScrollView', self.resetScrollView);
            container.removeEventListener('scroll', self.onScroll);
            container.removeEventListener('scrollChildIntoView', self.scrollChildIntoView);
            container.removeEventListener('resetScrollView', self.resetScrollView);
            container.removeEventListener(ionic.EVENTS.touchstart, self.handleTouchMove);
            container.removeEventListener(ionic.EVENTS.touchmove, self.handleTouchMove);
            ionic.tap.removeClonedInputs(container, self);
            delete self.__container;
            delete self.__content;
            delete self.__indicatorX;
            delete self.__indicatorY;
            delete self.options.el;
            self.resize = self.scrollTo = self.onScroll = self.resetScrollView = NOOP;
            self.scrollChildIntoView = NOOP;
            container = null;
          }
        });
      })(ionic);
      (function(ionic) {
        'use strict';
        var ITEM_CLASS = 'item';
        var ITEM_CONTENT_CLASS = 'item-content';
        var ITEM_SLIDING_CLASS = 'item-sliding';
        var ITEM_OPTIONS_CLASS = 'item-options';
        var ITEM_PLACEHOLDER_CLASS = 'item-placeholder';
        var ITEM_REORDERING_CLASS = 'item-reordering';
        var ITEM_REORDER_BTN_CLASS = 'item-reorder';
        var DragOp = function() {};
        DragOp.prototype = {
          start: function() {},
          drag: function() {},
          end: function() {},
          isSameItem: function() {
            return false;
          }
        };
        var SlideDrag = function(opts) {
          this.dragThresholdX = opts.dragThresholdX || 10;
          this.el = opts.el;
          this.item = opts.item;
          this.canSwipe = opts.canSwipe;
        };
        SlideDrag.prototype = new DragOp();
        SlideDrag.prototype.start = function(e) {
          var content,
              buttons,
              offsetX,
              buttonsWidth;
          if (!this.canSwipe()) {
            return;
          }
          if (e.target.classList.contains(ITEM_CONTENT_CLASS)) {
            content = e.target;
          } else if (e.target.classList.contains(ITEM_CLASS)) {
            content = e.target.querySelector('.' + ITEM_CONTENT_CLASS);
          } else {
            content = ionic.DomUtil.getParentWithClass(e.target, ITEM_CONTENT_CLASS);
          }
          if (!content) {
            return;
          }
          content.classList.remove(ITEM_SLIDING_CLASS);
          offsetX = parseFloat(content.style[ionic.CSS.TRANSFORM].replace('translate3d(', '').split(',')[0]) || 0;
          buttons = content.parentNode.querySelector('.' + ITEM_OPTIONS_CLASS);
          if (!buttons) {
            return;
          }
          buttons.classList.remove('invisible');
          buttonsWidth = buttons.offsetWidth;
          this._currentDrag = {
            buttons: buttons,
            buttonsWidth: buttonsWidth,
            content: content,
            startOffsetX: offsetX
          };
        };
        SlideDrag.prototype.isSameItem = function(op) {
          if (op._lastDrag && this._currentDrag) {
            return this._currentDrag.content == op._lastDrag.content;
          }
          return false;
        };
        SlideDrag.prototype.clean = function(isInstant) {
          var lastDrag = this._lastDrag;
          if (!lastDrag || !lastDrag.content)
            return;
          lastDrag.content.style[ionic.CSS.TRANSITION] = '';
          lastDrag.content.style[ionic.CSS.TRANSFORM] = '';
          if (isInstant) {
            lastDrag.content.style[ionic.CSS.TRANSITION] = 'none';
            makeInvisible();
            ionic.requestAnimationFrame(function() {
              lastDrag.content.style[ionic.CSS.TRANSITION] = '';
            });
          } else {
            ionic.requestAnimationFrame(function() {
              setTimeout(makeInvisible, 250);
            });
          }
          function makeInvisible() {
            lastDrag.buttons && lastDrag.buttons.classList.add('invisible');
          }
        };
        SlideDrag.prototype.drag = ionic.animationFrameThrottle(function(e) {
          var buttonsWidth;
          if (!this._currentDrag) {
            return;
          }
          if (!this._isDragging && ((Math.abs(e.gesture.deltaX) > this.dragThresholdX) || (Math.abs(this._currentDrag.startOffsetX) > 0))) {
            this._isDragging = true;
          }
          if (this._isDragging) {
            buttonsWidth = this._currentDrag.buttonsWidth;
            var newX = Math.min(0, this._currentDrag.startOffsetX + e.gesture.deltaX);
            if (newX < -buttonsWidth) {
              newX = Math.min(-buttonsWidth, -buttonsWidth + (((e.gesture.deltaX + buttonsWidth) * 0.4)));
            }
            this._currentDrag.content.$$ionicOptionsOpen = newX !== 0;
            this._currentDrag.content.style[ionic.CSS.TRANSFORM] = 'translate3d(' + newX + 'px, 0, 0)';
            this._currentDrag.content.style[ionic.CSS.TRANSITION] = 'none';
          }
        });
        SlideDrag.prototype.end = function(e, doneCallback) {
          var self = this;
          if (!self._currentDrag) {
            doneCallback && doneCallback();
            return;
          }
          var restingPoint = -self._currentDrag.buttonsWidth;
          if (e.gesture.deltaX > -(self._currentDrag.buttonsWidth / 2)) {
            if (e.gesture.direction == "left" && Math.abs(e.gesture.velocityX) < 0.3) {
              restingPoint = 0;
            } else if (e.gesture.direction == "right") {
              restingPoint = 0;
            }
          }
          ionic.requestAnimationFrame(function() {
            if (restingPoint === 0) {
              self._currentDrag.content.style[ionic.CSS.TRANSFORM] = '';
              var buttons = self._currentDrag.buttons;
              setTimeout(function() {
                buttons && buttons.classList.add('invisible');
              }, 250);
            } else {
              self._currentDrag.content.style[ionic.CSS.TRANSFORM] = 'translate3d(' + restingPoint + 'px,0,0)';
            }
            self._currentDrag.content.style[ionic.CSS.TRANSITION] = '';
            if (!self._lastDrag) {
              self._lastDrag = {};
            }
            ionic.extend(self._lastDrag, self._currentDrag);
            if (self._currentDrag) {
              self._currentDrag.buttons = null;
              self._currentDrag.content = null;
            }
            self._currentDrag = null;
            doneCallback && doneCallback();
          });
        };
        var ReorderDrag = function(opts) {
          var self = this;
          self.dragThresholdY = opts.dragThresholdY || 0;
          self.onReorder = opts.onReorder;
          self.listEl = opts.listEl;
          self.el = self.item = opts.el;
          self.scrollEl = opts.scrollEl;
          self.scrollView = opts.scrollView;
          self.listElTrueTop = 0;
          if (self.listEl.offsetParent) {
            var obj = self.listEl;
            do {
              self.listElTrueTop += obj.offsetTop;
              obj = obj.offsetParent;
            } while (obj);
          }
        };
        ReorderDrag.prototype = new DragOp();
        ReorderDrag.prototype._moveElement = function(e) {
          var y = e.gesture.center.pageY + this.scrollView.getValues().top - (this._currentDrag.elementHeight / 2) - this.listElTrueTop;
          this.el.style[ionic.CSS.TRANSFORM] = 'translate3d(0, ' + y + 'px, 0)';
        };
        ReorderDrag.prototype.deregister = function() {
          this.listEl = this.el = this.scrollEl = this.scrollView = null;
        };
        ReorderDrag.prototype.start = function(e) {
          var startIndex = ionic.DomUtil.getChildIndex(this.el, this.el.nodeName.toLowerCase());
          var elementHeight = this.el.scrollHeight;
          var placeholder = this.el.cloneNode(true);
          placeholder.classList.add(ITEM_PLACEHOLDER_CLASS);
          this.el.parentNode.insertBefore(placeholder, this.el);
          this.el.classList.add(ITEM_REORDERING_CLASS);
          this._currentDrag = {
            elementHeight: elementHeight,
            startIndex: startIndex,
            placeholder: placeholder,
            scrollHeight: scroll,
            list: placeholder.parentNode
          };
          this._moveElement(e);
        };
        ReorderDrag.prototype.drag = ionic.animationFrameThrottle(function(e) {
          var self = this;
          if (!this._currentDrag) {
            return;
          }
          var scrollY = 0;
          var pageY = e.gesture.center.pageY;
          var offset = this.listElTrueTop;
          if (this.scrollView) {
            var container = this.scrollView.__container;
            scrollY = this.scrollView.getValues().top;
            var containerTop = container.offsetTop;
            var pixelsPastTop = containerTop - pageY + this._currentDrag.elementHeight / 2;
            var pixelsPastBottom = pageY + this._currentDrag.elementHeight / 2 - containerTop - container.offsetHeight;
            if (e.gesture.deltaY < 0 && pixelsPastTop > 0 && scrollY > 0) {
              this.scrollView.scrollBy(null, -pixelsPastTop);
              ionic.requestAnimationFrame(function() {
                self.drag(e);
              });
            }
            if (e.gesture.deltaY > 0 && pixelsPastBottom > 0) {
              if (scrollY < this.scrollView.getScrollMax().top) {
                this.scrollView.scrollBy(null, pixelsPastBottom);
                ionic.requestAnimationFrame(function() {
                  self.drag(e);
                });
              }
            }
          }
          if (!this._isDragging && Math.abs(e.gesture.deltaY) > this.dragThresholdY) {
            this._isDragging = true;
          }
          if (this._isDragging) {
            this._moveElement(e);
            this._currentDrag.currentY = scrollY + pageY - offset;
          }
        });
        ReorderDrag.prototype._getReorderIndex = function() {
          var self = this;
          var siblings = Array.prototype.slice.call(self._currentDrag.placeholder.parentNode.children).filter(function(el) {
            return el.nodeName === self.el.nodeName && el !== self.el;
          });
          var dragOffsetTop = self._currentDrag.currentY;
          var el;
          for (var i = 0,
              len = siblings.length; i < len; i++) {
            el = siblings[i];
            if (i === len - 1) {
              if (dragOffsetTop > el.offsetTop) {
                return i;
              }
            } else if (i === 0) {
              if (dragOffsetTop < el.offsetTop + el.offsetHeight) {
                return i;
              }
            } else if (dragOffsetTop > el.offsetTop - el.offsetHeight / 2 && dragOffsetTop < el.offsetTop + el.offsetHeight) {
              return i;
            }
          }
          return self._currentDrag.startIndex;
        };
        ReorderDrag.prototype.end = function(e, doneCallback) {
          if (!this._currentDrag) {
            doneCallback && doneCallback();
            return;
          }
          var placeholder = this._currentDrag.placeholder;
          var finalIndex = this._getReorderIndex();
          this.el.classList.remove(ITEM_REORDERING_CLASS);
          this.el.style[ionic.CSS.TRANSFORM] = '';
          placeholder.parentNode.insertBefore(this.el, placeholder);
          placeholder.parentNode.removeChild(placeholder);
          this.onReorder && this.onReorder(this.el, this._currentDrag.startIndex, finalIndex);
          this._currentDrag = {
            placeholder: null,
            content: null
          };
          this._currentDrag = null;
          doneCallback && doneCallback();
        };
        ionic.views.ListView = ionic.views.View.inherit({
          initialize: function(opts) {
            var self = this;
            opts = ionic.extend({
              onReorder: function() {},
              virtualRemoveThreshold: -200,
              virtualAddThreshold: 200,
              canSwipe: function() {
                return true;
              }
            }, opts);
            ionic.extend(self, opts);
            if (!self.itemHeight && self.listEl) {
              self.itemHeight = self.listEl.children[0] && parseInt(self.listEl.children[0].style.height, 10);
            }
            self.onRefresh = opts.onRefresh || function() {};
            self.onRefreshOpening = opts.onRefreshOpening || function() {};
            self.onRefreshHolding = opts.onRefreshHolding || function() {};
            var gestureOpts = {};
            if (ionic.DomUtil.getParentOrSelfWithClass(self.el, 'overflow-scroll')) {
              gestureOpts.prevent_default_directions = ['left', 'right'];
            }
            window.ionic.onGesture('release', function(e) {
              self._handleEndDrag(e);
            }, self.el, gestureOpts);
            window.ionic.onGesture('drag', function(e) {
              self._handleDrag(e);
            }, self.el, gestureOpts);
            self._initDrag();
          },
          deregister: function() {
            this.el = this.listEl = this.scrollEl = this.scrollView = null;
            if (this.isScrollFreeze) {
              self.scrollView.freeze(false);
            }
          },
          stopRefreshing: function() {
            var refresher = this.el.querySelector('.list-refresher');
            refresher.style.height = '0';
          },
          didScroll: function(e) {
            var self = this;
            if (self.isVirtual) {
              var itemHeight = self.itemHeight;
              var scrollHeight = e.target.scrollHeight;
              var viewportHeight = self.el.parentNode.offsetHeight;
              var highWater = Math.max(0, e.scrollTop + self.virtualRemoveThreshold);
              var lowWater = Math.min(scrollHeight, Math.abs(e.scrollTop) + viewportHeight + self.virtualAddThreshold);
              var first = parseInt(Math.abs(highWater / itemHeight), 10);
              var last = parseInt(Math.abs(lowWater / itemHeight), 10);
              self._virtualItemsToRemove = Array.prototype.slice.call(self.listEl.children, 0, first);
              self.renderViewport && self.renderViewport(highWater, lowWater, first, last);
            }
          },
          didStopScrolling: function() {
            if (this.isVirtual) {
              for (var i = 0; i < this._virtualItemsToRemove.length; i++) {
                this.didHideItem && this.didHideItem(i);
              }
            }
          },
          clearDragEffects: function(isInstant) {
            if (this._lastDragOp) {
              this._lastDragOp.clean && this._lastDragOp.clean(isInstant);
              this._lastDragOp.deregister && this._lastDragOp.deregister();
              this._lastDragOp = null;
            }
          },
          _initDrag: function() {
            if (this._lastDragOp) {
              this._lastDragOp.deregister && this._lastDragOp.deregister();
            }
            this._lastDragOp = this._dragOp;
            this._dragOp = null;
          },
          _getItem: function(target) {
            while (target) {
              if (target.classList && target.classList.contains(ITEM_CLASS)) {
                return target;
              }
              target = target.parentNode;
            }
            return null;
          },
          _startDrag: function(e) {
            var self = this;
            self._isDragging = false;
            var lastDragOp = self._lastDragOp;
            var item;
            if (self._didDragUpOrDown && lastDragOp instanceof SlideDrag) {
              lastDragOp.clean && lastDragOp.clean();
            }
            if (ionic.DomUtil.getParentOrSelfWithClass(e.target, ITEM_REORDER_BTN_CLASS) && (e.gesture.direction == 'up' || e.gesture.direction == 'down')) {
              item = self._getItem(e.target);
              if (item) {
                self._dragOp = new ReorderDrag({
                  listEl: self.el,
                  el: item,
                  scrollEl: self.scrollEl,
                  scrollView: self.scrollView,
                  onReorder: function(el, start, end) {
                    self.onReorder && self.onReorder(el, start, end);
                  }
                });
                self._dragOp.start(e);
                e.preventDefault();
              }
            } else if (!self._didDragUpOrDown && (e.gesture.direction == 'left' || e.gesture.direction == 'right') && Math.abs(e.gesture.deltaX) > 5) {
              item = self._getItem(e.target);
              if (item && item.querySelector('.item-options')) {
                self._dragOp = new SlideDrag({
                  el: self.el,
                  item: item,
                  canSwipe: self.canSwipe
                });
                self._dragOp.start(e);
                e.preventDefault();
                self.isScrollFreeze = self.scrollView.freeze(true);
              }
            }
            if (lastDragOp && self._dragOp && !self._dragOp.isSameItem(lastDragOp) && e.defaultPrevented) {
              lastDragOp.clean && lastDragOp.clean();
            }
          },
          _handleEndDrag: function(e) {
            var self = this;
            if (self.scrollView) {
              self.isScrollFreeze = self.scrollView.freeze(false);
            }
            self._didDragUpOrDown = false;
            if (!self._dragOp) {
              return;
            }
            self._dragOp.end(e, function() {
              self._initDrag();
            });
          },
          _handleDrag: function(e) {
            var self = this;
            if (Math.abs(e.gesture.deltaY) > 5) {
              self._didDragUpOrDown = true;
            }
            if (!self.isDragging && !self._dragOp) {
              self._startDrag(e);
            }
            if (!self._dragOp) {
              return;
            }
            e.gesture.srcEvent.preventDefault();
            self._dragOp.drag(e);
          }
        });
      })(ionic);
      (function(ionic) {
        'use strict';
        ionic.views.Modal = ionic.views.View.inherit({
          initialize: function(opts) {
            opts = ionic.extend({
              focusFirstInput: false,
              unfocusOnHide: true,
              focusFirstDelay: 600,
              backdropClickToClose: true,
              hardwareBackButtonClose: true
            }, opts);
            ionic.extend(this, opts);
            this.el = opts.el;
          },
          show: function() {
            var self = this;
            if (self.focusFirstInput) {
              window.setTimeout(function() {
                var input = self.el.querySelector('input, textarea');
                input && input.focus && input.focus();
              }, self.focusFirstDelay);
            }
          },
          hide: function() {
            if (this.unfocusOnHide) {
              var inputs = this.el.querySelectorAll('input, textarea');
              window.setTimeout(function() {
                for (var i = 0; i < inputs.length; i++) {
                  inputs[i].blur && inputs[i].blur();
                }
              });
            }
          }
        });
      })(ionic);
      (function(ionic) {
        'use strict';
        ionic.views.SideMenu = ionic.views.View.inherit({
          initialize: function(opts) {
            this.el = opts.el;
            this.isEnabled = (typeof opts.isEnabled === 'undefined') ? true : opts.isEnabled;
            this.setWidth(opts.width);
          },
          getFullWidth: function() {
            return this.width;
          },
          setWidth: function(width) {
            this.width = width;
            this.el.style.width = width + 'px';
          },
          setIsEnabled: function(isEnabled) {
            this.isEnabled = isEnabled;
          },
          bringUp: function() {
            if (this.el.style.zIndex !== '0') {
              this.el.style.zIndex = '0';
            }
          },
          pushDown: function() {
            if (this.el.style.zIndex !== '-1') {
              this.el.style.zIndex = '-1';
            }
          }
        });
        ionic.views.SideMenuContent = ionic.views.View.inherit({
          initialize: function(opts) {
            ionic.extend(this, {
              animationClass: 'menu-animated',
              onDrag: function() {},
              onEndDrag: function() {}
            }, opts);
            ionic.onGesture('drag', ionic.proxy(this._onDrag, this), this.el);
            ionic.onGesture('release', ionic.proxy(this._onEndDrag, this), this.el);
          },
          _onDrag: function(e) {
            this.onDrag && this.onDrag(e);
          },
          _onEndDrag: function(e) {
            this.onEndDrag && this.onEndDrag(e);
          },
          disableAnimation: function() {
            this.el.classList.remove(this.animationClass);
          },
          enableAnimation: function() {
            this.el.classList.add(this.animationClass);
          },
          getTranslateX: function() {
            return parseFloat(this.el.style[ionic.CSS.TRANSFORM].replace('translate3d(', '').split(',')[0]);
          },
          setTranslateX: ionic.animationFrameThrottle(function(x) {
            this.el.style[ionic.CSS.TRANSFORM] = 'translate3d(' + x + 'px, 0, 0)';
          })
        });
      })(ionic);
      (function(ionic) {
        'use strict';
        ionic.views.Slider = ionic.views.View.inherit({initialize: function(options) {
            var slider = this;
            var touchStartEvent,
                touchMoveEvent,
                touchEndEvent;
            if (window.navigator.pointerEnabled) {
              touchStartEvent = 'pointerdown';
              touchMoveEvent = 'pointermove';
              touchEndEvent = 'pointerup';
            } else if (window.navigator.msPointerEnabled) {
              touchStartEvent = 'MSPointerDown';
              touchMoveEvent = 'MSPointerMove';
              touchEndEvent = 'MSPointerUp';
            } else {
              touchStartEvent = 'touchstart';
              touchMoveEvent = 'touchmove';
              touchEndEvent = 'touchend';
            }
            var mouseStartEvent = 'mousedown';
            var mouseMoveEvent = 'mousemove';
            var mouseEndEvent = 'mouseup';
            var noop = function() {};
            var offloadFn = function(fn) {
              setTimeout(fn || noop, 0);
            };
            var browser = {
              addEventListener: !!window.addEventListener,
              transitions: (function(temp) {
                var props = ['transitionProperty', 'WebkitTransition', 'MozTransition', 'OTransition', 'msTransition'];
                for (var i in props)
                  if (temp.style[props[i]] !== undefined)
                    return true;
                return false;
              })(document.createElement('swipe'))
            };
            var container = options.el;
            if (!container)
              return;
            var element = container.children[0];
            var slides,
                slidePos,
                width,
                length;
            options = options || {};
            var index = parseInt(options.startSlide, 10) || 0;
            var speed = options.speed || 300;
            options.continuous = options.continuous !== undefined ? options.continuous : true;
            function setup() {
              if (!container.offsetWidth) {
                return;
              }
              slides = element.children;
              length = slides.length;
              if (slides.length < 2)
                options.continuous = false;
              if (browser.transitions && options.continuous && slides.length < 3) {
                element.appendChild(slides[0].cloneNode(true));
                element.appendChild(element.children[1].cloneNode(true));
                slides = element.children;
              }
              slidePos = new Array(slides.length);
              width = container.offsetWidth || container.getBoundingClientRect().width;
              element.style.width = (slides.length * width) + 'px';
              var pos = slides.length;
              while (pos--) {
                var slide = slides[pos];
                slide.style.width = width + 'px';
                slide.setAttribute('data-index', pos);
                if (browser.transitions) {
                  slide.style.left = (pos * -width) + 'px';
                  move(pos, index > pos ? -width : (index < pos ? width : 0), 0);
                }
              }
              if (options.continuous && browser.transitions) {
                move(circle(index - 1), -width, 0);
                move(circle(index + 1), width, 0);
              }
              if (!browser.transitions)
                element.style.left = (index * -width) + 'px';
              container.style.visibility = 'visible';
              options.slidesChanged && options.slidesChanged();
            }
            function prev(slideSpeed) {
              if (options.continuous)
                slide(index - 1, slideSpeed);
              else if (index)
                slide(index - 1, slideSpeed);
            }
            function next(slideSpeed) {
              if (options.continuous)
                slide(index + 1, slideSpeed);
              else if (index < slides.length - 1)
                slide(index + 1, slideSpeed);
            }
            function circle(index) {
              return (slides.length + (index % slides.length)) % slides.length;
            }
            function slide(to, slideSpeed) {
              if (index == to)
                return;
              if (!slides) {
                index = to;
                return;
              }
              if (browser.transitions) {
                var direction = Math.abs(index - to) / (index - to);
                if (options.continuous) {
                  var naturalDirection = direction;
                  direction = -slidePos[circle(to)] / width;
                  if (direction !== naturalDirection)
                    to = -direction * slides.length + to;
                }
                var diff = Math.abs(index - to) - 1;
                while (diff--)
                  move(circle((to > index ? to : index) - diff - 1), width * direction, 0);
                to = circle(to);
                move(index, width * direction, slideSpeed || speed);
                move(to, 0, slideSpeed || speed);
                if (options.continuous)
                  move(circle(to - direction), -(width * direction), 0);
              } else {
                to = circle(to);
                animate(index * -width, to * -width, slideSpeed || speed);
              }
              index = to;
              offloadFn(options.callback && options.callback(index, slides[index]));
            }
            function move(index, dist, speed) {
              translate(index, dist, speed);
              slidePos[index] = dist;
            }
            function translate(index, dist, speed) {
              var slide = slides[index];
              var style = slide && slide.style;
              if (!style)
                return;
              style.webkitTransitionDuration = style.MozTransitionDuration = style.msTransitionDuration = style.OTransitionDuration = style.transitionDuration = speed + 'ms';
              style.webkitTransform = 'translate(' + dist + 'px,0)' + 'translateZ(0)';
              style.msTransform = style.MozTransform = style.OTransform = 'translateX(' + dist + 'px)';
            }
            function animate(from, to, speed) {
              if (!speed) {
                element.style.left = to + 'px';
                return;
              }
              var start = +new Date();
              var timer = setInterval(function() {
                var timeElap = +new Date() - start;
                if (timeElap > speed) {
                  element.style.left = to + 'px';
                  if (delay)
                    begin();
                  options.transitionEnd && options.transitionEnd.call(event, index, slides[index]);
                  clearInterval(timer);
                  return;
                }
                element.style.left = (((to - from) * (Math.floor((timeElap / speed) * 100) / 100)) + from) + 'px';
              }, 4);
            }
            var delay = options.auto || 0;
            var interval;
            function begin() {
              interval = setTimeout(next, delay);
            }
            function stop() {
              delay = options.auto || 0;
              clearTimeout(interval);
            }
            var start = {};
            var delta = {};
            var isScrolling;
            var events = {
              handleEvent: function(event) {
                if (!event.touches && event.pageX && event.pageY) {
                  event.touches = [{
                    pageX: event.pageX,
                    pageY: event.pageY
                  }];
                }
                switch (event.type) {
                  case touchStartEvent:
                    this.start(event);
                    break;
                  case mouseStartEvent:
                    this.start(event);
                    break;
                  case touchMoveEvent:
                    this.touchmove(event);
                    break;
                  case mouseMoveEvent:
                    this.touchmove(event);
                    break;
                  case touchEndEvent:
                    offloadFn(this.end(event));
                    break;
                  case mouseEndEvent:
                    offloadFn(this.end(event));
                    break;
                  case 'webkitTransitionEnd':
                  case 'msTransitionEnd':
                  case 'oTransitionEnd':
                  case 'otransitionend':
                  case 'transitionend':
                    offloadFn(this.transitionEnd(event));
                    break;
                  case 'resize':
                    offloadFn(setup);
                    break;
                }
                if (options.stopPropagation)
                  event.stopPropagation();
              },
              start: function(event) {
                if (!event.touches) {
                  return;
                }
                var touches = event.touches[0];
                start = {
                  x: touches.pageX,
                  y: touches.pageY,
                  time: +new Date()
                };
                isScrolling = undefined;
                delta = {};
                element.addEventListener(touchMoveEvent, this, false);
                element.addEventListener(mouseMoveEvent, this, false);
                element.addEventListener(touchEndEvent, this, false);
                element.addEventListener(mouseEndEvent, this, false);
                document.addEventListener(touchEndEvent, this, false);
                document.addEventListener(mouseEndEvent, this, false);
              },
              touchmove: function(event) {
                if (!event.touches || event.touches.length > 1 || event.scale && event.scale !== 1 || slider.slideIsDisabled) {
                  return;
                }
                if (options.disableScroll)
                  event.preventDefault();
                var touches = event.touches[0];
                delta = {
                  x: touches.pageX - start.x,
                  y: touches.pageY - start.y
                };
                if (typeof isScrolling == 'undefined') {
                  isScrolling = !!(isScrolling || Math.abs(delta.x) < Math.abs(delta.y));
                }
                if (!isScrolling) {
                  event.preventDefault();
                  stop();
                  if (options.continuous) {
                    translate(circle(index - 1), delta.x + slidePos[circle(index - 1)], 0);
                    translate(index, delta.x + slidePos[index], 0);
                    translate(circle(index + 1), delta.x + slidePos[circle(index + 1)], 0);
                  } else {
                    if (options.bouncing) {
                      delta.x = delta.x / ((!index && delta.x > 0 || index == slides.length - 1 && delta.x < 0) ? (Math.abs(delta.x) / width + 1) : 1);
                    } else {
                      if (width * index - delta.x < 0) {
                        delta.x = Math.min(delta.x, width * index);
                      }
                      if (Math.abs(delta.x) > width * (slides.length - index - 1)) {
                        delta.x = Math.max(-width * (slides.length - index - 1), delta.x);
                      }
                    }
                    translate(index - 1, delta.x + slidePos[index - 1], 0);
                    translate(index, delta.x + slidePos[index], 0);
                    translate(index + 1, delta.x + slidePos[index + 1], 0);
                  }
                  options.onDrag && options.onDrag();
                }
              },
              end: function() {
                var duration = +new Date() - start.time;
                var isValidSlide = Number(duration) < 250 && Math.abs(delta.x) > 20 || Math.abs(delta.x) > width / 2;
                var isPastBounds = (!index && delta.x > 0) || (index == slides.length - 1 && delta.x < 0);
                if (options.continuous)
                  isPastBounds = false;
                var direction = delta.x < 0;
                if (!isScrolling) {
                  if (isValidSlide && !isPastBounds) {
                    if (direction) {
                      if (options.continuous) {
                        move(circle(index - 1), -width, 0);
                        move(circle(index + 2), width, 0);
                      } else {
                        move(index - 1, -width, 0);
                      }
                      move(index, slidePos[index] - width, speed);
                      move(circle(index + 1), slidePos[circle(index + 1)] - width, speed);
                      index = circle(index + 1);
                    } else {
                      if (options.continuous) {
                        move(circle(index + 1), width, 0);
                        move(circle(index - 2), -width, 0);
                      } else {
                        move(index + 1, width, 0);
                      }
                      move(index, slidePos[index] + width, speed);
                      move(circle(index - 1), slidePos[circle(index - 1)] + width, speed);
                      index = circle(index - 1);
                    }
                    options.callback && options.callback(index, slides[index]);
                  } else {
                    if (options.continuous) {
                      move(circle(index - 1), -width, speed);
                      move(index, 0, speed);
                      move(circle(index + 1), width, speed);
                    } else {
                      move(index - 1, -width, speed);
                      move(index, 0, speed);
                      move(index + 1, width, speed);
                    }
                  }
                }
                element.removeEventListener(touchMoveEvent, events, false);
                element.removeEventListener(mouseMoveEvent, events, false);
                element.removeEventListener(touchEndEvent, events, false);
                element.removeEventListener(mouseEndEvent, events, false);
                document.removeEventListener(touchEndEvent, events, false);
                document.removeEventListener(mouseEndEvent, events, false);
                options.onDragEnd && options.onDragEnd();
              },
              transitionEnd: function(event) {
                if (parseInt(event.target.getAttribute('data-index'), 10) == index) {
                  if (delay)
                    begin();
                  options.transitionEnd && options.transitionEnd.call(event, index, slides[index]);
                }
              }
            };
            this.update = function() {
              setTimeout(setup);
            };
            this.setup = function() {
              setup();
            };
            this.loop = function(value) {
              if (arguments.length)
                options.continuous = !!value;
              return options.continuous;
            };
            this.enableSlide = function(shouldEnable) {
              if (arguments.length) {
                this.slideIsDisabled = !shouldEnable;
              }
              return !this.slideIsDisabled;
            };
            this.slide = this.select = function(to, speed) {
              stop();
              slide(to, speed);
            };
            this.prev = this.previous = function() {
              stop();
              prev();
            };
            this.next = function() {
              stop();
              next();
            };
            this.stop = function() {
              stop();
            };
            this.start = function() {
              begin();
            };
            this.autoPlay = function(newDelay) {
              if (!delay || delay < 0) {
                stop();
              } else {
                delay = newDelay;
                begin();
              }
            };
            this.currentIndex = this.selected = function() {
              return index;
            };
            this.slidesCount = this.count = function() {
              return length;
            };
            this.kill = function() {
              stop();
              element.style.width = '';
              element.style.left = '';
              slides && (slides = []);
              if (browser.addEventListener) {
                element.removeEventListener(touchStartEvent, events, false);
                element.removeEventListener(mouseStartEvent, events, false);
                element.removeEventListener('webkitTransitionEnd', events, false);
                element.removeEventListener('msTransitionEnd', events, false);
                element.removeEventListener('oTransitionEnd', events, false);
                element.removeEventListener('otransitionend', events, false);
                element.removeEventListener('transitionend', events, false);
                window.removeEventListener('resize', events, false);
              } else {
                window.onresize = null;
              }
            };
            this.load = function() {
              setup();
              if (delay)
                begin();
              if (browser.addEventListener) {
                element.addEventListener(touchStartEvent, events, false);
                element.addEventListener(mouseStartEvent, events, false);
                if (browser.transitions) {
                  element.addEventListener('webkitTransitionEnd', events, false);
                  element.addEventListener('msTransitionEnd', events, false);
                  element.addEventListener('oTransitionEnd', events, false);
                  element.addEventListener('otransitionend', events, false);
                  element.addEventListener('transitionend', events, false);
                }
                window.addEventListener('resize', events, false);
              } else {
                window.onresize = function() {
                  setup();
                };
              }
            };
          }});
      })(ionic);
      (function() {
        'use strict';
        var $;
        var Swiper = function(container, params, _scope, $compile) {
          if (!(this instanceof Swiper))
            return new Swiper(container, params);
          var defaults = {
            direction: 'horizontal',
            touchEventsTarget: 'container',
            initialSlide: 0,
            speed: 300,
            autoplay: false,
            autoplayDisableOnInteraction: true,
            iOSEdgeSwipeDetection: false,
            iOSEdgeSwipeThreshold: 20,
            freeMode: false,
            freeModeMomentum: true,
            freeModeMomentumRatio: 1,
            freeModeMomentumBounce: true,
            freeModeMomentumBounceRatio: 1,
            freeModeSticky: false,
            freeModeMinimumVelocity: 0.02,
            autoHeight: false,
            setWrapperSize: false,
            virtualTranslate: false,
            effect: 'slide',
            coverflow: {
              rotate: 50,
              stretch: 0,
              depth: 100,
              modifier: 1,
              slideShadows: true
            },
            cube: {
              slideShadows: true,
              shadow: true,
              shadowOffset: 20,
              shadowScale: 0.94
            },
            fade: {crossFade: false},
            parallax: false,
            scrollbar: null,
            scrollbarHide: true,
            scrollbarDraggable: false,
            scrollbarSnapOnRelease: false,
            keyboardControl: false,
            mousewheelControl: false,
            mousewheelReleaseOnEdges: false,
            mousewheelInvert: false,
            mousewheelForceToAxis: false,
            mousewheelSensitivity: 1,
            hashnav: false,
            breakpoints: undefined,
            spaceBetween: 0,
            slidesPerView: 1,
            slidesPerColumn: 1,
            slidesPerColumnFill: 'column',
            slidesPerGroup: 1,
            centeredSlides: false,
            slidesOffsetBefore: 0,
            slidesOffsetAfter: 0,
            roundLengths: false,
            touchRatio: 1,
            touchAngle: 45,
            simulateTouch: true,
            shortSwipes: true,
            longSwipes: true,
            longSwipesRatio: 0.5,
            longSwipesMs: 300,
            followFinger: true,
            onlyExternal: false,
            threshold: 0,
            touchMoveStopPropagation: true,
            pagination: null,
            paginationElement: 'span',
            paginationClickable: false,
            paginationHide: false,
            paginationBulletRender: null,
            resistance: true,
            resistanceRatio: 0.85,
            nextButton: null,
            prevButton: null,
            watchSlidesProgress: false,
            watchSlidesVisibility: false,
            grabCursor: false,
            preventClicks: true,
            preventClicksPropagation: true,
            slideToClickedSlide: false,
            lazyLoading: false,
            lazyLoadingInPrevNext: false,
            lazyLoadingOnTransitionStart: false,
            preloadImages: true,
            updateOnImagesReady: true,
            loop: false,
            loopAdditionalSlides: 0,
            loopedSlides: null,
            control: undefined,
            controlInverse: false,
            controlBy: 'slide',
            allowSwipeToPrev: true,
            allowSwipeToNext: true,
            swipeHandler: null,
            noSwiping: true,
            noSwipingClass: 'swiper-no-swiping',
            slideClass: 'swiper-slide',
            slideActiveClass: 'swiper-slide-active',
            slideVisibleClass: 'swiper-slide-visible',
            slideDuplicateClass: 'swiper-slide-duplicate',
            slideNextClass: 'swiper-slide-next',
            slidePrevClass: 'swiper-slide-prev',
            wrapperClass: 'swiper-wrapper',
            bulletClass: 'swiper-pagination-bullet',
            bulletActiveClass: 'swiper-pagination-bullet-active',
            buttonDisabledClass: 'swiper-button-disabled',
            paginationHiddenClass: 'swiper-pagination-hidden',
            observer: false,
            observeParents: false,
            a11y: false,
            prevSlideMessage: 'Previous slide',
            nextSlideMessage: 'Next slide',
            firstSlideMessage: 'This is the first slide',
            lastSlideMessage: 'This is the last slide',
            paginationBulletMessage: 'Go to slide {{index}}',
            runCallbacksOnInit: true
          };
          var initialVirtualTranslate = params && params.virtualTranslate;
          params = params || {};
          var originalParams = {};
          for (var param in params) {
            if (typeof params[param] === 'object' && !(params[param].nodeType || params[param] === window || params[param] === document || (typeof Dom7 !== 'undefined' && params[param] instanceof Dom7) || (typeof jQuery !== 'undefined' && params[param] instanceof jQuery))) {
              originalParams[param] = {};
              for (var deepParam in params[param]) {
                originalParams[param][deepParam] = params[param][deepParam];
              }
            } else {
              originalParams[param] = params[param];
            }
          }
          for (var def in defaults) {
            if (typeof params[def] === 'undefined') {
              params[def] = defaults[def];
            } else if (typeof params[def] === 'object') {
              for (var deepDef in defaults[def]) {
                if (typeof params[def][deepDef] === 'undefined') {
                  params[def][deepDef] = defaults[def][deepDef];
                }
              }
            }
          }
          var s = this;
          s.params = params;
          s.originalParams = originalParams;
          s.classNames = [];
          if (typeof $ !== 'undefined' && typeof Dom7 !== 'undefined') {
            $ = Dom7;
          }
          if (typeof $ === 'undefined') {
            if (typeof Dom7 === 'undefined') {
              $ = window.Dom7 || window.Zepto || window.jQuery;
            } else {
              $ = Dom7;
            }
            if (!$)
              return;
          }
          s.$ = $;
          s.currentBreakpoint = undefined;
          s.getActiveBreakpoint = function() {
            if (!s.params.breakpoints)
              return false;
            var breakpoint = false;
            var points = [],
                point;
            for (point in s.params.breakpoints) {
              if (s.params.breakpoints.hasOwnProperty(point)) {
                points.push(point);
              }
            }
            points.sort(function(a, b) {
              return parseInt(a, 10) > parseInt(b, 10);
            });
            for (var i = 0; i < points.length; i++) {
              point = points[i];
              if (point >= window.innerWidth && !breakpoint) {
                breakpoint = point;
              }
            }
            return breakpoint || 'max';
          };
          s.setBreakpoint = function() {
            var breakpoint = s.getActiveBreakpoint();
            if (breakpoint && s.currentBreakpoint !== breakpoint) {
              var breakPointsParams = breakpoint in s.params.breakpoints ? s.params.breakpoints[breakpoint] : s.originalParams;
              for (var param in breakPointsParams) {
                s.params[param] = breakPointsParams[param];
              }
              s.currentBreakpoint = breakpoint;
            }
          };
          if (s.params.breakpoints) {
            s.setBreakpoint();
          }
          s.container = $(container);
          if (s.container.length === 0)
            return;
          if (s.container.length > 1) {
            s.container.each(function() {
              new Swiper(this, params);
            });
            return;
          }
          s.container[0].swiper = s;
          s.container.data('swiper', s);
          s.classNames.push('swiper-container-' + s.params.direction);
          if (s.params.freeMode) {
            s.classNames.push('swiper-container-free-mode');
          }
          if (!s.support.flexbox) {
            s.classNames.push('swiper-container-no-flexbox');
            s.params.slidesPerColumn = 1;
          }
          if (s.params.autoHeight) {
            s.classNames.push('swiper-container-autoheight');
          }
          if (s.params.parallax || s.params.watchSlidesVisibility) {
            s.params.watchSlidesProgress = true;
          }
          if (['cube', 'coverflow'].indexOf(s.params.effect) >= 0) {
            if (s.support.transforms3d) {
              s.params.watchSlidesProgress = true;
              s.classNames.push('swiper-container-3d');
            } else {
              s.params.effect = 'slide';
            }
          }
          if (s.params.effect !== 'slide') {
            s.classNames.push('swiper-container-' + s.params.effect);
          }
          if (s.params.effect === 'cube') {
            s.params.resistanceRatio = 0;
            s.params.slidesPerView = 1;
            s.params.slidesPerColumn = 1;
            s.params.slidesPerGroup = 1;
            s.params.centeredSlides = false;
            s.params.spaceBetween = 0;
            s.params.virtualTranslate = true;
            s.params.setWrapperSize = false;
          }
          if (s.params.effect === 'fade') {
            s.params.slidesPerView = 1;
            s.params.slidesPerColumn = 1;
            s.params.slidesPerGroup = 1;
            s.params.watchSlidesProgress = true;
            s.params.spaceBetween = 0;
            if (typeof initialVirtualTranslate === 'undefined') {
              s.params.virtualTranslate = true;
            }
          }
          if (s.params.grabCursor && s.support.touch) {
            s.params.grabCursor = false;
          }
          s.wrapper = s.container.children('.' + s.params.wrapperClass);
          if (s.params.pagination) {
            s.paginationContainer = $(s.params.pagination);
            if (s.params.paginationClickable) {
              s.paginationContainer.addClass('swiper-pagination-clickable');
            }
          }
          function isH() {
            return s.params.direction === 'horizontal';
          }
          s.rtl = isH() && (s.container[0].dir.toLowerCase() === 'rtl' || s.container.css('direction') === 'rtl');
          if (s.rtl) {
            s.classNames.push('swiper-container-rtl');
          }
          if (s.rtl) {
            s.wrongRTL = s.wrapper.css('display') === '-webkit-box';
          }
          if (s.params.slidesPerColumn > 1) {
            s.classNames.push('swiper-container-multirow');
          }
          if (s.device.android) {
            s.classNames.push('swiper-container-android');
          }
          s.container.addClass(s.classNames.join(' '));
          s.translate = 0;
          s.progress = 0;
          s.velocity = 0;
          s.lockSwipeToNext = function() {
            s.params.allowSwipeToNext = false;
          };
          s.lockSwipeToPrev = function() {
            s.params.allowSwipeToPrev = false;
          };
          s.lockSwipes = function() {
            s.params.allowSwipeToNext = s.params.allowSwipeToPrev = false;
          };
          s.unlockSwipeToNext = function() {
            s.params.allowSwipeToNext = true;
          };
          s.unlockSwipeToPrev = function() {
            s.params.allowSwipeToPrev = true;
          };
          s.unlockSwipes = function() {
            s.params.allowSwipeToNext = s.params.allowSwipeToPrev = true;
          };
          function round(a) {
            return Math.floor(a);
          }
          if (s.params.grabCursor) {
            s.container[0].style.cursor = 'move';
            s.container[0].style.cursor = '-webkit-grab';
            s.container[0].style.cursor = '-moz-grab';
            s.container[0].style.cursor = 'grab';
          }
          s.imagesToLoad = [];
          s.imagesLoaded = 0;
          s.loadImage = function(imgElement, src, srcset, checkForComplete, callback) {
            var image;
            function onReady() {
              if (callback)
                callback();
            }
            if (!imgElement.complete || !checkForComplete) {
              if (src) {
                image = new window.Image();
                image.onload = onReady;
                image.onerror = onReady;
                if (srcset) {
                  image.srcset = srcset;
                }
                if (src) {
                  image.src = src;
                }
              } else {
                onReady();
              }
            } else {
              onReady();
            }
          };
          s.preloadImages = function() {
            s.imagesToLoad = s.container.find('img');
            function _onReady() {
              if (typeof s === 'undefined' || s === null)
                return;
              if (s.imagesLoaded !== undefined)
                s.imagesLoaded++;
              if (s.imagesLoaded === s.imagesToLoad.length) {
                if (s.params.updateOnImagesReady)
                  s.update();
                s.emit('onImagesReady', s);
              }
            }
            for (var i = 0; i < s.imagesToLoad.length; i++) {
              s.loadImage(s.imagesToLoad[i], (s.imagesToLoad[i].currentSrc || s.imagesToLoad[i].getAttribute('src')), (s.imagesToLoad[i].srcset || s.imagesToLoad[i].getAttribute('srcset')), true, _onReady);
            }
          };
          s.autoplayTimeoutId = undefined;
          s.autoplaying = false;
          s.autoplayPaused = false;
          function autoplay() {
            s.autoplayTimeoutId = setTimeout(function() {
              if (s.params.loop) {
                s.fixLoop();
                s._slideNext();
              } else {
                if (!s.isEnd) {
                  s._slideNext();
                } else {
                  if (!params.autoplayStopOnLast) {
                    s._slideTo(0);
                  } else {
                    s.stopAutoplay();
                  }
                }
              }
            }, s.params.autoplay);
          }
          s.startAutoplay = function() {
            if (typeof s.autoplayTimeoutId !== 'undefined')
              return false;
            if (!s.params.autoplay)
              return false;
            if (s.autoplaying)
              return false;
            s.autoplaying = true;
            s.emit('onAutoplayStart', s);
            autoplay();
          };
          s.stopAutoplay = function(internal) {
            if (!s.autoplayTimeoutId)
              return;
            if (s.autoplayTimeoutId)
              clearTimeout(s.autoplayTimeoutId);
            s.autoplaying = false;
            s.autoplayTimeoutId = undefined;
            s.emit('onAutoplayStop', s);
          };
          s.pauseAutoplay = function(speed) {
            if (s.autoplayPaused)
              return;
            if (s.autoplayTimeoutId)
              clearTimeout(s.autoplayTimeoutId);
            s.autoplayPaused = true;
            if (speed === 0) {
              s.autoplayPaused = false;
              autoplay();
            } else {
              s.wrapper.transitionEnd(function() {
                if (!s)
                  return;
                s.autoplayPaused = false;
                if (!s.autoplaying) {
                  s.stopAutoplay();
                } else {
                  autoplay();
                }
              });
            }
          };
          s.minTranslate = function() {
            return (-s.snapGrid[0]);
          };
          s.maxTranslate = function() {
            return (-s.snapGrid[s.snapGrid.length - 1]);
          };
          s.updateAutoHeight = function() {
            var newHeight = s.slides.eq(s.activeIndex)[0].offsetHeight;
            if (newHeight)
              s.wrapper.css('height', s.slides.eq(s.activeIndex)[0].offsetHeight + 'px');
          };
          s.updateContainerSize = function() {
            var width,
                height;
            if (typeof s.params.width !== 'undefined') {
              width = s.params.width;
            } else {
              width = s.container[0].clientWidth;
            }
            if (typeof s.params.height !== 'undefined') {
              height = s.params.height;
            } else {
              height = s.container[0].clientHeight;
            }
            if (width === 0 && isH() || height === 0 && !isH()) {
              return;
            }
            width = width - parseInt(s.container.css('padding-left'), 10) - parseInt(s.container.css('padding-right'), 10);
            height = height - parseInt(s.container.css('padding-top'), 10) - parseInt(s.container.css('padding-bottom'), 10);
            s.width = width;
            s.height = height;
            s.size = isH() ? s.width : s.height;
          };
          s.updateSlidesSize = function() {
            s.slides = s.wrapper.children('.' + s.params.slideClass);
            s.snapGrid = [];
            s.slidesGrid = [];
            s.slidesSizesGrid = [];
            var spaceBetween = s.params.spaceBetween,
                slidePosition = -s.params.slidesOffsetBefore,
                i,
                prevSlideSize = 0,
                index = 0;
            if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
              spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * s.size;
            }
            s.virtualSize = -spaceBetween;
            if (s.rtl)
              s.slides.css({
                marginLeft: '',
                marginTop: ''
              });
            else
              s.slides.css({
                marginRight: '',
                marginBottom: ''
              });
            var slidesNumberEvenToRows;
            if (s.params.slidesPerColumn > 1) {
              if (Math.floor(s.slides.length / s.params.slidesPerColumn) === s.slides.length / s.params.slidesPerColumn) {
                slidesNumberEvenToRows = s.slides.length;
              } else {
                slidesNumberEvenToRows = Math.ceil(s.slides.length / s.params.slidesPerColumn) * s.params.slidesPerColumn;
              }
              if (s.params.slidesPerView !== 'auto' && s.params.slidesPerColumnFill === 'row') {
                slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, s.params.slidesPerView * s.params.slidesPerColumn);
              }
            }
            var slideSize;
            var slidesPerColumn = s.params.slidesPerColumn;
            var slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
            var numFullColumns = slidesPerRow - (s.params.slidesPerColumn * slidesPerRow - s.slides.length);
            for (i = 0; i < s.slides.length; i++) {
              slideSize = 0;
              var slide = s.slides.eq(i);
              if (s.params.slidesPerColumn > 1) {
                var newSlideOrderIndex;
                var column,
                    row;
                if (s.params.slidesPerColumnFill === 'column') {
                  column = Math.floor(i / slidesPerColumn);
                  row = i - column * slidesPerColumn;
                  if (column > numFullColumns || (column === numFullColumns && row === slidesPerColumn - 1)) {
                    if (++row >= slidesPerColumn) {
                      row = 0;
                      column++;
                    }
                  }
                  newSlideOrderIndex = column + row * slidesNumberEvenToRows / slidesPerColumn;
                  slide.css({
                    '-webkit-box-ordinal-group': newSlideOrderIndex,
                    '-moz-box-ordinal-group': newSlideOrderIndex,
                    '-ms-flex-order': newSlideOrderIndex,
                    '-webkit-order': newSlideOrderIndex,
                    'order': newSlideOrderIndex
                  });
                } else {
                  row = Math.floor(i / slidesPerRow);
                  column = i - row * slidesPerRow;
                }
                slide.css({'margin-top': (row !== 0 && s.params.spaceBetween) && (s.params.spaceBetween + 'px')}).attr('data-swiper-column', column).attr('data-swiper-row', row);
              }
              if (slide.css('display') === 'none')
                continue;
              if (s.params.slidesPerView === 'auto') {
                slideSize = isH() ? slide.outerWidth(true) : slide.outerHeight(true);
                if (s.params.roundLengths)
                  slideSize = round(slideSize);
              } else {
                slideSize = (s.size - (s.params.slidesPerView - 1) * spaceBetween) / s.params.slidesPerView;
                if (s.params.roundLengths)
                  slideSize = round(slideSize);
                if (isH()) {
                  s.slides[i].style.width = slideSize + 'px';
                } else {
                  s.slides[i].style.height = slideSize + 'px';
                }
              }
              s.slides[i].swiperSlideSize = slideSize;
              s.slidesSizesGrid.push(slideSize);
              if (s.params.centeredSlides) {
                slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
                if (i === 0)
                  slidePosition = slidePosition - s.size / 2 - spaceBetween;
                if (Math.abs(slidePosition) < 1 / 1000)
                  slidePosition = 0;
                if ((index) % s.params.slidesPerGroup === 0)
                  s.snapGrid.push(slidePosition);
                s.slidesGrid.push(slidePosition);
              } else {
                if ((index) % s.params.slidesPerGroup === 0)
                  s.snapGrid.push(slidePosition);
                s.slidesGrid.push(slidePosition);
                slidePosition = slidePosition + slideSize + spaceBetween;
              }
              s.virtualSize += slideSize + spaceBetween;
              prevSlideSize = slideSize;
              index++;
            }
            s.virtualSize = Math.max(s.virtualSize, s.size) + s.params.slidesOffsetAfter;
            var newSlidesGrid;
            if (s.rtl && s.wrongRTL && (s.params.effect === 'slide' || s.params.effect === 'coverflow')) {
              s.wrapper.css({width: s.virtualSize + s.params.spaceBetween + 'px'});
            }
            if (!s.support.flexbox || s.params.setWrapperSize) {
              if (isH())
                s.wrapper.css({width: s.virtualSize + s.params.spaceBetween + 'px'});
              else
                s.wrapper.css({height: s.virtualSize + s.params.spaceBetween + 'px'});
            }
            if (s.params.slidesPerColumn > 1) {
              s.virtualSize = (slideSize + s.params.spaceBetween) * slidesNumberEvenToRows;
              s.virtualSize = Math.ceil(s.virtualSize / s.params.slidesPerColumn) - s.params.spaceBetween;
              s.wrapper.css({width: s.virtualSize + s.params.spaceBetween + 'px'});
              if (s.params.centeredSlides) {
                newSlidesGrid = [];
                for (i = 0; i < s.snapGrid.length; i++) {
                  if (s.snapGrid[i] < s.virtualSize + s.snapGrid[0])
                    newSlidesGrid.push(s.snapGrid[i]);
                }
                s.snapGrid = newSlidesGrid;
              }
            }
            if (!s.params.centeredSlides) {
              newSlidesGrid = [];
              for (i = 0; i < s.snapGrid.length; i++) {
                if (s.snapGrid[i] <= s.virtualSize - s.size) {
                  newSlidesGrid.push(s.snapGrid[i]);
                }
              }
              s.snapGrid = newSlidesGrid;
              if (Math.floor(s.virtualSize - s.size) > Math.floor(s.snapGrid[s.snapGrid.length - 1])) {
                s.snapGrid.push(s.virtualSize - s.size);
              }
            }
            if (s.snapGrid.length === 0)
              s.snapGrid = [0];
            if (s.params.spaceBetween !== 0) {
              if (isH()) {
                if (s.rtl)
                  s.slides.css({marginLeft: spaceBetween + 'px'});
                else
                  s.slides.css({marginRight: spaceBetween + 'px'});
              } else
                s.slides.css({marginBottom: spaceBetween + 'px'});
            }
            if (s.params.watchSlidesProgress) {
              s.updateSlidesOffset();
            }
          };
          s.updateSlidesOffset = function() {
            for (var i = 0; i < s.slides.length; i++) {
              s.slides[i].swiperSlideOffset = isH() ? s.slides[i].offsetLeft : s.slides[i].offsetTop;
            }
          };
          s.updateSlidesProgress = function(translate) {
            if (typeof translate === 'undefined') {
              translate = s.translate || 0;
            }
            if (s.slides.length === 0)
              return;
            if (typeof s.slides[0].swiperSlideOffset === 'undefined')
              s.updateSlidesOffset();
            var offsetCenter = -translate;
            if (s.rtl)
              offsetCenter = translate;
            s.slides.removeClass(s.params.slideVisibleClass);
            for (var i = 0; i < s.slides.length; i++) {
              var slide = s.slides[i];
              var slideProgress = (offsetCenter - slide.swiperSlideOffset) / (slide.swiperSlideSize + s.params.spaceBetween);
              if (s.params.watchSlidesVisibility) {
                var slideBefore = -(offsetCenter - slide.swiperSlideOffset);
                var slideAfter = slideBefore + s.slidesSizesGrid[i];
                var isVisible = (slideBefore >= 0 && slideBefore < s.size) || (slideAfter > 0 && slideAfter <= s.size) || (slideBefore <= 0 && slideAfter >= s.size);
                if (isVisible) {
                  s.slides.eq(i).addClass(s.params.slideVisibleClass);
                }
              }
              slide.progress = s.rtl ? -slideProgress : slideProgress;
            }
          };
          s.updateProgress = function(translate) {
            if (typeof translate === 'undefined') {
              translate = s.translate || 0;
            }
            var translatesDiff = s.maxTranslate() - s.minTranslate();
            var wasBeginning = s.isBeginning;
            var wasEnd = s.isEnd;
            if (translatesDiff === 0) {
              s.progress = 0;
              s.isBeginning = s.isEnd = true;
            } else {
              s.progress = (translate - s.minTranslate()) / (translatesDiff);
              s.isBeginning = s.progress <= 0;
              s.isEnd = s.progress >= 1;
            }
            if (s.isBeginning && !wasBeginning)
              s.emit('onReachBeginning', s);
            if (s.isEnd && !wasEnd)
              s.emit('onReachEnd', s);
            if (s.params.watchSlidesProgress)
              s.updateSlidesProgress(translate);
            s.emit('onProgress', s, s.progress);
          };
          s.updateActiveIndex = function() {
            var translate = s.rtl ? s.translate : -s.translate;
            var newActiveIndex,
                i,
                snapIndex;
            for (i = 0; i < s.slidesGrid.length; i++) {
              if (typeof s.slidesGrid[i + 1] !== 'undefined') {
                if (translate >= s.slidesGrid[i] && translate < s.slidesGrid[i + 1] - (s.slidesGrid[i + 1] - s.slidesGrid[i]) / 2) {
                  newActiveIndex = i;
                } else if (translate >= s.slidesGrid[i] && translate < s.slidesGrid[i + 1]) {
                  newActiveIndex = i + 1;
                }
              } else {
                if (translate >= s.slidesGrid[i]) {
                  newActiveIndex = i;
                }
              }
            }
            if (newActiveIndex < 0 || typeof newActiveIndex === 'undefined')
              newActiveIndex = 0;
            snapIndex = Math.floor(newActiveIndex / s.params.slidesPerGroup);
            if (snapIndex >= s.snapGrid.length)
              snapIndex = s.snapGrid.length - 1;
            if (newActiveIndex === s.activeIndex) {
              return;
            }
            s.snapIndex = snapIndex;
            s.previousIndex = s.activeIndex;
            s.activeIndex = newActiveIndex;
            s.updateClasses();
          };
          s.updateClasses = function() {
            s.slides.removeClass(s.params.slideActiveClass + ' ' + s.params.slideNextClass + ' ' + s.params.slidePrevClass);
            var activeSlide = s.slides.eq(s.activeIndex);
            activeSlide.addClass(s.params.slideActiveClass);
            activeSlide.next('.' + s.params.slideClass).addClass(s.params.slideNextClass);
            activeSlide.prev('.' + s.params.slideClass).addClass(s.params.slidePrevClass);
            if (s.bullets && s.bullets.length > 0) {
              s.bullets.removeClass(s.params.bulletActiveClass);
              var bulletIndex;
              if (s.params.loop) {
                bulletIndex = Math.ceil(s.activeIndex - s.loopedSlides) / s.params.slidesPerGroup;
                if (bulletIndex > s.slides.length - 1 - s.loopedSlides * 2) {
                  bulletIndex = bulletIndex - (s.slides.length - s.loopedSlides * 2);
                }
                if (bulletIndex > s.bullets.length - 1)
                  bulletIndex = bulletIndex - s.bullets.length;
              } else {
                if (typeof s.snapIndex !== 'undefined') {
                  bulletIndex = s.snapIndex;
                } else {
                  bulletIndex = s.activeIndex || 0;
                }
              }
              if (s.paginationContainer.length > 1) {
                s.bullets.each(function() {
                  if ($(this).index() === bulletIndex)
                    $(this).addClass(s.params.bulletActiveClass);
                });
              } else {
                s.bullets.eq(bulletIndex).addClass(s.params.bulletActiveClass);
              }
            }
            if (!s.params.loop) {
              if (s.params.prevButton) {
                if (s.isBeginning) {
                  $(s.params.prevButton).addClass(s.params.buttonDisabledClass);
                  if (s.params.a11y && s.a11y)
                    s.a11y.disable($(s.params.prevButton));
                } else {
                  $(s.params.prevButton).removeClass(s.params.buttonDisabledClass);
                  if (s.params.a11y && s.a11y)
                    s.a11y.enable($(s.params.prevButton));
                }
              }
              if (s.params.nextButton) {
                if (s.isEnd) {
                  $(s.params.nextButton).addClass(s.params.buttonDisabledClass);
                  if (s.params.a11y && s.a11y)
                    s.a11y.disable($(s.params.nextButton));
                } else {
                  $(s.params.nextButton).removeClass(s.params.buttonDisabledClass);
                  if (s.params.a11y && s.a11y)
                    s.a11y.enable($(s.params.nextButton));
                }
              }
            }
          };
          s.updatePagination = function() {
            if (!s.params.pagination)
              return;
            if (s.paginationContainer && s.paginationContainer.length > 0) {
              var bulletsHTML = '';
              var numberOfBullets = s.params.loop ? Math.ceil((s.slides.length - s.loopedSlides * 2) / s.params.slidesPerGroup) : s.snapGrid.length;
              for (var i = 0; i < numberOfBullets; i++) {
                if (s.params.paginationBulletRender) {
                  bulletsHTML += s.params.paginationBulletRender(i, s.params.bulletClass);
                } else {
                  bulletsHTML += '<' + s.params.paginationElement + ' class="' + s.params.bulletClass + '"></' + s.params.paginationElement + '>';
                }
              }
              s.paginationContainer.html(bulletsHTML);
              s.bullets = s.paginationContainer.find('.' + s.params.bulletClass);
              if (s.params.paginationClickable && s.params.a11y && s.a11y) {
                s.a11y.initPagination();
              }
            }
          };
          s.update = function(updateTranslate) {
            s.updateContainerSize();
            s.updateSlidesSize();
            s.updateProgress();
            s.updatePagination();
            s.updateClasses();
            if (s.params.scrollbar && s.scrollbar) {
              s.scrollbar.set();
            }
            function forceSetTranslate() {
              newTranslate = Math.min(Math.max(s.translate, s.maxTranslate()), s.minTranslate());
              s.setWrapperTranslate(newTranslate);
              s.updateActiveIndex();
              s.updateClasses();
            }
            if (updateTranslate) {
              var translated,
                  newTranslate;
              if (s.controller && s.controller.spline) {
                s.controller.spline = undefined;
              }
              if (s.params.freeMode) {
                forceSetTranslate();
                if (s.params.autoHeight) {
                  s.updateAutoHeight();
                }
              } else {
                if ((s.params.slidesPerView === 'auto' || s.params.slidesPerView > 1) && s.isEnd && !s.params.centeredSlides) {
                  translated = s.slideTo(s.slides.length - 1, 0, false, true);
                } else {
                  translated = s.slideTo(s.activeIndex, 0, false, true);
                }
                if (!translated) {
                  forceSetTranslate();
                }
              }
            } else if (s.params.autoHeight) {
              s.updateAutoHeight();
            }
          };
          s.onResize = function(forceUpdatePagination) {
            if (s.params.breakpoints) {
              s.setBreakpoint();
            }
            var allowSwipeToPrev = s.params.allowSwipeToPrev;
            var allowSwipeToNext = s.params.allowSwipeToNext;
            s.params.allowSwipeToPrev = s.params.allowSwipeToNext = true;
            s.updateContainerSize();
            s.updateSlidesSize();
            if (s.params.slidesPerView === 'auto' || s.params.freeMode || forceUpdatePagination)
              s.updatePagination();
            if (s.params.scrollbar && s.scrollbar) {
              s.scrollbar.set();
            }
            if (s.controller && s.controller.spline) {
              s.controller.spline = undefined;
            }
            if (s.params.freeMode) {
              var newTranslate = Math.min(Math.max(s.translate, s.maxTranslate()), s.minTranslate());
              s.setWrapperTranslate(newTranslate);
              s.updateActiveIndex();
              s.updateClasses();
              if (s.params.autoHeight) {
                s.updateAutoHeight();
              }
            } else {
              s.updateClasses();
              if ((s.params.slidesPerView === 'auto' || s.params.slidesPerView > 1) && s.isEnd && !s.params.centeredSlides) {
                s.slideTo(s.slides.length - 1, 0, false, true);
              } else {
                s.slideTo(s.activeIndex, 0, false, true);
              }
            }
            s.params.allowSwipeToPrev = allowSwipeToPrev;
            s.params.allowSwipeToNext = allowSwipeToNext;
          };
          var desktopEvents = ['mousedown', 'mousemove', 'mouseup'];
          if (window.navigator.pointerEnabled)
            desktopEvents = ['pointerdown', 'pointermove', 'pointerup'];
          else if (window.navigator.msPointerEnabled)
            desktopEvents = ['MSPointerDown', 'MSPointerMove', 'MSPointerUp'];
          s.touchEvents = {
            start: s.support.touch || !s.params.simulateTouch ? 'touchstart' : desktopEvents[0],
            move: s.support.touch || !s.params.simulateTouch ? 'touchmove' : desktopEvents[1],
            end: s.support.touch || !s.params.simulateTouch ? 'touchend' : desktopEvents[2]
          };
          if (window.navigator.pointerEnabled || window.navigator.msPointerEnabled) {
            (s.params.touchEventsTarget === 'container' ? s.container : s.wrapper).addClass('swiper-wp8-' + s.params.direction);
          }
          s.initEvents = function(detach) {
            var actionDom = detach ? 'off' : 'on';
            var action = detach ? 'removeEventListener' : 'addEventListener';
            var touchEventsTarget = s.params.touchEventsTarget === 'container' ? s.container[0] : s.wrapper[0];
            var target = s.support.touch ? touchEventsTarget : document;
            var moveCapture = s.params.nested ? true : false;
            if (s.browser.ie) {
              touchEventsTarget[action](s.touchEvents.start, s.onTouchStart, false);
              target[action](s.touchEvents.move, s.onTouchMove, moveCapture);
              target[action](s.touchEvents.end, s.onTouchEnd, false);
            } else {
              if (s.support.touch) {
                touchEventsTarget[action](s.touchEvents.start, s.onTouchStart, false);
                touchEventsTarget[action](s.touchEvents.move, s.onTouchMove, moveCapture);
                touchEventsTarget[action](s.touchEvents.end, s.onTouchEnd, false);
              }
              if (params.simulateTouch && !s.device.ios && !s.device.android) {
                touchEventsTarget[action]('mousedown', s.onTouchStart, false);
                document[action]('mousemove', s.onTouchMove, moveCapture);
                document[action]('mouseup', s.onTouchEnd, false);
              }
            }
            window[action]('resize', s.onResize);
            if (s.params.nextButton) {
              $(s.params.nextButton)[actionDom]('click', s.onClickNext);
              if (s.params.a11y && s.a11y)
                $(s.params.nextButton)[actionDom]('keydown', s.a11y.onEnterKey);
            }
            if (s.params.prevButton) {
              $(s.params.prevButton)[actionDom]('click', s.onClickPrev);
              if (s.params.a11y && s.a11y)
                $(s.params.prevButton)[actionDom]('keydown', s.a11y.onEnterKey);
            }
            if (s.params.pagination && s.params.paginationClickable) {
              $(s.paginationContainer)[actionDom]('click', '.' + s.params.bulletClass, s.onClickIndex);
              if (s.params.a11y && s.a11y)
                $(s.paginationContainer)[actionDom]('keydown', '.' + s.params.bulletClass, s.a11y.onEnterKey);
            }
            if (s.params.preventClicks || s.params.preventClicksPropagation)
              touchEventsTarget[action]('click', s.preventClicks, true);
          };
          s.attachEvents = function(detach) {
            s.initEvents();
          };
          s.detachEvents = function() {
            s.initEvents(true);
          };
          s.allowClick = true;
          s.preventClicks = function(e) {
            if (!s.allowClick) {
              if (s.params.preventClicks)
                e.preventDefault();
              if (s.params.preventClicksPropagation && s.animating) {
                e.stopPropagation();
                e.stopImmediatePropagation();
              }
            }
          };
          s.onClickNext = function(e) {
            e.preventDefault();
            if (s.isEnd && !s.params.loop)
              return;
            s.slideNext();
          };
          s.onClickPrev = function(e) {
            e.preventDefault();
            if (s.isBeginning && !s.params.loop)
              return;
            s.slidePrev();
          };
          s.onClickIndex = function(e) {
            e.preventDefault();
            var index = $(this).index() * s.params.slidesPerGroup;
            if (s.params.loop)
              index = index + s.loopedSlides;
            s.slideTo(index);
          };
          function findElementInEvent(e, selector) {
            var el = $(e.target);
            if (!el.is(selector)) {
              if (typeof selector === 'string') {
                el = el.parents(selector);
              } else if (selector.nodeType) {
                var found;
                el.parents().each(function(index, _el) {
                  if (_el === selector)
                    found = selector;
                });
                if (!found)
                  return undefined;
                else
                  return selector;
              }
            }
            if (el.length === 0) {
              return undefined;
            }
            return el[0];
          }
          s.updateClickedSlide = function(e) {
            var slide = findElementInEvent(e, '.' + s.params.slideClass);
            var slideFound = false;
            if (slide) {
              for (var i = 0; i < s.slides.length; i++) {
                if (s.slides[i] === slide)
                  slideFound = true;
              }
            }
            if (slide && slideFound) {
              s.clickedSlide = slide;
              s.clickedIndex = $(slide).index();
            } else {
              s.clickedSlide = undefined;
              s.clickedIndex = undefined;
              return;
            }
            if (s.params.slideToClickedSlide && s.clickedIndex !== undefined && s.clickedIndex !== s.activeIndex) {
              var slideToIndex = s.clickedIndex,
                  realIndex,
                  duplicatedSlides;
              if (s.params.loop) {
                if (s.animating)
                  return;
                realIndex = $(s.clickedSlide).attr('data-swiper-slide-index');
                if (s.params.centeredSlides) {
                  if ((slideToIndex < s.loopedSlides - s.params.slidesPerView / 2) || (slideToIndex > s.slides.length - s.loopedSlides + s.params.slidesPerView / 2)) {
                    s.fixLoop();
                    slideToIndex = s.wrapper.children('.' + s.params.slideClass + '[data-swiper-slide-index="' + realIndex + '"]:not(.swiper-slide-duplicate)').eq(0).index();
                    setTimeout(function() {
                      s.slideTo(slideToIndex);
                    }, 0);
                  } else {
                    s.slideTo(slideToIndex);
                  }
                } else {
                  if (slideToIndex > s.slides.length - s.params.slidesPerView) {
                    s.fixLoop();
                    slideToIndex = s.wrapper.children('.' + s.params.slideClass + '[data-swiper-slide-index="' + realIndex + '"]:not(.swiper-slide-duplicate)').eq(0).index();
                    setTimeout(function() {
                      s.slideTo(slideToIndex);
                    }, 0);
                  } else {
                    s.slideTo(slideToIndex);
                  }
                }
              } else {
                s.slideTo(slideToIndex);
              }
            }
          };
          var isTouched,
              isMoved,
              allowTouchCallbacks,
              touchStartTime,
              isScrolling,
              currentTranslate,
              startTranslate,
              allowThresholdMove,
              formElements = 'input, select, textarea, button',
              lastClickTime = Date.now(),
              clickTimeout,
              velocities = [],
              allowMomentumBounce;
          s.animating = false;
          s.touches = {
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0,
            diff: 0
          };
          var isTouchEvent,
              startMoving;
          s.onTouchStart = function(e) {
            if (e.originalEvent)
              e = e.originalEvent;
            isTouchEvent = e.type === 'touchstart';
            if (!isTouchEvent && 'which' in e && e.which === 3)
              return;
            if (s.params.noSwiping && findElementInEvent(e, '.' + s.params.noSwipingClass)) {
              s.allowClick = true;
              return;
            }
            if (s.params.swipeHandler) {
              if (!findElementInEvent(e, s.params.swipeHandler))
                return;
            }
            var startX = s.touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
            var startY = s.touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
            if (s.device.ios && s.params.iOSEdgeSwipeDetection && startX <= s.params.iOSEdgeSwipeThreshold) {
              return;
            }
            isTouched = true;
            isMoved = false;
            allowTouchCallbacks = true;
            isScrolling = undefined;
            startMoving = undefined;
            s.touches.startX = startX;
            s.touches.startY = startY;
            touchStartTime = Date.now();
            s.allowClick = true;
            s.updateContainerSize();
            s.swipeDirection = undefined;
            if (s.params.threshold > 0)
              allowThresholdMove = false;
            if (e.type !== 'touchstart') {
              var preventDefault = true;
              if ($(e.target).is(formElements))
                preventDefault = false;
              if (document.activeElement && $(document.activeElement).is(formElements)) {
                document.activeElement.blur();
              }
              if (preventDefault) {
                e.preventDefault();
              }
            }
            s.emit('onTouchStart', s, e);
          };
          s.onTouchMove = function(e) {
            if (e.originalEvent)
              e = e.originalEvent;
            if (isTouchEvent && e.type === 'mousemove')
              return;
            if (e.preventedByNestedSwiper)
              return;
            if (s.params.onlyExternal) {
              s.allowClick = false;
              if (isTouched) {
                s.touches.startX = s.touches.currentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
                s.touches.startY = s.touches.currentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
                touchStartTime = Date.now();
              }
              return;
            }
            if (isTouchEvent && document.activeElement) {
              if (e.target === document.activeElement && $(e.target).is(formElements)) {
                isMoved = true;
                s.allowClick = false;
                return;
              }
            }
            if (allowTouchCallbacks) {
              s.emit('onTouchMove', s, e);
            }
            if (e.targetTouches && e.targetTouches.length > 1)
              return;
            s.touches.currentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
            s.touches.currentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
            if (typeof isScrolling === 'undefined') {
              var touchAngle = Math.atan2(Math.abs(s.touches.currentY - s.touches.startY), Math.abs(s.touches.currentX - s.touches.startX)) * 180 / Math.PI;
              isScrolling = isH() ? touchAngle > s.params.touchAngle : (90 - touchAngle > s.params.touchAngle);
            }
            if (isScrolling) {
              s.emit('onTouchMoveOpposite', s, e);
            }
            if (typeof startMoving === 'undefined' && s.browser.ieTouch) {
              if (s.touches.currentX !== s.touches.startX || s.touches.currentY !== s.touches.startY) {
                startMoving = true;
              }
            }
            if (!isTouched)
              return;
            if (isScrolling) {
              isTouched = false;
              return;
            }
            if (!startMoving && s.browser.ieTouch) {
              return;
            }
            s.allowClick = false;
            s.emit('onSliderMove', s, e);
            e.preventDefault();
            if (s.params.touchMoveStopPropagation && !s.params.nested) {
              e.stopPropagation();
            }
            if (!isMoved) {
              if (params.loop) {
                s.fixLoop();
              }
              startTranslate = s.getWrapperTranslate();
              s.setWrapperTransition(0);
              if (s.animating) {
                s.wrapper.trigger('webkitTransitionEnd transitionend oTransitionEnd MSTransitionEnd msTransitionEnd');
              }
              if (s.params.autoplay && s.autoplaying) {
                if (s.params.autoplayDisableOnInteraction) {
                  s.stopAutoplay();
                } else {
                  s.pauseAutoplay();
                }
              }
              allowMomentumBounce = false;
              if (s.params.grabCursor) {
                s.container[0].style.cursor = 'move';
                s.container[0].style.cursor = '-webkit-grabbing';
                s.container[0].style.cursor = '-moz-grabbin';
                s.container[0].style.cursor = 'grabbing';
              }
            }
            isMoved = true;
            var diff = s.touches.diff = isH() ? s.touches.currentX - s.touches.startX : s.touches.currentY - s.touches.startY;
            diff = diff * s.params.touchRatio;
            if (s.rtl)
              diff = -diff;
            s.swipeDirection = diff > 0 ? 'prev' : 'next';
            currentTranslate = diff + startTranslate;
            var disableParentSwiper = true;
            if ((diff > 0 && currentTranslate > s.minTranslate())) {
              disableParentSwiper = false;
              if (s.params.resistance)
                currentTranslate = s.minTranslate() - 1 + Math.pow(-s.minTranslate() + startTranslate + diff, s.params.resistanceRatio);
            } else if (diff < 0 && currentTranslate < s.maxTranslate()) {
              disableParentSwiper = false;
              if (s.params.resistance)
                currentTranslate = s.maxTranslate() + 1 - Math.pow(s.maxTranslate() - startTranslate - diff, s.params.resistanceRatio);
            }
            if (disableParentSwiper) {
              e.preventedByNestedSwiper = true;
            }
            if (!s.params.allowSwipeToNext && s.swipeDirection === 'next' && currentTranslate < startTranslate) {
              currentTranslate = startTranslate;
            }
            if (!s.params.allowSwipeToPrev && s.swipeDirection === 'prev' && currentTranslate > startTranslate) {
              currentTranslate = startTranslate;
            }
            if (!s.params.followFinger)
              return;
            if (s.params.threshold > 0) {
              if (Math.abs(diff) > s.params.threshold || allowThresholdMove) {
                if (!allowThresholdMove) {
                  allowThresholdMove = true;
                  s.touches.startX = s.touches.currentX;
                  s.touches.startY = s.touches.currentY;
                  currentTranslate = startTranslate;
                  s.touches.diff = isH() ? s.touches.currentX - s.touches.startX : s.touches.currentY - s.touches.startY;
                  return;
                }
              } else {
                currentTranslate = startTranslate;
                return;
              }
            }
            if (s.params.freeMode || s.params.watchSlidesProgress) {
              s.updateActiveIndex();
            }
            if (s.params.freeMode) {
              if (velocities.length === 0) {
                velocities.push({
                  position: s.touches[isH() ? 'startX' : 'startY'],
                  time: touchStartTime
                });
              }
              velocities.push({
                position: s.touches[isH() ? 'currentX' : 'currentY'],
                time: (new window.Date()).getTime()
              });
            }
            s.updateProgress(currentTranslate);
            s.setWrapperTranslate(currentTranslate);
          };
          s.onTouchEnd = function(e) {
            if (e.originalEvent)
              e = e.originalEvent;
            if (allowTouchCallbacks) {
              s.emit('onTouchEnd', s, e);
            }
            allowTouchCallbacks = false;
            if (!isTouched)
              return;
            if (s.params.grabCursor && isMoved && isTouched) {
              s.container[0].style.cursor = 'move';
              s.container[0].style.cursor = '-webkit-grab';
              s.container[0].style.cursor = '-moz-grab';
              s.container[0].style.cursor = 'grab';
            }
            var touchEndTime = Date.now();
            var timeDiff = touchEndTime - touchStartTime;
            if (s.allowClick) {
              s.updateClickedSlide(e);
              s.emit('onTap', s, e);
              if (timeDiff < 300 && (touchEndTime - lastClickTime) > 300) {
                if (clickTimeout)
                  clearTimeout(clickTimeout);
                clickTimeout = setTimeout(function() {
                  if (!s)
                    return;
                  if (s.params.paginationHide && s.paginationContainer.length > 0 && !$(e.target).hasClass(s.params.bulletClass)) {
                    s.paginationContainer.toggleClass(s.params.paginationHiddenClass);
                  }
                  s.emit('onClick', s, e);
                }, 300);
              }
              if (timeDiff < 300 && (touchEndTime - lastClickTime) < 300) {
                if (clickTimeout)
                  clearTimeout(clickTimeout);
                s.emit('onDoubleTap', s, e);
              }
            }
            lastClickTime = Date.now();
            setTimeout(function() {
              if (s)
                s.allowClick = true;
            }, 0);
            if (!isTouched || !isMoved || !s.swipeDirection || s.touches.diff === 0 || currentTranslate === startTranslate) {
              isTouched = isMoved = false;
              return;
            }
            isTouched = isMoved = false;
            var currentPos;
            if (s.params.followFinger) {
              currentPos = s.rtl ? s.translate : -s.translate;
            } else {
              currentPos = -currentTranslate;
            }
            if (s.params.freeMode) {
              if (currentPos < -s.minTranslate()) {
                s.slideTo(s.activeIndex);
                return;
              } else if (currentPos > -s.maxTranslate()) {
                if (s.slides.length < s.snapGrid.length) {
                  s.slideTo(s.snapGrid.length - 1);
                } else {
                  s.slideTo(s.slides.length - 1);
                }
                return;
              }
              if (s.params.freeModeMomentum) {
                if (velocities.length > 1) {
                  var lastMoveEvent = velocities.pop(),
                      velocityEvent = velocities.pop();
                  var distance = lastMoveEvent.position - velocityEvent.position;
                  var time = lastMoveEvent.time - velocityEvent.time;
                  s.velocity = distance / time;
                  s.velocity = s.velocity / 2;
                  if (Math.abs(s.velocity) < s.params.freeModeMinimumVelocity) {
                    s.velocity = 0;
                  }
                  if (time > 150 || (new window.Date().getTime() - lastMoveEvent.time) > 300) {
                    s.velocity = 0;
                  }
                } else {
                  s.velocity = 0;
                }
                velocities.length = 0;
                var momentumDuration = 1000 * s.params.freeModeMomentumRatio;
                var momentumDistance = s.velocity * momentumDuration;
                var newPosition = s.translate + momentumDistance;
                if (s.rtl)
                  newPosition = -newPosition;
                var doBounce = false;
                var afterBouncePosition;
                var bounceAmount = Math.abs(s.velocity) * 20 * s.params.freeModeMomentumBounceRatio;
                if (newPosition < s.maxTranslate()) {
                  if (s.params.freeModeMomentumBounce) {
                    if (newPosition + s.maxTranslate() < -bounceAmount) {
                      newPosition = s.maxTranslate() - bounceAmount;
                    }
                    afterBouncePosition = s.maxTranslate();
                    doBounce = true;
                    allowMomentumBounce = true;
                  } else {
                    newPosition = s.maxTranslate();
                  }
                } else if (newPosition > s.minTranslate()) {
                  if (s.params.freeModeMomentumBounce) {
                    if (newPosition - s.minTranslate() > bounceAmount) {
                      newPosition = s.minTranslate() + bounceAmount;
                    }
                    afterBouncePosition = s.minTranslate();
                    doBounce = true;
                    allowMomentumBounce = true;
                  } else {
                    newPosition = s.minTranslate();
                  }
                } else if (s.params.freeModeSticky) {
                  var j = 0,
                      nextSlide;
                  for (j = 0; j < s.snapGrid.length; j += 1) {
                    if (s.snapGrid[j] > -newPosition) {
                      nextSlide = j;
                      break;
                    }
                  }
                  if (Math.abs(s.snapGrid[nextSlide] - newPosition) < Math.abs(s.snapGrid[nextSlide - 1] - newPosition) || s.swipeDirection === 'next') {
                    newPosition = s.snapGrid[nextSlide];
                  } else {
                    newPosition = s.snapGrid[nextSlide - 1];
                  }
                  if (!s.rtl)
                    newPosition = -newPosition;
                }
                if (s.velocity !== 0) {
                  if (s.rtl) {
                    momentumDuration = Math.abs((-newPosition - s.translate) / s.velocity);
                  } else {
                    momentumDuration = Math.abs((newPosition - s.translate) / s.velocity);
                  }
                } else if (s.params.freeModeSticky) {
                  s.slideReset();
                  return;
                }
                if (s.params.freeModeMomentumBounce && doBounce) {
                  s.updateProgress(afterBouncePosition);
                  s.setWrapperTransition(momentumDuration);
                  s.setWrapperTranslate(newPosition);
                  s.onTransitionStart();
                  s.animating = true;
                  s.wrapper.transitionEnd(function() {
                    if (!s || !allowMomentumBounce)
                      return;
                    s.emit('onMomentumBounce', s);
                    s.setWrapperTransition(s.params.speed);
                    s.setWrapperTranslate(afterBouncePosition);
                    s.wrapper.transitionEnd(function() {
                      if (!s)
                        return;
                      s.onTransitionEnd();
                    });
                  });
                } else if (s.velocity) {
                  s.updateProgress(newPosition);
                  s.setWrapperTransition(momentumDuration);
                  s.setWrapperTranslate(newPosition);
                  s.onTransitionStart();
                  if (!s.animating) {
                    s.animating = true;
                    s.wrapper.transitionEnd(function() {
                      if (!s)
                        return;
                      s.onTransitionEnd();
                    });
                  }
                } else {
                  s.updateProgress(newPosition);
                }
                s.updateActiveIndex();
              }
              if (!s.params.freeModeMomentum || timeDiff >= s.params.longSwipesMs) {
                s.updateProgress();
                s.updateActiveIndex();
              }
              return;
            }
            var i,
                stopIndex = 0,
                groupSize = s.slidesSizesGrid[0];
            for (i = 0; i < s.slidesGrid.length; i += s.params.slidesPerGroup) {
              if (typeof s.slidesGrid[i + s.params.slidesPerGroup] !== 'undefined') {
                if (currentPos >= s.slidesGrid[i] && currentPos < s.slidesGrid[i + s.params.slidesPerGroup]) {
                  stopIndex = i;
                  groupSize = s.slidesGrid[i + s.params.slidesPerGroup] - s.slidesGrid[i];
                }
              } else {
                if (currentPos >= s.slidesGrid[i]) {
                  stopIndex = i;
                  groupSize = s.slidesGrid[s.slidesGrid.length - 1] - s.slidesGrid[s.slidesGrid.length - 2];
                }
              }
            }
            var ratio = (currentPos - s.slidesGrid[stopIndex]) / groupSize;
            if (timeDiff > s.params.longSwipesMs) {
              if (!s.params.longSwipes) {
                s.slideTo(s.activeIndex);
                return;
              }
              if (s.swipeDirection === 'next') {
                if (ratio >= s.params.longSwipesRatio)
                  s.slideTo(stopIndex + s.params.slidesPerGroup);
                else
                  s.slideTo(stopIndex);
              }
              if (s.swipeDirection === 'prev') {
                if (ratio > (1 - s.params.longSwipesRatio))
                  s.slideTo(stopIndex + s.params.slidesPerGroup);
                else
                  s.slideTo(stopIndex);
              }
            } else {
              if (!s.params.shortSwipes) {
                s.slideTo(s.activeIndex);
                return;
              }
              if (s.swipeDirection === 'next') {
                s.slideTo(stopIndex + s.params.slidesPerGroup);
              }
              if (s.swipeDirection === 'prev') {
                s.slideTo(stopIndex);
              }
            }
          };
          s._slideTo = function(slideIndex, speed) {
            return s.slideTo(slideIndex, speed, true, true);
          };
          s.slideTo = function(slideIndex, speed, runCallbacks, internal) {
            if (typeof runCallbacks === 'undefined')
              runCallbacks = true;
            if (typeof slideIndex === 'undefined')
              slideIndex = 0;
            if (slideIndex < 0)
              slideIndex = 0;
            s.snapIndex = Math.floor(slideIndex / s.params.slidesPerGroup);
            if (s.snapIndex >= s.snapGrid.length)
              s.snapIndex = s.snapGrid.length - 1;
            var translate = -s.snapGrid[s.snapIndex];
            if (s.params.autoplay && s.autoplaying) {
              if (internal || !s.params.autoplayDisableOnInteraction) {
                s.pauseAutoplay(speed);
              } else {
                s.stopAutoplay();
              }
            }
            s.updateProgress(translate);
            for (var i = 0; i < s.slidesGrid.length; i++) {
              if (-Math.floor(translate * 100) >= Math.floor(s.slidesGrid[i] * 100)) {
                slideIndex = i;
              }
            }
            if (!s.params.allowSwipeToNext && translate < s.translate && translate < s.minTranslate()) {
              return false;
            }
            if (!s.params.allowSwipeToPrev && translate > s.translate && translate > s.maxTranslate()) {
              if ((s.activeIndex || 0) !== slideIndex)
                return false;
            }
            if (typeof speed === 'undefined')
              speed = s.params.speed;
            s.previousIndex = s.activeIndex || 0;
            s.activeIndex = slideIndex;
            if ((s.rtl && -translate === s.translate) || (!s.rtl && translate === s.translate)) {
              if (s.params.autoHeight) {
                s.updateAutoHeight();
              }
              s.updateClasses();
              if (s.params.effect !== 'slide') {
                s.setWrapperTranslate(translate);
              }
              return false;
            }
            s.updateClasses();
            s.onTransitionStart(runCallbacks);
            if (speed === 0) {
              s.setWrapperTranslate(translate);
              s.setWrapperTransition(0);
              s.onTransitionEnd(runCallbacks);
            } else {
              s.setWrapperTranslate(translate);
              s.setWrapperTransition(speed);
              if (!s.animating) {
                s.animating = true;
                s.wrapper.transitionEnd(function() {
                  if (!s)
                    return;
                  s.onTransitionEnd(runCallbacks);
                });
              }
            }
            return true;
          };
          s.onTransitionStart = function(runCallbacks) {
            if (typeof runCallbacks === 'undefined')
              runCallbacks = true;
            if (s.params.autoHeight) {
              s.updateAutoHeight();
            }
            if (s.lazy)
              s.lazy.onTransitionStart();
            if (runCallbacks) {
              s.emit('onTransitionStart', s);
              if (s.activeIndex !== s.previousIndex) {
                s.emit('onSlideChangeStart', s);
                if (s.activeIndex > s.previousIndex) {
                  s.emit('onSlideNextStart', s);
                } else {
                  s.emit('onSlidePrevStart', s);
                }
              }
            }
          };
          s.onTransitionEnd = function(runCallbacks) {
            s.animating = false;
            s.setWrapperTransition(0);
            if (typeof runCallbacks === 'undefined')
              runCallbacks = true;
            if (s.lazy)
              s.lazy.onTransitionEnd();
            if (runCallbacks) {
              s.emit('onTransitionEnd', s);
              if (s.activeIndex !== s.previousIndex) {
                s.emit('onSlideChangeEnd', s);
                if (s.activeIndex > s.previousIndex) {
                  s.emit('onSlideNextEnd', s);
                } else {
                  s.emit('onSlidePrevEnd', s);
                }
              }
            }
            if (s.params.hashnav && s.hashnav) {
              s.hashnav.setHash();
            }
          };
          s.slideNext = function(runCallbacks, speed, internal) {
            if (s.params.loop) {
              if (s.animating)
                return false;
              s.fixLoop();
              var clientLeft = s.container[0].clientLeft;
              return s.slideTo(s.activeIndex + s.params.slidesPerGroup, speed, runCallbacks, internal);
            } else
              return s.slideTo(s.activeIndex + s.params.slidesPerGroup, speed, runCallbacks, internal);
          };
          s._slideNext = function(speed) {
            return s.slideNext(true, speed, true);
          };
          s.slidePrev = function(runCallbacks, speed, internal) {
            if (s.params.loop) {
              if (s.animating)
                return false;
              s.fixLoop();
              var clientLeft = s.container[0].clientLeft;
              return s.slideTo(s.activeIndex - 1, speed, runCallbacks, internal);
            } else
              return s.slideTo(s.activeIndex - 1, speed, runCallbacks, internal);
          };
          s._slidePrev = function(speed) {
            return s.slidePrev(true, speed, true);
          };
          s.slideReset = function(runCallbacks, speed, internal) {
            return s.slideTo(s.activeIndex, speed, runCallbacks);
          };
          s.setWrapperTransition = function(duration, byController) {
            s.wrapper.transition(duration);
            if (s.params.effect !== 'slide' && s.effects[s.params.effect]) {
              s.effects[s.params.effect].setTransition(duration);
            }
            if (s.params.parallax && s.parallax) {
              s.parallax.setTransition(duration);
            }
            if (s.params.scrollbar && s.scrollbar) {
              s.scrollbar.setTransition(duration);
            }
            if (s.params.control && s.controller) {
              s.controller.setTransition(duration, byController);
            }
            s.emit('onSetTransition', s, duration);
          };
          s.setWrapperTranslate = function(translate, updateActiveIndex, byController) {
            var x = 0,
                y = 0,
                z = 0;
            if (isH()) {
              x = s.rtl ? -translate : translate;
            } else {
              y = translate;
            }
            if (s.params.roundLengths) {
              x = round(x);
              y = round(y);
            }
            if (!s.params.virtualTranslate) {
              if (s.support.transforms3d)
                s.wrapper.transform('translate3d(' + x + 'px, ' + y + 'px, ' + z + 'px)');
              else
                s.wrapper.transform('translate(' + x + 'px, ' + y + 'px)');
            }
            s.translate = isH() ? x : y;
            var progress;
            var translatesDiff = s.maxTranslate() - s.minTranslate();
            if (translatesDiff === 0) {
              progress = 0;
            } else {
              progress = (translate - s.minTranslate()) / (translatesDiff);
            }
            if (progress !== s.progress) {
              s.updateProgress(translate);
            }
            if (updateActiveIndex)
              s.updateActiveIndex();
            if (s.params.effect !== 'slide' && s.effects[s.params.effect]) {
              s.effects[s.params.effect].setTranslate(s.translate);
            }
            if (s.params.parallax && s.parallax) {
              s.parallax.setTranslate(s.translate);
            }
            if (s.params.scrollbar && s.scrollbar) {
              s.scrollbar.setTranslate(s.translate);
            }
            if (s.params.control && s.controller) {
              s.controller.setTranslate(s.translate, byController);
            }
            s.emit('onSetTranslate', s, s.translate);
          };
          s.getTranslate = function(el, axis) {
            var matrix,
                curTransform,
                curStyle,
                transformMatrix;
            if (typeof axis === 'undefined') {
              axis = 'x';
            }
            if (s.params.virtualTranslate) {
              return s.rtl ? -s.translate : s.translate;
            }
            curStyle = window.getComputedStyle(el, null);
            if (window.WebKitCSSMatrix) {
              curTransform = curStyle.transform || curStyle.webkitTransform;
              if (curTransform.split(',').length > 6) {
                curTransform = curTransform.split(', ').map(function(a) {
                  return a.replace(',', '.');
                }).join(', ');
              }
              transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
            } else {
              transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
              matrix = transformMatrix.toString().split(',');
            }
            if (axis === 'x') {
              if (window.WebKitCSSMatrix)
                curTransform = transformMatrix.m41;
              else if (matrix.length === 16)
                curTransform = parseFloat(matrix[12]);
              else
                curTransform = parseFloat(matrix[4]);
            }
            if (axis === 'y') {
              if (window.WebKitCSSMatrix)
                curTransform = transformMatrix.m42;
              else if (matrix.length === 16)
                curTransform = parseFloat(matrix[13]);
              else
                curTransform = parseFloat(matrix[5]);
            }
            if (s.rtl && curTransform)
              curTransform = -curTransform;
            return curTransform || 0;
          };
          s.getWrapperTranslate = function(axis) {
            if (typeof axis === 'undefined') {
              axis = isH() ? 'x' : 'y';
            }
            return s.getTranslate(s.wrapper[0], axis);
          };
          s.observers = [];
          function initObserver(target, options) {
            options = options || {};
            var ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
            var observer = new ObserverFunc(function(mutations) {
              mutations.forEach(function(mutation) {
                s.onResize(true);
                s.emit('onObserverUpdate', s, mutation);
              });
            });
            observer.observe(target, {
              attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
              childList: typeof options.childList === 'undefined' ? true : options.childList,
              characterData: typeof options.characterData === 'undefined' ? true : options.characterData
            });
            s.observers.push(observer);
          }
          s.initObservers = function() {
            if (s.params.observeParents) {
              var containerParents = s.container.parents();
              for (var i = 0; i < containerParents.length; i++) {
                initObserver(containerParents[i]);
              }
            }
            initObserver(s.container[0], {childList: false});
            initObserver(s.wrapper[0], {attributes: false});
          };
          s.disconnectObservers = function() {
            for (var i = 0; i < s.observers.length; i++) {
              s.observers[i].disconnect();
            }
            s.observers = [];
          };
          s.updateLoop = function() {
            var duplicates = s.wrapper.children('.' + s.params.slideClass + '.' + s.params.slideDuplicateClass);
            var slides = s.wrapper.children('.' + s.params.slideClass);
            for (var i = 0; i < duplicates.length; i++) {
              var duplicate = duplicates[i];
              var swiperSlideIndex = angular.element(duplicate).attr("data-swiper-slide-index");
              for (var j = 0; i < slides.length; j++) {
                var slide = slides[j];
                if (!angular.element(slide).hasClass(s.params.slideDuplicateClass) && angular.element(slide).attr("data-swiper-slide-index") === swiperSlideIndex) {
                  duplicate.innerHTML = slide.innerHTML;
                  break;
                }
              }
            }
          };
          s.createLoop = function() {
            s.wrapper.children('.' + s.params.slideClass + '.' + s.params.slideDuplicateClass).remove();
            var slides = s.wrapper.children('.' + s.params.slideClass);
            if (s.params.slidesPerView === 'auto' && !s.params.loopedSlides)
              s.params.loopedSlides = slides.length;
            s.loopedSlides = parseInt(s.params.loopedSlides || s.params.slidesPerView, 10);
            s.loopedSlides = s.loopedSlides + s.params.loopAdditionalSlides;
            if (s.loopedSlides > slides.length) {
              s.loopedSlides = slides.length;
            }
            var prependSlides = [],
                appendSlides = [],
                i,
                scope,
                newNode;
            slides.each(function(index, el) {
              var slide = $(this);
              if (index < s.loopedSlides)
                appendSlides.push(el);
              if (index < slides.length && index >= slides.length - s.loopedSlides)
                prependSlides.push(el);
              slide.attr('data-swiper-slide-index', index);
            });
            for (i = 0; i < appendSlides.length; i++) {
              s.wrapper.append($(appendSlides[i].cloneNode(true)).addClass(s.params.slideDuplicateClass));
            }
            for (i = prependSlides.length - 1; i >= 0; i--) {
              s.wrapper.prepend($(prependSlides[i].cloneNode(true)).addClass(s.params.slideDuplicateClass));
            }
          };
          s.destroyLoop = function() {
            s.wrapper.children('.' + s.params.slideClass + '.' + s.params.slideDuplicateClass).remove();
            s.slides.removeAttr('data-swiper-slide-index');
          };
          s.fixLoop = function() {
            var newIndex;
            if (s.activeIndex < s.loopedSlides) {
              newIndex = s.slides.length - s.loopedSlides * 3 + s.activeIndex;
              newIndex = newIndex + s.loopedSlides;
              s.slideTo(newIndex, 0, false, true);
            } else if ((s.params.slidesPerView === 'auto' && s.activeIndex >= s.loopedSlides * 2) || (s.activeIndex > s.slides.length - s.params.slidesPerView * 2)) {
              newIndex = -s.slides.length + s.activeIndex + s.loopedSlides;
              newIndex = newIndex + s.loopedSlides;
              s.slideTo(newIndex, 0, false, true);
            }
          };
          s.appendSlide = function(slides) {
            if (s.params.loop) {
              s.destroyLoop();
            }
            if (typeof slides === 'object' && slides.length) {
              for (var i = 0; i < slides.length; i++) {
                if (slides[i])
                  s.wrapper.append(slides[i]);
              }
            } else {
              s.wrapper.append(slides);
            }
            if (s.params.loop) {
              s.createLoop();
            }
            if (!(s.params.observer && s.support.observer)) {
              s.update(true);
            }
          };
          s.prependSlide = function(slides) {
            if (s.params.loop) {
              s.destroyLoop();
            }
            var newActiveIndex = s.activeIndex + 1;
            if (typeof slides === 'object' && slides.length) {
              for (var i = 0; i < slides.length; i++) {
                if (slides[i])
                  s.wrapper.prepend(slides[i]);
              }
              newActiveIndex = s.activeIndex + slides.length;
            } else {
              s.wrapper.prepend(slides);
            }
            if (s.params.loop) {
              s.createLoop();
            }
            if (!(s.params.observer && s.support.observer)) {
              s.update(true);
            }
            s.slideTo(newActiveIndex, 0, false);
          };
          s.removeSlide = function(slidesIndexes) {
            if (s.params.loop) {
              s.destroyLoop();
              s.slides = s.wrapper.children('.' + s.params.slideClass);
            }
            var newActiveIndex = s.activeIndex,
                indexToRemove;
            if (typeof slidesIndexes === 'object' && slidesIndexes.length) {
              for (var i = 0; i < slidesIndexes.length; i++) {
                indexToRemove = slidesIndexes[i];
                if (s.slides[indexToRemove])
                  s.slides.eq(indexToRemove).remove();
                if (indexToRemove < newActiveIndex)
                  newActiveIndex--;
              }
              newActiveIndex = Math.max(newActiveIndex, 0);
            } else {
              indexToRemove = slidesIndexes;
              if (s.slides[indexToRemove])
                s.slides.eq(indexToRemove).remove();
              if (indexToRemove < newActiveIndex)
                newActiveIndex--;
              newActiveIndex = Math.max(newActiveIndex, 0);
            }
            if (s.params.loop) {
              s.createLoop();
            }
            if (!(s.params.observer && s.support.observer)) {
              s.update(true);
            }
            if (s.params.loop) {
              s.slideTo(newActiveIndex + s.loopedSlides, 0, false);
            } else {
              s.slideTo(newActiveIndex, 0, false);
            }
          };
          s.removeAllSlides = function() {
            var slidesIndexes = [];
            for (var i = 0; i < s.slides.length; i++) {
              slidesIndexes.push(i);
            }
            s.removeSlide(slidesIndexes);
          };
          s.effects = {
            fade: {
              setTranslate: function() {
                for (var i = 0; i < s.slides.length; i++) {
                  var slide = s.slides.eq(i);
                  var offset = slide[0].swiperSlideOffset;
                  var tx = -offset;
                  if (!s.params.virtualTranslate)
                    tx = tx - s.translate;
                  var ty = 0;
                  if (!isH()) {
                    ty = tx;
                    tx = 0;
                  }
                  var slideOpacity = s.params.fade.crossFade ? Math.max(1 - Math.abs(slide[0].progress), 0) : 1 + Math.min(Math.max(slide[0].progress, -1), 0);
                  slide.css({opacity: slideOpacity}).transform('translate3d(' + tx + 'px, ' + ty + 'px, 0px)');
                }
              },
              setTransition: function(duration) {
                s.slides.transition(duration);
                if (s.params.virtualTranslate && duration !== 0) {
                  var eventTriggered = false;
                  s.slides.transitionEnd(function() {
                    if (eventTriggered)
                      return;
                    if (!s)
                      return;
                    eventTriggered = true;
                    s.animating = false;
                    var triggerEvents = ['webkitTransitionEnd', 'transitionend', 'oTransitionEnd', 'MSTransitionEnd', 'msTransitionEnd'];
                    for (var i = 0; i < triggerEvents.length; i++) {
                      s.wrapper.trigger(triggerEvents[i]);
                    }
                  });
                }
              }
            },
            cube: {
              setTranslate: function() {
                var wrapperRotate = 0,
                    cubeShadow;
                if (s.params.cube.shadow) {
                  if (isH()) {
                    cubeShadow = s.wrapper.find('.swiper-cube-shadow');
                    if (cubeShadow.length === 0) {
                      cubeShadow = $('<div class="swiper-cube-shadow"></div>');
                      s.wrapper.append(cubeShadow);
                    }
                    cubeShadow.css({height: s.width + 'px'});
                  } else {
                    cubeShadow = s.container.find('.swiper-cube-shadow');
                    if (cubeShadow.length === 0) {
                      cubeShadow = $('<div class="swiper-cube-shadow"></div>');
                      s.container.append(cubeShadow);
                    }
                  }
                }
                for (var i = 0; i < s.slides.length; i++) {
                  var slide = s.slides.eq(i);
                  var slideAngle = i * 90;
                  var round = Math.floor(slideAngle / 360);
                  if (s.rtl) {
                    slideAngle = -slideAngle;
                    round = Math.floor(-slideAngle / 360);
                  }
                  var progress = Math.max(Math.min(slide[0].progress, 1), -1);
                  var tx = 0,
                      ty = 0,
                      tz = 0;
                  if (i % 4 === 0) {
                    tx = -round * 4 * s.size;
                    tz = 0;
                  } else if ((i - 1) % 4 === 0) {
                    tx = 0;
                    tz = -round * 4 * s.size;
                  } else if ((i - 2) % 4 === 0) {
                    tx = s.size + round * 4 * s.size;
                    tz = s.size;
                  } else if ((i - 3) % 4 === 0) {
                    tx = -s.size;
                    tz = 3 * s.size + s.size * 4 * round;
                  }
                  if (s.rtl) {
                    tx = -tx;
                  }
                  if (!isH()) {
                    ty = tx;
                    tx = 0;
                  }
                  var transform = 'rotateX(' + (isH() ? 0 : -slideAngle) + 'deg) rotateY(' + (isH() ? slideAngle : 0) + 'deg) translate3d(' + tx + 'px, ' + ty + 'px, ' + tz + 'px)';
                  if (progress <= 1 && progress > -1) {
                    wrapperRotate = i * 90 + progress * 90;
                    if (s.rtl)
                      wrapperRotate = -i * 90 - progress * 90;
                  }
                  slide.transform(transform);
                  if (s.params.cube.slideShadows) {
                    var shadowBefore = isH() ? slide.find('.swiper-slide-shadow-left') : slide.find('.swiper-slide-shadow-top');
                    var shadowAfter = isH() ? slide.find('.swiper-slide-shadow-right') : slide.find('.swiper-slide-shadow-bottom');
                    if (shadowBefore.length === 0) {
                      shadowBefore = $('<div class="swiper-slide-shadow-' + (isH() ? 'left' : 'top') + '"></div>');
                      slide.append(shadowBefore);
                    }
                    if (shadowAfter.length === 0) {
                      shadowAfter = $('<div class="swiper-slide-shadow-' + (isH() ? 'right' : 'bottom') + '"></div>');
                      slide.append(shadowAfter);
                    }
                    var shadowOpacity = slide[0].progress;
                    if (shadowBefore.length)
                      shadowBefore[0].style.opacity = -slide[0].progress;
                    if (shadowAfter.length)
                      shadowAfter[0].style.opacity = slide[0].progress;
                  }
                }
                s.wrapper.css({
                  '-webkit-transform-origin': '50% 50% -' + (s.size / 2) + 'px',
                  '-moz-transform-origin': '50% 50% -' + (s.size / 2) + 'px',
                  '-ms-transform-origin': '50% 50% -' + (s.size / 2) + 'px',
                  'transform-origin': '50% 50% -' + (s.size / 2) + 'px'
                });
                if (s.params.cube.shadow) {
                  if (isH()) {
                    cubeShadow.transform('translate3d(0px, ' + (s.width / 2 + s.params.cube.shadowOffset) + 'px, ' + (-s.width / 2) + 'px) rotateX(90deg) rotateZ(0deg) scale(' + (s.params.cube.shadowScale) + ')');
                  } else {
                    var shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
                    var multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
                    var scale1 = s.params.cube.shadowScale,
                        scale2 = s.params.cube.shadowScale / multiplier,
                        offset = s.params.cube.shadowOffset;
                    cubeShadow.transform('scale3d(' + scale1 + ', 1, ' + scale2 + ') translate3d(0px, ' + (s.height / 2 + offset) + 'px, ' + (-s.height / 2 / scale2) + 'px) rotateX(-90deg)');
                  }
                }
                var zFactor = (s.isSafari || s.isUiWebView) ? (-s.size / 2) : 0;
                s.wrapper.transform('translate3d(0px,0,' + zFactor + 'px) rotateX(' + (isH() ? 0 : wrapperRotate) + 'deg) rotateY(' + (isH() ? -wrapperRotate : 0) + 'deg)');
              },
              setTransition: function(duration) {
                s.slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
                if (s.params.cube.shadow && !isH()) {
                  s.container.find('.swiper-cube-shadow').transition(duration);
                }
              }
            },
            coverflow: {
              setTranslate: function() {
                var transform = s.translate;
                var center = isH() ? -transform + s.width / 2 : -transform + s.height / 2;
                var rotate = isH() ? s.params.coverflow.rotate : -s.params.coverflow.rotate;
                var translate = s.params.coverflow.depth;
                for (var i = 0,
                    length = s.slides.length; i < length; i++) {
                  var slide = s.slides.eq(i);
                  var slideSize = s.slidesSizesGrid[i];
                  var slideOffset = slide[0].swiperSlideOffset;
                  var offsetMultiplier = (center - slideOffset - slideSize / 2) / slideSize * s.params.coverflow.modifier;
                  var rotateY = isH() ? rotate * offsetMultiplier : 0;
                  var rotateX = isH() ? 0 : rotate * offsetMultiplier;
                  var translateZ = -translate * Math.abs(offsetMultiplier);
                  var translateY = isH() ? 0 : s.params.coverflow.stretch * (offsetMultiplier);
                  var translateX = isH() ? s.params.coverflow.stretch * (offsetMultiplier) : 0;
                  if (Math.abs(translateX) < 0.001)
                    translateX = 0;
                  if (Math.abs(translateY) < 0.001)
                    translateY = 0;
                  if (Math.abs(translateZ) < 0.001)
                    translateZ = 0;
                  if (Math.abs(rotateY) < 0.001)
                    rotateY = 0;
                  if (Math.abs(rotateX) < 0.001)
                    rotateX = 0;
                  var slideTransform = 'translate3d(' + translateX + 'px,' + translateY + 'px,' + translateZ + 'px)  rotateX(' + rotateX + 'deg) rotateY(' + rotateY + 'deg)';
                  slide.transform(slideTransform);
                  slide[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
                  if (s.params.coverflow.slideShadows) {
                    var shadowBefore = isH() ? slide.find('.swiper-slide-shadow-left') : slide.find('.swiper-slide-shadow-top');
                    var shadowAfter = isH() ? slide.find('.swiper-slide-shadow-right') : slide.find('.swiper-slide-shadow-bottom');
                    if (shadowBefore.length === 0) {
                      shadowBefore = $('<div class="swiper-slide-shadow-' + (isH() ? 'left' : 'top') + '"></div>');
                      slide.append(shadowBefore);
                    }
                    if (shadowAfter.length === 0) {
                      shadowAfter = $('<div class="swiper-slide-shadow-' + (isH() ? 'right' : 'bottom') + '"></div>');
                      slide.append(shadowAfter);
                    }
                    if (shadowBefore.length)
                      shadowBefore[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
                    if (shadowAfter.length)
                      shadowAfter[0].style.opacity = (-offsetMultiplier) > 0 ? -offsetMultiplier : 0;
                  }
                }
                if (s.browser.ie) {
                  var ws = s.wrapper[0].style;
                  ws.perspectiveOrigin = center + 'px 50%';
                }
              },
              setTransition: function(duration) {
                s.slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
              }
            }
          };
          s.lazy = {
            initialImageLoaded: false,
            loadImageInSlide: function(index, loadInDuplicate) {
              if (typeof index === 'undefined')
                return;
              if (typeof loadInDuplicate === 'undefined')
                loadInDuplicate = true;
              if (s.slides.length === 0)
                return;
              var slide = s.slides.eq(index);
              var img = slide.find('.swiper-lazy:not(.swiper-lazy-loaded):not(.swiper-lazy-loading)');
              if (slide.hasClass('swiper-lazy') && !slide.hasClass('swiper-lazy-loaded') && !slide.hasClass('swiper-lazy-loading')) {
                img = img.add(slide[0]);
              }
              if (img.length === 0)
                return;
              img.each(function() {
                var _img = $(this);
                _img.addClass('swiper-lazy-loading');
                var background = _img.attr('data-background');
                var src = _img.attr('data-src'),
                    srcset = _img.attr('data-srcset');
                s.loadImage(_img[0], (src || background), srcset, false, function() {
                  if (background) {
                    _img.css('background-image', 'url(' + background + ')');
                    _img.removeAttr('data-background');
                  } else {
                    if (srcset) {
                      _img.attr('srcset', srcset);
                      _img.removeAttr('data-srcset');
                    }
                    if (src) {
                      _img.attr('src', src);
                      _img.removeAttr('data-src');
                    }
                  }
                  _img.addClass('swiper-lazy-loaded').removeClass('swiper-lazy-loading');
                  slide.find('.swiper-lazy-preloader, .preloader').remove();
                  if (s.params.loop && loadInDuplicate) {
                    var slideOriginalIndex = slide.attr('data-swiper-slide-index');
                    if (slide.hasClass(s.params.slideDuplicateClass)) {
                      var originalSlide = s.wrapper.children('[data-swiper-slide-index="' + slideOriginalIndex + '"]:not(.' + s.params.slideDuplicateClass + ')');
                      s.lazy.loadImageInSlide(originalSlide.index(), false);
                    } else {
                      var duplicatedSlide = s.wrapper.children('.' + s.params.slideDuplicateClass + '[data-swiper-slide-index="' + slideOriginalIndex + '"]');
                      s.lazy.loadImageInSlide(duplicatedSlide.index(), false);
                    }
                  }
                  s.emit('onLazyImageReady', s, slide[0], _img[0]);
                });
                s.emit('onLazyImageLoad', s, slide[0], _img[0]);
              });
            },
            load: function() {
              var i;
              if (s.params.watchSlidesVisibility) {
                s.wrapper.children('.' + s.params.slideVisibleClass).each(function() {
                  s.lazy.loadImageInSlide($(this).index());
                });
              } else {
                if (s.params.slidesPerView > 1) {
                  for (i = s.activeIndex; i < s.activeIndex + s.params.slidesPerView; i++) {
                    if (s.slides[i])
                      s.lazy.loadImageInSlide(i);
                  }
                } else {
                  s.lazy.loadImageInSlide(s.activeIndex);
                }
              }
              if (s.params.lazyLoadingInPrevNext) {
                if (s.params.slidesPerView > 1) {
                  for (i = s.activeIndex + s.params.slidesPerView; i < s.activeIndex + s.params.slidesPerView + s.params.slidesPerView; i++) {
                    if (s.slides[i])
                      s.lazy.loadImageInSlide(i);
                  }
                  for (i = s.activeIndex - s.params.slidesPerView; i < s.activeIndex; i++) {
                    if (s.slides[i])
                      s.lazy.loadImageInSlide(i);
                  }
                } else {
                  var nextSlide = s.wrapper.children('.' + s.params.slideNextClass);
                  if (nextSlide.length > 0)
                    s.lazy.loadImageInSlide(nextSlide.index());
                  var prevSlide = s.wrapper.children('.' + s.params.slidePrevClass);
                  if (prevSlide.length > 0)
                    s.lazy.loadImageInSlide(prevSlide.index());
                }
              }
            },
            onTransitionStart: function() {
              if (s.params.lazyLoading) {
                if (s.params.lazyLoadingOnTransitionStart || (!s.params.lazyLoadingOnTransitionStart && !s.lazy.initialImageLoaded)) {
                  s.lazy.load();
                }
              }
            },
            onTransitionEnd: function() {
              if (s.params.lazyLoading && !s.params.lazyLoadingOnTransitionStart) {
                s.lazy.load();
              }
            }
          };
          s.scrollbar = {
            isTouched: false,
            setDragPosition: function(e) {
              var sb = s.scrollbar;
              var x = 0,
                  y = 0;
              var translate;
              var pointerPosition = isH() ? ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].pageX : e.pageX || e.clientX) : ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].pageY : e.pageY || e.clientY);
              var position = (pointerPosition) - sb.track.offset()[isH() ? 'left' : 'top'] - sb.dragSize / 2;
              var positionMin = -s.minTranslate() * sb.moveDivider;
              var positionMax = -s.maxTranslate() * sb.moveDivider;
              if (position < positionMin) {
                position = positionMin;
              } else if (position > positionMax) {
                position = positionMax;
              }
              position = -position / sb.moveDivider;
              s.updateProgress(position);
              s.setWrapperTranslate(position, true);
            },
            dragStart: function(e) {
              var sb = s.scrollbar;
              sb.isTouched = true;
              e.preventDefault();
              e.stopPropagation();
              sb.setDragPosition(e);
              clearTimeout(sb.dragTimeout);
              sb.track.transition(0);
              if (s.params.scrollbarHide) {
                sb.track.css('opacity', 1);
              }
              s.wrapper.transition(100);
              sb.drag.transition(100);
              s.emit('onScrollbarDragStart', s);
            },
            dragMove: function(e) {
              var sb = s.scrollbar;
              if (!sb.isTouched)
                return;
              if (e.preventDefault)
                e.preventDefault();
              else
                e.returnValue = false;
              sb.setDragPosition(e);
              s.wrapper.transition(0);
              sb.track.transition(0);
              sb.drag.transition(0);
              s.emit('onScrollbarDragMove', s);
            },
            dragEnd: function(e) {
              var sb = s.scrollbar;
              if (!sb.isTouched)
                return;
              sb.isTouched = false;
              if (s.params.scrollbarHide) {
                clearTimeout(sb.dragTimeout);
                sb.dragTimeout = setTimeout(function() {
                  sb.track.css('opacity', 0);
                  sb.track.transition(400);
                }, 1000);
              }
              s.emit('onScrollbarDragEnd', s);
              if (s.params.scrollbarSnapOnRelease) {
                s.slideReset();
              }
            },
            enableDraggable: function() {
              var sb = s.scrollbar;
              var target = s.support.touch ? sb.track : document;
              $(sb.track).on(s.touchEvents.start, sb.dragStart);
              $(target).on(s.touchEvents.move, sb.dragMove);
              $(target).on(s.touchEvents.end, sb.dragEnd);
            },
            disableDraggable: function() {
              var sb = s.scrollbar;
              var target = s.support.touch ? sb.track : document;
              $(sb.track).off(s.touchEvents.start, sb.dragStart);
              $(target).off(s.touchEvents.move, sb.dragMove);
              $(target).off(s.touchEvents.end, sb.dragEnd);
            },
            set: function() {
              if (!s.params.scrollbar)
                return;
              var sb = s.scrollbar;
              sb.track = $(s.params.scrollbar);
              sb.drag = sb.track.find('.swiper-scrollbar-drag');
              if (sb.drag.length === 0) {
                sb.drag = $('<div class="swiper-scrollbar-drag"></div>');
                sb.track.append(sb.drag);
              }
              sb.drag[0].style.width = '';
              sb.drag[0].style.height = '';
              sb.trackSize = isH() ? sb.track[0].offsetWidth : sb.track[0].offsetHeight;
              sb.divider = s.size / s.virtualSize;
              sb.moveDivider = sb.divider * (sb.trackSize / s.size);
              sb.dragSize = sb.trackSize * sb.divider;
              if (isH()) {
                sb.drag[0].style.width = sb.dragSize + 'px';
              } else {
                sb.drag[0].style.height = sb.dragSize + 'px';
              }
              if (sb.divider >= 1) {
                sb.track[0].style.display = 'none';
              } else {
                sb.track[0].style.display = '';
              }
              if (s.params.scrollbarHide) {
                sb.track[0].style.opacity = 0;
              }
            },
            setTranslate: function() {
              if (!s.params.scrollbar)
                return;
              var diff;
              var sb = s.scrollbar;
              var translate = s.translate || 0;
              var newPos;
              var newSize = sb.dragSize;
              newPos = (sb.trackSize - sb.dragSize) * s.progress;
              if (s.rtl && isH()) {
                newPos = -newPos;
                if (newPos > 0) {
                  newSize = sb.dragSize - newPos;
                  newPos = 0;
                } else if (-newPos + sb.dragSize > sb.trackSize) {
                  newSize = sb.trackSize + newPos;
                }
              } else {
                if (newPos < 0) {
                  newSize = sb.dragSize + newPos;
                  newPos = 0;
                } else if (newPos + sb.dragSize > sb.trackSize) {
                  newSize = sb.trackSize - newPos;
                }
              }
              if (isH()) {
                if (s.support.transforms3d) {
                  sb.drag.transform('translate3d(' + (newPos) + 'px, 0, 0)');
                } else {
                  sb.drag.transform('translateX(' + (newPos) + 'px)');
                }
                sb.drag[0].style.width = newSize + 'px';
              } else {
                if (s.support.transforms3d) {
                  sb.drag.transform('translate3d(0px, ' + (newPos) + 'px, 0)');
                } else {
                  sb.drag.transform('translateY(' + (newPos) + 'px)');
                }
                sb.drag[0].style.height = newSize + 'px';
              }
              if (s.params.scrollbarHide) {
                clearTimeout(sb.timeout);
                sb.track[0].style.opacity = 1;
                sb.timeout = setTimeout(function() {
                  sb.track[0].style.opacity = 0;
                  sb.track.transition(400);
                }, 1000);
              }
            },
            setTransition: function(duration) {
              if (!s.params.scrollbar)
                return;
              s.scrollbar.drag.transition(duration);
            }
          };
          s.controller = {
            LinearSpline: function(x, y) {
              this.x = x;
              this.y = y;
              this.lastIndex = x.length - 1;
              var i1,
                  i3;
              var l = this.x.length;
              this.interpolate = function(x2) {
                if (!x2)
                  return 0;
                i3 = binarySearch(this.x, x2);
                i1 = i3 - 1;
                return ((x2 - this.x[i1]) * (this.y[i3] - this.y[i1])) / (this.x[i3] - this.x[i1]) + this.y[i1];
              };
              var binarySearch = (function() {
                var maxIndex,
                    minIndex,
                    guess;
                return function(array, val) {
                  minIndex = -1;
                  maxIndex = array.length;
                  while (maxIndex - minIndex > 1)
                    if (array[guess = maxIndex + minIndex >> 1] <= val) {
                      minIndex = guess;
                    } else {
                      maxIndex = guess;
                    }
                  return maxIndex;
                };
              })();
            },
            getInterpolateFunction: function(c) {
              if (!s.controller.spline)
                s.controller.spline = s.params.loop ? new s.controller.LinearSpline(s.slidesGrid, c.slidesGrid) : new s.controller.LinearSpline(s.snapGrid, c.snapGrid);
            },
            setTranslate: function(translate, byController) {
              var controlled = s.params.control;
              var multiplier,
                  controlledTranslate;
              function setControlledTranslate(c) {
                translate = c.rtl && c.params.direction === 'horizontal' ? -s.translate : s.translate;
                if (s.params.controlBy === 'slide') {
                  s.controller.getInterpolateFunction(c);
                  controlledTranslate = -s.controller.spline.interpolate(-translate);
                }
                if (!controlledTranslate || s.params.controlBy === 'container') {
                  multiplier = (c.maxTranslate() - c.minTranslate()) / (s.maxTranslate() - s.minTranslate());
                  controlledTranslate = (translate - s.minTranslate()) * multiplier + c.minTranslate();
                }
                if (s.params.controlInverse) {
                  controlledTranslate = c.maxTranslate() - controlledTranslate;
                }
                c.updateProgress(controlledTranslate);
                c.setWrapperTranslate(controlledTranslate, false, s);
                c.updateActiveIndex();
              }
              if (s.isArray(controlled)) {
                for (var i = 0; i < controlled.length; i++) {
                  if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
                    setControlledTranslate(controlled[i]);
                  }
                }
              } else if (controlled instanceof Swiper && byController !== controlled) {
                setControlledTranslate(controlled);
              }
            },
            setTransition: function(duration, byController) {
              var controlled = s.params.control;
              var i;
              function setControlledTransition(c) {
                c.setWrapperTransition(duration, s);
                if (duration !== 0) {
                  c.onTransitionStart();
                  c.wrapper.transitionEnd(function() {
                    if (!controlled)
                      return;
                    if (c.params.loop && s.params.controlBy === 'slide') {
                      c.fixLoop();
                    }
                    c.onTransitionEnd();
                  });
                }
              }
              if (s.isArray(controlled)) {
                for (i = 0; i < controlled.length; i++) {
                  if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
                    setControlledTransition(controlled[i]);
                  }
                }
              } else if (controlled instanceof Swiper && byController !== controlled) {
                setControlledTransition(controlled);
              }
            }
          };
          s.hashnav = {
            init: function() {
              if (!s.params.hashnav)
                return;
              s.hashnav.initialized = true;
              var hash = document.location.hash.replace('#', '');
              if (!hash)
                return;
              var speed = 0;
              for (var i = 0,
                  length = s.slides.length; i < length; i++) {
                var slide = s.slides.eq(i);
                var slideHash = slide.attr('data-hash');
                if (slideHash === hash && !slide.hasClass(s.params.slideDuplicateClass)) {
                  var index = slide.index();
                  s.slideTo(index, speed, s.params.runCallbacksOnInit, true);
                }
              }
            },
            setHash: function() {
              if (!s.hashnav.initialized || !s.params.hashnav)
                return;
              document.location.hash = s.slides.eq(s.activeIndex).attr('data-hash') || '';
            }
          };
          function handleKeyboard(e) {
            if (e.originalEvent)
              e = e.originalEvent;
            var kc = e.keyCode || e.charCode;
            if (!s.params.allowSwipeToNext && (isH() && kc === 39 || !isH() && kc === 40)) {
              return false;
            }
            if (!s.params.allowSwipeToPrev && (isH() && kc === 37 || !isH() && kc === 38)) {
              return false;
            }
            if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
              return;
            }
            if (document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea')) {
              return;
            }
            if (kc === 37 || kc === 39 || kc === 38 || kc === 40) {
              var inView = false;
              if (s.container.parents('.swiper-slide').length > 0 && s.container.parents('.swiper-slide-active').length === 0) {
                return;
              }
              var windowScroll = {
                left: window.pageXOffset,
                top: window.pageYOffset
              };
              var windowWidth = window.innerWidth;
              var windowHeight = window.innerHeight;
              var swiperOffset = s.container.offset();
              if (s.rtl)
                swiperOffset.left = swiperOffset.left - s.container[0].scrollLeft;
              var swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + s.width, swiperOffset.top], [swiperOffset.left, swiperOffset.top + s.height], [swiperOffset.left + s.width, swiperOffset.top + s.height]];
              for (var i = 0; i < swiperCoord.length; i++) {
                var point = swiperCoord[i];
                if (point[0] >= windowScroll.left && point[0] <= windowScroll.left + windowWidth && point[1] >= windowScroll.top && point[1] <= windowScroll.top + windowHeight) {
                  inView = true;
                }
              }
              if (!inView)
                return;
            }
            if (isH()) {
              if (kc === 37 || kc === 39) {
                if (e.preventDefault)
                  e.preventDefault();
                else
                  e.returnValue = false;
              }
              if ((kc === 39 && !s.rtl) || (kc === 37 && s.rtl))
                s.slideNext();
              if ((kc === 37 && !s.rtl) || (kc === 39 && s.rtl))
                s.slidePrev();
            } else {
              if (kc === 38 || kc === 40) {
                if (e.preventDefault)
                  e.preventDefault();
                else
                  e.returnValue = false;
              }
              if (kc === 40)
                s.slideNext();
              if (kc === 38)
                s.slidePrev();
            }
          }
          s.disableKeyboardControl = function() {
            s.params.keyboardControl = false;
            $(document).off('keydown', handleKeyboard);
          };
          s.enableKeyboardControl = function() {
            s.params.keyboardControl = true;
            $(document).on('keydown', handleKeyboard);
          };
          s.mousewheel = {
            event: false,
            lastScrollTime: (new window.Date()).getTime()
          };
          if (s.params.mousewheelControl) {
            try {
              new window.WheelEvent('wheel');
              s.mousewheel.event = 'wheel';
            } catch (e) {}
            if (!s.mousewheel.event && document.onmousewheel !== undefined) {
              s.mousewheel.event = 'mousewheel';
            }
            if (!s.mousewheel.event) {
              s.mousewheel.event = 'DOMMouseScroll';
            }
          }
          function handleMousewheel(e) {
            if (e.originalEvent)
              e = e.originalEvent;
            var we = s.mousewheel.event;
            var delta = 0;
            var rtlFactor = s.rtl ? -1 : 1;
            if (e.detail)
              delta = -e.detail;
            else if (we === 'mousewheel') {
              if (s.params.mousewheelForceToAxis) {
                if (isH()) {
                  if (Math.abs(e.wheelDeltaX) > Math.abs(e.wheelDeltaY))
                    delta = e.wheelDeltaX * rtlFactor;
                  else
                    return;
                } else {
                  if (Math.abs(e.wheelDeltaY) > Math.abs(e.wheelDeltaX))
                    delta = e.wheelDeltaY;
                  else
                    return;
                }
              } else {
                delta = Math.abs(e.wheelDeltaX) > Math.abs(e.wheelDeltaY) ? -e.wheelDeltaX * rtlFactor : -e.wheelDeltaY;
              }
            } else if (we === 'DOMMouseScroll')
              delta = -e.detail;
            else if (we === 'wheel') {
              if (s.params.mousewheelForceToAxis) {
                if (isH()) {
                  if (Math.abs(e.deltaX) > Math.abs(e.deltaY))
                    delta = -e.deltaX * rtlFactor;
                  else
                    return;
                } else {
                  if (Math.abs(e.deltaY) > Math.abs(e.deltaX))
                    delta = -e.deltaY;
                  else
                    return;
                }
              } else {
                delta = Math.abs(e.deltaX) > Math.abs(e.deltaY) ? -e.deltaX * rtlFactor : -e.deltaY;
              }
            }
            if (delta === 0)
              return;
            if (s.params.mousewheelInvert)
              delta = -delta;
            if (!s.params.freeMode) {
              if ((new window.Date()).getTime() - s.mousewheel.lastScrollTime > 60) {
                if (delta < 0) {
                  if ((!s.isEnd || s.params.loop) && !s.animating)
                    s.slideNext();
                  else if (s.params.mousewheelReleaseOnEdges)
                    return true;
                } else {
                  if ((!s.isBeginning || s.params.loop) && !s.animating)
                    s.slidePrev();
                  else if (s.params.mousewheelReleaseOnEdges)
                    return true;
                }
              }
              s.mousewheel.lastScrollTime = (new window.Date()).getTime();
            } else {
              var position = s.getWrapperTranslate() + delta * s.params.mousewheelSensitivity;
              var wasBeginning = s.isBeginning,
                  wasEnd = s.isEnd;
              if (position >= s.minTranslate())
                position = s.minTranslate();
              if (position <= s.maxTranslate())
                position = s.maxTranslate();
              s.setWrapperTransition(0);
              s.setWrapperTranslate(position);
              s.updateProgress();
              s.updateActiveIndex();
              if (!wasBeginning && s.isBeginning || !wasEnd && s.isEnd) {
                s.updateClasses();
              }
              if (s.params.freeModeSticky) {
                clearTimeout(s.mousewheel.timeout);
                s.mousewheel.timeout = setTimeout(function() {
                  s.slideReset();
                }, 300);
              }
              if (position === 0 || position === s.maxTranslate())
                return;
            }
            if (s.params.autoplay)
              s.stopAutoplay();
            if (e.preventDefault)
              e.preventDefault();
            else
              e.returnValue = false;
            return false;
          }
          s.disableMousewheelControl = function() {
            if (!s.mousewheel.event)
              return false;
            s.container.off(s.mousewheel.event, handleMousewheel);
            return true;
          };
          s.enableMousewheelControl = function() {
            if (!s.mousewheel.event)
              return false;
            s.container.on(s.mousewheel.event, handleMousewheel);
            return true;
          };
          function setParallaxTransform(el, progress) {
            el = $(el);
            var p,
                pX,
                pY;
            var rtlFactor = s.rtl ? -1 : 1;
            p = el.attr('data-swiper-parallax') || '0';
            pX = el.attr('data-swiper-parallax-x');
            pY = el.attr('data-swiper-parallax-y');
            if (pX || pY) {
              pX = pX || '0';
              pY = pY || '0';
            } else {
              if (isH()) {
                pX = p;
                pY = '0';
              } else {
                pY = p;
                pX = '0';
              }
            }
            if ((pX).indexOf('%') >= 0) {
              pX = parseInt(pX, 10) * progress * rtlFactor + '%';
            } else {
              pX = pX * progress * rtlFactor + 'px';
            }
            if ((pY).indexOf('%') >= 0) {
              pY = parseInt(pY, 10) * progress + '%';
            } else {
              pY = pY * progress + 'px';
            }
            el.transform('translate3d(' + pX + ', ' + pY + ',0px)');
          }
          s.parallax = {
            setTranslate: function() {
              s.container.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function() {
                setParallaxTransform(this, s.progress);
              });
              s.slides.each(function() {
                var slide = $(this);
                slide.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function() {
                  var progress = Math.min(Math.max(slide[0].progress, -1), 1);
                  setParallaxTransform(this, progress);
                });
              });
            },
            setTransition: function(duration) {
              if (typeof duration === 'undefined')
                duration = s.params.speed;
              s.container.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function() {
                var el = $(this);
                var parallaxDuration = parseInt(el.attr('data-swiper-parallax-duration'), 10) || duration;
                if (duration === 0)
                  parallaxDuration = 0;
                el.transition(parallaxDuration);
              });
            }
          };
          s._plugins = [];
          for (var plugin in s.plugins) {
            var p = s.plugins[plugin](s, s.params[plugin]);
            if (p)
              s._plugins.push(p);
          }
          s.callPlugins = function(eventName) {
            for (var i = 0; i < s._plugins.length; i++) {
              if (eventName in s._plugins[i]) {
                s._plugins[i][eventName](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
              }
            }
          };
          function normalizeEventName(eventName) {
            if (eventName.indexOf('on') !== 0) {
              if (eventName[0] !== eventName[0].toUpperCase()) {
                eventName = 'on' + eventName[0].toUpperCase() + eventName.substring(1);
              } else {
                eventName = 'on' + eventName;
              }
            }
            return eventName;
          }
          s.emitterEventListeners = {};
          s.emit = function(eventName) {
            if (s.params[eventName]) {
              s.params[eventName](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
            }
            var i;
            if (s.emitterEventListeners[eventName]) {
              for (i = 0; i < s.emitterEventListeners[eventName].length; i++) {
                s.emitterEventListeners[eventName][i](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
              }
            }
            if (s.callPlugins)
              s.callPlugins(eventName, arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
          };
          s.on = function(eventName, handler) {
            eventName = normalizeEventName(eventName);
            if (!s.emitterEventListeners[eventName])
              s.emitterEventListeners[eventName] = [];
            s.emitterEventListeners[eventName].push(handler);
            return s;
          };
          s.off = function(eventName, handler) {
            var i;
            eventName = normalizeEventName(eventName);
            if (typeof handler === 'undefined') {
              s.emitterEventListeners[eventName] = [];
              return s;
            }
            if (!s.emitterEventListeners[eventName] || s.emitterEventListeners[eventName].length === 0)
              return;
            for (i = 0; i < s.emitterEventListeners[eventName].length; i++) {
              if (s.emitterEventListeners[eventName][i] === handler)
                s.emitterEventListeners[eventName].splice(i, 1);
            }
            return s;
          };
          s.once = function(eventName, handler) {
            eventName = normalizeEventName(eventName);
            var _handler = function() {
              handler(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]);
              s.off(eventName, _handler);
            };
            s.on(eventName, _handler);
            return s;
          };
          s.a11y = {
            makeFocusable: function($el) {
              $el.attr('tabIndex', '0');
              return $el;
            },
            addRole: function($el, role) {
              $el.attr('role', role);
              return $el;
            },
            addLabel: function($el, label) {
              $el.attr('aria-label', label);
              return $el;
            },
            disable: function($el) {
              $el.attr('aria-disabled', true);
              return $el;
            },
            enable: function($el) {
              $el.attr('aria-disabled', false);
              return $el;
            },
            onEnterKey: function(event) {
              if (event.keyCode !== 13)
                return;
              if ($(event.target).is(s.params.nextButton)) {
                s.onClickNext(event);
                if (s.isEnd) {
                  s.a11y.notify(s.params.lastSlideMessage);
                } else {
                  s.a11y.notify(s.params.nextSlideMessage);
                }
              } else if ($(event.target).is(s.params.prevButton)) {
                s.onClickPrev(event);
                if (s.isBeginning) {
                  s.a11y.notify(s.params.firstSlideMessage);
                } else {
                  s.a11y.notify(s.params.prevSlideMessage);
                }
              }
              if ($(event.target).is('.' + s.params.bulletClass)) {
                $(event.target)[0].click();
              }
            },
            liveRegion: $('<span class="swiper-notification" aria-live="assertive" aria-atomic="true"></span>'),
            notify: function(message) {
              var notification = s.a11y.liveRegion;
              if (notification.length === 0)
                return;
              notification.html('');
              notification.html(message);
            },
            init: function() {
              if (s.params.nextButton) {
                var nextButton = $(s.params.nextButton);
                s.a11y.makeFocusable(nextButton);
                s.a11y.addRole(nextButton, 'button');
                s.a11y.addLabel(nextButton, s.params.nextSlideMessage);
              }
              if (s.params.prevButton) {
                var prevButton = $(s.params.prevButton);
                s.a11y.makeFocusable(prevButton);
                s.a11y.addRole(prevButton, 'button');
                s.a11y.addLabel(prevButton, s.params.prevSlideMessage);
              }
              $(s.container).append(s.a11y.liveRegion);
            },
            initPagination: function() {
              if (s.params.pagination && s.params.paginationClickable && s.bullets && s.bullets.length) {
                s.bullets.each(function() {
                  var bullet = $(this);
                  s.a11y.makeFocusable(bullet);
                  s.a11y.addRole(bullet, 'button');
                  s.a11y.addLabel(bullet, s.params.paginationBulletMessage.replace(/{{index}}/, bullet.index() + 1));
                });
              }
            },
            destroy: function() {
              if (s.a11y.liveRegion && s.a11y.liveRegion.length > 0)
                s.a11y.liveRegion.remove();
            }
          };
          s.init = function() {
            if (s.params.loop)
              s.createLoop();
            s.updateContainerSize();
            s.updateSlidesSize();
            s.updatePagination();
            if (s.params.scrollbar && s.scrollbar) {
              s.scrollbar.set();
              if (s.params.scrollbarDraggable) {
                s.scrollbar.enableDraggable();
              }
            }
            if (s.params.effect !== 'slide' && s.effects[s.params.effect]) {
              if (!s.params.loop)
                s.updateProgress();
              s.effects[s.params.effect].setTranslate();
            }
            if (s.params.loop) {
              s.slideTo(s.params.initialSlide + s.loopedSlides, 0, s.params.runCallbacksOnInit);
            } else {
              s.slideTo(s.params.initialSlide, 0, s.params.runCallbacksOnInit);
              if (s.params.initialSlide === 0) {
                if (s.parallax && s.params.parallax)
                  s.parallax.setTranslate();
                if (s.lazy && s.params.lazyLoading) {
                  s.lazy.load();
                  s.lazy.initialImageLoaded = true;
                }
              }
            }
            s.attachEvents();
            if (s.params.observer && s.support.observer) {
              s.initObservers();
            }
            if (s.params.preloadImages && !s.params.lazyLoading) {
              s.preloadImages();
            }
            if (s.params.autoplay) {
              s.startAutoplay();
            }
            if (s.params.keyboardControl) {
              if (s.enableKeyboardControl)
                s.enableKeyboardControl();
            }
            if (s.params.mousewheelControl) {
              if (s.enableMousewheelControl)
                s.enableMousewheelControl();
            }
            if (s.params.hashnav) {
              if (s.hashnav)
                s.hashnav.init();
            }
            if (s.params.a11y && s.a11y)
              s.a11y.init();
            s.emit('onInit', s);
          };
          s.cleanupStyles = function() {
            s.container.removeClass(s.classNames.join(' ')).removeAttr('style');
            s.wrapper.removeAttr('style');
            if (s.slides && s.slides.length) {
              s.slides.removeClass([s.params.slideVisibleClass, s.params.slideActiveClass, s.params.slideNextClass, s.params.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-column').removeAttr('data-swiper-row');
            }
            if (s.paginationContainer && s.paginationContainer.length) {
              s.paginationContainer.removeClass(s.params.paginationHiddenClass);
            }
            if (s.bullets && s.bullets.length) {
              s.bullets.removeClass(s.params.bulletActiveClass);
            }
            if (s.params.prevButton)
              $(s.params.prevButton).removeClass(s.params.buttonDisabledClass);
            if (s.params.nextButton)
              $(s.params.nextButton).removeClass(s.params.buttonDisabledClass);
            if (s.params.scrollbar && s.scrollbar) {
              if (s.scrollbar.track && s.scrollbar.track.length)
                s.scrollbar.track.removeAttr('style');
              if (s.scrollbar.drag && s.scrollbar.drag.length)
                s.scrollbar.drag.removeAttr('style');
            }
          };
          s.destroy = function(deleteInstance, cleanupStyles) {
            s.detachEvents();
            s.stopAutoplay();
            if (s.params.scrollbar && s.scrollbar) {
              if (s.params.scrollbarDraggable) {
                s.scrollbar.disableDraggable();
              }
            }
            if (s.params.loop) {
              s.destroyLoop();
            }
            if (cleanupStyles) {
              s.cleanupStyles();
            }
            s.disconnectObservers();
            if (s.params.keyboardControl) {
              if (s.disableKeyboardControl)
                s.disableKeyboardControl();
            }
            if (s.params.mousewheelControl) {
              if (s.disableMousewheelControl)
                s.disableMousewheelControl();
            }
            if (s.params.a11y && s.a11y)
              s.a11y.destroy();
            s.emit('onDestroy');
            if (deleteInstance !== false)
              s = null;
          };
          s.init();
          return s;
        };
        Swiper.prototype = {
          isSafari: (function() {
            var ua = navigator.userAgent.toLowerCase();
            return (ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0);
          })(),
          isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(navigator.userAgent),
          isArray: function(arr) {
            return Object.prototype.toString.apply(arr) === '[object Array]';
          },
          browser: {
            ie: window.navigator.pointerEnabled || window.navigator.msPointerEnabled,
            ieTouch: (window.navigator.msPointerEnabled && window.navigator.msMaxTouchPoints > 1) || (window.navigator.pointerEnabled && window.navigator.maxTouchPoints > 1)
          },
          device: (function() {
            var ua = navigator.userAgent;
            var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
            var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
            var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
            var iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);
            return {
              ios: ipad || iphone || ipod,
              android: android
            };
          })(),
          support: {
            touch: (window.Modernizr && Modernizr.touch === true) || (function() {
              return !!(('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch);
            })(),
            transforms3d: (window.Modernizr && Modernizr.csstransforms3d === true) || (function() {
              var div = document.createElement('div').style;
              return ('webkitPerspective' in div || 'MozPerspective' in div || 'OPerspective' in div || 'MsPerspective' in div || 'perspective' in div);
            })(),
            flexbox: (function() {
              var div = document.createElement('div').style;
              var styles = ('alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient').split(' ');
              for (var i = 0; i < styles.length; i++) {
                if (styles[i] in div)
                  return true;
              }
            })(),
            observer: (function() {
              return ('MutationObserver' in window || 'WebkitMutationObserver' in window);
            })()
          },
          plugins: {}
        };
        var Dom7 = (function() {
          var Dom7 = function(arr) {
            var _this = this,
                i = 0;
            for (i = 0; i < arr.length; i++) {
              _this[i] = arr[i];
            }
            _this.length = arr.length;
            return this;
          };
          var $ = function(selector, context) {
            var arr = [],
                i = 0;
            if (selector && !context) {
              if (selector instanceof Dom7) {
                return selector;
              }
            }
            if (selector) {
              if (typeof selector === 'string') {
                var els,
                    tempParent,
                    html = selector.trim();
                if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
                  var toCreate = 'div';
                  if (html.indexOf('<li') === 0)
                    toCreate = 'ul';
                  if (html.indexOf('<tr') === 0)
                    toCreate = 'tbody';
                  if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0)
                    toCreate = 'tr';
                  if (html.indexOf('<tbody') === 0)
                    toCreate = 'table';
                  if (html.indexOf('<option') === 0)
                    toCreate = 'select';
                  tempParent = document.createElement(toCreate);
                  tempParent.innerHTML = selector;
                  for (i = 0; i < tempParent.childNodes.length; i++) {
                    arr.push(tempParent.childNodes[i]);
                  }
                } else {
                  if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {
                    els = [document.getElementById(selector.split('#')[1])];
                  } else {
                    els = (context || document).querySelectorAll(selector);
                  }
                  for (i = 0; i < els.length; i++) {
                    if (els[i])
                      arr.push(els[i]);
                  }
                }
              } else if (selector.nodeType || selector === window || selector === document) {
                arr.push(selector);
              } else if (selector.length > 0 && selector[0].nodeType) {
                for (i = 0; i < selector.length; i++) {
                  arr.push(selector[i]);
                }
              }
            }
            return new Dom7(arr);
          };
          Dom7.prototype = {
            addClass: function(className) {
              if (typeof className === 'undefined') {
                return this;
              }
              var classes = className.split(' ');
              for (var i = 0; i < classes.length; i++) {
                for (var j = 0; j < this.length; j++) {
                  this[j].classList.add(classes[i]);
                }
              }
              return this;
            },
            removeClass: function(className) {
              var classes = className.split(' ');
              for (var i = 0; i < classes.length; i++) {
                for (var j = 0; j < this.length; j++) {
                  this[j].classList.remove(classes[i]);
                }
              }
              return this;
            },
            hasClass: function(className) {
              if (!this[0])
                return false;
              else
                return this[0].classList.contains(className);
            },
            toggleClass: function(className) {
              var classes = className.split(' ');
              for (var i = 0; i < classes.length; i++) {
                for (var j = 0; j < this.length; j++) {
                  this[j].classList.toggle(classes[i]);
                }
              }
              return this;
            },
            attr: function(attrs, value) {
              if (arguments.length === 1 && typeof attrs === 'string') {
                if (this[0])
                  return this[0].getAttribute(attrs);
                else
                  return undefined;
              } else {
                for (var i = 0; i < this.length; i++) {
                  if (arguments.length === 2) {
                    this[i].setAttribute(attrs, value);
                  } else {
                    for (var attrName in attrs) {
                      this[i][attrName] = attrs[attrName];
                      this[i].setAttribute(attrName, attrs[attrName]);
                    }
                  }
                }
                return this;
              }
            },
            removeAttr: function(attr) {
              for (var i = 0; i < this.length; i++) {
                this[i].removeAttribute(attr);
              }
              return this;
            },
            data: function(key, value) {
              if (typeof value === 'undefined') {
                if (this[0]) {
                  var dataKey = this[0].getAttribute('data-' + key);
                  if (dataKey)
                    return dataKey;
                  else if (this[0].dom7ElementDataStorage && (key in this[0].dom7ElementDataStorage))
                    return this[0].dom7ElementDataStorage[key];
                  else
                    return undefined;
                } else
                  return undefined;
              } else {
                for (var i = 0; i < this.length; i++) {
                  var el = this[i];
                  if (!el.dom7ElementDataStorage)
                    el.dom7ElementDataStorage = {};
                  el.dom7ElementDataStorage[key] = value;
                }
                return this;
              }
            },
            transform: function(transform) {
              for (var i = 0; i < this.length; i++) {
                var elStyle = this[i].style;
                elStyle.webkitTransform = elStyle.MsTransform = elStyle.msTransform = elStyle.MozTransform = elStyle.OTransform = elStyle.transform = transform;
              }
              return this;
            },
            transition: function(duration) {
              if (typeof duration !== 'string') {
                duration = duration + 'ms';
              }
              for (var i = 0; i < this.length; i++) {
                var elStyle = this[i].style;
                elStyle.webkitTransitionDuration = elStyle.MsTransitionDuration = elStyle.msTransitionDuration = elStyle.MozTransitionDuration = elStyle.OTransitionDuration = elStyle.transitionDuration = duration;
              }
              return this;
            },
            on: function(eventName, targetSelector, listener, capture) {
              function handleLiveEvent(e) {
                var target = e.target;
                if ($(target).is(targetSelector))
                  listener.call(target, e);
                else {
                  var parents = $(target).parents();
                  for (var k = 0; k < parents.length; k++) {
                    if ($(parents[k]).is(targetSelector))
                      listener.call(parents[k], e);
                  }
                }
              }
              var events = eventName.split(' ');
              var i,
                  j;
              for (i = 0; i < this.length; i++) {
                if (typeof targetSelector === 'function' || targetSelector === false) {
                  if (typeof targetSelector === 'function') {
                    listener = arguments[1];
                    capture = arguments[2] || false;
                  }
                  for (j = 0; j < events.length; j++) {
                    this[i].addEventListener(events[j], listener, capture);
                  }
                } else {
                  for (j = 0; j < events.length; j++) {
                    if (!this[i].dom7LiveListeners)
                      this[i].dom7LiveListeners = [];
                    this[i].dom7LiveListeners.push({
                      listener: listener,
                      liveListener: handleLiveEvent
                    });
                    this[i].addEventListener(events[j], handleLiveEvent, capture);
                  }
                }
              }
              return this;
            },
            off: function(eventName, targetSelector, listener, capture) {
              var events = eventName.split(' ');
              for (var i = 0; i < events.length; i++) {
                for (var j = 0; j < this.length; j++) {
                  if (typeof targetSelector === 'function' || targetSelector === false) {
                    if (typeof targetSelector === 'function') {
                      listener = arguments[1];
                      capture = arguments[2] || false;
                    }
                    this[j].removeEventListener(events[i], listener, capture);
                  } else {
                    if (this[j].dom7LiveListeners) {
                      for (var k = 0; k < this[j].dom7LiveListeners.length; k++) {
                        if (this[j].dom7LiveListeners[k].listener === listener) {
                          this[j].removeEventListener(events[i], this[j].dom7LiveListeners[k].liveListener, capture);
                        }
                      }
                    }
                  }
                }
              }
              return this;
            },
            once: function(eventName, targetSelector, listener, capture) {
              var dom = this;
              if (typeof targetSelector === 'function') {
                targetSelector = false;
                listener = arguments[1];
                capture = arguments[2];
              }
              function proxy(e) {
                listener(e);
                dom.off(eventName, targetSelector, proxy, capture);
              }
              dom.on(eventName, targetSelector, proxy, capture);
            },
            trigger: function(eventName, eventData) {
              for (var i = 0; i < this.length; i++) {
                var evt;
                try {
                  evt = new window.CustomEvent(eventName, {
                    detail: eventData,
                    bubbles: true,
                    cancelable: true
                  });
                } catch (e) {
                  evt = document.createEvent('Event');
                  evt.initEvent(eventName, true, true);
                  evt.detail = eventData;
                }
                this[i].dispatchEvent(evt);
              }
              return this;
            },
            transitionEnd: function(callback) {
              var events = ['webkitTransitionEnd', 'transitionend', 'oTransitionEnd', 'MSTransitionEnd', 'msTransitionEnd'],
                  i,
                  j,
                  dom = this;
              function fireCallBack(e) {
                if (e.target !== this)
                  return;
                callback.call(this, e);
                for (i = 0; i < events.length; i++) {
                  dom.off(events[i], fireCallBack);
                }
              }
              if (callback) {
                for (i = 0; i < events.length; i++) {
                  dom.on(events[i], fireCallBack);
                }
              }
              return this;
            },
            width: function() {
              if (this[0] === window) {
                return window.innerWidth;
              } else {
                if (this.length > 0) {
                  return parseFloat(this.css('width'));
                } else {
                  return null;
                }
              }
            },
            outerWidth: function(includeMargins) {
              if (this.length > 0) {
                if (includeMargins)
                  return this[0].offsetWidth + parseFloat(this.css('margin-right')) + parseFloat(this.css('margin-left'));
                else
                  return this[0].offsetWidth;
              } else
                return null;
            },
            height: function() {
              if (this[0] === window) {
                return window.innerHeight;
              } else {
                if (this.length > 0) {
                  return parseFloat(this.css('height'));
                } else {
                  return null;
                }
              }
            },
            outerHeight: function(includeMargins) {
              if (this.length > 0) {
                if (includeMargins)
                  return this[0].offsetHeight + parseFloat(this.css('margin-top')) + parseFloat(this.css('margin-bottom'));
                else
                  return this[0].offsetHeight;
              } else
                return null;
            },
            offset: function() {
              if (this.length > 0) {
                var el = this[0];
                var box = el.getBoundingClientRect();
                var body = document.body;
                var clientTop = el.clientTop || body.clientTop || 0;
                var clientLeft = el.clientLeft || body.clientLeft || 0;
                var scrollTop = window.pageYOffset || el.scrollTop;
                var scrollLeft = window.pageXOffset || el.scrollLeft;
                return {
                  top: box.top + scrollTop - clientTop,
                  left: box.left + scrollLeft - clientLeft
                };
              } else {
                return null;
              }
            },
            css: function(props, value) {
              var i;
              if (arguments.length === 1) {
                if (typeof props === 'string') {
                  if (this[0])
                    return window.getComputedStyle(this[0], null).getPropertyValue(props);
                } else {
                  for (i = 0; i < this.length; i++) {
                    for (var prop in props) {
                      this[i].style[prop] = props[prop];
                    }
                  }
                  return this;
                }
              }
              if (arguments.length === 2 && typeof props === 'string') {
                for (i = 0; i < this.length; i++) {
                  this[i].style[props] = value;
                }
                return this;
              }
              return this;
            },
            each: function(callback) {
              for (var i = 0; i < this.length; i++) {
                callback.call(this[i], i, this[i]);
              }
              return this;
            },
            html: function(html) {
              if (typeof html === 'undefined') {
                return this[0] ? this[0].innerHTML : undefined;
              } else {
                for (var i = 0; i < this.length; i++) {
                  this[i].innerHTML = html;
                }
                return this;
              }
            },
            is: function(selector) {
              if (!this[0])
                return false;
              var compareWith,
                  i;
              if (typeof selector === 'string') {
                var el = this[0];
                if (el === document)
                  return selector === document;
                if (el === window)
                  return selector === window;
                if (el.matches)
                  return el.matches(selector);
                else if (el.webkitMatchesSelector)
                  return el.webkitMatchesSelector(selector);
                else if (el.mozMatchesSelector)
                  return el.mozMatchesSelector(selector);
                else if (el.msMatchesSelector)
                  return el.msMatchesSelector(selector);
                else {
                  compareWith = $(selector);
                  for (i = 0; i < compareWith.length; i++) {
                    if (compareWith[i] === this[0])
                      return true;
                  }
                  return false;
                }
              } else if (selector === document)
                return this[0] === document;
              else if (selector === window)
                return this[0] === window;
              else {
                if (selector.nodeType || selector instanceof Dom7) {
                  compareWith = selector.nodeType ? [selector] : selector;
                  for (i = 0; i < compareWith.length; i++) {
                    if (compareWith[i] === this[0])
                      return true;
                  }
                  return false;
                }
                return false;
              }
            },
            index: function() {
              if (this[0]) {
                var child = this[0];
                var i = 0;
                while ((child = child.previousSibling) !== null) {
                  if (child.nodeType === 1)
                    i++;
                }
                return i;
              } else
                return undefined;
            },
            eq: function(index) {
              if (typeof index === 'undefined')
                return this;
              var length = this.length;
              var returnIndex;
              if (index > length - 1) {
                return new Dom7([]);
              }
              if (index < 0) {
                returnIndex = length + index;
                if (returnIndex < 0)
                  return new Dom7([]);
                else
                  return new Dom7([this[returnIndex]]);
              }
              return new Dom7([this[index]]);
            },
            append: function(newChild) {
              var i,
                  j;
              for (i = 0; i < this.length; i++) {
                if (typeof newChild === 'string') {
                  var tempDiv = document.createElement('div');
                  tempDiv.innerHTML = newChild;
                  while (tempDiv.firstChild) {
                    this[i].appendChild(tempDiv.firstChild);
                  }
                } else if (newChild instanceof Dom7) {
                  for (j = 0; j < newChild.length; j++) {
                    this[i].appendChild(newChild[j]);
                  }
                } else {
                  this[i].appendChild(newChild);
                }
              }
              return this;
            },
            prepend: function(newChild) {
              var i,
                  j;
              for (i = 0; i < this.length; i++) {
                if (typeof newChild === 'string') {
                  var tempDiv = document.createElement('div');
                  tempDiv.innerHTML = newChild;
                  for (j = tempDiv.childNodes.length - 1; j >= 0; j--) {
                    this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
                  }
                } else if (newChild instanceof Dom7) {
                  for (j = 0; j < newChild.length; j++) {
                    this[i].insertBefore(newChild[j], this[i].childNodes[0]);
                  }
                } else {
                  this[i].insertBefore(newChild, this[i].childNodes[0]);
                }
              }
              return this;
            },
            insertBefore: function(selector) {
              var before = $(selector);
              for (var i = 0; i < this.length; i++) {
                if (before.length === 1) {
                  before[0].parentNode.insertBefore(this[i], before[0]);
                } else if (before.length > 1) {
                  for (var j = 0; j < before.length; j++) {
                    before[j].parentNode.insertBefore(this[i].cloneNode(true), before[j]);
                  }
                }
              }
            },
            insertAfter: function(selector) {
              var after = $(selector);
              for (var i = 0; i < this.length; i++) {
                if (after.length === 1) {
                  after[0].parentNode.insertBefore(this[i], after[0].nextSibling);
                } else if (after.length > 1) {
                  for (var j = 0; j < after.length; j++) {
                    after[j].parentNode.insertBefore(this[i].cloneNode(true), after[j].nextSibling);
                  }
                }
              }
            },
            next: function(selector) {
              if (this.length > 0) {
                if (selector) {
                  if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector))
                    return new Dom7([this[0].nextElementSibling]);
                  else
                    return new Dom7([]);
                } else {
                  if (this[0].nextElementSibling)
                    return new Dom7([this[0].nextElementSibling]);
                  else
                    return new Dom7([]);
                }
              } else
                return new Dom7([]);
            },
            nextAll: function(selector) {
              var nextEls = [];
              var el = this[0];
              if (!el)
                return new Dom7([]);
              while (el.nextElementSibling) {
                var next = el.nextElementSibling;
                if (selector) {
                  if ($(next).is(selector))
                    nextEls.push(next);
                } else
                  nextEls.push(next);
                el = next;
              }
              return new Dom7(nextEls);
            },
            prev: function(selector) {
              if (this.length > 0) {
                if (selector) {
                  if (this[0].previousElementSibling && $(this[0].previousElementSibling).is(selector))
                    return new Dom7([this[0].previousElementSibling]);
                  else
                    return new Dom7([]);
                } else {
                  if (this[0].previousElementSibling)
                    return new Dom7([this[0].previousElementSibling]);
                  else
                    return new Dom7([]);
                }
              } else
                return new Dom7([]);
            },
            prevAll: function(selector) {
              var prevEls = [];
              var el = this[0];
              if (!el)
                return new Dom7([]);
              while (el.previousElementSibling) {
                var prev = el.previousElementSibling;
                if (selector) {
                  if ($(prev).is(selector))
                    prevEls.push(prev);
                } else
                  prevEls.push(prev);
                el = prev;
              }
              return new Dom7(prevEls);
            },
            parent: function(selector) {
              var parents = [];
              for (var i = 0; i < this.length; i++) {
                if (selector) {
                  if ($(this[i].parentNode).is(selector))
                    parents.push(this[i].parentNode);
                } else {
                  parents.push(this[i].parentNode);
                }
              }
              return $($.unique(parents));
            },
            parents: function(selector) {
              var parents = [];
              for (var i = 0; i < this.length; i++) {
                var parent = this[i].parentNode;
                while (parent) {
                  if (selector) {
                    if ($(parent).is(selector))
                      parents.push(parent);
                  } else {
                    parents.push(parent);
                  }
                  parent = parent.parentNode;
                }
              }
              return $($.unique(parents));
            },
            find: function(selector) {
              var foundElements = [];
              for (var i = 0; i < this.length; i++) {
                var found = this[i].querySelectorAll(selector);
                for (var j = 0; j < found.length; j++) {
                  foundElements.push(found[j]);
                }
              }
              return new Dom7(foundElements);
            },
            children: function(selector) {
              var children = [];
              for (var i = 0; i < this.length; i++) {
                var childNodes = this[i].childNodes;
                for (var j = 0; j < childNodes.length; j++) {
                  if (!selector) {
                    if (childNodes[j].nodeType === 1)
                      children.push(childNodes[j]);
                  } else {
                    if (childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector))
                      children.push(childNodes[j]);
                  }
                }
              }
              return new Dom7($.unique(children));
            },
            remove: function() {
              for (var i = 0; i < this.length; i++) {
                if (this[i].parentNode)
                  this[i].parentNode.removeChild(this[i]);
              }
              return this;
            },
            add: function() {
              var dom = this;
              var i,
                  j;
              for (i = 0; i < arguments.length; i++) {
                var toAdd = $(arguments[i]);
                for (j = 0; j < toAdd.length; j++) {
                  dom[dom.length] = toAdd[j];
                  dom.length++;
                }
              }
              return dom;
            }
          };
          $.fn = Dom7.prototype;
          $.unique = function(arr) {
            var unique = [];
            for (var i = 0; i < arr.length; i++) {
              if (unique.indexOf(arr[i]) === -1)
                unique.push(arr[i]);
            }
            return unique;
          };
          return $;
        })();
        var swiperDomPlugins = ['jQuery', 'Zepto', 'Dom7'];
        for (var i = 0; i < swiperDomPlugins.length; i++) {
          if (window[swiperDomPlugins[i]]) {
            addLibraryPlugin(window[swiperDomPlugins[i]]);
          }
        }
        var domLib;
        if (typeof Dom7 === 'undefined') {
          domLib = window.Dom7 || window.Zepto || window.jQuery;
        } else {
          domLib = Dom7;
        }
        function addLibraryPlugin(lib) {
          lib.fn.swiper = function(params) {
            var firstInstance;
            lib(this).each(function() {
              var s = new Swiper(this, params);
              if (!firstInstance)
                firstInstance = s;
            });
            return firstInstance;
          };
        }
        if (domLib) {
          if (!('transitionEnd' in domLib.fn)) {
            domLib.fn.transitionEnd = function(callback) {
              var events = ['webkitTransitionEnd', 'transitionend', 'oTransitionEnd', 'MSTransitionEnd', 'msTransitionEnd'],
                  i,
                  j,
                  dom = this;
              function fireCallBack(e) {
                if (e.target !== this)
                  return;
                callback.call(this, e);
                for (i = 0; i < events.length; i++) {
                  dom.off(events[i], fireCallBack);
                }
              }
              if (callback) {
                for (i = 0; i < events.length; i++) {
                  dom.on(events[i], fireCallBack);
                }
              }
              return this;
            };
          }
          if (!('transform' in domLib.fn)) {
            domLib.fn.transform = function(transform) {
              for (var i = 0; i < this.length; i++) {
                var elStyle = this[i].style;
                elStyle.webkitTransform = elStyle.MsTransform = elStyle.msTransform = elStyle.MozTransform = elStyle.OTransform = elStyle.transform = transform;
              }
              return this;
            };
          }
          if (!('transition' in domLib.fn)) {
            domLib.fn.transition = function(duration) {
              if (typeof duration !== 'string') {
                duration = duration + 'ms';
              }
              for (var i = 0; i < this.length; i++) {
                var elStyle = this[i].style;
                elStyle.webkitTransitionDuration = elStyle.MsTransitionDuration = elStyle.msTransitionDuration = elStyle.MozTransitionDuration = elStyle.OTransitionDuration = elStyle.transitionDuration = duration;
              }
              return this;
            };
          }
        }
        ionic.views.Swiper = Swiper;
      })();
      (function(ionic) {
        'use strict';
        ionic.views.Toggle = ionic.views.View.inherit({
          initialize: function(opts) {
            var self = this;
            this.el = opts.el;
            this.checkbox = opts.checkbox;
            this.track = opts.track;
            this.handle = opts.handle;
            this.openPercent = -1;
            this.onChange = opts.onChange || function() {};
            this.triggerThreshold = opts.triggerThreshold || 20;
            this.dragStartHandler = function(e) {
              self.dragStart(e);
            };
            this.dragHandler = function(e) {
              self.drag(e);
            };
            this.holdHandler = function(e) {
              self.hold(e);
            };
            this.releaseHandler = function(e) {
              self.release(e);
            };
            this.dragStartGesture = ionic.onGesture('dragstart', this.dragStartHandler, this.el);
            this.dragGesture = ionic.onGesture('drag', this.dragHandler, this.el);
            this.dragHoldGesture = ionic.onGesture('hold', this.holdHandler, this.el);
            this.dragReleaseGesture = ionic.onGesture('release', this.releaseHandler, this.el);
          },
          destroy: function() {
            ionic.offGesture(this.dragStartGesture, 'dragstart', this.dragStartGesture);
            ionic.offGesture(this.dragGesture, 'drag', this.dragGesture);
            ionic.offGesture(this.dragHoldGesture, 'hold', this.holdHandler);
            ionic.offGesture(this.dragReleaseGesture, 'release', this.releaseHandler);
          },
          tap: function() {
            if (this.el.getAttribute('disabled') !== 'disabled') {
              this.val(!this.checkbox.checked);
            }
          },
          dragStart: function(e) {
            if (this.checkbox.disabled)
              return;
            this._dragInfo = {
              width: this.el.offsetWidth,
              left: this.el.offsetLeft,
              right: this.el.offsetLeft + this.el.offsetWidth,
              triggerX: this.el.offsetWidth / 2,
              initialState: this.checkbox.checked
            };
            e.gesture.srcEvent.preventDefault();
            this.hold(e);
          },
          drag: function(e) {
            var self = this;
            if (!this._dragInfo) {
              return;
            }
            e.gesture.srcEvent.preventDefault();
            ionic.requestAnimationFrame(function() {
              if (!self._dragInfo) {
                return;
              }
              var px = e.gesture.touches[0].pageX - self._dragInfo.left;
              var mx = self._dragInfo.width - self.triggerThreshold;
              if (self._dragInfo.initialState) {
                if (px < self.triggerThreshold) {
                  self.setOpenPercent(0);
                } else if (px > self._dragInfo.triggerX) {
                  self.setOpenPercent(100);
                }
              } else {
                if (px < self._dragInfo.triggerX) {
                  self.setOpenPercent(0);
                } else if (px > mx) {
                  self.setOpenPercent(100);
                }
              }
            });
          },
          endDrag: function() {
            this._dragInfo = null;
          },
          hold: function() {
            this.el.classList.add('dragging');
          },
          release: function(e) {
            this.el.classList.remove('dragging');
            this.endDrag(e);
          },
          setOpenPercent: function(openPercent) {
            if (this.openPercent < 0 || (openPercent < (this.openPercent - 3) || openPercent > (this.openPercent + 3))) {
              this.openPercent = openPercent;
              if (openPercent === 0) {
                this.val(false);
              } else if (openPercent === 100) {
                this.val(true);
              } else {
                var openPixel = Math.round((openPercent / 100) * this.track.offsetWidth - (this.handle.offsetWidth));
                openPixel = (openPixel < 1 ? 0 : openPixel);
                this.handle.style[ionic.CSS.TRANSFORM] = 'translate3d(' + openPixel + 'px,0,0)';
              }
            }
          },
          val: function(value) {
            if (value === true || value === false) {
              if (this.handle.style[ionic.CSS.TRANSFORM] !== "") {
                this.handle.style[ionic.CSS.TRANSFORM] = "";
              }
              this.checkbox.checked = value;
              this.openPercent = (value ? 100 : 0);
              this.onChange && this.onChange();
            }
            return this.checkbox.checked;
          }
        });
      })(ionic);
    })();
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("13", ["14"], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    "format global";
    "deps angular";
    (function(window, angular) {
      'use strict';
      var ELEMENT_NODE = 1;
      var COMMENT_NODE = 8;
      var ADD_CLASS_SUFFIX = '-add';
      var REMOVE_CLASS_SUFFIX = '-remove';
      var EVENT_CLASS_PREFIX = 'ng-';
      var ACTIVE_CLASS_SUFFIX = '-active';
      var PREPARE_CLASS_SUFFIX = '-prepare';
      var NG_ANIMATE_CLASSNAME = 'ng-animate';
      var NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';
      var CSS_PREFIX = '',
          TRANSITION_PROP,
          TRANSITIONEND_EVENT,
          ANIMATION_PROP,
          ANIMATIONEND_EVENT;
      if ((window.ontransitionend === void 0) && (window.onwebkittransitionend !== void 0)) {
        CSS_PREFIX = '-webkit-';
        TRANSITION_PROP = 'WebkitTransition';
        TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';
      } else {
        TRANSITION_PROP = 'transition';
        TRANSITIONEND_EVENT = 'transitionend';
      }
      if ((window.onanimationend === void 0) && (window.onwebkitanimationend !== void 0)) {
        CSS_PREFIX = '-webkit-';
        ANIMATION_PROP = 'WebkitAnimation';
        ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';
      } else {
        ANIMATION_PROP = 'animation';
        ANIMATIONEND_EVENT = 'animationend';
      }
      var DURATION_KEY = 'Duration';
      var PROPERTY_KEY = 'Property';
      var DELAY_KEY = 'Delay';
      var TIMING_KEY = 'TimingFunction';
      var ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';
      var ANIMATION_PLAYSTATE_KEY = 'PlayState';
      var SAFE_FAST_FORWARD_DURATION_VALUE = 9999;
      var ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;
      var ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;
      var TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;
      var TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;
      var ngMinErr = angular.$$minErr('ng');
      function assertArg(arg, name, reason) {
        if (!arg) {
          throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
        }
        return arg;
      }
      function mergeClasses(a, b) {
        if (!a && !b)
          return '';
        if (!a)
          return b;
        if (!b)
          return a;
        if (isArray(a))
          a = a.join(' ');
        if (isArray(b))
          b = b.join(' ');
        return a + ' ' + b;
      }
      function packageStyles(options) {
        var styles = {};
        if (options && (options.to || options.from)) {
          styles.to = options.to;
          styles.from = options.from;
        }
        return styles;
      }
      function pendClasses(classes, fix, isPrefix) {
        var className = '';
        classes = isArray(classes) ? classes : classes && isString(classes) && classes.length ? classes.split(/\s+/) : [];
        forEach(classes, function(klass, i) {
          if (klass && klass.length > 0) {
            className += (i > 0) ? ' ' : '';
            className += isPrefix ? fix + klass : klass + fix;
          }
        });
        return className;
      }
      function removeFromArray(arr, val) {
        var index = arr.indexOf(val);
        if (val >= 0) {
          arr.splice(index, 1);
        }
      }
      function stripCommentsFromElement(element) {
        if (element instanceof jqLite) {
          switch (element.length) {
            case 0:
              return element;
            case 1:
              if (element[0].nodeType === ELEMENT_NODE) {
                return element;
              }
              break;
            default:
              return jqLite(extractElementNode(element));
          }
        }
        if (element.nodeType === ELEMENT_NODE) {
          return jqLite(element);
        }
      }
      function extractElementNode(element) {
        if (!element[0])
          return element;
        for (var i = 0; i < element.length; i++) {
          var elm = element[i];
          if (elm.nodeType == ELEMENT_NODE) {
            return elm;
          }
        }
      }
      function $$addClass($$jqLite, element, className) {
        forEach(element, function(elm) {
          $$jqLite.addClass(elm, className);
        });
      }
      function $$removeClass($$jqLite, element, className) {
        forEach(element, function(elm) {
          $$jqLite.removeClass(elm, className);
        });
      }
      function applyAnimationClassesFactory($$jqLite) {
        return function(element, options) {
          if (options.addClass) {
            $$addClass($$jqLite, element, options.addClass);
            options.addClass = null;
          }
          if (options.removeClass) {
            $$removeClass($$jqLite, element, options.removeClass);
            options.removeClass = null;
          }
        };
      }
      function prepareAnimationOptions(options) {
        options = options || {};
        if (!options.$$prepared) {
          var domOperation = options.domOperation || noop;
          options.domOperation = function() {
            options.$$domOperationFired = true;
            domOperation();
            domOperation = noop;
          };
          options.$$prepared = true;
        }
        return options;
      }
      function applyAnimationStyles(element, options) {
        applyAnimationFromStyles(element, options);
        applyAnimationToStyles(element, options);
      }
      function applyAnimationFromStyles(element, options) {
        if (options.from) {
          element.css(options.from);
          options.from = null;
        }
      }
      function applyAnimationToStyles(element, options) {
        if (options.to) {
          element.css(options.to);
          options.to = null;
        }
      }
      function mergeAnimationDetails(element, oldAnimation, newAnimation) {
        var target = oldAnimation.options || {};
        var newOptions = newAnimation.options || {};
        var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');
        var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');
        var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);
        if (newOptions.preparationClasses) {
          target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);
          delete newOptions.preparationClasses;
        }
        var realDomOperation = target.domOperation !== noop ? target.domOperation : null;
        extend(target, newOptions);
        if (realDomOperation) {
          target.domOperation = realDomOperation;
        }
        if (classes.addClass) {
          target.addClass = classes.addClass;
        } else {
          target.addClass = null;
        }
        if (classes.removeClass) {
          target.removeClass = classes.removeClass;
        } else {
          target.removeClass = null;
        }
        oldAnimation.addClass = target.addClass;
        oldAnimation.removeClass = target.removeClass;
        return target;
      }
      function resolveElementClasses(existing, toAdd, toRemove) {
        var ADD_CLASS = 1;
        var REMOVE_CLASS = -1;
        var flags = {};
        existing = splitClassesToLookup(existing);
        toAdd = splitClassesToLookup(toAdd);
        forEach(toAdd, function(value, key) {
          flags[key] = ADD_CLASS;
        });
        toRemove = splitClassesToLookup(toRemove);
        forEach(toRemove, function(value, key) {
          flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;
        });
        var classes = {
          addClass: '',
          removeClass: ''
        };
        forEach(flags, function(val, klass) {
          var prop,
              allow;
          if (val === ADD_CLASS) {
            prop = 'addClass';
            allow = !existing[klass] || existing[klass + REMOVE_CLASS_SUFFIX];
          } else if (val === REMOVE_CLASS) {
            prop = 'removeClass';
            allow = existing[klass] || existing[klass + ADD_CLASS_SUFFIX];
          }
          if (allow) {
            if (classes[prop].length) {
              classes[prop] += ' ';
            }
            classes[prop] += klass;
          }
        });
        function splitClassesToLookup(classes) {
          if (isString(classes)) {
            classes = classes.split(' ');
          }
          var obj = {};
          forEach(classes, function(klass) {
            if (klass.length) {
              obj[klass] = true;
            }
          });
          return obj;
        }
        return classes;
      }
      function getDomNode(element) {
        return (element instanceof jqLite) ? element[0] : element;
      }
      function applyGeneratedPreparationClasses(element, event, options) {
        var classes = '';
        if (event) {
          classes = pendClasses(event, EVENT_CLASS_PREFIX, true);
        }
        if (options.addClass) {
          classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));
        }
        if (options.removeClass) {
          classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));
        }
        if (classes.length) {
          options.preparationClasses = classes;
          element.addClass(classes);
        }
      }
      function clearGeneratedClasses(element, options) {
        if (options.preparationClasses) {
          element.removeClass(options.preparationClasses);
          options.preparationClasses = null;
        }
        if (options.activeClasses) {
          element.removeClass(options.activeClasses);
          options.activeClasses = null;
        }
      }
      function blockTransitions(node, duration) {
        var value = duration ? '-' + duration + 's' : '';
        applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);
        return [TRANSITION_DELAY_PROP, value];
      }
      function blockKeyframeAnimations(node, applyBlock) {
        var value = applyBlock ? 'paused' : '';
        var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;
        applyInlineStyle(node, [key, value]);
        return [key, value];
      }
      function applyInlineStyle(node, styleTuple) {
        var prop = styleTuple[0];
        var value = styleTuple[1];
        node.style[prop] = value;
      }
      function concatWithSpace(a, b) {
        if (!a)
          return b;
        if (!b)
          return a;
        return a + ' ' + b;
      }
      var $$rAFSchedulerFactory = ['$$rAF', function($$rAF) {
        var queue,
            cancelFn;
        function scheduler(tasks) {
          queue = queue.concat(tasks);
          nextTick();
        }
        queue = scheduler.queue = [];
        scheduler.waitUntilQuiet = function(fn) {
          if (cancelFn)
            cancelFn();
          cancelFn = $$rAF(function() {
            cancelFn = null;
            fn();
            nextTick();
          });
        };
        return scheduler;
        function nextTick() {
          if (!queue.length)
            return;
          var items = queue.shift();
          for (var i = 0; i < items.length; i++) {
            items[i]();
          }
          if (!cancelFn) {
            $$rAF(function() {
              if (!cancelFn)
                nextTick();
            });
          }
        }
      }];
      var $$AnimateChildrenDirective = ['$interpolate', function($interpolate) {
        return {link: function(scope, element, attrs) {
            var val = attrs.ngAnimateChildren;
            if (isString(val) && val.length === 0) {
              element.data(NG_ANIMATE_CHILDREN_DATA, true);
            } else {
              setData($interpolate(val)(scope));
              attrs.$observe('ngAnimateChildren', setData);
            }
            function setData(value) {
              value = value === 'on' || value === 'true';
              element.data(NG_ANIMATE_CHILDREN_DATA, value);
            }
          }};
      }];
      var ANIMATE_TIMER_KEY = '$$animateCss';
      var ONE_SECOND = 1000;
      var BASE_TEN = 10;
      var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;
      var CLOSING_TIME_BUFFER = 1.5;
      var DETECT_CSS_PROPERTIES = {
        transitionDuration: TRANSITION_DURATION_PROP,
        transitionDelay: TRANSITION_DELAY_PROP,
        transitionProperty: TRANSITION_PROP + PROPERTY_KEY,
        animationDuration: ANIMATION_DURATION_PROP,
        animationDelay: ANIMATION_DELAY_PROP,
        animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY
      };
      var DETECT_STAGGER_CSS_PROPERTIES = {
        transitionDuration: TRANSITION_DURATION_PROP,
        transitionDelay: TRANSITION_DELAY_PROP,
        animationDuration: ANIMATION_DURATION_PROP,
        animationDelay: ANIMATION_DELAY_PROP
      };
      function getCssKeyframeDurationStyle(duration) {
        return [ANIMATION_DURATION_PROP, duration + 's'];
      }
      function getCssDelayStyle(delay, isKeyframeAnimation) {
        var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;
        return [prop, delay + 's'];
      }
      function computeCssStyles($window, element, properties) {
        var styles = Object.create(null);
        var detectedStyles = $window.getComputedStyle(element) || {};
        forEach(properties, function(formalStyleName, actualStyleName) {
          var val = detectedStyles[formalStyleName];
          if (val) {
            var c = val.charAt(0);
            if (c === '-' || c === '+' || c >= 0) {
              val = parseMaxTime(val);
            }
            if (val === 0) {
              val = null;
            }
            styles[actualStyleName] = val;
          }
        });
        return styles;
      }
      function parseMaxTime(str) {
        var maxValue = 0;
        var values = str.split(/\s*,\s*/);
        forEach(values, function(value) {
          if (value.charAt(value.length - 1) == 's') {
            value = value.substring(0, value.length - 1);
          }
          value = parseFloat(value) || 0;
          maxValue = maxValue ? Math.max(value, maxValue) : value;
        });
        return maxValue;
      }
      function truthyTimingValue(val) {
        return val === 0 || val != null;
      }
      function getCssTransitionDurationStyle(duration, applyOnlyDuration) {
        var style = TRANSITION_PROP;
        var value = duration + 's';
        if (applyOnlyDuration) {
          style += DURATION_KEY;
        } else {
          value += ' linear all';
        }
        return [style, value];
      }
      function createLocalCacheLookup() {
        var cache = Object.create(null);
        return {
          flush: function() {
            cache = Object.create(null);
          },
          count: function(key) {
            var entry = cache[key];
            return entry ? entry.total : 0;
          },
          get: function(key) {
            var entry = cache[key];
            return entry && entry.value;
          },
          put: function(key, value) {
            if (!cache[key]) {
              cache[key] = {
                total: 1,
                value: value
              };
            } else {
              cache[key].total++;
            }
          }
        };
      }
      function registerRestorableStyles(backup, node, properties) {
        forEach(properties, function(prop) {
          backup[prop] = isDefined(backup[prop]) ? backup[prop] : node.style.getPropertyValue(prop);
        });
      }
      var $AnimateCssProvider = ['$animateProvider', function($animateProvider) {
        var gcsLookup = createLocalCacheLookup();
        var gcsStaggerLookup = createLocalCacheLookup();
        this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout', '$$forceReflow', '$sniffer', '$$rAFScheduler', '$$animateQueue', function($window, $$jqLite, $$AnimateRunner, $timeout, $$forceReflow, $sniffer, $$rAFScheduler, $$animateQueue) {
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          var parentCounter = 0;
          function gcsHashFn(node, extraClasses) {
            var KEY = "$$ngAnimateParentKey";
            var parentNode = node.parentNode;
            var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);
            return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;
          }
          function computeCachedCssStyles(node, className, cacheKey, properties) {
            var timings = gcsLookup.get(cacheKey);
            if (!timings) {
              timings = computeCssStyles($window, node, properties);
              if (timings.animationIterationCount === 'infinite') {
                timings.animationIterationCount = 1;
              }
            }
            gcsLookup.put(cacheKey, timings);
            return timings;
          }
          function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {
            var stagger;
            if (gcsLookup.count(cacheKey) > 0) {
              stagger = gcsStaggerLookup.get(cacheKey);
              if (!stagger) {
                var staggerClassName = pendClasses(className, '-stagger');
                $$jqLite.addClass(node, staggerClassName);
                stagger = computeCssStyles($window, node, properties);
                stagger.animationDuration = Math.max(stagger.animationDuration, 0);
                stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);
                $$jqLite.removeClass(node, staggerClassName);
                gcsStaggerLookup.put(cacheKey, stagger);
              }
            }
            return stagger || {};
          }
          var cancelLastRAFRequest;
          var rafWaitQueue = [];
          function waitUntilQuiet(callback) {
            rafWaitQueue.push(callback);
            $$rAFScheduler.waitUntilQuiet(function() {
              gcsLookup.flush();
              gcsStaggerLookup.flush();
              var pageWidth = $$forceReflow();
              for (var i = 0; i < rafWaitQueue.length; i++) {
                rafWaitQueue[i](pageWidth);
              }
              rafWaitQueue.length = 0;
            });
          }
          function computeTimings(node, className, cacheKey) {
            var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);
            var aD = timings.animationDelay;
            var tD = timings.transitionDelay;
            timings.maxDelay = aD && tD ? Math.max(aD, tD) : (aD || tD);
            timings.maxDuration = Math.max(timings.animationDuration * timings.animationIterationCount, timings.transitionDuration);
            return timings;
          }
          return function init(element, initialOptions) {
            var options = initialOptions || {};
            if (!options.$$prepared) {
              options = prepareAnimationOptions(copy(options));
            }
            var restoreStyles = {};
            var node = getDomNode(element);
            if (!node || !node.parentNode || !$$animateQueue.enabled()) {
              return closeAndReturnNoopAnimator();
            }
            var temporaryStyles = [];
            var classes = element.attr('class');
            var styles = packageStyles(options);
            var animationClosed;
            var animationPaused;
            var animationCompleted;
            var runner;
            var runnerHost;
            var maxDelay;
            var maxDelayTime;
            var maxDuration;
            var maxDurationTime;
            var startTime;
            var events = [];
            if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {
              return closeAndReturnNoopAnimator();
            }
            var method = options.event && isArray(options.event) ? options.event.join(' ') : options.event;
            var isStructural = method && options.structural;
            var structuralClassName = '';
            var addRemoveClassName = '';
            if (isStructural) {
              structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);
            } else if (method) {
              structuralClassName = method;
            }
            if (options.addClass) {
              addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);
            }
            if (options.removeClass) {
              if (addRemoveClassName.length) {
                addRemoveClassName += ' ';
              }
              addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);
            }
            if (options.applyClassesEarly && addRemoveClassName.length) {
              applyAnimationClasses(element, options);
            }
            var preparationClasses = [structuralClassName, addRemoveClassName].join(' ').trim();
            var fullClassName = classes + ' ' + preparationClasses;
            var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);
            var hasToStyles = styles.to && Object.keys(styles.to).length > 0;
            var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0;
            if (!containsKeyframeAnimation && !hasToStyles && !preparationClasses) {
              return closeAndReturnNoopAnimator();
            }
            var cacheKey,
                stagger;
            if (options.stagger > 0) {
              var staggerVal = parseFloat(options.stagger);
              stagger = {
                transitionDelay: staggerVal,
                animationDelay: staggerVal,
                transitionDuration: 0,
                animationDuration: 0
              };
            } else {
              cacheKey = gcsHashFn(node, fullClassName);
              stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);
            }
            if (!options.$$skipPreparationClasses) {
              $$jqLite.addClass(element, preparationClasses);
            }
            var applyOnlyDuration;
            if (options.transitionStyle) {
              var transitionStyle = [TRANSITION_PROP, options.transitionStyle];
              applyInlineStyle(node, transitionStyle);
              temporaryStyles.push(transitionStyle);
            }
            if (options.duration >= 0) {
              applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;
              var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);
              applyInlineStyle(node, durationStyle);
              temporaryStyles.push(durationStyle);
            }
            if (options.keyframeStyle) {
              var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];
              applyInlineStyle(node, keyframeStyle);
              temporaryStyles.push(keyframeStyle);
            }
            var itemIndex = stagger ? options.staggerIndex >= 0 ? options.staggerIndex : gcsLookup.count(cacheKey) : 0;
            var isFirst = itemIndex === 0;
            if (isFirst && !options.skipBlocking) {
              blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);
            }
            var timings = computeTimings(node, fullClassName, cacheKey);
            var relativeDelay = timings.maxDelay;
            maxDelay = Math.max(relativeDelay, 0);
            maxDuration = timings.maxDuration;
            var flags = {};
            flags.hasTransitions = timings.transitionDuration > 0;
            flags.hasAnimations = timings.animationDuration > 0;
            flags.hasTransitionAll = flags.hasTransitions && timings.transitionProperty == 'all';
            flags.applyTransitionDuration = hasToStyles && ((flags.hasTransitions && !flags.hasTransitionAll) || (flags.hasAnimations && !flags.hasTransitions));
            flags.applyAnimationDuration = options.duration && flags.hasAnimations;
            flags.applyTransitionDelay = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);
            flags.applyAnimationDelay = truthyTimingValue(options.delay) && flags.hasAnimations;
            flags.recalculateTimingStyles = addRemoveClassName.length > 0;
            if (flags.applyTransitionDuration || flags.applyAnimationDuration) {
              maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;
              if (flags.applyTransitionDuration) {
                flags.hasTransitions = true;
                timings.transitionDuration = maxDuration;
                applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;
                temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));
              }
              if (flags.applyAnimationDuration) {
                flags.hasAnimations = true;
                timings.animationDuration = maxDuration;
                temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));
              }
            }
            if (maxDuration === 0 && !flags.recalculateTimingStyles) {
              return closeAndReturnNoopAnimator();
            }
            if (options.delay != null) {
              var delayStyle;
              if (typeof options.delay !== "boolean") {
                delayStyle = parseFloat(options.delay);
                maxDelay = Math.max(delayStyle, 0);
              }
              if (flags.applyTransitionDelay) {
                temporaryStyles.push(getCssDelayStyle(delayStyle));
              }
              if (flags.applyAnimationDelay) {
                temporaryStyles.push(getCssDelayStyle(delayStyle, true));
              }
            }
            if (options.duration == null && timings.transitionDuration > 0) {
              flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;
            }
            maxDelayTime = maxDelay * ONE_SECOND;
            maxDurationTime = maxDuration * ONE_SECOND;
            if (!options.skipBlocking) {
              flags.blockTransition = timings.transitionDuration > 0;
              flags.blockKeyframeAnimation = timings.animationDuration > 0 && stagger.animationDelay > 0 && stagger.animationDuration === 0;
            }
            if (options.from) {
              if (options.cleanupStyles) {
                registerRestorableStyles(restoreStyles, node, Object.keys(options.from));
              }
              applyAnimationFromStyles(element, options);
            }
            if (flags.blockTransition || flags.blockKeyframeAnimation) {
              applyBlocking(maxDuration);
            } else if (!options.skipBlocking) {
              blockTransitions(node, false);
            }
            return {
              $$willAnimate: true,
              end: endFn,
              start: function() {
                if (animationClosed)
                  return;
                runnerHost = {
                  end: endFn,
                  cancel: cancelFn,
                  resume: null,
                  pause: null
                };
                runner = new $$AnimateRunner(runnerHost);
                waitUntilQuiet(start);
                return runner;
              }
            };
            function endFn() {
              close();
            }
            function cancelFn() {
              close(true);
            }
            function close(rejected) {
              if (animationClosed || (animationCompleted && animationPaused))
                return;
              animationClosed = true;
              animationPaused = false;
              if (!options.$$skipPreparationClasses) {
                $$jqLite.removeClass(element, preparationClasses);
              }
              $$jqLite.removeClass(element, activeClasses);
              blockKeyframeAnimations(node, false);
              blockTransitions(node, false);
              forEach(temporaryStyles, function(entry) {
                node.style[entry[0]] = '';
              });
              applyAnimationClasses(element, options);
              applyAnimationStyles(element, options);
              if (Object.keys(restoreStyles).length) {
                forEach(restoreStyles, function(value, prop) {
                  value ? node.style.setProperty(prop, value) : node.style.removeProperty(prop);
                });
              }
              if (options.onDone) {
                options.onDone();
              }
              if (events && events.length) {
                element.off(events.join(' '), onAnimationProgress);
              }
              var animationTimerData = element.data(ANIMATE_TIMER_KEY);
              if (animationTimerData) {
                $timeout.cancel(animationTimerData[0].timer);
                element.removeData(ANIMATE_TIMER_KEY);
              }
              if (runner) {
                runner.complete(!rejected);
              }
            }
            function applyBlocking(duration) {
              if (flags.blockTransition) {
                blockTransitions(node, duration);
              }
              if (flags.blockKeyframeAnimation) {
                blockKeyframeAnimations(node, !!duration);
              }
            }
            function closeAndReturnNoopAnimator() {
              runner = new $$AnimateRunner({
                end: endFn,
                cancel: cancelFn
              });
              waitUntilQuiet(noop);
              close();
              return {
                $$willAnimate: false,
                start: function() {
                  return runner;
                },
                end: endFn
              };
            }
            function onAnimationProgress(event) {
              event.stopPropagation();
              var ev = event.originalEvent || event;
              var timeStamp = ev.$manualTimeStamp || Date.now();
              var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));
              if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {
                animationCompleted = true;
                close();
              }
            }
            function start() {
              if (animationClosed)
                return;
              if (!node.parentNode) {
                close();
                return;
              }
              var playPause = function(playAnimation) {
                if (!animationCompleted) {
                  animationPaused = !playAnimation;
                  if (timings.animationDuration) {
                    var value = blockKeyframeAnimations(node, animationPaused);
                    animationPaused ? temporaryStyles.push(value) : removeFromArray(temporaryStyles, value);
                  }
                } else if (animationPaused && playAnimation) {
                  animationPaused = false;
                  close();
                }
              };
              var maxStagger = itemIndex > 0 && ((timings.transitionDuration && stagger.transitionDuration === 0) || (timings.animationDuration && stagger.animationDuration === 0)) && Math.max(stagger.animationDelay, stagger.transitionDelay);
              if (maxStagger) {
                $timeout(triggerAnimationStart, Math.floor(maxStagger * itemIndex * ONE_SECOND), false);
              } else {
                triggerAnimationStart();
              }
              runnerHost.resume = function() {
                playPause(true);
              };
              runnerHost.pause = function() {
                playPause(false);
              };
              function triggerAnimationStart() {
                if (animationClosed)
                  return;
                applyBlocking(false);
                forEach(temporaryStyles, function(entry) {
                  var key = entry[0];
                  var value = entry[1];
                  node.style[key] = value;
                });
                applyAnimationClasses(element, options);
                $$jqLite.addClass(element, activeClasses);
                if (flags.recalculateTimingStyles) {
                  fullClassName = node.className + ' ' + preparationClasses;
                  cacheKey = gcsHashFn(node, fullClassName);
                  timings = computeTimings(node, fullClassName, cacheKey);
                  relativeDelay = timings.maxDelay;
                  maxDelay = Math.max(relativeDelay, 0);
                  maxDuration = timings.maxDuration;
                  if (maxDuration === 0) {
                    close();
                    return;
                  }
                  flags.hasTransitions = timings.transitionDuration > 0;
                  flags.hasAnimations = timings.animationDuration > 0;
                }
                if (flags.applyAnimationDelay) {
                  relativeDelay = typeof options.delay !== "boolean" && truthyTimingValue(options.delay) ? parseFloat(options.delay) : relativeDelay;
                  maxDelay = Math.max(relativeDelay, 0);
                  timings.animationDelay = relativeDelay;
                  delayStyle = getCssDelayStyle(relativeDelay, true);
                  temporaryStyles.push(delayStyle);
                  node.style[delayStyle[0]] = delayStyle[1];
                }
                maxDelayTime = maxDelay * ONE_SECOND;
                maxDurationTime = maxDuration * ONE_SECOND;
                if (options.easing) {
                  var easeProp,
                      easeVal = options.easing;
                  if (flags.hasTransitions) {
                    easeProp = TRANSITION_PROP + TIMING_KEY;
                    temporaryStyles.push([easeProp, easeVal]);
                    node.style[easeProp] = easeVal;
                  }
                  if (flags.hasAnimations) {
                    easeProp = ANIMATION_PROP + TIMING_KEY;
                    temporaryStyles.push([easeProp, easeVal]);
                    node.style[easeProp] = easeVal;
                  }
                }
                if (timings.transitionDuration) {
                  events.push(TRANSITIONEND_EVENT);
                }
                if (timings.animationDuration) {
                  events.push(ANIMATIONEND_EVENT);
                }
                startTime = Date.now();
                var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;
                var endTime = startTime + timerTime;
                var animationsData = element.data(ANIMATE_TIMER_KEY) || [];
                var setupFallbackTimer = true;
                if (animationsData.length) {
                  var currentTimerData = animationsData[0];
                  setupFallbackTimer = endTime > currentTimerData.expectedEndTime;
                  if (setupFallbackTimer) {
                    $timeout.cancel(currentTimerData.timer);
                  } else {
                    animationsData.push(close);
                  }
                }
                if (setupFallbackTimer) {
                  var timer = $timeout(onAnimationExpired, timerTime, false);
                  animationsData[0] = {
                    timer: timer,
                    expectedEndTime: endTime
                  };
                  animationsData.push(close);
                  element.data(ANIMATE_TIMER_KEY, animationsData);
                }
                if (events.length) {
                  element.on(events.join(' '), onAnimationProgress);
                }
                if (options.to) {
                  if (options.cleanupStyles) {
                    registerRestorableStyles(restoreStyles, node, Object.keys(options.to));
                  }
                  applyAnimationToStyles(element, options);
                }
              }
              function onAnimationExpired() {
                var animationsData = element.data(ANIMATE_TIMER_KEY);
                if (animationsData) {
                  for (var i = 1; i < animationsData.length; i++) {
                    animationsData[i]();
                  }
                  element.removeData(ANIMATE_TIMER_KEY);
                }
              }
            }
          };
        }];
      }];
      var $$AnimateCssDriverProvider = ['$$animationProvider', function($$animationProvider) {
        $$animationProvider.drivers.push('$$animateCssDriver');
        var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';
        var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';
        var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';
        var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';
        function isDocumentFragment(node) {
          return node.parentNode && node.parentNode.nodeType === 11;
        }
        this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$sniffer', '$$jqLite', '$document', function($animateCss, $rootScope, $$AnimateRunner, $rootElement, $sniffer, $$jqLite, $document) {
          if (!$sniffer.animations && !$sniffer.transitions)
            return noop;
          var bodyNode = $document[0].body;
          var rootNode = getDomNode($rootElement);
          var rootBodyElement = jqLite(isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode);
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          return function initDriverFn(animationDetails) {
            return animationDetails.from && animationDetails.to ? prepareFromToAnchorAnimation(animationDetails.from, animationDetails.to, animationDetails.classes, animationDetails.anchors) : prepareRegularAnimation(animationDetails);
          };
          function filterCssClasses(classes) {
            return classes.replace(/\bng-\S+\b/g, '');
          }
          function getUniqueValues(a, b) {
            if (isString(a))
              a = a.split(' ');
            if (isString(b))
              b = b.split(' ');
            return a.filter(function(val) {
              return b.indexOf(val) === -1;
            }).join(' ');
          }
          function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {
            var clone = jqLite(getDomNode(outAnchor).cloneNode(true));
            var startingClasses = filterCssClasses(getClassVal(clone));
            outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
            inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
            clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);
            rootBodyElement.append(clone);
            var animatorIn,
                animatorOut = prepareOutAnimation();
            if (!animatorOut) {
              animatorIn = prepareInAnimation();
              if (!animatorIn) {
                return end();
              }
            }
            var startingAnimator = animatorOut || animatorIn;
            return {start: function() {
                var runner;
                var currentAnimation = startingAnimator.start();
                currentAnimation.done(function() {
                  currentAnimation = null;
                  if (!animatorIn) {
                    animatorIn = prepareInAnimation();
                    if (animatorIn) {
                      currentAnimation = animatorIn.start();
                      currentAnimation.done(function() {
                        currentAnimation = null;
                        end();
                        runner.complete();
                      });
                      return currentAnimation;
                    }
                  }
                  end();
                  runner.complete();
                });
                runner = new $$AnimateRunner({
                  end: endFn,
                  cancel: endFn
                });
                return runner;
                function endFn() {
                  if (currentAnimation) {
                    currentAnimation.end();
                  }
                }
              }};
            function calculateAnchorStyles(anchor) {
              var styles = {};
              var coords = getDomNode(anchor).getBoundingClientRect();
              forEach(['width', 'height', 'top', 'left'], function(key) {
                var value = coords[key];
                switch (key) {
                  case 'top':
                    value += bodyNode.scrollTop;
                    break;
                  case 'left':
                    value += bodyNode.scrollLeft;
                    break;
                }
                styles[key] = Math.floor(value) + 'px';
              });
              return styles;
            }
            function prepareOutAnimation() {
              var animator = $animateCss(clone, {
                addClass: NG_OUT_ANCHOR_CLASS_NAME,
                delay: true,
                from: calculateAnchorStyles(outAnchor)
              });
              return animator.$$willAnimate ? animator : null;
            }
            function getClassVal(element) {
              return element.attr('class') || '';
            }
            function prepareInAnimation() {
              var endingClasses = filterCssClasses(getClassVal(inAnchor));
              var toAdd = getUniqueValues(endingClasses, startingClasses);
              var toRemove = getUniqueValues(startingClasses, endingClasses);
              var animator = $animateCss(clone, {
                to: calculateAnchorStyles(inAnchor),
                addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,
                removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,
                delay: true
              });
              return animator.$$willAnimate ? animator : null;
            }
            function end() {
              clone.remove();
              outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
              inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
            }
          }
          function prepareFromToAnchorAnimation(from, to, classes, anchors) {
            var fromAnimation = prepareRegularAnimation(from, noop);
            var toAnimation = prepareRegularAnimation(to, noop);
            var anchorAnimations = [];
            forEach(anchors, function(anchor) {
              var outElement = anchor['out'];
              var inElement = anchor['in'];
              var animator = prepareAnchoredAnimation(classes, outElement, inElement);
              if (animator) {
                anchorAnimations.push(animator);
              }
            });
            if (!fromAnimation && !toAnimation && anchorAnimations.length === 0)
              return;
            return {start: function() {
                var animationRunners = [];
                if (fromAnimation) {
                  animationRunners.push(fromAnimation.start());
                }
                if (toAnimation) {
                  animationRunners.push(toAnimation.start());
                }
                forEach(anchorAnimations, function(animation) {
                  animationRunners.push(animation.start());
                });
                var runner = new $$AnimateRunner({
                  end: endFn,
                  cancel: endFn
                });
                $$AnimateRunner.all(animationRunners, function(status) {
                  runner.complete(status);
                });
                return runner;
                function endFn() {
                  forEach(animationRunners, function(runner) {
                    runner.end();
                  });
                }
              }};
          }
          function prepareRegularAnimation(animationDetails) {
            var element = animationDetails.element;
            var options = animationDetails.options || {};
            if (animationDetails.structural) {
              options.event = animationDetails.event;
              options.structural = true;
              options.applyClassesEarly = true;
              if (animationDetails.event === 'leave') {
                options.onDone = options.domOperation;
              }
            }
            if (options.preparationClasses) {
              options.event = concatWithSpace(options.event, options.preparationClasses);
            }
            var animator = $animateCss(element, options);
            return animator.$$willAnimate ? animator : null;
          }
        }];
      }];
      var $$AnimateJsProvider = ['$animateProvider', function($animateProvider) {
        this.$get = ['$injector', '$$AnimateRunner', '$$jqLite', function($injector, $$AnimateRunner, $$jqLite) {
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          return function(element, event, classes, options) {
            var animationClosed = false;
            if (arguments.length === 3 && isObject(classes)) {
              options = classes;
              classes = null;
            }
            options = prepareAnimationOptions(options);
            if (!classes) {
              classes = element.attr('class') || '';
              if (options.addClass) {
                classes += ' ' + options.addClass;
              }
              if (options.removeClass) {
                classes += ' ' + options.removeClass;
              }
            }
            var classesToAdd = options.addClass;
            var classesToRemove = options.removeClass;
            var animations = lookupAnimations(classes);
            var before,
                after;
            if (animations.length) {
              var afterFn,
                  beforeFn;
              if (event == 'leave') {
                beforeFn = 'leave';
                afterFn = 'afterLeave';
              } else {
                beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);
                afterFn = event;
              }
              if (event !== 'enter' && event !== 'move') {
                before = packageAnimations(element, event, options, animations, beforeFn);
              }
              after = packageAnimations(element, event, options, animations, afterFn);
            }
            if (!before && !after)
              return;
            function applyOptions() {
              options.domOperation();
              applyAnimationClasses(element, options);
            }
            function close() {
              animationClosed = true;
              applyOptions();
              applyAnimationStyles(element, options);
            }
            var runner;
            return {
              $$willAnimate: true,
              end: function() {
                if (runner) {
                  runner.end();
                } else {
                  close();
                  runner = new $$AnimateRunner();
                  runner.complete(true);
                }
                return runner;
              },
              start: function() {
                if (runner) {
                  return runner;
                }
                runner = new $$AnimateRunner();
                var closeActiveAnimations;
                var chain = [];
                if (before) {
                  chain.push(function(fn) {
                    closeActiveAnimations = before(fn);
                  });
                }
                if (chain.length) {
                  chain.push(function(fn) {
                    applyOptions();
                    fn(true);
                  });
                } else {
                  applyOptions();
                }
                if (after) {
                  chain.push(function(fn) {
                    closeActiveAnimations = after(fn);
                  });
                }
                runner.setHost({
                  end: function() {
                    endAnimations();
                  },
                  cancel: function() {
                    endAnimations(true);
                  }
                });
                $$AnimateRunner.chain(chain, onComplete);
                return runner;
                function onComplete(success) {
                  close(success);
                  runner.complete(success);
                }
                function endAnimations(cancelled) {
                  if (!animationClosed) {
                    (closeActiveAnimations || noop)(cancelled);
                    onComplete(cancelled);
                  }
                }
              }
            };
            function executeAnimationFn(fn, element, event, options, onDone) {
              var args;
              switch (event) {
                case 'animate':
                  args = [element, options.from, options.to, onDone];
                  break;
                case 'setClass':
                  args = [element, classesToAdd, classesToRemove, onDone];
                  break;
                case 'addClass':
                  args = [element, classesToAdd, onDone];
                  break;
                case 'removeClass':
                  args = [element, classesToRemove, onDone];
                  break;
                default:
                  args = [element, onDone];
                  break;
              }
              args.push(options);
              var value = fn.apply(fn, args);
              if (value) {
                if (isFunction(value.start)) {
                  value = value.start();
                }
                if (value instanceof $$AnimateRunner) {
                  value.done(onDone);
                } else if (isFunction(value)) {
                  return value;
                }
              }
              return noop;
            }
            function groupEventedAnimations(element, event, options, animations, fnName) {
              var operations = [];
              forEach(animations, function(ani) {
                var animation = ani[fnName];
                if (!animation)
                  return;
                operations.push(function() {
                  var runner;
                  var endProgressCb;
                  var resolved = false;
                  var onAnimationComplete = function(rejected) {
                    if (!resolved) {
                      resolved = true;
                      (endProgressCb || noop)(rejected);
                      runner.complete(!rejected);
                    }
                  };
                  runner = new $$AnimateRunner({
                    end: function() {
                      onAnimationComplete();
                    },
                    cancel: function() {
                      onAnimationComplete(true);
                    }
                  });
                  endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {
                    var cancelled = result === false;
                    onAnimationComplete(cancelled);
                  });
                  return runner;
                });
              });
              return operations;
            }
            function packageAnimations(element, event, options, animations, fnName) {
              var operations = groupEventedAnimations(element, event, options, animations, fnName);
              if (operations.length === 0) {
                var a,
                    b;
                if (fnName === 'beforeSetClass') {
                  a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');
                  b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');
                } else if (fnName === 'setClass') {
                  a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');
                  b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');
                }
                if (a) {
                  operations = operations.concat(a);
                }
                if (b) {
                  operations = operations.concat(b);
                }
              }
              if (operations.length === 0)
                return;
              return function startAnimation(callback) {
                var runners = [];
                if (operations.length) {
                  forEach(operations, function(animateFn) {
                    runners.push(animateFn());
                  });
                }
                runners.length ? $$AnimateRunner.all(runners, callback) : callback();
                return function endFn(reject) {
                  forEach(runners, function(runner) {
                    reject ? runner.cancel() : runner.end();
                  });
                };
              };
            }
          };
          function lookupAnimations(classes) {
            classes = isArray(classes) ? classes : classes.split(' ');
            var matches = [],
                flagMap = {};
            for (var i = 0; i < classes.length; i++) {
              var klass = classes[i],
                  animationFactory = $animateProvider.$$registeredAnimations[klass];
              if (animationFactory && !flagMap[klass]) {
                matches.push($injector.get(animationFactory));
                flagMap[klass] = true;
              }
            }
            return matches;
          }
        }];
      }];
      var $$AnimateJsDriverProvider = ['$$animationProvider', function($$animationProvider) {
        $$animationProvider.drivers.push('$$animateJsDriver');
        this.$get = ['$$animateJs', '$$AnimateRunner', function($$animateJs, $$AnimateRunner) {
          return function initDriverFn(animationDetails) {
            if (animationDetails.from && animationDetails.to) {
              var fromAnimation = prepareAnimation(animationDetails.from);
              var toAnimation = prepareAnimation(animationDetails.to);
              if (!fromAnimation && !toAnimation)
                return;
              return {start: function() {
                  var animationRunners = [];
                  if (fromAnimation) {
                    animationRunners.push(fromAnimation.start());
                  }
                  if (toAnimation) {
                    animationRunners.push(toAnimation.start());
                  }
                  $$AnimateRunner.all(animationRunners, done);
                  var runner = new $$AnimateRunner({
                    end: endFnFactory(),
                    cancel: endFnFactory()
                  });
                  return runner;
                  function endFnFactory() {
                    return function() {
                      forEach(animationRunners, function(runner) {
                        runner.end();
                      });
                    };
                  }
                  function done(status) {
                    runner.complete(status);
                  }
                }};
            } else {
              return prepareAnimation(animationDetails);
            }
          };
          function prepareAnimation(animationDetails) {
            var element = animationDetails.element;
            var event = animationDetails.event;
            var options = animationDetails.options;
            var classes = animationDetails.classes;
            return $$animateJs(element, event, classes, options);
          }
        }];
      }];
      var NG_ANIMATE_ATTR_NAME = 'data-ng-animate';
      var NG_ANIMATE_PIN_DATA = '$ngAnimatePin';
      var $$AnimateQueueProvider = ['$animateProvider', function($animateProvider) {
        var PRE_DIGEST_STATE = 1;
        var RUNNING_STATE = 2;
        var ONE_SPACE = ' ';
        var rules = this.rules = {
          skip: [],
          cancel: [],
          join: []
        };
        function makeTruthyCssClassMap(classString) {
          if (!classString) {
            return null;
          }
          var keys = classString.split(ONE_SPACE);
          var map = Object.create(null);
          forEach(keys, function(key) {
            map[key] = true;
          });
          return map;
        }
        function hasMatchingClasses(newClassString, currentClassString) {
          if (newClassString && currentClassString) {
            var currentClassMap = makeTruthyCssClassMap(currentClassString);
            return newClassString.split(ONE_SPACE).some(function(className) {
              return currentClassMap[className];
            });
          }
        }
        function isAllowed(ruleType, element, currentAnimation, previousAnimation) {
          return rules[ruleType].some(function(fn) {
            return fn(element, currentAnimation, previousAnimation);
          });
        }
        function hasAnimationClasses(animation, and) {
          var a = (animation.addClass || '').length > 0;
          var b = (animation.removeClass || '').length > 0;
          return and ? a && b : a || b;
        }
        rules.join.push(function(element, newAnimation, currentAnimation) {
          return !newAnimation.structural && hasAnimationClasses(newAnimation);
        });
        rules.skip.push(function(element, newAnimation, currentAnimation) {
          return !newAnimation.structural && !hasAnimationClasses(newAnimation);
        });
        rules.skip.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.event == 'leave' && newAnimation.structural;
        });
        rules.skip.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;
        });
        rules.cancel.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.structural && newAnimation.structural;
        });
        rules.cancel.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.state === RUNNING_STATE && newAnimation.structural;
        });
        rules.cancel.push(function(element, newAnimation, currentAnimation) {
          if (currentAnimation.structural)
            return false;
          var nA = newAnimation.addClass;
          var nR = newAnimation.removeClass;
          var cA = currentAnimation.addClass;
          var cR = currentAnimation.removeClass;
          if ((isUndefined(nA) && isUndefined(nR)) || (isUndefined(cA) && isUndefined(cR))) {
            return false;
          }
          return hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA);
        });
        this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$HashMap', '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', '$$forceReflow', function($$rAF, $rootScope, $rootElement, $document, $$HashMap, $$animation, $$AnimateRunner, $templateRequest, $$jqLite, $$forceReflow) {
          var activeAnimationsLookup = new $$HashMap();
          var disabledElementsLookup = new $$HashMap();
          var animationsEnabled = null;
          function postDigestTaskFactory() {
            var postDigestCalled = false;
            return function(fn) {
              if (postDigestCalled) {
                fn();
              } else {
                $rootScope.$$postDigest(function() {
                  postDigestCalled = true;
                  fn();
                });
              }
            };
          }
          var deregisterWatch = $rootScope.$watch(function() {
            return $templateRequest.totalPendingRequests === 0;
          }, function(isEmpty) {
            if (!isEmpty)
              return;
            deregisterWatch();
            $rootScope.$$postDigest(function() {
              $rootScope.$$postDigest(function() {
                if (animationsEnabled === null) {
                  animationsEnabled = true;
                }
              });
            });
          });
          var callbackRegistry = Object.create(null);
          var classNameFilter = $animateProvider.classNameFilter();
          var isAnimatableClassName = !classNameFilter ? function() {
            return true;
          } : function(className) {
            return classNameFilter.test(className);
          };
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          function normalizeAnimationDetails(element, animation) {
            return mergeAnimationDetails(element, animation, {});
          }
          var contains = window.Node.prototype.contains || function(arg) {
            return this === arg || !!(this.compareDocumentPosition(arg) & 16);
          };
          function findCallbacks(parent, element, event) {
            var targetNode = getDomNode(element);
            var targetParentNode = getDomNode(parent);
            var matches = [];
            var entries = callbackRegistry[event];
            if (entries) {
              forEach(entries, function(entry) {
                if (contains.call(entry.node, targetNode)) {
                  matches.push(entry.callback);
                } else if (event === 'leave' && contains.call(entry.node, targetParentNode)) {
                  matches.push(entry.callback);
                }
              });
            }
            return matches;
          }
          function filterFromRegistry(list, matchContainer, matchCallback) {
            var containerNode = extractElementNode(matchContainer);
            return list.filter(function(entry) {
              var isMatch = entry.node === containerNode && (!matchCallback || entry.callback === matchCallback);
              return !isMatch;
            });
          }
          function cleanupEventListeners(phase, element) {
            if (phase === 'close' && !element[0].parentNode) {
              $animate.off(element);
            }
          }
          var $animate = {
            on: function(event, container, callback) {
              var node = extractElementNode(container);
              callbackRegistry[event] = callbackRegistry[event] || [];
              callbackRegistry[event].push({
                node: node,
                callback: callback
              });
              jqLite(container).on('$destroy', function() {
                var animationDetails = activeAnimationsLookup.get(node);
                if (!animationDetails) {
                  $animate.off(event, container, callback);
                }
              });
            },
            off: function(event, container, callback) {
              if (arguments.length === 1 && !isString(arguments[0])) {
                container = arguments[0];
                for (var eventType in callbackRegistry) {
                  callbackRegistry[eventType] = filterFromRegistry(callbackRegistry[eventType], container);
                }
                return;
              }
              var entries = callbackRegistry[event];
              if (!entries)
                return;
              callbackRegistry[event] = arguments.length === 1 ? null : filterFromRegistry(entries, container, callback);
            },
            pin: function(element, parentElement) {
              assertArg(isElement(element), 'element', 'not an element');
              assertArg(isElement(parentElement), 'parentElement', 'not an element');
              element.data(NG_ANIMATE_PIN_DATA, parentElement);
            },
            push: function(element, event, options, domOperation) {
              options = options || {};
              options.domOperation = domOperation;
              return queueAnimation(element, event, options);
            },
            enabled: function(element, bool) {
              var argCount = arguments.length;
              if (argCount === 0) {
                bool = !!animationsEnabled;
              } else {
                var hasElement = isElement(element);
                if (!hasElement) {
                  bool = animationsEnabled = !!element;
                } else {
                  var node = getDomNode(element);
                  if (argCount === 1) {
                    bool = !disabledElementsLookup.get(node);
                  } else {
                    disabledElementsLookup.put(node, !bool);
                  }
                }
              }
              return bool;
            }
          };
          return $animate;
          function queueAnimation(element, event, initialOptions) {
            var options = copy(initialOptions);
            var node,
                parent;
            element = stripCommentsFromElement(element);
            if (element) {
              node = getDomNode(element);
              parent = element.parent();
            }
            options = prepareAnimationOptions(options);
            var runner = new $$AnimateRunner();
            var runInNextPostDigestOrNow = postDigestTaskFactory();
            if (isArray(options.addClass)) {
              options.addClass = options.addClass.join(' ');
            }
            if (options.addClass && !isString(options.addClass)) {
              options.addClass = null;
            }
            if (isArray(options.removeClass)) {
              options.removeClass = options.removeClass.join(' ');
            }
            if (options.removeClass && !isString(options.removeClass)) {
              options.removeClass = null;
            }
            if (options.from && !isObject(options.from)) {
              options.from = null;
            }
            if (options.to && !isObject(options.to)) {
              options.to = null;
            }
            if (!node) {
              close();
              return runner;
            }
            var className = [node.className, options.addClass, options.removeClass].join(' ');
            if (!isAnimatableClassName(className)) {
              close();
              return runner;
            }
            var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;
            var documentHidden = $document[0].hidden;
            var skipAnimations = !animationsEnabled || documentHidden || disabledElementsLookup.get(node);
            var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};
            var hasExistingAnimation = !!existingAnimation.state;
            if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state != PRE_DIGEST_STATE)) {
              skipAnimations = !areAnimationsAllowed(element, parent, event);
            }
            if (skipAnimations) {
              if (documentHidden)
                notifyProgress(runner, event, 'start');
              close();
              if (documentHidden)
                notifyProgress(runner, event, 'close');
              return runner;
            }
            if (isStructural) {
              closeChildAnimations(element);
            }
            var newAnimation = {
              structural: isStructural,
              element: element,
              event: event,
              addClass: options.addClass,
              removeClass: options.removeClass,
              close: close,
              options: options,
              runner: runner
            };
            if (hasExistingAnimation) {
              var skipAnimationFlag = isAllowed('skip', element, newAnimation, existingAnimation);
              if (skipAnimationFlag) {
                if (existingAnimation.state === RUNNING_STATE) {
                  close();
                  return runner;
                } else {
                  mergeAnimationDetails(element, existingAnimation, newAnimation);
                  return existingAnimation.runner;
                }
              }
              var cancelAnimationFlag = isAllowed('cancel', element, newAnimation, existingAnimation);
              if (cancelAnimationFlag) {
                if (existingAnimation.state === RUNNING_STATE) {
                  existingAnimation.runner.end();
                } else if (existingAnimation.structural) {
                  existingAnimation.close();
                } else {
                  mergeAnimationDetails(element, existingAnimation, newAnimation);
                  return existingAnimation.runner;
                }
              } else {
                var joinAnimationFlag = isAllowed('join', element, newAnimation, existingAnimation);
                if (joinAnimationFlag) {
                  if (existingAnimation.state === RUNNING_STATE) {
                    normalizeAnimationDetails(element, newAnimation);
                  } else {
                    applyGeneratedPreparationClasses(element, isStructural ? event : null, options);
                    event = newAnimation.event = existingAnimation.event;
                    options = mergeAnimationDetails(element, existingAnimation, newAnimation);
                    return existingAnimation.runner;
                  }
                }
              }
            } else {
              normalizeAnimationDetails(element, newAnimation);
            }
            var isValidAnimation = newAnimation.structural;
            if (!isValidAnimation) {
              isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0) || hasAnimationClasses(newAnimation);
            }
            if (!isValidAnimation) {
              close();
              clearElementAnimationState(element);
              return runner;
            }
            var counter = (existingAnimation.counter || 0) + 1;
            newAnimation.counter = counter;
            markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);
            $rootScope.$$postDigest(function() {
              var animationDetails = activeAnimationsLookup.get(node);
              var animationCancelled = !animationDetails;
              animationDetails = animationDetails || {};
              var parentElement = element.parent() || [];
              var isValidAnimation = parentElement.length > 0 && (animationDetails.event === 'animate' || animationDetails.structural || hasAnimationClasses(animationDetails));
              if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {
                if (animationCancelled) {
                  applyAnimationClasses(element, options);
                  applyAnimationStyles(element, options);
                }
                if (animationCancelled || (isStructural && animationDetails.event !== event)) {
                  options.domOperation();
                  runner.end();
                }
                if (!isValidAnimation) {
                  clearElementAnimationState(element);
                }
                return;
              }
              event = !animationDetails.structural && hasAnimationClasses(animationDetails, true) ? 'setClass' : animationDetails.event;
              markElementAnimationState(element, RUNNING_STATE);
              var realRunner = $$animation(element, event, animationDetails.options);
              runner.setHost(realRunner);
              notifyProgress(runner, event, 'start', {});
              realRunner.done(function(status) {
                close(!status);
                var animationDetails = activeAnimationsLookup.get(node);
                if (animationDetails && animationDetails.counter === counter) {
                  clearElementAnimationState(getDomNode(element));
                }
                notifyProgress(runner, event, 'close', {});
              });
            });
            return runner;
            function notifyProgress(runner, event, phase, data) {
              runInNextPostDigestOrNow(function() {
                var callbacks = findCallbacks(parent, element, event);
                if (callbacks.length) {
                  $$rAF(function() {
                    forEach(callbacks, function(callback) {
                      callback(element, phase, data);
                    });
                    cleanupEventListeners(phase, element);
                  });
                } else {
                  cleanupEventListeners(phase, element);
                }
              });
              runner.progress(event, phase, data);
            }
            function close(reject) {
              clearGeneratedClasses(element, options);
              applyAnimationClasses(element, options);
              applyAnimationStyles(element, options);
              options.domOperation();
              runner.complete(!reject);
            }
          }
          function closeChildAnimations(element) {
            var node = getDomNode(element);
            var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');
            forEach(children, function(child) {
              var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME));
              var animationDetails = activeAnimationsLookup.get(child);
              if (animationDetails) {
                switch (state) {
                  case RUNNING_STATE:
                    animationDetails.runner.end();
                  case PRE_DIGEST_STATE:
                    activeAnimationsLookup.remove(child);
                    break;
                }
              }
            });
          }
          function clearElementAnimationState(element) {
            var node = getDomNode(element);
            node.removeAttribute(NG_ANIMATE_ATTR_NAME);
            activeAnimationsLookup.remove(node);
          }
          function isMatchingElement(nodeOrElmA, nodeOrElmB) {
            return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);
          }
          function areAnimationsAllowed(element, parentElement, event) {
            var bodyElement = jqLite($document[0].body);
            var bodyElementDetected = isMatchingElement(element, bodyElement) || element[0].nodeName === 'HTML';
            var rootElementDetected = isMatchingElement(element, $rootElement);
            var parentAnimationDetected = false;
            var animateChildren;
            var elementDisabled = disabledElementsLookup.get(getDomNode(element));
            var parentHost = jqLite.data(element[0], NG_ANIMATE_PIN_DATA);
            if (parentHost) {
              parentElement = parentHost;
            }
            parentElement = getDomNode(parentElement);
            while (parentElement) {
              if (!rootElementDetected) {
                rootElementDetected = isMatchingElement(parentElement, $rootElement);
              }
              if (parentElement.nodeType !== ELEMENT_NODE) {
                break;
              }
              var details = activeAnimationsLookup.get(parentElement) || {};
              if (!parentAnimationDetected) {
                var parentElementDisabled = disabledElementsLookup.get(parentElement);
                if (parentElementDisabled === true && elementDisabled !== false) {
                  elementDisabled = true;
                  break;
                } else if (parentElementDisabled === false) {
                  elementDisabled = false;
                }
                parentAnimationDetected = details.structural;
              }
              if (isUndefined(animateChildren) || animateChildren === true) {
                var value = jqLite.data(parentElement, NG_ANIMATE_CHILDREN_DATA);
                if (isDefined(value)) {
                  animateChildren = value;
                }
              }
              if (parentAnimationDetected && animateChildren === false)
                break;
              if (!bodyElementDetected) {
                bodyElementDetected = isMatchingElement(parentElement, bodyElement);
              }
              if (bodyElementDetected && rootElementDetected) {
                break;
              }
              if (!rootElementDetected) {
                parentHost = jqLite.data(parentElement, NG_ANIMATE_PIN_DATA);
                if (parentHost) {
                  parentElement = getDomNode(parentHost);
                  continue;
                }
              }
              parentElement = parentElement.parentNode;
            }
            var allowAnimation = (!parentAnimationDetected || animateChildren) && elementDisabled !== true;
            return allowAnimation && rootElementDetected && bodyElementDetected;
          }
          function markElementAnimationState(element, state, details) {
            details = details || {};
            details.state = state;
            var node = getDomNode(element);
            node.setAttribute(NG_ANIMATE_ATTR_NAME, state);
            var oldValue = activeAnimationsLookup.get(node);
            var newValue = oldValue ? extend(oldValue, details) : details;
            activeAnimationsLookup.put(node, newValue);
          }
        }];
      }];
      var $$AnimationProvider = ['$animateProvider', function($animateProvider) {
        var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';
        var drivers = this.drivers = [];
        var RUNNER_STORAGE_KEY = '$$animationRunner';
        function setRunner(element, runner) {
          element.data(RUNNER_STORAGE_KEY, runner);
        }
        function removeRunner(element) {
          element.removeData(RUNNER_STORAGE_KEY);
        }
        function getRunner(element) {
          return element.data(RUNNER_STORAGE_KEY);
        }
        this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$HashMap', '$$rAFScheduler', function($$jqLite, $rootScope, $injector, $$AnimateRunner, $$HashMap, $$rAFScheduler) {
          var animationQueue = [];
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          function sortAnimations(animations) {
            var tree = {children: []};
            var i,
                lookup = new $$HashMap();
            for (i = 0; i < animations.length; i++) {
              var animation = animations[i];
              lookup.put(animation.domNode, animations[i] = {
                domNode: animation.domNode,
                fn: animation.fn,
                children: []
              });
            }
            for (i = 0; i < animations.length; i++) {
              processNode(animations[i]);
            }
            return flatten(tree);
            function processNode(entry) {
              if (entry.processed)
                return entry;
              entry.processed = true;
              var elementNode = entry.domNode;
              var parentNode = elementNode.parentNode;
              lookup.put(elementNode, entry);
              var parentEntry;
              while (parentNode) {
                parentEntry = lookup.get(parentNode);
                if (parentEntry) {
                  if (!parentEntry.processed) {
                    parentEntry = processNode(parentEntry);
                  }
                  break;
                }
                parentNode = parentNode.parentNode;
              }
              (parentEntry || tree).children.push(entry);
              return entry;
            }
            function flatten(tree) {
              var result = [];
              var queue = [];
              var i;
              for (i = 0; i < tree.children.length; i++) {
                queue.push(tree.children[i]);
              }
              var remainingLevelEntries = queue.length;
              var nextLevelEntries = 0;
              var row = [];
              for (i = 0; i < queue.length; i++) {
                var entry = queue[i];
                if (remainingLevelEntries <= 0) {
                  remainingLevelEntries = nextLevelEntries;
                  nextLevelEntries = 0;
                  result.push(row);
                  row = [];
                }
                row.push(entry.fn);
                entry.children.forEach(function(childEntry) {
                  nextLevelEntries++;
                  queue.push(childEntry);
                });
                remainingLevelEntries--;
              }
              if (row.length) {
                result.push(row);
              }
              return result;
            }
          }
          return function(element, event, options) {
            options = prepareAnimationOptions(options);
            var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;
            var runner = new $$AnimateRunner({
              end: function() {
                close();
              },
              cancel: function() {
                close(true);
              }
            });
            if (!drivers.length) {
              close();
              return runner;
            }
            setRunner(element, runner);
            var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));
            var tempClasses = options.tempClasses;
            if (tempClasses) {
              classes += ' ' + tempClasses;
              options.tempClasses = null;
            }
            var prepareClassName;
            if (isStructural) {
              prepareClassName = 'ng-' + event + PREPARE_CLASS_SUFFIX;
              $$jqLite.addClass(element, prepareClassName);
            }
            animationQueue.push({
              element: element,
              classes: classes,
              event: event,
              structural: isStructural,
              options: options,
              beforeStart: beforeStart,
              close: close
            });
            element.on('$destroy', handleDestroyedElement);
            if (animationQueue.length > 1)
              return runner;
            $rootScope.$$postDigest(function() {
              var animations = [];
              forEach(animationQueue, function(entry) {
                if (getRunner(entry.element)) {
                  animations.push(entry);
                } else {
                  entry.close();
                }
              });
              animationQueue.length = 0;
              var groupedAnimations = groupAnimations(animations);
              var toBeSortedAnimations = [];
              forEach(groupedAnimations, function(animationEntry) {
                toBeSortedAnimations.push({
                  domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),
                  fn: function triggerAnimationStart() {
                    animationEntry.beforeStart();
                    var startAnimationFn,
                        closeFn = animationEntry.close;
                    var targetElement = animationEntry.anchors ? (animationEntry.from.element || animationEntry.to.element) : animationEntry.element;
                    if (getRunner(targetElement)) {
                      var operation = invokeFirstDriver(animationEntry);
                      if (operation) {
                        startAnimationFn = operation.start;
                      }
                    }
                    if (!startAnimationFn) {
                      closeFn();
                    } else {
                      var animationRunner = startAnimationFn();
                      animationRunner.done(function(status) {
                        closeFn(!status);
                      });
                      updateAnimationRunners(animationEntry, animationRunner);
                    }
                  }
                });
              });
              $$rAFScheduler(sortAnimations(toBeSortedAnimations));
            });
            return runner;
            function getAnchorNodes(node) {
              var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';
              var items = node.hasAttribute(NG_ANIMATE_REF_ATTR) ? [node] : node.querySelectorAll(SELECTOR);
              var anchors = [];
              forEach(items, function(node) {
                var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);
                if (attr && attr.length) {
                  anchors.push(node);
                }
              });
              return anchors;
            }
            function groupAnimations(animations) {
              var preparedAnimations = [];
              var refLookup = {};
              forEach(animations, function(animation, index) {
                var element = animation.element;
                var node = getDomNode(element);
                var event = animation.event;
                var enterOrMove = ['enter', 'move'].indexOf(event) >= 0;
                var anchorNodes = animation.structural ? getAnchorNodes(node) : [];
                if (anchorNodes.length) {
                  var direction = enterOrMove ? 'to' : 'from';
                  forEach(anchorNodes, function(anchor) {
                    var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);
                    refLookup[key] = refLookup[key] || {};
                    refLookup[key][direction] = {
                      animationID: index,
                      element: jqLite(anchor)
                    };
                  });
                } else {
                  preparedAnimations.push(animation);
                }
              });
              var usedIndicesLookup = {};
              var anchorGroups = {};
              forEach(refLookup, function(operations, key) {
                var from = operations.from;
                var to = operations.to;
                if (!from || !to) {
                  var index = from ? from.animationID : to.animationID;
                  var indexKey = index.toString();
                  if (!usedIndicesLookup[indexKey]) {
                    usedIndicesLookup[indexKey] = true;
                    preparedAnimations.push(animations[index]);
                  }
                  return;
                }
                var fromAnimation = animations[from.animationID];
                var toAnimation = animations[to.animationID];
                var lookupKey = from.animationID.toString();
                if (!anchorGroups[lookupKey]) {
                  var group = anchorGroups[lookupKey] = {
                    structural: true,
                    beforeStart: function() {
                      fromAnimation.beforeStart();
                      toAnimation.beforeStart();
                    },
                    close: function() {
                      fromAnimation.close();
                      toAnimation.close();
                    },
                    classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),
                    from: fromAnimation,
                    to: toAnimation,
                    anchors: []
                  };
                  if (group.classes.length) {
                    preparedAnimations.push(group);
                  } else {
                    preparedAnimations.push(fromAnimation);
                    preparedAnimations.push(toAnimation);
                  }
                }
                anchorGroups[lookupKey].anchors.push({
                  'out': from.element,
                  'in': to.element
                });
              });
              return preparedAnimations;
            }
            function cssClassesIntersection(a, b) {
              a = a.split(' ');
              b = b.split(' ');
              var matches = [];
              for (var i = 0; i < a.length; i++) {
                var aa = a[i];
                if (aa.substring(0, 3) === 'ng-')
                  continue;
                for (var j = 0; j < b.length; j++) {
                  if (aa === b[j]) {
                    matches.push(aa);
                    break;
                  }
                }
              }
              return matches.join(' ');
            }
            function invokeFirstDriver(animationDetails) {
              for (var i = drivers.length - 1; i >= 0; i--) {
                var driverName = drivers[i];
                var factory = $injector.get(driverName);
                var driver = factory(animationDetails);
                if (driver) {
                  return driver;
                }
              }
            }
            function beforeStart() {
              element.addClass(NG_ANIMATE_CLASSNAME);
              if (tempClasses) {
                $$jqLite.addClass(element, tempClasses);
              }
              if (prepareClassName) {
                $$jqLite.removeClass(element, prepareClassName);
                prepareClassName = null;
              }
            }
            function updateAnimationRunners(animation, newRunner) {
              if (animation.from && animation.to) {
                update(animation.from.element);
                update(animation.to.element);
              } else {
                update(animation.element);
              }
              function update(element) {
                var runner = getRunner(element);
                if (runner)
                  runner.setHost(newRunner);
              }
            }
            function handleDestroyedElement() {
              var runner = getRunner(element);
              if (runner && (event !== 'leave' || !options.$$domOperationFired)) {
                runner.end();
              }
            }
            function close(rejected) {
              element.off('$destroy', handleDestroyedElement);
              removeRunner(element);
              applyAnimationClasses(element, options);
              applyAnimationStyles(element, options);
              options.domOperation();
              if (tempClasses) {
                $$jqLite.removeClass(element, tempClasses);
              }
              element.removeClass(NG_ANIMATE_CLASSNAME);
              runner.complete(!rejected);
            }
          };
        }];
      }];
      var ngAnimateSwapDirective = ['$animate', '$rootScope', function($animate, $rootScope) {
        return {
          restrict: 'A',
          transclude: 'element',
          terminal: true,
          priority: 600,
          link: function(scope, $element, attrs, ctrl, $transclude) {
            var previousElement,
                previousScope;
            scope.$watchCollection(attrs.ngAnimateSwap || attrs['for'], function(value) {
              if (previousElement) {
                $animate.leave(previousElement);
              }
              if (previousScope) {
                previousScope.$destroy();
                previousScope = null;
              }
              if (value || value === 0) {
                previousScope = scope.$new();
                $transclude(previousScope, function(element) {
                  previousElement = element;
                  $animate.enter(element, null, $element);
                });
              }
            });
          }
        };
      }];
      var copy;
      var extend;
      var forEach;
      var isArray;
      var isDefined;
      var isElement;
      var isFunction;
      var isObject;
      var isString;
      var isUndefined;
      var jqLite;
      var noop;
      angular.module('ngAnimate', [], function initAngularHelpers() {
        noop = angular.noop;
        copy = angular.copy;
        extend = angular.extend;
        jqLite = angular.element;
        forEach = angular.forEach;
        isArray = angular.isArray;
        isString = angular.isString;
        isObject = angular.isObject;
        isUndefined = angular.isUndefined;
        isDefined = angular.isDefined;
        isFunction = angular.isFunction;
        isElement = angular.isElement;
      }).directive('ngAnimateSwap', ngAnimateSwapDirective).directive('ngAnimateChildren', $$AnimateChildrenDirective).factory('$$rAFScheduler', $$rAFSchedulerFactory).provider('$$animateQueue', $$AnimateQueueProvider).provider('$$animation', $$AnimationProvider).provider('$animateCss', $AnimateCssProvider).provider('$$animateCssDriver', $$AnimateCssDriverProvider).provider('$$animateJs', $$AnimateJsProvider).provider('$$animateJsDriver', $$AnimateJsDriverProvider);
    })(window, window.angular);
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("15", ["13"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('13');
  return module.exports;
});

$__System.registerDynamic("16", ["14"], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    "format global";
    "deps angular";
    (function(window, angular) {
      'use strict';
      var $sanitizeMinErr = angular.$$minErr('$sanitize');
      var bind;
      var extend;
      var forEach;
      var isDefined;
      var lowercase;
      var noop;
      var htmlParser;
      var htmlSanitizeWriter;
      function $SanitizeProvider() {
        var svgEnabled = false;
        this.$get = ['$$sanitizeUri', function($$sanitizeUri) {
          if (svgEnabled) {
            extend(validElements, svgElements);
          }
          return function(html) {
            var buf = [];
            htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {
              return !/^unsafe:/.test($$sanitizeUri(uri, isImage));
            }));
            return buf.join('');
          };
        }];
        this.enableSvg = function(enableSvg) {
          if (isDefined(enableSvg)) {
            svgEnabled = enableSvg;
            return this;
          } else {
            return svgEnabled;
          }
        };
        bind = angular.bind;
        extend = angular.extend;
        forEach = angular.forEach;
        isDefined = angular.isDefined;
        lowercase = angular.lowercase;
        noop = angular.noop;
        htmlParser = htmlParserImpl;
        htmlSanitizeWriter = htmlSanitizeWriterImpl;
        var SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
            NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
        var voidElements = toMap("area,br,col,hr,img,wbr");
        var optionalEndTagBlockElements = toMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
            optionalEndTagInlineElements = toMap("rp,rt"),
            optionalEndTagElements = extend({}, optionalEndTagInlineElements, optionalEndTagBlockElements);
        var blockElements = extend({}, optionalEndTagBlockElements, toMap("address,article," + "aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5," + "h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,section,table,ul"));
        var inlineElements = extend({}, optionalEndTagInlineElements, toMap("a,abbr,acronym,b," + "bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s," + "samp,small,span,strike,strong,sub,sup,time,tt,u,var"));
        var svgElements = toMap("circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph," + "hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline," + "radialGradient,rect,stop,svg,switch,text,title,tspan");
        var blockedElements = toMap("script,style");
        var validElements = extend({}, voidElements, blockElements, inlineElements, optionalEndTagElements);
        var uriAttrs = toMap("background,cite,href,longdesc,src,xlink:href");
        var htmlAttrs = toMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' + 'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' + 'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' + 'scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,' + 'valign,value,vspace,width');
        var svgAttrs = toMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' + 'baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,' + 'cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,' + 'font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,' + 'height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,' + 'marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,' + 'max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,' + 'path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,' + 'requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,' + 'stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,' + 'stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,' + 'stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,' + 'underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,' + 'width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,' + 'xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan', true);
        var validAttrs = extend({}, uriAttrs, svgAttrs, htmlAttrs);
        function toMap(str, lowercaseKeys) {
          var obj = {},
              items = str.split(','),
              i;
          for (i = 0; i < items.length; i++) {
            obj[lowercaseKeys ? lowercase(items[i]) : items[i]] = true;
          }
          return obj;
        }
        var inertBodyElement;
        (function(window) {
          var doc;
          if (window.document && window.document.implementation) {
            doc = window.document.implementation.createHTMLDocument("inert");
          } else {
            throw $sanitizeMinErr('noinert', "Can't create an inert html document");
          }
          var docElement = doc.documentElement || doc.getDocumentElement();
          var bodyElements = docElement.getElementsByTagName('body');
          if (bodyElements.length === 1) {
            inertBodyElement = bodyElements[0];
          } else {
            var html = doc.createElement('html');
            inertBodyElement = doc.createElement('body');
            html.appendChild(inertBodyElement);
            doc.appendChild(html);
          }
        })(window);
        function htmlParserImpl(html, handler) {
          if (html === null || html === undefined) {
            html = '';
          } else if (typeof html !== 'string') {
            html = '' + html;
          }
          inertBodyElement.innerHTML = html;
          var mXSSAttempts = 5;
          do {
            if (mXSSAttempts === 0) {
              throw $sanitizeMinErr('uinput', "Failed to sanitize html because the input is unstable");
            }
            mXSSAttempts--;
            if (window.document.documentMode) {
              stripCustomNsAttrs(inertBodyElement);
            }
            html = inertBodyElement.innerHTML;
            inertBodyElement.innerHTML = html;
          } while (html !== inertBodyElement.innerHTML);
          var node = inertBodyElement.firstChild;
          while (node) {
            switch (node.nodeType) {
              case 1:
                handler.start(node.nodeName.toLowerCase(), attrToMap(node.attributes));
                break;
              case 3:
                handler.chars(node.textContent);
                break;
            }
            var nextNode;
            if (!(nextNode = node.firstChild)) {
              if (node.nodeType == 1) {
                handler.end(node.nodeName.toLowerCase());
              }
              nextNode = node.nextSibling;
              if (!nextNode) {
                while (nextNode == null) {
                  node = node.parentNode;
                  if (node === inertBodyElement)
                    break;
                  nextNode = node.nextSibling;
                  if (node.nodeType == 1) {
                    handler.end(node.nodeName.toLowerCase());
                  }
                }
              }
            }
            node = nextNode;
          }
          while (node = inertBodyElement.firstChild) {
            inertBodyElement.removeChild(node);
          }
        }
        function attrToMap(attrs) {
          var map = {};
          for (var i = 0,
              ii = attrs.length; i < ii; i++) {
            var attr = attrs[i];
            map[attr.name] = attr.value;
          }
          return map;
        }
        function encodeEntities(value) {
          return value.replace(/&/g, '&amp;').replace(SURROGATE_PAIR_REGEXP, function(value) {
            var hi = value.charCodeAt(0);
            var low = value.charCodeAt(1);
            return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';
          }).replace(NON_ALPHANUMERIC_REGEXP, function(value) {
            return '&#' + value.charCodeAt(0) + ';';
          }).replace(/</g, '&lt;').replace(/>/g, '&gt;');
        }
        function htmlSanitizeWriterImpl(buf, uriValidator) {
          var ignoreCurrentElement = false;
          var out = bind(buf, buf.push);
          return {
            start: function(tag, attrs) {
              tag = lowercase(tag);
              if (!ignoreCurrentElement && blockedElements[tag]) {
                ignoreCurrentElement = tag;
              }
              if (!ignoreCurrentElement && validElements[tag] === true) {
                out('<');
                out(tag);
                forEach(attrs, function(value, key) {
                  var lkey = lowercase(key);
                  var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');
                  if (validAttrs[lkey] === true && (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {
                    out(' ');
                    out(key);
                    out('="');
                    out(encodeEntities(value));
                    out('"');
                  }
                });
                out('>');
              }
            },
            end: function(tag) {
              tag = lowercase(tag);
              if (!ignoreCurrentElement && validElements[tag] === true && voidElements[tag] !== true) {
                out('</');
                out(tag);
                out('>');
              }
              if (tag == ignoreCurrentElement) {
                ignoreCurrentElement = false;
              }
            },
            chars: function(chars) {
              if (!ignoreCurrentElement) {
                out(encodeEntities(chars));
              }
            }
          };
        }
        function stripCustomNsAttrs(node) {
          if (node.nodeType === window.Node.ELEMENT_NODE) {
            var attrs = node.attributes;
            for (var i = 0,
                l = attrs.length; i < l; i++) {
              var attrNode = attrs[i];
              var attrName = attrNode.name.toLowerCase();
              if (attrName === 'xmlns:ns1' || attrName.lastIndexOf('ns1:', 0) === 0) {
                node.removeAttributeNode(attrNode);
                i--;
                l--;
              }
            }
          }
          var nextNode = node.firstChild;
          if (nextNode) {
            stripCustomNsAttrs(nextNode);
          }
          nextNode = node.nextSibling;
          if (nextNode) {
            stripCustomNsAttrs(nextNode);
          }
        }
      }
      function sanitizeText(chars) {
        var buf = [];
        var writer = htmlSanitizeWriter(buf, noop);
        writer.chars(chars);
        return buf.join('');
      }
      angular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);
      angular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {
        var LINKY_URL_REGEXP = /((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"\u201d\u2019]/i,
            MAILTO_REGEXP = /^mailto:/i;
        var linkyMinErr = angular.$$minErr('linky');
        var isDefined = angular.isDefined;
        var isFunction = angular.isFunction;
        var isObject = angular.isObject;
        var isString = angular.isString;
        return function(text, target, attributes) {
          if (text == null || text === '')
            return text;
          if (!isString(text))
            throw linkyMinErr('notstring', 'Expected string but received: {0}', text);
          var attributesFn = isFunction(attributes) ? attributes : isObject(attributes) ? function getAttributesObject() {
            return attributes;
          } : function getEmptyAttributesObject() {
            return {};
          };
          var match;
          var raw = text;
          var html = [];
          var url;
          var i;
          while ((match = raw.match(LINKY_URL_REGEXP))) {
            url = match[0];
            if (!match[2] && !match[4]) {
              url = (match[3] ? 'http://' : 'mailto:') + url;
            }
            i = match.index;
            addText(raw.substr(0, i));
            addLink(url, match[0].replace(MAILTO_REGEXP, ''));
            raw = raw.substring(i + match[0].length);
          }
          addText(raw);
          return $sanitize(html.join(''));
          function addText(text) {
            if (!text) {
              return;
            }
            html.push(sanitizeText(text));
          }
          function addLink(url, text) {
            var key,
                linkAttributes = attributesFn(url);
            html.push('<a ');
            for (key in linkAttributes) {
              html.push(key + '="' + linkAttributes[key] + '" ');
            }
            if (isDefined(target) && !('target' in linkAttributes)) {
              html.push('target="', target, '" ');
            }
            html.push('href="', url.replace(/"/g, '&quot;'), '">');
            addText(text);
            html.push('</a>');
          }
        };
      }]);
    })(window, window.angular);
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("17", ["16"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('16');
  return module.exports;
});

$__System.registerDynamic("18", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  if (typeof module !== "undefined" && typeof exports !== "undefined" && module.exports === exports) {
    module.exports = 'ui.router';
  }
  (function(window, angular, undefined) {
    'use strict';
    var isDefined = angular.isDefined,
        isFunction = angular.isFunction,
        isString = angular.isString,
        isObject = angular.isObject,
        isArray = angular.isArray,
        forEach = angular.forEach,
        extend = angular.extend,
        copy = angular.copy;
    function inherit(parent, extra) {
      return extend(new (extend(function() {}, {prototype: parent}))(), extra);
    }
    function merge(dst) {
      forEach(arguments, function(obj) {
        if (obj !== dst) {
          forEach(obj, function(value, key) {
            if (!dst.hasOwnProperty(key))
              dst[key] = value;
          });
        }
      });
      return dst;
    }
    function ancestors(first, second) {
      var path = [];
      for (var n in first.path) {
        if (first.path[n] !== second.path[n])
          break;
        path.push(first.path[n]);
      }
      return path;
    }
    function objectKeys(object) {
      if (Object.keys) {
        return Object.keys(object);
      }
      var result = [];
      angular.forEach(object, function(val, key) {
        result.push(key);
      });
      return result;
    }
    function indexOf(array, value) {
      if (Array.prototype.indexOf) {
        return array.indexOf(value, Number(arguments[2]) || 0);
      }
      var len = array.length >>> 0,
          from = Number(arguments[2]) || 0;
      from = (from < 0) ? Math.ceil(from) : Math.floor(from);
      if (from < 0)
        from += len;
      for (; from < len; from++) {
        if (from in array && array[from] === value)
          return from;
      }
      return -1;
    }
    function inheritParams(currentParams, newParams, $current, $to) {
      var parents = ancestors($current, $to),
          parentParams,
          inherited = {},
          inheritList = [];
      for (var i in parents) {
        if (!parents[i].params)
          continue;
        parentParams = objectKeys(parents[i].params);
        if (!parentParams.length)
          continue;
        for (var j in parentParams) {
          if (indexOf(inheritList, parentParams[j]) >= 0)
            continue;
          inheritList.push(parentParams[j]);
          inherited[parentParams[j]] = currentParams[parentParams[j]];
        }
      }
      return extend({}, inherited, newParams);
    }
    function equalForKeys(a, b, keys) {
      if (!keys) {
        keys = [];
        for (var n in a)
          keys.push(n);
      }
      for (var i = 0; i < keys.length; i++) {
        var k = keys[i];
        if (a[k] != b[k])
          return false;
      }
      return true;
    }
    function filterByKeys(keys, values) {
      var filtered = {};
      forEach(keys, function(name) {
        filtered[name] = values[name];
      });
      return filtered;
    }
    function indexBy(array, propName) {
      var result = {};
      forEach(array, function(item) {
        result[item[propName]] = item;
      });
      return result;
    }
    function pick(obj) {
      var copy = {};
      var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
      forEach(keys, function(key) {
        if (key in obj)
          copy[key] = obj[key];
      });
      return copy;
    }
    function omit(obj) {
      var copy = {};
      var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
      for (var key in obj) {
        if (indexOf(keys, key) == -1)
          copy[key] = obj[key];
      }
      return copy;
    }
    function pluck(collection, key) {
      var result = isArray(collection) ? [] : {};
      forEach(collection, function(val, i) {
        result[i] = isFunction(key) ? key(val) : val[key];
      });
      return result;
    }
    function filter(collection, callback) {
      var array = isArray(collection);
      var result = array ? [] : {};
      forEach(collection, function(val, i) {
        if (callback(val, i)) {
          result[array ? result.length : i] = val;
        }
      });
      return result;
    }
    function map(collection, callback) {
      var result = isArray(collection) ? [] : {};
      forEach(collection, function(val, i) {
        result[i] = callback(val, i);
      });
      return result;
    }
    angular.module('ui.router.util', ['ng']);
    angular.module('ui.router.router', ['ui.router.util']);
    angular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);
    angular.module('ui.router', ['ui.router.state']);
    angular.module('ui.router.compat', ['ui.router']);
    $Resolve.$inject = ['$q', '$injector'];
    function $Resolve($q, $injector) {
      var VISIT_IN_PROGRESS = 1,
          VISIT_DONE = 2,
          NOTHING = {},
          NO_DEPENDENCIES = [],
          NO_LOCALS = NOTHING,
          NO_PARENT = extend($q.when(NOTHING), {
            $$promises: NOTHING,
            $$values: NOTHING
          });
      this.study = function(invocables) {
        if (!isObject(invocables))
          throw new Error("'invocables' must be an object");
        var invocableKeys = objectKeys(invocables || {});
        var plan = [],
            cycle = [],
            visited = {};
        function visit(value, key) {
          if (visited[key] === VISIT_DONE)
            return;
          cycle.push(key);
          if (visited[key] === VISIT_IN_PROGRESS) {
            cycle.splice(0, indexOf(cycle, key));
            throw new Error("Cyclic dependency: " + cycle.join(" -> "));
          }
          visited[key] = VISIT_IN_PROGRESS;
          if (isString(value)) {
            plan.push(key, [function() {
              return $injector.get(value);
            }], NO_DEPENDENCIES);
          } else {
            var params = $injector.annotate(value);
            forEach(params, function(param) {
              if (param !== key && invocables.hasOwnProperty(param))
                visit(invocables[param], param);
            });
            plan.push(key, value, params);
          }
          cycle.pop();
          visited[key] = VISIT_DONE;
        }
        forEach(invocables, visit);
        invocables = cycle = visited = null;
        function isResolve(value) {
          return isObject(value) && value.then && value.$$promises;
        }
        return function(locals, parent, self) {
          if (isResolve(locals) && self === undefined) {
            self = parent;
            parent = locals;
            locals = null;
          }
          if (!locals)
            locals = NO_LOCALS;
          else if (!isObject(locals)) {
            throw new Error("'locals' must be an object");
          }
          if (!parent)
            parent = NO_PARENT;
          else if (!isResolve(parent)) {
            throw new Error("'parent' must be a promise returned by $resolve.resolve()");
          }
          var resolution = $q.defer(),
              result = resolution.promise,
              promises = result.$$promises = {},
              values = extend({}, locals),
              wait = 1 + plan.length / 3,
              merged = false;
          function done() {
            if (!--wait) {
              if (!merged)
                merge(values, parent.$$values);
              result.$$values = values;
              result.$$promises = result.$$promises || true;
              delete result.$$inheritedValues;
              resolution.resolve(values);
            }
          }
          function fail(reason) {
            result.$$failure = reason;
            resolution.reject(reason);
          }
          if (isDefined(parent.$$failure)) {
            fail(parent.$$failure);
            return result;
          }
          if (parent.$$inheritedValues) {
            merge(values, omit(parent.$$inheritedValues, invocableKeys));
          }
          extend(promises, parent.$$promises);
          if (parent.$$values) {
            merged = merge(values, omit(parent.$$values, invocableKeys));
            result.$$inheritedValues = omit(parent.$$values, invocableKeys);
            done();
          } else {
            if (parent.$$inheritedValues) {
              result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);
            }
            parent.then(done, fail);
          }
          for (var i = 0,
              ii = plan.length; i < ii; i += 3) {
            if (locals.hasOwnProperty(plan[i]))
              done();
            else
              invoke(plan[i], plan[i + 1], plan[i + 2]);
          }
          function invoke(key, invocable, params) {
            var invocation = $q.defer(),
                waitParams = 0;
            function onfailure(reason) {
              invocation.reject(reason);
              fail(reason);
            }
            forEach(params, function(dep) {
              if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {
                waitParams++;
                promises[dep].then(function(result) {
                  values[dep] = result;
                  if (!(--waitParams))
                    proceed();
                }, onfailure);
              }
            });
            if (!waitParams)
              proceed();
            function proceed() {
              if (isDefined(result.$$failure))
                return;
              try {
                invocation.resolve($injector.invoke(invocable, self, values));
                invocation.promise.then(function(result) {
                  values[key] = result;
                  done();
                }, onfailure);
              } catch (e) {
                onfailure(e);
              }
            }
            promises[key] = invocation.promise;
          }
          return result;
        };
      };
      this.resolve = function(invocables, locals, parent, self) {
        return this.study(invocables)(locals, parent, self);
      };
    }
    angular.module('ui.router.util').service('$resolve', $Resolve);
    $TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];
    function $TemplateFactory($http, $templateCache, $injector) {
      this.fromConfig = function(config, params, locals) {
        return (isDefined(config.template) ? this.fromString(config.template, params) : isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) : isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) : null);
      };
      this.fromString = function(template, params) {
        return isFunction(template) ? template(params) : template;
      };
      this.fromUrl = function(url, params) {
        if (isFunction(url))
          url = url(params);
        if (url == null)
          return null;
        else
          return $http.get(url, {
            cache: $templateCache,
            headers: {Accept: 'text/html'}
          }).then(function(response) {
            return response.data;
          });
      };
      this.fromProvider = function(provider, params, locals) {
        return $injector.invoke(provider, null, locals || {params: params});
      };
    }
    angular.module('ui.router.util').service('$templateFactory', $TemplateFactory);
    var $$UMFP;
    function UrlMatcher(pattern, config, parentMatcher) {
      config = extend({params: {}}, isObject(config) ? config : {});
      var placeholder = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
          searchPlaceholder = /([:]?)([\w\[\]-]+)|\{([\w\[\]-]+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
          compiled = '^',
          last = 0,
          m,
          segments = this.segments = [],
          parentParams = parentMatcher ? parentMatcher.params : {},
          params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),
          paramNames = [];
      function addParameter(id, type, config, location) {
        paramNames.push(id);
        if (parentParams[id])
          return parentParams[id];
        if (!/^\w+(-+\w+)*(?:\[\])?$/.test(id))
          throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
        if (params[id])
          throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
        params[id] = new $$UMFP.Param(id, type, config, location);
        return params[id];
      }
      function quoteRegExp(string, pattern, squash) {
        var surroundPattern = ['', ''],
            result = string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
        if (!pattern)
          return result;
        switch (squash) {
          case false:
            surroundPattern = ['(', ')'];
            break;
          case true:
            surroundPattern = ['?(', ')?'];
            break;
          default:
            surroundPattern = ['(' + squash + "|", ')?'];
            break;
        }
        return result + surroundPattern[0] + pattern + surroundPattern[1];
      }
      this.source = pattern;
      function matchDetails(m, isSearch) {
        var id,
            regexp,
            segment,
            type,
            cfg,
            arrayMode;
        id = m[2] || m[3];
        cfg = config.params[id];
        segment = pattern.substring(last, m.index);
        regexp = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);
        type = $$UMFP.type(regexp || "string") || inherit($$UMFP.type("string"), {pattern: new RegExp(regexp)});
        return {
          id: id,
          regexp: regexp,
          segment: segment,
          type: type,
          cfg: cfg
        };
      }
      var p,
          param,
          segment;
      while ((m = placeholder.exec(pattern))) {
        p = matchDetails(m, false);
        if (p.segment.indexOf('?') >= 0)
          break;
        param = addParameter(p.id, p.type, p.cfg, "path");
        compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash);
        segments.push(p.segment);
        last = placeholder.lastIndex;
      }
      segment = pattern.substring(last);
      var i = segment.indexOf('?');
      if (i >= 0) {
        var search = this.sourceSearch = segment.substring(i);
        segment = segment.substring(0, i);
        this.sourcePath = pattern.substring(0, last + i);
        if (search.length > 0) {
          last = 0;
          while ((m = searchPlaceholder.exec(search))) {
            p = matchDetails(m, true);
            param = addParameter(p.id, p.type, p.cfg, "search");
            last = placeholder.lastIndex;
          }
        }
      } else {
        this.sourcePath = pattern;
        this.sourceSearch = '';
      }
      compiled += quoteRegExp(segment) + (config.strict === false ? '\/?' : '') + '$';
      segments.push(segment);
      this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);
      this.prefix = segments[0];
      this.$$paramNames = paramNames;
    }
    UrlMatcher.prototype.concat = function(pattern, config) {
      var defaultConfig = {
        caseInsensitive: $$UMFP.caseInsensitive(),
        strict: $$UMFP.strictMode(),
        squash: $$UMFP.defaultSquashPolicy()
      };
      return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);
    };
    UrlMatcher.prototype.toString = function() {
      return this.source;
    };
    UrlMatcher.prototype.exec = function(path, searchParams) {
      var m = this.regexp.exec(path);
      if (!m)
        return null;
      searchParams = searchParams || {};
      var paramNames = this.parameters(),
          nTotal = paramNames.length,
          nPath = this.segments.length - 1,
          values = {},
          i,
          j,
          cfg,
          paramName;
      if (nPath !== m.length - 1)
        throw new Error("Unbalanced capture group in route '" + this.source + "'");
      function decodePathArray(string) {
        function reverseString(str) {
          return str.split("").reverse().join("");
        }
        function unquoteDashes(str) {
          return str.replace(/\\-/, "-");
        }
        var split = reverseString(string).split(/-(?!\\)/);
        var allReversed = map(split, reverseString);
        return map(allReversed, unquoteDashes).reverse();
      }
      for (i = 0; i < nPath; i++) {
        paramName = paramNames[i];
        var param = this.params[paramName];
        var paramVal = m[i + 1];
        for (j = 0; j < param.replace; j++) {
          if (param.replace[j].from === paramVal)
            paramVal = param.replace[j].to;
        }
        if (paramVal && param.array === true)
          paramVal = decodePathArray(paramVal);
        values[paramName] = param.value(paramVal);
      }
      for (; i < nTotal; i++) {
        paramName = paramNames[i];
        values[paramName] = this.params[paramName].value(searchParams[paramName]);
      }
      return values;
    };
    UrlMatcher.prototype.parameters = function(param) {
      if (!isDefined(param))
        return this.$$paramNames;
      return this.params[param] || null;
    };
    UrlMatcher.prototype.validates = function(params) {
      return this.params.$$validates(params);
    };
    UrlMatcher.prototype.format = function(values) {
      values = values || {};
      var segments = this.segments,
          params = this.parameters(),
          paramset = this.params;
      if (!this.validates(values))
        return null;
      var i,
          search = false,
          nPath = segments.length - 1,
          nTotal = params.length,
          result = segments[0];
      function encodeDashes(str) {
        return encodeURIComponent(str).replace(/-/g, function(c) {
          return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase();
        });
      }
      for (i = 0; i < nTotal; i++) {
        var isPathParam = i < nPath;
        var name = params[i],
            param = paramset[name],
            value = param.value(values[name]);
        var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);
        var squash = isDefaultValue ? param.squash : false;
        var encoded = param.type.encode(value);
        if (isPathParam) {
          var nextSegment = segments[i + 1];
          if (squash === false) {
            if (encoded != null) {
              if (isArray(encoded)) {
                result += map(encoded, encodeDashes).join("-");
              } else {
                result += encodeURIComponent(encoded);
              }
            }
            result += nextSegment;
          } else if (squash === true) {
            var capture = result.match(/\/$/) ? /\/?(.*)/ : /(.*)/;
            result += nextSegment.match(capture)[1];
          } else if (isString(squash)) {
            result += squash + nextSegment;
          }
        } else {
          if (encoded == null || (isDefaultValue && squash !== false))
            continue;
          if (!isArray(encoded))
            encoded = [encoded];
          encoded = map(encoded, encodeURIComponent).join('&' + name + '=');
          result += (search ? '&' : '?') + (name + '=' + encoded);
          search = true;
        }
      }
      return result;
    };
    function Type(config) {
      extend(this, config);
    }
    Type.prototype.is = function(val, key) {
      return true;
    };
    Type.prototype.encode = function(val, key) {
      return val;
    };
    Type.prototype.decode = function(val, key) {
      return val;
    };
    Type.prototype.equals = function(a, b) {
      return a == b;
    };
    Type.prototype.$subPattern = function() {
      var sub = this.pattern.toString();
      return sub.substr(1, sub.length - 2);
    };
    Type.prototype.pattern = /.*/;
    Type.prototype.toString = function() {
      return "{Type:" + this.name + "}";
    };
    Type.prototype.$asArray = function(mode, isSearch) {
      if (!mode)
        return this;
      if (mode === "auto" && !isSearch)
        throw new Error("'auto' array mode is for query parameters only");
      return new ArrayType(this, mode);
      function ArrayType(type, mode) {
        function bindTo(type, callbackName) {
          return function() {
            return type[callbackName].apply(type, arguments);
          };
        }
        function arrayWrap(val) {
          return isArray(val) ? val : (isDefined(val) ? [val] : []);
        }
        function arrayUnwrap(val) {
          switch (val.length) {
            case 0:
              return undefined;
            case 1:
              return mode === "auto" ? val[0] : val;
            default:
              return val;
          }
        }
        function falsey(val) {
          return !val;
        }
        function arrayHandler(callback, allTruthyMode) {
          return function handleArray(val) {
            val = arrayWrap(val);
            var result = map(val, callback);
            if (allTruthyMode === true)
              return filter(result, falsey).length === 0;
            return arrayUnwrap(result);
          };
        }
        function arrayEqualsHandler(callback) {
          return function handleArray(val1, val2) {
            var left = arrayWrap(val1),
                right = arrayWrap(val2);
            if (left.length !== right.length)
              return false;
            for (var i = 0; i < left.length; i++) {
              if (!callback(left[i], right[i]))
                return false;
            }
            return true;
          };
        }
        this.encode = arrayHandler(bindTo(type, 'encode'));
        this.decode = arrayHandler(bindTo(type, 'decode'));
        this.is = arrayHandler(bindTo(type, 'is'), true);
        this.equals = arrayEqualsHandler(bindTo(type, 'equals'));
        this.pattern = type.pattern;
        this.$arrayMode = mode;
      }
    };
    function $UrlMatcherFactory() {
      $$UMFP = this;
      var isCaseInsensitive = false,
          isStrictMode = true,
          defaultSquashPolicy = false;
      function valToString(val) {
        return val != null ? val.toString().replace(/\//g, "%2F") : val;
      }
      function valFromString(val) {
        return val != null ? val.toString().replace(/%2F/g, "/") : val;
      }
      function regexpMatches(val) {
        return this.pattern.test(val);
      }
      var $types = {},
          enqueue = true,
          typeQueue = [],
          injector,
          defaultTypes = {
            string: {
              encode: valToString,
              decode: valFromString,
              is: regexpMatches,
              pattern: /[^/]*/
            },
            int: {
              encode: valToString,
              decode: function(val) {
                return parseInt(val, 10);
              },
              is: function(val) {
                return isDefined(val) && this.decode(val.toString()) === val;
              },
              pattern: /\d+/
            },
            bool: {
              encode: function(val) {
                return val ? 1 : 0;
              },
              decode: function(val) {
                return parseInt(val, 10) !== 0;
              },
              is: function(val) {
                return val === true || val === false;
              },
              pattern: /0|1/
            },
            date: {
              encode: function(val) {
                if (!this.is(val))
                  return undefined;
                return [val.getFullYear(), ('0' + (val.getMonth() + 1)).slice(-2), ('0' + val.getDate()).slice(-2)].join("-");
              },
              decode: function(val) {
                if (this.is(val))
                  return val;
                var match = this.capture.exec(val);
                return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
              },
              is: function(val) {
                return val instanceof Date && !isNaN(val.valueOf());
              },
              equals: function(a, b) {
                return this.is(a) && this.is(b) && a.toISOString() === b.toISOString();
              },
              pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
              capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
            },
            json: {
              encode: angular.toJson,
              decode: angular.fromJson,
              is: angular.isObject,
              equals: angular.equals,
              pattern: /[^/]*/
            },
            any: {
              encode: angular.identity,
              decode: angular.identity,
              is: angular.identity,
              equals: angular.equals,
              pattern: /.*/
            }
          };
      function getDefaultConfig() {
        return {
          strict: isStrictMode,
          caseInsensitive: isCaseInsensitive
        };
      }
      function isInjectable(value) {
        return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));
      }
      $UrlMatcherFactory.$$getDefaultValue = function(config) {
        if (!isInjectable(config.value))
          return config.value;
        if (!injector)
          throw new Error("Injectable functions cannot be called at configuration time");
        return injector.invoke(config.value);
      };
      this.caseInsensitive = function(value) {
        if (isDefined(value))
          isCaseInsensitive = value;
        return isCaseInsensitive;
      };
      this.strictMode = function(value) {
        if (isDefined(value))
          isStrictMode = value;
        return isStrictMode;
      };
      this.defaultSquashPolicy = function(value) {
        if (!isDefined(value))
          return defaultSquashPolicy;
        if (value !== true && value !== false && !isString(value))
          throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");
        defaultSquashPolicy = value;
        return value;
      };
      this.compile = function(pattern, config) {
        return new UrlMatcher(pattern, extend(getDefaultConfig(), config));
      };
      this.isMatcher = function(o) {
        if (!isObject(o))
          return false;
        var result = true;
        forEach(UrlMatcher.prototype, function(val, name) {
          if (isFunction(val)) {
            result = result && (isDefined(o[name]) && isFunction(o[name]));
          }
        });
        return result;
      };
      this.type = function(name, definition, definitionFn) {
        if (!isDefined(definition))
          return $types[name];
        if ($types.hasOwnProperty(name))
          throw new Error("A type named '" + name + "' has already been defined.");
        $types[name] = new Type(extend({name: name}, definition));
        if (definitionFn) {
          typeQueue.push({
            name: name,
            def: definitionFn
          });
          if (!enqueue)
            flushTypeQueue();
        }
        return this;
      };
      function flushTypeQueue() {
        while (typeQueue.length) {
          var type = typeQueue.shift();
          if (type.pattern)
            throw new Error("You cannot override a type's .pattern at runtime.");
          angular.extend($types[type.name], injector.invoke(type.def));
        }
      }
      forEach(defaultTypes, function(type, name) {
        $types[name] = new Type(extend({name: name}, type));
      });
      $types = inherit($types, {});
      this.$get = ['$injector', function($injector) {
        injector = $injector;
        enqueue = false;
        flushTypeQueue();
        forEach(defaultTypes, function(type, name) {
          if (!$types[name])
            $types[name] = new Type(type);
        });
        return this;
      }];
      this.Param = function Param(id, type, config, location) {
        var self = this;
        config = unwrapShorthand(config);
        type = getType(config, type, location);
        var arrayMode = getArrayMode();
        type = arrayMode ? type.$asArray(arrayMode, location === "search") : type;
        if (type.name === "string" && !arrayMode && location === "path" && config.value === undefined)
          config.value = "";
        var isOptional = config.value !== undefined;
        var squash = getSquashPolicy(config, isOptional);
        var replace = getReplace(config, arrayMode, isOptional, squash);
        function unwrapShorthand(config) {
          var keys = isObject(config) ? objectKeys(config) : [];
          var isShorthand = indexOf(keys, "value") === -1 && indexOf(keys, "type") === -1 && indexOf(keys, "squash") === -1 && indexOf(keys, "array") === -1;
          if (isShorthand)
            config = {value: config};
          config.$$fn = isInjectable(config.value) ? config.value : function() {
            return config.value;
          };
          return config;
        }
        function getType(config, urlType, location) {
          if (config.type && urlType)
            throw new Error("Param '" + id + "' has two type configurations.");
          if (urlType)
            return urlType;
          if (!config.type)
            return (location === "config" ? $types.any : $types.string);
          return config.type instanceof Type ? config.type : new Type(config.type);
        }
        function getArrayMode() {
          var arrayDefaults = {array: (location === "search" ? "auto" : false)};
          var arrayParamNomenclature = id.match(/\[\]$/) ? {array: true} : {};
          return extend(arrayDefaults, arrayParamNomenclature, config).array;
        }
        function getSquashPolicy(config, isOptional) {
          var squash = config.squash;
          if (!isOptional || squash === false)
            return false;
          if (!isDefined(squash) || squash == null)
            return defaultSquashPolicy;
          if (squash === true || isString(squash))
            return squash;
          throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string");
        }
        function getReplace(config, arrayMode, isOptional, squash) {
          var replace,
              configuredKeys,
              defaultPolicy = [{
                from: "",
                to: (isOptional || arrayMode ? undefined : "")
              }, {
                from: null,
                to: (isOptional || arrayMode ? undefined : "")
              }];
          replace = isArray(config.replace) ? config.replace : [];
          if (isString(squash))
            replace.push({
              from: squash,
              to: undefined
            });
          configuredKeys = map(replace, function(item) {
            return item.from;
          });
          return filter(defaultPolicy, function(item) {
            return indexOf(configuredKeys, item.from) === -1;
          }).concat(replace);
        }
        function $$getDefaultValue() {
          if (!injector)
            throw new Error("Injectable functions cannot be called at configuration time");
          return injector.invoke(config.$$fn);
        }
        function $value(value) {
          function hasReplaceVal(val) {
            return function(obj) {
              return obj.from === val;
            };
          }
          function $replace(value) {
            var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) {
              return obj.to;
            });
            return replacement.length ? replacement[0] : value;
          }
          value = $replace(value);
          return isDefined(value) ? self.type.decode(value) : $$getDefaultValue();
        }
        function toString() {
          return "{Param:" + id + " " + type + " squash: '" + squash + "' optional: " + isOptional + "}";
        }
        extend(this, {
          id: id,
          type: type,
          location: location,
          array: arrayMode,
          squash: squash,
          replace: replace,
          isOptional: isOptional,
          value: $value,
          dynamic: undefined,
          config: config,
          toString: toString
        });
      };
      function ParamSet(params) {
        extend(this, params || {});
      }
      ParamSet.prototype = {
        $$new: function() {
          return inherit(this, extend(new ParamSet(), {$$parent: this}));
        },
        $$keys: function() {
          var keys = [],
              chain = [],
              parent = this,
              ignore = objectKeys(ParamSet.prototype);
          while (parent) {
            chain.push(parent);
            parent = parent.$$parent;
          }
          chain.reverse();
          forEach(chain, function(paramset) {
            forEach(objectKeys(paramset), function(key) {
              if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1)
                keys.push(key);
            });
          });
          return keys;
        },
        $$values: function(paramValues) {
          var values = {},
              self = this;
          forEach(self.$$keys(), function(key) {
            values[key] = self[key].value(paramValues && paramValues[key]);
          });
          return values;
        },
        $$equals: function(paramValues1, paramValues2) {
          var equal = true,
              self = this;
          forEach(self.$$keys(), function(key) {
            var left = paramValues1 && paramValues1[key],
                right = paramValues2 && paramValues2[key];
            if (!self[key].type.equals(left, right))
              equal = false;
          });
          return equal;
        },
        $$validates: function $$validate(paramValues) {
          var result = true,
              isOptional,
              val,
              param,
              self = this;
          forEach(this.$$keys(), function(key) {
            param = self[key];
            val = paramValues[key];
            isOptional = !val && param.isOptional;
            result = result && (isOptional || !!param.type.is(val));
          });
          return result;
        },
        $$parent: undefined
      };
      this.ParamSet = ParamSet;
    }
    angular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);
    angular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) {}]);
    $UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];
    function $UrlRouterProvider($locationProvider, $urlMatcherFactory) {
      var rules = [],
          otherwise = null,
          interceptDeferred = false,
          listener;
      function regExpPrefix(re) {
        var prefix = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(re.source);
        return (prefix != null) ? prefix[1].replace(/\\(.)/g, "$1") : '';
      }
      function interpolate(pattern, match) {
        return pattern.replace(/\$(\$|\d{1,2})/, function(m, what) {
          return match[what === '$' ? 0 : Number(what)];
        });
      }
      this.rule = function(rule) {
        if (!isFunction(rule))
          throw new Error("'rule' must be a function");
        rules.push(rule);
        return this;
      };
      this.otherwise = function(rule) {
        if (isString(rule)) {
          var redirect = rule;
          rule = function() {
            return redirect;
          };
        } else if (!isFunction(rule))
          throw new Error("'rule' must be a function");
        otherwise = rule;
        return this;
      };
      function handleIfMatch($injector, handler, match) {
        if (!match)
          return false;
        var result = $injector.invoke(handler, handler, {$match: match});
        return isDefined(result) ? result : true;
      }
      this.when = function(what, handler) {
        var redirect,
            handlerIsString = isString(handler);
        if (isString(what))
          what = $urlMatcherFactory.compile(what);
        if (!handlerIsString && !isFunction(handler) && !isArray(handler))
          throw new Error("invalid 'handler' in when()");
        var strategies = {
          matcher: function(what, handler) {
            if (handlerIsString) {
              redirect = $urlMatcherFactory.compile(handler);
              handler = ['$match', function($match) {
                return redirect.format($match);
              }];
            }
            return extend(function($injector, $location) {
              return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));
            }, {prefix: isString(what.prefix) ? what.prefix : ''});
          },
          regex: function(what, handler) {
            if (what.global || what.sticky)
              throw new Error("when() RegExp must not be global or sticky");
            if (handlerIsString) {
              redirect = handler;
              handler = ['$match', function($match) {
                return interpolate(redirect, $match);
              }];
            }
            return extend(function($injector, $location) {
              return handleIfMatch($injector, handler, what.exec($location.path()));
            }, {prefix: regExpPrefix(what)});
          }
        };
        var check = {
          matcher: $urlMatcherFactory.isMatcher(what),
          regex: what instanceof RegExp
        };
        for (var n in check) {
          if (check[n])
            return this.rule(strategies[n](what, handler));
        }
        throw new Error("invalid 'what' in when()");
      };
      this.deferIntercept = function(defer) {
        if (defer === undefined)
          defer = true;
        interceptDeferred = defer;
      };
      this.$get = $get;
      $get.$inject = ['$location', '$rootScope', '$injector', '$browser'];
      function $get($location, $rootScope, $injector, $browser) {
        var baseHref = $browser.baseHref(),
            location = $location.url(),
            lastPushedUrl;
        function appendBasePath(url, isHtml5, absolute) {
          if (baseHref === '/')
            return url;
          if (isHtml5)
            return baseHref.slice(0, -1) + url;
          if (absolute)
            return baseHref.slice(1) + url;
          return url;
        }
        function update(evt) {
          if (evt && evt.defaultPrevented)
            return;
          var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;
          lastPushedUrl = undefined;
          if (ignoreUpdate)
            return true;
          function check(rule) {
            var handled = rule($injector, $location);
            if (!handled)
              return false;
            if (isString(handled))
              $location.replace().url(handled);
            return true;
          }
          var n = rules.length,
              i;
          for (i = 0; i < n; i++) {
            if (check(rules[i]))
              return;
          }
          if (otherwise)
            check(otherwise);
        }
        function listen() {
          listener = listener || $rootScope.$on('$locationChangeSuccess', update);
          return listener;
        }
        if (!interceptDeferred)
          listen();
        return {
          sync: function() {
            update();
          },
          listen: function() {
            return listen();
          },
          update: function(read) {
            if (read) {
              location = $location.url();
              return;
            }
            if ($location.url() === location)
              return;
            $location.url(location);
            $location.replace();
          },
          push: function(urlMatcher, params, options) {
            $location.url(urlMatcher.format(params || {}));
            lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;
            if (options && options.replace)
              $location.replace();
          },
          href: function(urlMatcher, params, options) {
            if (!urlMatcher.validates(params))
              return null;
            var isHtml5 = $locationProvider.html5Mode();
            if (angular.isObject(isHtml5)) {
              isHtml5 = isHtml5.enabled;
            }
            var url = urlMatcher.format(params);
            options = options || {};
            if (!isHtml5 && url !== null) {
              url = "#" + $locationProvider.hashPrefix() + url;
            }
            url = appendBasePath(url, isHtml5, options.absolute);
            if (!options.absolute || !url) {
              return url;
            }
            var slash = (!isHtml5 && url ? '/' : ''),
                port = $location.port();
            port = (port === 80 || port === 443 ? '' : ':' + port);
            return [$location.protocol(), '://', $location.host(), port, slash, url].join('');
          }
        };
      }
    }
    angular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);
    $StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];
    function $StateProvider($urlRouterProvider, $urlMatcherFactory) {
      var root,
          states = {},
          $state,
          queue = {},
          abstractKey = 'abstract';
      var stateBuilder = {
        parent: function(state) {
          if (isDefined(state.parent) && state.parent)
            return findState(state.parent);
          var compositeName = /^(.+)\.[^.]+$/.exec(state.name);
          return compositeName ? findState(compositeName[1]) : root;
        },
        data: function(state) {
          if (state.parent && state.parent.data) {
            state.data = state.self.data = extend({}, state.parent.data, state.data);
          }
          return state.data;
        },
        url: function(state) {
          var url = state.url,
              config = {params: state.params || {}};
          if (isString(url)) {
            if (url.charAt(0) == '^')
              return $urlMatcherFactory.compile(url.substring(1), config);
            return (state.parent.navigable || root).url.concat(url, config);
          }
          if (!url || $urlMatcherFactory.isMatcher(url))
            return url;
          throw new Error("Invalid url '" + url + "' in state '" + state + "'");
        },
        navigable: function(state) {
          return state.url ? state : (state.parent ? state.parent.navigable : null);
        },
        ownParams: function(state) {
          var params = state.url && state.url.params || new $$UMFP.ParamSet();
          forEach(state.params || {}, function(config, id) {
            if (!params[id])
              params[id] = new $$UMFP.Param(id, null, config, "config");
          });
          return params;
        },
        params: function(state) {
          return state.parent && state.parent.params ? extend(state.parent.params.$$new(), state.ownParams) : new $$UMFP.ParamSet();
        },
        views: function(state) {
          var views = {};
          forEach(isDefined(state.views) ? state.views : {'': state}, function(view, name) {
            if (name.indexOf('@') < 0)
              name += '@' + state.parent.name;
            views[name] = view;
          });
          return views;
        },
        path: function(state) {
          return state.parent ? state.parent.path.concat(state) : [];
        },
        includes: function(state) {
          var includes = state.parent ? extend({}, state.parent.includes) : {};
          includes[state.name] = true;
          return includes;
        },
        $delegates: {}
      };
      function isRelative(stateName) {
        return stateName.indexOf(".") === 0 || stateName.indexOf("^") === 0;
      }
      function findState(stateOrName, base) {
        if (!stateOrName)
          return undefined;
        var isStr = isString(stateOrName),
            name = isStr ? stateOrName : stateOrName.name,
            path = isRelative(name);
        if (path) {
          if (!base)
            throw new Error("No reference point given for path '" + name + "'");
          base = findState(base);
          var rel = name.split("."),
              i = 0,
              pathLength = rel.length,
              current = base;
          for (; i < pathLength; i++) {
            if (rel[i] === "" && i === 0) {
              current = base;
              continue;
            }
            if (rel[i] === "^") {
              if (!current.parent)
                throw new Error("Path '" + name + "' not valid for state '" + base.name + "'");
              current = current.parent;
              continue;
            }
            break;
          }
          rel = rel.slice(i).join(".");
          name = current.name + (current.name && rel ? "." : "") + rel;
        }
        var state = states[name];
        if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {
          return state;
        }
        return undefined;
      }
      function queueState(parentName, state) {
        if (!queue[parentName]) {
          queue[parentName] = [];
        }
        queue[parentName].push(state);
      }
      function flushQueuedChildren(parentName) {
        var queued = queue[parentName] || [];
        while (queued.length) {
          registerState(queued.shift());
        }
      }
      function registerState(state) {
        state = inherit(state, {
          self: state,
          resolve: state.resolve || {},
          toString: function() {
            return this.name;
          }
        });
        var name = state.name;
        if (!isString(name) || name.indexOf('@') >= 0)
          throw new Error("State must have a valid name");
        if (states.hasOwnProperty(name))
          throw new Error("State '" + name + "'' is already defined");
        var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.')) : (isString(state.parent)) ? state.parent : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name : '';
        if (parentName && !states[parentName]) {
          return queueState(parentName, state.self);
        }
        for (var key in stateBuilder) {
          if (isFunction(stateBuilder[key]))
            state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);
        }
        states[name] = state;
        if (!state[abstractKey] && state.url) {
          $urlRouterProvider.when(state.url, ['$match', '$stateParams', function($match, $stateParams) {
            if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {
              $state.transitionTo(state, $match, {
                inherit: true,
                location: false
              });
            }
          }]);
        }
        flushQueuedChildren(name);
        return state;
      }
      function isGlob(text) {
        return text.indexOf('*') > -1;
      }
      function doesStateMatchGlob(glob) {
        var globSegments = glob.split('.'),
            segments = $state.$current.name.split('.');
        if (globSegments[0] === '**') {
          segments = segments.slice(indexOf(segments, globSegments[1]));
          segments.unshift('**');
        }
        if (globSegments[globSegments.length - 1] === '**') {
          segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);
          segments.push('**');
        }
        if (globSegments.length != segments.length) {
          return false;
        }
        for (var i = 0,
            l = globSegments.length; i < l; i++) {
          if (globSegments[i] === '*') {
            segments[i] = '*';
          }
        }
        return segments.join('') === globSegments.join('');
      }
      root = registerState({
        name: '',
        url: '^',
        views: null,
        'abstract': true
      });
      root.navigable = null;
      this.decorator = decorator;
      function decorator(name, func) {
        if (isString(name) && !isDefined(func)) {
          return stateBuilder[name];
        }
        if (!isFunction(func) || !isString(name)) {
          return this;
        }
        if (stateBuilder[name] && !stateBuilder.$delegates[name]) {
          stateBuilder.$delegates[name] = stateBuilder[name];
        }
        stateBuilder[name] = func;
        return this;
      }
      this.state = state;
      function state(name, definition) {
        if (isObject(name))
          definition = name;
        else
          definition.name = name;
        registerState(definition);
        return this;
      }
      this.$get = $get;
      $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];
      function $get($rootScope, $q, $view, $injector, $resolve, $stateParams, $urlRouter, $location, $urlMatcherFactory) {
        var TransitionSuperseded = $q.reject(new Error('transition superseded'));
        var TransitionPrevented = $q.reject(new Error('transition prevented'));
        var TransitionAborted = $q.reject(new Error('transition aborted'));
        var TransitionFailed = $q.reject(new Error('transition failed'));
        function handleRedirect(redirect, state, params, options) {
          var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);
          if (evt.defaultPrevented) {
            $urlRouter.update();
            return TransitionAborted;
          }
          if (!evt.retry) {
            return null;
          }
          if (options.$retry) {
            $urlRouter.update();
            return TransitionFailed;
          }
          var retryTransition = $state.transition = $q.when(evt.retry);
          retryTransition.then(function() {
            if (retryTransition !== $state.transition)
              return TransitionSuperseded;
            redirect.options.$retry = true;
            return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);
          }, function() {
            return TransitionAborted;
          });
          $urlRouter.update();
          return retryTransition;
        }
        root.locals = {
          resolve: null,
          globals: {$stateParams: {}}
        };
        $state = {
          params: {},
          current: root.self,
          $current: root,
          transition: null
        };
        $state.reload = function reload() {
          return $state.transitionTo($state.current, $stateParams, {
            reload: true,
            inherit: false,
            notify: true
          });
        };
        $state.go = function go(to, params, options) {
          return $state.transitionTo(to, params, extend({
            inherit: true,
            relative: $state.$current
          }, options));
        };
        $state.transitionTo = function transitionTo(to, toParams, options) {
          toParams = toParams || {};
          options = extend({
            location: true,
            inherit: false,
            relative: null,
            notify: true,
            reload: false,
            $retry: false
          }, options || {});
          var from = $state.$current,
              fromParams = $state.params,
              fromPath = from.path;
          var evt,
              toState = findState(to, options.relative);
          if (!isDefined(toState)) {
            var redirect = {
              to: to,
              toParams: toParams,
              options: options
            };
            var redirectResult = handleRedirect(redirect, from.self, fromParams, options);
            if (redirectResult) {
              return redirectResult;
            }
            to = redirect.to;
            toParams = redirect.toParams;
            options = redirect.options;
            toState = findState(to, options.relative);
            if (!isDefined(toState)) {
              if (!options.relative)
                throw new Error("No such state '" + to + "'");
              throw new Error("Could not resolve '" + to + "' from state '" + options.relative + "'");
            }
          }
          if (toState[abstractKey])
            throw new Error("Cannot transition to abstract state '" + to + "'");
          if (options.inherit)
            toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);
          if (!toState.params.$$validates(toParams))
            return TransitionFailed;
          toParams = toState.params.$$values(toParams);
          to = toState;
          var toPath = to.path;
          var keep = 0,
              state = toPath[keep],
              locals = root.locals,
              toLocals = [];
          if (!options.reload) {
            while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {
              locals = toLocals[keep] = state.locals;
              keep++;
              state = toPath[keep];
            }
          }
          if (shouldTriggerReload(to, from, locals, options)) {
            if (to.self.reloadOnSearch !== false)
              $urlRouter.update();
            $state.transition = null;
            return $q.when($state.current);
          }
          toParams = filterByKeys(to.params.$$keys(), toParams || {});
          if (options.notify) {
            if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams).defaultPrevented) {
              $urlRouter.update();
              return TransitionPrevented;
            }
          }
          var resolved = $q.when(locals);
          for (var l = keep; l < toPath.length; l++, state = toPath[l]) {
            locals = toLocals[l] = inherit(locals);
            resolved = resolveState(state, toParams, state === to, resolved, locals, options);
          }
          var transition = $state.transition = resolved.then(function() {
            var l,
                entering,
                exiting;
            if ($state.transition !== transition)
              return TransitionSuperseded;
            for (l = fromPath.length - 1; l >= keep; l--) {
              exiting = fromPath[l];
              if (exiting.self.onExit) {
                $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);
              }
              exiting.locals = null;
            }
            for (l = keep; l < toPath.length; l++) {
              entering = toPath[l];
              entering.locals = toLocals[l];
              if (entering.self.onEnter) {
                $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);
              }
            }
            if ($state.transition !== transition)
              return TransitionSuperseded;
            $state.$current = to;
            $state.current = to.self;
            $state.params = toParams;
            copy($state.params, $stateParams);
            $state.transition = null;
            if (options.location && to.navigable) {
              $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {
                $$avoidResync: true,
                replace: options.location === 'replace'
              });
            }
            if (options.notify) {
              $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);
            }
            $urlRouter.update(true);
            return $state.current;
          }, function(error) {
            if ($state.transition !== transition)
              return TransitionSuperseded;
            $state.transition = null;
            evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);
            if (!evt.defaultPrevented) {
              $urlRouter.update();
            }
            return $q.reject(error);
          });
          return transition;
        };
        $state.is = function is(stateOrName, params, options) {
          options = extend({relative: $state.$current}, options || {});
          var state = findState(stateOrName, options.relative);
          if (!isDefined(state)) {
            return undefined;
          }
          if ($state.$current !== state) {
            return false;
          }
          return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;
        };
        $state.includes = function includes(stateOrName, params, options) {
          options = extend({relative: $state.$current}, options || {});
          if (isString(stateOrName) && isGlob(stateOrName)) {
            if (!doesStateMatchGlob(stateOrName)) {
              return false;
            }
            stateOrName = $state.$current.name;
          }
          var state = findState(stateOrName, options.relative);
          if (!isDefined(state)) {
            return undefined;
          }
          if (!isDefined($state.$current.includes[state.name])) {
            return false;
          }
          return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;
        };
        $state.href = function href(stateOrName, params, options) {
          options = extend({
            lossy: true,
            inherit: true,
            absolute: false,
            relative: $state.$current
          }, options || {});
          var state = findState(stateOrName, options.relative);
          if (!isDefined(state))
            return null;
          if (options.inherit)
            params = inheritParams($stateParams, params || {}, $state.$current, state);
          var nav = (state && options.lossy) ? state.navigable : state;
          if (!nav || nav.url === undefined || nav.url === null) {
            return null;
          }
          return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys(), params || {}), {absolute: options.absolute});
        };
        $state.get = function(stateOrName, context) {
          if (arguments.length === 0)
            return map(objectKeys(states), function(name) {
              return states[name].self;
            });
          var state = findState(stateOrName, context || $state.$current);
          return (state && state.self) ? state.self : null;
        };
        function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {
          var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);
          var locals = {$stateParams: $stateParams};
          dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);
          var promises = [dst.resolve.then(function(globals) {
            dst.globals = globals;
          })];
          if (inherited)
            promises.push(inherited);
          forEach(state.views, function(view, name) {
            var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});
            injectables.$template = [function() {
              return $view.load(name, {
                view: view,
                locals: locals,
                params: $stateParams,
                notify: options.notify
              }) || '';
            }];
            promises.push($resolve.resolve(injectables, locals, dst.resolve, state).then(function(result) {
              if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {
                var injectLocals = angular.extend({}, injectables, locals);
                result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);
              } else {
                result.$$controller = view.controller;
              }
              result.$$state = state;
              result.$$controllerAs = view.controllerAs;
              dst[name] = result;
            }));
          });
          return $q.all(promises).then(function(values) {
            return dst;
          });
        }
        return $state;
      }
      function shouldTriggerReload(to, from, locals, options) {
        if (to === from && ((locals === from.locals && !options.reload) || (to.self.reloadOnSearch === false))) {
          return true;
        }
      }
    }
    angular.module('ui.router.state').value('$stateParams', {}).provider('$state', $StateProvider);
    $ViewProvider.$inject = [];
    function $ViewProvider() {
      this.$get = $get;
      $get.$inject = ['$rootScope', '$templateFactory'];
      function $get($rootScope, $templateFactory) {
        return {load: function load(name, options) {
            var result,
                defaults = {
                  template: null,
                  controller: null,
                  view: null,
                  locals: null,
                  notify: true,
                  async: true,
                  params: {}
                };
            options = extend(defaults, options);
            if (options.view) {
              result = $templateFactory.fromConfig(options.view, options.params, options.locals);
            }
            if (result && options.notify) {
              $rootScope.$broadcast('$viewContentLoading', options);
            }
            return result;
          }};
      }
    }
    angular.module('ui.router.state').provider('$view', $ViewProvider);
    function $ViewScrollProvider() {
      var useAnchorScroll = false;
      this.useAnchorScroll = function() {
        useAnchorScroll = true;
      };
      this.$get = ['$anchorScroll', '$timeout', function($anchorScroll, $timeout) {
        if (useAnchorScroll) {
          return $anchorScroll;
        }
        return function($element) {
          $timeout(function() {
            $element[0].scrollIntoView();
          }, 0, false);
        };
      }];
    }
    angular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);
    $ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate'];
    function $ViewDirective($state, $injector, $uiViewScroll, $interpolate) {
      function getService() {
        return ($injector.has) ? function(service) {
          return $injector.has(service) ? $injector.get(service) : null;
        } : function(service) {
          try {
            return $injector.get(service);
          } catch (e) {
            return null;
          }
        };
      }
      var service = getService(),
          $animator = service('$animator'),
          $animate = service('$animate');
      function getRenderer(attrs, scope) {
        var statics = function() {
          return {
            enter: function(element, target, cb) {
              target.after(element);
              cb();
            },
            leave: function(element, cb) {
              element.remove();
              cb();
            }
          };
        };
        if ($animate) {
          return {
            enter: function(element, target, cb) {
              var promise = $animate.enter(element, null, target, cb);
              if (promise && promise.then)
                promise.then(cb);
            },
            leave: function(element, cb) {
              var promise = $animate.leave(element, cb);
              if (promise && promise.then)
                promise.then(cb);
            }
          };
        }
        if ($animator) {
          var animate = $animator && $animator(scope, attrs);
          return {
            enter: function(element, target, cb) {
              animate.enter(element, null, target);
              cb();
            },
            leave: function(element, cb) {
              animate.leave(element);
              cb();
            }
          };
        }
        return statics();
      }
      var directive = {
        restrict: 'ECA',
        terminal: true,
        priority: 400,
        transclude: 'element',
        compile: function(tElement, tAttrs, $transclude) {
          return function(scope, $element, attrs) {
            var previousEl,
                currentEl,
                currentScope,
                latestLocals,
                onloadExp = attrs.onload || '',
                autoScrollExp = attrs.autoscroll,
                renderer = getRenderer(attrs, scope);
            scope.$on('$stateChangeSuccess', function() {
              updateView(false);
            });
            scope.$on('$viewContentLoading', function() {
              updateView(false);
            });
            updateView(true);
            function cleanupLastView() {
              if (previousEl) {
                previousEl.remove();
                previousEl = null;
              }
              if (currentScope) {
                currentScope.$destroy();
                currentScope = null;
              }
              if (currentEl) {
                renderer.leave(currentEl, function() {
                  previousEl = null;
                });
                previousEl = currentEl;
                currentEl = null;
              }
            }
            function updateView(firstTime) {
              var newScope,
                  name = getUiViewName(scope, attrs, $element, $interpolate),
                  previousLocals = name && $state.$current && $state.$current.locals[name];
              if (!firstTime && previousLocals === latestLocals)
                return;
              newScope = scope.$new();
              latestLocals = $state.$current.locals[name];
              var clone = $transclude(newScope, function(clone) {
                renderer.enter(clone, $element, function onUiViewEnter() {
                  if (currentScope) {
                    currentScope.$emit('$viewContentAnimationEnded');
                  }
                  if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {
                    $uiViewScroll(clone);
                  }
                });
                cleanupLastView();
              });
              currentEl = clone;
              currentScope = newScope;
              currentScope.$emit('$viewContentLoaded');
              currentScope.$eval(onloadExp);
            }
          };
        }
      };
      return directive;
    }
    $ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];
    function $ViewDirectiveFill($compile, $controller, $state, $interpolate) {
      return {
        restrict: 'ECA',
        priority: -400,
        compile: function(tElement) {
          var initial = tElement.html();
          return function(scope, $element, attrs) {
            var current = $state.$current,
                name = getUiViewName(scope, attrs, $element, $interpolate),
                locals = current && current.locals[name];
            if (!locals) {
              return;
            }
            $element.data('$uiView', {
              name: name,
              state: locals.$$state
            });
            $element.html(locals.$template ? locals.$template : initial);
            var link = $compile($element.contents());
            if (locals.$$controller) {
              locals.$scope = scope;
              var controller = $controller(locals.$$controller, locals);
              if (locals.$$controllerAs) {
                scope[locals.$$controllerAs] = controller;
              }
              $element.data('$ngControllerController', controller);
              $element.children().data('$ngControllerController', controller);
            }
            link(scope);
          };
        }
      };
    }
    function getUiViewName(scope, attrs, element, $interpolate) {
      var name = $interpolate(attrs.uiView || attrs.name || '')(scope);
      var inherited = element.inheritedData('$uiView');
      return name.indexOf('@') >= 0 ? name : (name + '@' + (inherited ? inherited.state.name : ''));
    }
    angular.module('ui.router.state').directive('uiView', $ViewDirective);
    angular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);
    function parseStateRef(ref, current) {
      var preparsed = ref.match(/^\s*({[^}]*})\s*$/),
          parsed;
      if (preparsed)
        ref = current + '(' + preparsed[1] + ')';
      parsed = ref.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/);
      if (!parsed || parsed.length !== 4)
        throw new Error("Invalid state ref '" + ref + "'");
      return {
        state: parsed[1],
        paramExpr: parsed[3] || null
      };
    }
    function stateContext(el) {
      var stateData = el.parent().inheritedData('$uiView');
      if (stateData && stateData.state && stateData.state.name) {
        return stateData.state;
      }
    }
    $StateRefDirective.$inject = ['$state', '$timeout'];
    function $StateRefDirective($state, $timeout) {
      var allowedOptions = ['location', 'inherit', 'reload'];
      return {
        restrict: 'A',
        require: ['?^uiSrefActive', '?^uiSrefActiveEq'],
        link: function(scope, element, attrs, uiSrefActive) {
          var ref = parseStateRef(attrs.uiSref, $state.current.name);
          var params = null,
              url = null,
              base = stateContext(element) || $state.$current;
          var newHref = null,
              isAnchor = element.prop("tagName") === "A";
          var isForm = element[0].nodeName === "FORM";
          var attr = isForm ? "action" : "href",
              nav = true;
          var options = {
            relative: base,
            inherit: true
          };
          var optionsOverride = scope.$eval(attrs.uiSrefOpts) || {};
          angular.forEach(allowedOptions, function(option) {
            if (option in optionsOverride) {
              options[option] = optionsOverride[option];
            }
          });
          var update = function(newVal) {
            if (newVal)
              params = angular.copy(newVal);
            if (!nav)
              return;
            newHref = $state.href(ref.state, params, options);
            var activeDirective = uiSrefActive[1] || uiSrefActive[0];
            if (activeDirective) {
              activeDirective.$$setStateInfo(ref.state, params);
            }
            if (newHref === null) {
              nav = false;
              return false;
            }
            attrs.$set(attr, newHref);
          };
          if (ref.paramExpr) {
            scope.$watch(ref.paramExpr, function(newVal, oldVal) {
              if (newVal !== params)
                update(newVal);
            }, true);
            params = angular.copy(scope.$eval(ref.paramExpr));
          }
          update();
          if (isForm)
            return;
          element.bind("click", function(e) {
            var button = e.which || e.button;
            if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || element.attr('target'))) {
              var transition = $timeout(function() {
                $state.go(ref.state, params, options);
              });
              e.preventDefault();
              var ignorePreventDefaultCount = isAnchor && !newHref ? 1 : 0;
              e.preventDefault = function() {
                if (ignorePreventDefaultCount-- <= 0)
                  $timeout.cancel(transition);
              };
            }
          });
        }
      };
    }
    $StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];
    function $StateRefActiveDirective($state, $stateParams, $interpolate) {
      return {
        restrict: "A",
        controller: ['$scope', '$element', '$attrs', function($scope, $element, $attrs) {
          var state,
              params,
              activeClass;
          activeClass = $interpolate($attrs.uiSrefActiveEq || $attrs.uiSrefActive || '', false)($scope);
          this.$$setStateInfo = function(newState, newParams) {
            state = $state.get(newState, stateContext($element));
            params = newParams;
            update();
          };
          $scope.$on('$stateChangeSuccess', update);
          function update() {
            if (isMatch()) {
              $element.addClass(activeClass);
            } else {
              $element.removeClass(activeClass);
            }
          }
          function isMatch() {
            if (typeof $attrs.uiSrefActiveEq !== 'undefined') {
              return state && $state.is(state.name, params);
            } else {
              return state && $state.includes(state.name, params);
            }
          }
        }]
      };
    }
    angular.module('ui.router.state').directive('uiSref', $StateRefDirective).directive('uiSrefActive', $StateRefActiveDirective).directive('uiSrefActiveEq', $StateRefActiveDirective);
    $IsStateFilter.$inject = ['$state'];
    function $IsStateFilter($state) {
      var isFilter = function(state) {
        return $state.is(state);
      };
      isFilter.$stateful = true;
      return isFilter;
    }
    $IncludedByStateFilter.$inject = ['$state'];
    function $IncludedByStateFilter($state) {
      var includesFilter = function(state) {
        return $state.includes(state);
      };
      includesFilter.$stateful = true;
      return includesFilter;
    }
    angular.module('ui.router.state').filter('isState', $IsStateFilter).filter('includedByState', $IncludedByStateFilter);
  })(window, window.angular);
  return module.exports;
});

$__System.registerDynamic("19", ["18"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('18');
  return module.exports;
});

$__System.registerDynamic("1a", ["11", "12", "14", "15", "17", "19"], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, "ionic", null);
  (function() {
    "format global";
    "deps ../css/ionic.css!";
    "deps ./ionic";
    "deps angular";
    "deps angular-animate";
    "deps angular-sanitize";
    "deps angular-ui-router";
    "exports ionic";
    (function() {
      var IonicModule = angular.module('ionic', ['ngAnimate', 'ngSanitize', 'ui.router', 'ngIOS9UIWebViewPatch']),
          extend = angular.extend,
          forEach = angular.forEach,
          isDefined = angular.isDefined,
          isNumber = angular.isNumber,
          isString = angular.isString,
          jqLite = angular.element,
          noop = angular.noop;
      IonicModule.factory('$ionicActionSheet', ['$rootScope', '$compile', '$animate', '$timeout', '$ionicTemplateLoader', '$ionicPlatform', '$ionicBody', 'IONIC_BACK_PRIORITY', function($rootScope, $compile, $animate, $timeout, $ionicTemplateLoader, $ionicPlatform, $ionicBody, IONIC_BACK_PRIORITY) {
        return {show: actionSheet};
        function actionSheet(opts) {
          var scope = $rootScope.$new(true);
          extend(scope, {
            cancel: noop,
            destructiveButtonClicked: noop,
            buttonClicked: noop,
            $deregisterBackButton: noop,
            buttons: [],
            cancelOnStateChange: true
          }, opts || {});
          function textForIcon(text) {
            if (text && /icon/.test(text)) {
              scope.$actionSheetHasIcon = true;
            }
          }
          for (var x = 0; x < scope.buttons.length; x++) {
            textForIcon(scope.buttons[x].text);
          }
          textForIcon(scope.cancelText);
          textForIcon(scope.destructiveText);
          var element = scope.element = $compile('<ion-action-sheet ng-class="cssClass" buttons="buttons"></ion-action-sheet>')(scope);
          var sheetEl = jqLite(element[0].querySelector('.action-sheet-wrapper'));
          var stateChangeListenDone = scope.cancelOnStateChange ? $rootScope.$on('$stateChangeSuccess', function() {
            scope.cancel();
          }) : noop;
          scope.removeSheet = function(done) {
            if (scope.removed)
              return;
            scope.removed = true;
            sheetEl.removeClass('action-sheet-up');
            $timeout(function() {
              $ionicBody.removeClass('action-sheet-open');
            }, 400);
            scope.$deregisterBackButton();
            stateChangeListenDone();
            $animate.removeClass(element, 'active').then(function() {
              scope.$destroy();
              element.remove();
              scope.cancel.$scope = sheetEl = null;
              (done || noop)(opts.buttons);
            });
          };
          scope.showSheet = function(done) {
            if (scope.removed)
              return;
            $ionicBody.append(element).addClass('action-sheet-open');
            $animate.addClass(element, 'active').then(function() {
              if (scope.removed)
                return;
              (done || noop)();
            });
            $timeout(function() {
              if (scope.removed)
                return;
              sheetEl.addClass('action-sheet-up');
            }, 20, false);
          };
          scope.$deregisterBackButton = $ionicPlatform.registerBackButtonAction(function() {
            $timeout(scope.cancel);
          }, IONIC_BACK_PRIORITY.actionSheet);
          scope.cancel = function() {
            scope.removeSheet(opts.cancel);
          };
          scope.buttonClicked = function(index) {
            if (opts.buttonClicked(index, opts.buttons[index]) === true) {
              scope.removeSheet();
            }
          };
          scope.destructiveButtonClicked = function() {
            if (opts.destructiveButtonClicked() === true) {
              scope.removeSheet();
            }
          };
          scope.showSheet();
          scope.cancel.$scope = scope;
          return scope.cancel;
        }
      }]);
      jqLite.prototype.addClass = function(cssClasses) {
        var x,
            y,
            cssClass,
            el,
            splitClasses,
            existingClasses;
        if (cssClasses && cssClasses != 'ng-scope' && cssClasses != 'ng-isolate-scope') {
          for (x = 0; x < this.length; x++) {
            el = this[x];
            if (el.setAttribute) {
              if (cssClasses.indexOf(' ') < 0 && el.classList.add) {
                el.classList.add(cssClasses);
              } else {
                existingClasses = (' ' + (el.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, " ");
                splitClasses = cssClasses.split(' ');
                for (y = 0; y < splitClasses.length; y++) {
                  cssClass = splitClasses[y].trim();
                  if (existingClasses.indexOf(' ' + cssClass + ' ') === -1) {
                    existingClasses += cssClass + ' ';
                  }
                }
                el.setAttribute('class', existingClasses.trim());
              }
            }
          }
        }
        return this;
      };
      jqLite.prototype.removeClass = function(cssClasses) {
        var x,
            y,
            splitClasses,
            cssClass,
            el;
        if (cssClasses) {
          for (x = 0; x < this.length; x++) {
            el = this[x];
            if (el.getAttribute) {
              if (cssClasses.indexOf(' ') < 0 && el.classList.remove) {
                el.classList.remove(cssClasses);
              } else {
                splitClasses = cssClasses.split(' ');
                for (y = 0; y < splitClasses.length; y++) {
                  cssClass = splitClasses[y];
                  el.setAttribute('class', ((" " + (el.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").replace(" " + cssClass.trim() + " ", " ")).trim());
                }
              }
            }
          }
        }
        return this;
      };
      IonicModule.factory('$ionicBackdrop', ['$document', '$timeout', '$$rAF', '$rootScope', function($document, $timeout, $$rAF, $rootScope) {
        var el = jqLite('<div class="backdrop">');
        var backdropHolds = 0;
        $document[0].body.appendChild(el[0]);
        return {
          retain: retain,
          release: release,
          getElement: getElement,
          _element: el
        };
        function retain() {
          backdropHolds++;
          if (backdropHolds === 1) {
            el.addClass('visible');
            $rootScope.$broadcast('backdrop.shown');
            $$rAF(function() {
              if (backdropHolds >= 1)
                el.addClass('active');
            });
          }
        }
        function release() {
          if (backdropHolds === 1) {
            el.removeClass('active');
            $rootScope.$broadcast('backdrop.hidden');
            $timeout(function() {
              if (backdropHolds === 0)
                el.removeClass('visible');
            }, 400, false);
          }
          backdropHolds = Math.max(0, backdropHolds - 1);
        }
        function getElement() {
          return el;
        }
      }]);
      IonicModule.factory('$ionicBind', ['$parse', '$interpolate', function($parse, $interpolate) {
        var LOCAL_REGEXP = /^\s*([@=&])(\??)\s*(\w*)\s*$/;
        return function(scope, attrs, bindDefinition) {
          forEach(bindDefinition || {}, function(definition, scopeName) {
            var match = definition.match(LOCAL_REGEXP) || [],
                attrName = match[3] || scopeName,
                mode = match[1],
                parentGet,
                unwatch;
            switch (mode) {
              case '@':
                if (!attrs[attrName]) {
                  return;
                }
                attrs.$observe(attrName, function(value) {
                  scope[scopeName] = value;
                });
                if (attrs[attrName]) {
                  scope[scopeName] = $interpolate(attrs[attrName])(scope);
                }
                break;
              case '=':
                if (!attrs[attrName]) {
                  return;
                }
                unwatch = scope.$watch(attrs[attrName], function(value) {
                  scope[scopeName] = value;
                });
                scope.$on('$destroy', unwatch);
                break;
              case '&':
                if (attrs[attrName] && attrs[attrName].match(RegExp(scopeName + '\(.*?\)'))) {
                  throw new Error('& expression binding "' + scopeName + '" looks like it will recursively call "' + attrs[attrName] + '" and cause a stack overflow! Please choose a different scopeName.');
                }
                parentGet = $parse(attrs[attrName]);
                scope[scopeName] = function(locals) {
                  return parentGet(scope, locals);
                };
                break;
            }
          });
        };
      }]);
      IonicModule.factory('$ionicBody', ['$document', function($document) {
        return {
          addClass: function() {
            for (var x = 0; x < arguments.length; x++) {
              $document[0].body.classList.add(arguments[x]);
            }
            return this;
          },
          removeClass: function() {
            for (var x = 0; x < arguments.length; x++) {
              $document[0].body.classList.remove(arguments[x]);
            }
            return this;
          },
          enableClass: function(shouldEnableClass) {
            var args = Array.prototype.slice.call(arguments).slice(1);
            if (shouldEnableClass) {
              this.addClass.apply(this, args);
            } else {
              this.removeClass.apply(this, args);
            }
            return this;
          },
          append: function(ele) {
            $document[0].body.appendChild(ele.length ? ele[0] : ele);
            return this;
          },
          get: function() {
            return $document[0].body;
          }
        };
      }]);
      IonicModule.factory('$ionicClickBlock', ['$document', '$ionicBody', '$timeout', function($document, $ionicBody, $timeout) {
        var CSS_HIDE = 'click-block-hide';
        var cbEle,
            fallbackTimer,
            pendingShow;
        function preventClick(ev) {
          ev.preventDefault();
          ev.stopPropagation();
        }
        function addClickBlock() {
          if (pendingShow) {
            if (cbEle) {
              cbEle.classList.remove(CSS_HIDE);
            } else {
              cbEle = $document[0].createElement('div');
              cbEle.className = 'click-block';
              $ionicBody.append(cbEle);
              cbEle.addEventListener('touchstart', preventClick);
              cbEle.addEventListener('mousedown', preventClick);
            }
            pendingShow = false;
          }
        }
        function removeClickBlock() {
          cbEle && cbEle.classList.add(CSS_HIDE);
        }
        return {
          show: function(autoExpire) {
            pendingShow = true;
            $timeout.cancel(fallbackTimer);
            fallbackTimer = $timeout(this.hide, autoExpire || 310, false);
            addClickBlock();
          },
          hide: function() {
            pendingShow = false;
            $timeout.cancel(fallbackTimer);
            removeClickBlock();
          }
        };
      }]);
      IonicModule.factory('$ionicGesture', [function() {
        return {
          on: function(eventType, cb, $element, options) {
            return window.ionic.onGesture(eventType, cb, $element[0], options);
          },
          off: function(gesture, eventType, cb) {
            return window.ionic.offGesture(gesture, eventType, cb);
          }
        };
      }]);
      IonicModule.factory('$ionicHistory', ['$rootScope', '$state', '$location', '$window', '$timeout', '$ionicViewSwitcher', '$ionicNavViewDelegate', function($rootScope, $state, $location, $window, $timeout, $ionicViewSwitcher, $ionicNavViewDelegate) {
        var ACTION_INITIAL_VIEW = 'initialView';
        var ACTION_NEW_VIEW = 'newView';
        var ACTION_MOVE_BACK = 'moveBack';
        var ACTION_MOVE_FORWARD = 'moveForward';
        var DIRECTION_BACK = 'back';
        var DIRECTION_FORWARD = 'forward';
        var DIRECTION_ENTER = 'enter';
        var DIRECTION_EXIT = 'exit';
        var DIRECTION_SWAP = 'swap';
        var DIRECTION_NONE = 'none';
        var stateChangeCounter = 0;
        var lastStateId,
            nextViewOptions,
            deregisterStateChangeListener,
            nextViewExpireTimer,
            forcedNav;
        var viewHistory = {
          histories: {root: {
              historyId: 'root',
              parentHistoryId: null,
              stack: [],
              cursor: -1
            }},
          views: {},
          backView: null,
          forwardView: null,
          currentView: null
        };
        var View = function() {};
        View.prototype.initialize = function(data) {
          if (data) {
            for (var name in data)
              this[name] = data[name];
            return this;
          }
          return null;
        };
        View.prototype.go = function() {
          if (this.stateName) {
            return $state.go(this.stateName, this.stateParams);
          }
          if (this.url && this.url !== $location.url()) {
            if (viewHistory.backView === this) {
              return $window.history.go(-1);
            } else if (viewHistory.forwardView === this) {
              return $window.history.go(1);
            }
            $location.url(this.url);
          }
          return null;
        };
        View.prototype.destroy = function() {
          if (this.scope) {
            this.scope.$destroy && this.scope.$destroy();
            this.scope = null;
          }
        };
        function getViewById(viewId) {
          return (viewId ? viewHistory.views[viewId] : null);
        }
        function getBackView(view) {
          return (view ? getViewById(view.backViewId) : null);
        }
        function getForwardView(view) {
          return (view ? getViewById(view.forwardViewId) : null);
        }
        function getHistoryById(historyId) {
          return (historyId ? viewHistory.histories[historyId] : null);
        }
        function getHistory(scope) {
          var histObj = getParentHistoryObj(scope);
          if (!viewHistory.histories[histObj.historyId]) {
            viewHistory.histories[histObj.historyId] = {
              historyId: histObj.historyId,
              parentHistoryId: getParentHistoryObj(histObj.scope.$parent).historyId,
              stack: [],
              cursor: -1
            };
          }
          return getHistoryById(histObj.historyId);
        }
        function getParentHistoryObj(scope) {
          var parentScope = scope;
          while (parentScope) {
            if (parentScope.hasOwnProperty('$historyId')) {
              return {
                historyId: parentScope.$historyId,
                scope: parentScope
              };
            }
            parentScope = parentScope.$parent;
          }
          return {
            historyId: 'root',
            scope: $rootScope
          };
        }
        function setNavViews(viewId) {
          viewHistory.currentView = getViewById(viewId);
          viewHistory.backView = getBackView(viewHistory.currentView);
          viewHistory.forwardView = getForwardView(viewHistory.currentView);
        }
        function getCurrentStateId() {
          var id;
          if ($state && $state.current && $state.current.name) {
            id = $state.current.name;
            if ($state.params) {
              for (var key in $state.params) {
                if ($state.params.hasOwnProperty(key) && $state.params[key]) {
                  id += "_" + key + "=" + $state.params[key];
                }
              }
            }
            return id;
          }
          return ionic.Utils.nextUid();
        }
        function getCurrentStateParams() {
          var rtn;
          if ($state && $state.params) {
            for (var key in $state.params) {
              if ($state.params.hasOwnProperty(key)) {
                rtn = rtn || {};
                rtn[key] = $state.params[key];
              }
            }
          }
          return rtn;
        }
        return {
          register: function(parentScope, viewLocals) {
            var currentStateId = getCurrentStateId(),
                hist = getHistory(parentScope),
                currentView = viewHistory.currentView,
                backView = viewHistory.backView,
                forwardView = viewHistory.forwardView,
                viewId = null,
                action = null,
                direction = DIRECTION_NONE,
                historyId = hist.historyId,
                url = $location.url(),
                tmp,
                x,
                ele;
            if (lastStateId !== currentStateId) {
              lastStateId = currentStateId;
              stateChangeCounter++;
            }
            if (forcedNav) {
              viewId = forcedNav.viewId;
              action = forcedNav.action;
              direction = forcedNav.direction;
              forcedNav = null;
            } else if (backView && backView.stateId === currentStateId) {
              viewId = backView.viewId;
              historyId = backView.historyId;
              action = ACTION_MOVE_BACK;
              if (backView.historyId === currentView.historyId) {
                direction = DIRECTION_BACK;
              } else if (currentView) {
                direction = DIRECTION_EXIT;
                tmp = getHistoryById(backView.historyId);
                if (tmp && tmp.parentHistoryId === currentView.historyId) {
                  direction = DIRECTION_ENTER;
                } else {
                  tmp = getHistoryById(currentView.historyId);
                  if (tmp && tmp.parentHistoryId === hist.parentHistoryId) {
                    direction = DIRECTION_SWAP;
                  }
                }
              }
            } else if (forwardView && forwardView.stateId === currentStateId) {
              viewId = forwardView.viewId;
              historyId = forwardView.historyId;
              action = ACTION_MOVE_FORWARD;
              if (forwardView.historyId === currentView.historyId) {
                direction = DIRECTION_FORWARD;
              } else if (currentView) {
                direction = DIRECTION_EXIT;
                if (currentView.historyId === hist.parentHistoryId) {
                  direction = DIRECTION_ENTER;
                } else {
                  tmp = getHistoryById(currentView.historyId);
                  if (tmp && tmp.parentHistoryId === hist.parentHistoryId) {
                    direction = DIRECTION_SWAP;
                  }
                }
              }
              tmp = getParentHistoryObj(parentScope);
              if (forwardView.historyId && tmp.scope) {
                tmp.scope.$historyId = forwardView.historyId;
                historyId = forwardView.historyId;
              }
            } else if (currentView && currentView.historyId !== historyId && hist.cursor > -1 && hist.stack.length > 0 && hist.cursor < hist.stack.length && hist.stack[hist.cursor].stateId === currentStateId) {
              var switchToView = hist.stack[hist.cursor];
              viewId = switchToView.viewId;
              historyId = switchToView.historyId;
              action = ACTION_MOVE_BACK;
              direction = DIRECTION_SWAP;
              tmp = getHistoryById(currentView.historyId);
              if (tmp && tmp.parentHistoryId === historyId) {
                direction = DIRECTION_EXIT;
              } else {
                tmp = getHistoryById(historyId);
                if (tmp && tmp.parentHistoryId === currentView.historyId) {
                  direction = DIRECTION_ENTER;
                }
              }
              tmp = getViewById(switchToView.backViewId);
              if (tmp && switchToView.historyId !== tmp.historyId) {
                hist.stack[hist.cursor].backViewId = currentView.viewId;
              }
            } else {
              ele = $ionicViewSwitcher.createViewEle(viewLocals);
              if (this.isAbstractEle(ele, viewLocals)) {
                void 0;
                return {
                  action: 'abstractView',
                  direction: DIRECTION_NONE,
                  ele: ele
                };
              }
              viewId = ionic.Utils.nextUid();
              if (currentView) {
                currentView.forwardViewId = viewId;
                action = ACTION_NEW_VIEW;
                if (forwardView && currentView.stateId !== forwardView.stateId && currentView.historyId === forwardView.historyId) {
                  tmp = getHistoryById(forwardView.historyId);
                  if (tmp) {
                    for (x = tmp.stack.length - 1; x >= forwardView.index; x--) {
                      var stackItem = tmp.stack[x];
                      stackItem && stackItem.destroy && stackItem.destroy();
                      tmp.stack.splice(x);
                    }
                    historyId = forwardView.historyId;
                  }
                }
                if (hist.historyId === currentView.historyId) {
                  direction = DIRECTION_FORWARD;
                } else if (currentView.historyId !== hist.historyId) {
                  direction = DIRECTION_ENTER;
                  tmp = getHistoryById(currentView.historyId);
                  if (tmp && tmp.parentHistoryId === hist.parentHistoryId) {
                    direction = DIRECTION_SWAP;
                  } else {
                    tmp = getHistoryById(tmp.parentHistoryId);
                    if (tmp && tmp.historyId === hist.historyId) {
                      direction = DIRECTION_EXIT;
                    }
                  }
                }
              } else {
                action = ACTION_INITIAL_VIEW;
              }
              if (stateChangeCounter < 2) {
                direction = DIRECTION_NONE;
              }
              viewHistory.views[viewId] = this.createView({
                viewId: viewId,
                index: hist.stack.length,
                historyId: hist.historyId,
                backViewId: (currentView && currentView.viewId && (currentView.historyId === hist.historyId || currentView.historyId === hist.parentHistoryId) ? currentView.viewId : null),
                forwardViewId: null,
                stateId: currentStateId,
                stateName: this.currentStateName(),
                stateParams: getCurrentStateParams(),
                url: url,
                canSwipeBack: canSwipeBack(ele, viewLocals)
              });
              hist.stack.push(viewHistory.views[viewId]);
            }
            deregisterStateChangeListener && deregisterStateChangeListener();
            $timeout.cancel(nextViewExpireTimer);
            if (nextViewOptions) {
              if (nextViewOptions.disableAnimate)
                direction = DIRECTION_NONE;
              if (nextViewOptions.disableBack)
                viewHistory.views[viewId].backViewId = null;
              if (nextViewOptions.historyRoot) {
                for (x = 0; x < hist.stack.length; x++) {
                  if (hist.stack[x].viewId === viewId) {
                    hist.stack[x].index = 0;
                    hist.stack[x].backViewId = hist.stack[x].forwardViewId = null;
                  } else {
                    delete viewHistory.views[hist.stack[x].viewId];
                  }
                }
                hist.stack = [viewHistory.views[viewId]];
              }
              nextViewOptions = null;
            }
            setNavViews(viewId);
            if (viewHistory.backView && historyId == viewHistory.backView.historyId && currentStateId == viewHistory.backView.stateId && url == viewHistory.backView.url) {
              for (x = 0; x < hist.stack.length; x++) {
                if (hist.stack[x].viewId == viewId) {
                  action = 'dupNav';
                  direction = DIRECTION_NONE;
                  if (x > 0) {
                    hist.stack[x - 1].forwardViewId = null;
                  }
                  viewHistory.forwardView = null;
                  viewHistory.currentView.index = viewHistory.backView.index;
                  viewHistory.currentView.backViewId = viewHistory.backView.backViewId;
                  viewHistory.backView = getBackView(viewHistory.backView);
                  hist.stack.splice(x, 1);
                  break;
                }
              }
            }
            void 0;
            hist.cursor = viewHistory.currentView.index;
            return {
              viewId: viewId,
              action: action,
              direction: direction,
              historyId: historyId,
              enableBack: this.enabledBack(viewHistory.currentView),
              isHistoryRoot: (viewHistory.currentView.index === 0),
              ele: ele
            };
          },
          registerHistory: function(scope) {
            scope.$historyId = ionic.Utils.nextUid();
          },
          createView: function(data) {
            var newView = new View();
            return newView.initialize(data);
          },
          getViewById: getViewById,
          viewHistory: function() {
            return viewHistory;
          },
          currentView: function(view) {
            if (arguments.length) {
              viewHistory.currentView = view;
            }
            return viewHistory.currentView;
          },
          currentHistoryId: function() {
            return viewHistory.currentView ? viewHistory.currentView.historyId : null;
          },
          currentTitle: function(val) {
            if (viewHistory.currentView) {
              if (arguments.length) {
                viewHistory.currentView.title = val;
              }
              return viewHistory.currentView.title;
            }
          },
          backView: function(view) {
            if (arguments.length) {
              viewHistory.backView = view;
            }
            return viewHistory.backView;
          },
          backTitle: function(view) {
            var backView = (view && getViewById(view.backViewId)) || viewHistory.backView;
            return backView && backView.title;
          },
          forwardView: function(view) {
            if (arguments.length) {
              viewHistory.forwardView = view;
            }
            return viewHistory.forwardView;
          },
          currentStateName: function() {
            return ($state && $state.current ? $state.current.name : null);
          },
          isCurrentStateNavView: function(navView) {
            return !!($state && $state.current && $state.current.views && $state.current.views[navView]);
          },
          goToHistoryRoot: function(historyId) {
            if (historyId) {
              var hist = getHistoryById(historyId);
              if (hist && hist.stack.length) {
                if (viewHistory.currentView && viewHistory.currentView.viewId === hist.stack[0].viewId) {
                  return;
                }
                forcedNav = {
                  viewId: hist.stack[0].viewId,
                  action: ACTION_MOVE_BACK,
                  direction: DIRECTION_BACK
                };
                hist.stack[0].go();
              }
            }
          },
          goBack: function(backCount) {
            if (isDefined(backCount) && backCount !== -1) {
              if (backCount > -1)
                return;
              var currentHistory = viewHistory.histories[this.currentHistoryId()];
              var newCursor = currentHistory.cursor + backCount + 1;
              if (newCursor < 1) {
                newCursor = 1;
              }
              currentHistory.cursor = newCursor;
              setNavViews(currentHistory.stack[newCursor].viewId);
              var cursor = newCursor - 1;
              var clearStateIds = [];
              var fwdView = getViewById(currentHistory.stack[cursor].forwardViewId);
              while (fwdView) {
                clearStateIds.push(fwdView.stateId || fwdView.viewId);
                cursor++;
                if (cursor >= currentHistory.stack.length)
                  break;
                fwdView = getViewById(currentHistory.stack[cursor].forwardViewId);
              }
              var self = this;
              if (clearStateIds.length) {
                $timeout(function() {
                  self.clearCache(clearStateIds);
                }, 300);
              }
            }
            viewHistory.backView && viewHistory.backView.go();
          },
          removeBackView: function() {
            var self = this;
            var currentHistory = viewHistory.histories[this.currentHistoryId()];
            var currentCursor = currentHistory.cursor;
            var currentView = currentHistory.stack[currentCursor];
            var backView = currentHistory.stack[currentCursor - 1];
            var replacementView = currentHistory.stack[currentCursor - 2];
            if (!backView || !replacementView) {
              return;
            }
            currentHistory.stack.splice(currentCursor - 1, 1);
            self.clearCache([backView.viewId]);
            currentView.backViewId = replacementView.viewId;
            currentView.index = currentView.index - 1;
            replacementView.forwardViewId = currentView.viewId;
            viewHistory.backView = replacementView;
            currentHistory.currentCursor += -1;
          },
          enabledBack: function(view) {
            var backView = getBackView(view);
            return !!(backView && backView.historyId === view.historyId);
          },
          clearHistory: function() {
            var histories = viewHistory.histories,
                currentView = viewHistory.currentView;
            if (histories) {
              for (var historyId in histories) {
                if (histories[historyId].stack) {
                  histories[historyId].stack = [];
                  histories[historyId].cursor = -1;
                }
                if (currentView && currentView.historyId === historyId) {
                  currentView.backViewId = currentView.forwardViewId = null;
                  histories[historyId].stack.push(currentView);
                } else if (histories[historyId].destroy) {
                  histories[historyId].destroy();
                }
              }
            }
            for (var viewId in viewHistory.views) {
              if (viewId !== currentView.viewId) {
                delete viewHistory.views[viewId];
              }
            }
            if (currentView) {
              setNavViews(currentView.viewId);
            }
          },
          clearCache: function(stateIds) {
            return $timeout(function() {
              $ionicNavViewDelegate._instances.forEach(function(instance) {
                instance.clearCache(stateIds);
              });
            });
          },
          nextViewOptions: function(opts) {
            deregisterStateChangeListener && deregisterStateChangeListener();
            if (arguments.length) {
              $timeout.cancel(nextViewExpireTimer);
              if (opts === null) {
                nextViewOptions = opts;
              } else {
                nextViewOptions = nextViewOptions || {};
                extend(nextViewOptions, opts);
                if (nextViewOptions.expire) {
                  deregisterStateChangeListener = $rootScope.$on('$stateChangeSuccess', function() {
                    nextViewExpireTimer = $timeout(function() {
                      nextViewOptions = null;
                    }, nextViewOptions.expire);
                  });
                }
              }
            }
            return nextViewOptions;
          },
          isAbstractEle: function(ele, viewLocals) {
            if (viewLocals && viewLocals.$$state && viewLocals.$$state.self['abstract']) {
              return true;
            }
            return !!(ele && (isAbstractTag(ele) || isAbstractTag(ele.children())));
          },
          isActiveScope: function(scope) {
            if (!scope)
              return false;
            var climbScope = scope;
            var currentHistoryId = this.currentHistoryId();
            var foundHistoryId;
            while (climbScope) {
              if (climbScope.$$disconnected) {
                return false;
              }
              if (!foundHistoryId && climbScope.hasOwnProperty('$historyId')) {
                foundHistoryId = true;
              }
              if (currentHistoryId) {
                if (climbScope.hasOwnProperty('$historyId') && currentHistoryId == climbScope.$historyId) {
                  return true;
                }
                if (climbScope.hasOwnProperty('$activeHistoryId')) {
                  if (currentHistoryId == climbScope.$activeHistoryId) {
                    if (climbScope.hasOwnProperty('$historyId')) {
                      return true;
                    }
                    if (!foundHistoryId) {
                      return true;
                    }
                  }
                }
              }
              if (foundHistoryId && climbScope.hasOwnProperty('$activeHistoryId')) {
                foundHistoryId = false;
              }
              climbScope = climbScope.$parent;
            }
            return currentHistoryId ? currentHistoryId == 'root' : true;
          }
        };
        function isAbstractTag(ele) {
          return ele && ele.length && /ion-side-menus|ion-tabs/i.test(ele[0].tagName);
        }
        function canSwipeBack(ele, viewLocals) {
          if (viewLocals && viewLocals.$$state && viewLocals.$$state.self.canSwipeBack === false) {
            return false;
          }
          if (ele && ele.attr('can-swipe-back') === 'false') {
            return false;
          }
          var eleChild = ele.find('ion-view');
          if (eleChild && eleChild.attr('can-swipe-back') === 'false') {
            return false;
          }
          return true;
        }
      }]).run(['$rootScope', '$state', '$location', '$document', '$ionicPlatform', '$ionicHistory', 'IONIC_BACK_PRIORITY', function($rootScope, $state, $location, $document, $ionicPlatform, $ionicHistory, IONIC_BACK_PRIORITY) {
        $rootScope.$on('$ionicView.beforeEnter', function() {
          ionic.keyboard && ionic.keyboard.hide && ionic.keyboard.hide();
        });
        $rootScope.$on('$ionicHistory.change', function(e, data) {
          if (!data)
            return null;
          var viewHistory = $ionicHistory.viewHistory();
          var hist = (data.historyId ? viewHistory.histories[data.historyId] : null);
          if (hist && hist.cursor > -1 && hist.cursor < hist.stack.length) {
            var view = hist.stack[hist.cursor];
            return view.go(data);
          }
          if (!data.url && data.uiSref) {
            data.url = $state.href(data.uiSref);
          }
          if (data.url) {
            if (data.url.indexOf('#') === 0) {
              data.url = data.url.replace('#', '');
            }
            if (data.url !== $location.url()) {
              $location.url(data.url);
            }
          }
        });
        $rootScope.$ionicGoBack = function(backCount) {
          $ionicHistory.goBack(backCount);
        };
        $rootScope.$on('$ionicView.afterEnter', function(ev, data) {
          if (data && data.title) {
            $document[0].title = data.title;
          }
        });
        function onHardwareBackButton(e) {
          var backView = $ionicHistory.backView();
          if (backView) {
            backView.go();
          } else {
            ionic.Platform.exitApp();
          }
          e.preventDefault();
          return false;
        }
        $ionicPlatform.registerBackButtonAction(onHardwareBackButton, IONIC_BACK_PRIORITY.view);
      }]);
      IonicModule.provider('$ionicConfig', function() {
        var provider = this;
        provider.platform = {};
        var PLATFORM = 'platform';
        var configProperties = {
          views: {
            maxCache: PLATFORM,
            forwardCache: PLATFORM,
            transition: PLATFORM,
            swipeBackEnabled: PLATFORM,
            swipeBackHitWidth: PLATFORM
          },
          navBar: {
            alignTitle: PLATFORM,
            positionPrimaryButtons: PLATFORM,
            positionSecondaryButtons: PLATFORM,
            transition: PLATFORM
          },
          backButton: {
            icon: PLATFORM,
            text: PLATFORM,
            previousTitleText: PLATFORM
          },
          form: {
            checkbox: PLATFORM,
            toggle: PLATFORM
          },
          scrolling: {jsScrolling: PLATFORM},
          spinner: {icon: PLATFORM},
          tabs: {
            style: PLATFORM,
            position: PLATFORM
          },
          templates: {maxPrefetch: PLATFORM},
          platform: {}
        };
        createConfig(configProperties, provider, '');
        setPlatformConfig('default', {
          views: {
            maxCache: 10,
            forwardCache: false,
            transition: 'ios',
            swipeBackEnabled: true,
            swipeBackHitWidth: 45
          },
          navBar: {
            alignTitle: 'center',
            positionPrimaryButtons: 'left',
            positionSecondaryButtons: 'right',
            transition: 'view'
          },
          backButton: {
            icon: 'ion-ios-arrow-back',
            text: 'Back',
            previousTitleText: true
          },
          form: {
            checkbox: 'circle',
            toggle: 'large'
          },
          scrolling: {jsScrolling: true},
          spinner: {icon: 'ios'},
          tabs: {
            style: 'standard',
            position: 'bottom'
          },
          templates: {maxPrefetch: 30}
        });
        setPlatformConfig('ios', {});
        setPlatformConfig('android', {
          views: {
            transition: 'android',
            swipeBackEnabled: false
          },
          navBar: {
            alignTitle: 'left',
            positionPrimaryButtons: 'right',
            positionSecondaryButtons: 'right'
          },
          backButton: {
            icon: 'ion-android-arrow-back',
            text: false,
            previousTitleText: false
          },
          form: {
            checkbox: 'square',
            toggle: 'small'
          },
          spinner: {icon: 'android'},
          tabs: {
            style: 'striped',
            position: 'top'
          },
          scrolling: {jsScrolling: false}
        });
        setPlatformConfig('windowsphone', {spinner: {icon: 'android'}});
        provider.transitions = {
          views: {},
          navBar: {}
        };
        provider.transitions.views.ios = function(enteringEle, leavingEle, direction, shouldAnimate) {
          function setStyles(ele, opacity, x, boxShadowOpacity) {
            var css = {};
            css[ionic.CSS.TRANSITION_DURATION] = d.shouldAnimate ? '' : 0;
            css.opacity = opacity;
            if (boxShadowOpacity > -1) {
              css.boxShadow = '0 0 10px rgba(0,0,0,' + (d.shouldAnimate ? boxShadowOpacity * 0.45 : 0.3) + ')';
            }
            css[ionic.CSS.TRANSFORM] = 'translate3d(' + x + '%,0,0)';
            ionic.DomUtil.cachedStyles(ele, css);
          }
          var d = {
            run: function(step) {
              if (direction == 'forward') {
                setStyles(enteringEle, 1, (1 - step) * 99, 1 - step);
                setStyles(leavingEle, (1 - 0.1 * step), step * -33, -1);
              } else if (direction == 'back') {
                setStyles(enteringEle, (1 - 0.1 * (1 - step)), (1 - step) * -33, -1);
                setStyles(leavingEle, 1, step * 100, 1 - step);
              } else {
                setStyles(enteringEle, 1, 0, -1);
                setStyles(leavingEle, 0, 0, -1);
              }
            },
            shouldAnimate: shouldAnimate && (direction == 'forward' || direction == 'back')
          };
          return d;
        };
        provider.transitions.navBar.ios = function(enteringHeaderBar, leavingHeaderBar, direction, shouldAnimate) {
          function setStyles(ctrl, opacity, titleX, backTextX) {
            var css = {};
            css[ionic.CSS.TRANSITION_DURATION] = d.shouldAnimate ? '' : '0ms';
            css.opacity = opacity === 1 ? '' : opacity;
            ctrl.setCss('buttons-left', css);
            ctrl.setCss('buttons-right', css);
            ctrl.setCss('back-button', css);
            css[ionic.CSS.TRANSFORM] = 'translate3d(' + backTextX + 'px,0,0)';
            ctrl.setCss('back-text', css);
            css[ionic.CSS.TRANSFORM] = 'translate3d(' + titleX + 'px,0,0)';
            ctrl.setCss('title', css);
          }
          function enter(ctrlA, ctrlB, step) {
            if (!ctrlA || !ctrlB)
              return;
            var titleX = (ctrlA.titleTextX() + ctrlA.titleWidth()) * (1 - step);
            var backTextX = (ctrlB && (ctrlB.titleTextX() - ctrlA.backButtonTextLeft()) * (1 - step)) || 0;
            setStyles(ctrlA, step, titleX, backTextX);
          }
          function leave(ctrlA, ctrlB, step) {
            if (!ctrlA || !ctrlB)
              return;
            var titleX = (-(ctrlA.titleTextX() - ctrlB.backButtonTextLeft()) - (ctrlA.titleLeftRight())) * step;
            setStyles(ctrlA, 1 - step, titleX, 0);
          }
          var d = {
            run: function(step) {
              var enteringHeaderCtrl = enteringHeaderBar.controller();
              var leavingHeaderCtrl = leavingHeaderBar && leavingHeaderBar.controller();
              if (d.direction == 'back') {
                leave(enteringHeaderCtrl, leavingHeaderCtrl, 1 - step);
                enter(leavingHeaderCtrl, enteringHeaderCtrl, 1 - step);
              } else {
                enter(enteringHeaderCtrl, leavingHeaderCtrl, step);
                leave(leavingHeaderCtrl, enteringHeaderCtrl, step);
              }
            },
            direction: direction,
            shouldAnimate: shouldAnimate && (direction == 'forward' || direction == 'back')
          };
          return d;
        };
        provider.transitions.views.android = function(enteringEle, leavingEle, direction, shouldAnimate) {
          shouldAnimate = shouldAnimate && (direction == 'forward' || direction == 'back');
          function setStyles(ele, x, opacity) {
            var css = {};
            css[ionic.CSS.TRANSITION_DURATION] = d.shouldAnimate ? '' : 0;
            css[ionic.CSS.TRANSFORM] = 'translate3d(' + x + '%,0,0)';
            css.opacity = opacity;
            ionic.DomUtil.cachedStyles(ele, css);
          }
          var d = {
            run: function(step) {
              if (direction == 'forward') {
                setStyles(enteringEle, (1 - step) * 99, 1);
                setStyles(leavingEle, step * -100, 1);
              } else if (direction == 'back') {
                setStyles(enteringEle, (1 - step) * -100, 1);
                setStyles(leavingEle, step * 100, 1);
              } else {
                setStyles(enteringEle, 0, 1);
                setStyles(leavingEle, 0, 0);
              }
            },
            shouldAnimate: shouldAnimate
          };
          return d;
        };
        provider.transitions.navBar.android = function(enteringHeaderBar, leavingHeaderBar, direction, shouldAnimate) {
          function setStyles(ctrl, opacity) {
            if (!ctrl)
              return;
            var css = {};
            css.opacity = opacity === 1 ? '' : opacity;
            ctrl.setCss('buttons-left', css);
            ctrl.setCss('buttons-right', css);
            ctrl.setCss('back-button', css);
            ctrl.setCss('back-text', css);
            ctrl.setCss('title', css);
          }
          return {
            run: function(step) {
              setStyles(enteringHeaderBar.controller(), step);
              setStyles(leavingHeaderBar && leavingHeaderBar.controller(), 1 - step);
            },
            shouldAnimate: shouldAnimate && (direction == 'forward' || direction == 'back')
          };
        };
        provider.transitions.views.none = function(enteringEle, leavingEle) {
          return {
            run: function(step) {
              provider.transitions.views.android(enteringEle, leavingEle, false, false).run(step);
            },
            shouldAnimate: false
          };
        };
        provider.transitions.navBar.none = function(enteringHeaderBar, leavingHeaderBar) {
          return {
            run: function(step) {
              provider.transitions.navBar.ios(enteringHeaderBar, leavingHeaderBar, false, false).run(step);
              provider.transitions.navBar.android(enteringHeaderBar, leavingHeaderBar, false, false).run(step);
            },
            shouldAnimate: false
          };
        };
        function setPlatformConfig(platformName, platformConfigs) {
          configProperties.platform[platformName] = platformConfigs;
          provider.platform[platformName] = {};
          addConfig(configProperties, configProperties.platform[platformName]);
          createConfig(configProperties.platform[platformName], provider.platform[platformName], '');
        }
        function addConfig(configObj, platformObj) {
          for (var n in configObj) {
            if (n != PLATFORM && configObj.hasOwnProperty(n)) {
              if (angular.isObject(configObj[n])) {
                if (!isDefined(platformObj[n])) {
                  platformObj[n] = {};
                }
                addConfig(configObj[n], platformObj[n]);
              } else if (!isDefined(platformObj[n])) {
                platformObj[n] = null;
              }
            }
          }
        }
        function createConfig(configObj, providerObj, platformPath) {
          forEach(configObj, function(value, namespace) {
            if (angular.isObject(configObj[namespace])) {
              providerObj[namespace] = {};
              createConfig(configObj[namespace], providerObj[namespace], platformPath + '.' + namespace);
            } else {
              providerObj[namespace] = function(newValue) {
                if (arguments.length) {
                  configObj[namespace] = newValue;
                  return providerObj;
                }
                if (configObj[namespace] == PLATFORM) {
                  var platformConfig = stringObj(configProperties.platform, ionic.Platform.platform() + platformPath + '.' + namespace);
                  if (platformConfig || platformConfig === false) {
                    return platformConfig;
                  }
                  return stringObj(configProperties.platform, 'default' + platformPath + '.' + namespace);
                }
                return configObj[namespace];
              };
            }
          });
        }
        function stringObj(obj, str) {
          str = str.split(".");
          for (var i = 0; i < str.length; i++) {
            if (obj && isDefined(obj[str[i]])) {
              obj = obj[str[i]];
            } else {
              return null;
            }
          }
          return obj;
        }
        provider.setPlatformConfig = setPlatformConfig;
        provider.$get = function() {
          return provider;
        };
      }).config(['$compileProvider', function($compileProvider) {
        $compileProvider.aHrefSanitizationWhitelist(/^\s*(https?|sms|tel|geo|ftp|mailto|file|ghttps?|ms-appx-web|ms-appx|x-wmapp0):/);
        $compileProvider.imgSrcSanitizationWhitelist(/^\s*(https?|ftp|file|content|blob|ms-appx|ms-appx-web|x-wmapp0):|data:image\//);
      }]);
      var LOADING_TPL = '<div class="loading-container">' + '<div class="loading">' + '</div>' + '</div>';
      var LOADING_HIDE_DEPRECATED = '$ionicLoading instance.hide() has been deprecated. Use $ionicLoading.hide().';
      var LOADING_SHOW_DEPRECATED = '$ionicLoading instance.show() has been deprecated. Use $ionicLoading.show().';
      var LOADING_SET_DEPRECATED = '$ionicLoading instance.setContent() has been deprecated. Use $ionicLoading.show({ template: \'my content\' }).';
      IonicModule.constant('$ionicLoadingConfig', {template: '<ion-spinner></ion-spinner>'}).factory('$ionicLoading', ['$ionicLoadingConfig', '$ionicBody', '$ionicTemplateLoader', '$ionicBackdrop', '$timeout', '$q', '$log', '$compile', '$ionicPlatform', '$rootScope', 'IONIC_BACK_PRIORITY', function($ionicLoadingConfig, $ionicBody, $ionicTemplateLoader, $ionicBackdrop, $timeout, $q, $log, $compile, $ionicPlatform, $rootScope, IONIC_BACK_PRIORITY) {
        var loaderInstance;
        var deregisterBackAction = noop;
        var deregisterStateListener1 = noop;
        var deregisterStateListener2 = noop;
        var loadingShowDelay = $q.when();
        return {
          show: showLoader,
          hide: hideLoader,
          _getLoader: getLoader
        };
        function getLoader() {
          if (!loaderInstance) {
            loaderInstance = $ionicTemplateLoader.compile({
              template: LOADING_TPL,
              appendTo: $ionicBody.get()
            }).then(function(self) {
              self.show = function(options) {
                var templatePromise = options.templateUrl ? $ionicTemplateLoader.load(options.templateUrl) : $q.when(options.template || options.content || '');
                self.scope = options.scope || self.scope;
                if (!self.isShown) {
                  self.hasBackdrop = !options.noBackdrop && options.showBackdrop !== false;
                  if (self.hasBackdrop) {
                    $ionicBackdrop.retain();
                    $ionicBackdrop.getElement().addClass('backdrop-loading');
                  }
                }
                if (options.duration) {
                  $timeout.cancel(self.durationTimeout);
                  self.durationTimeout = $timeout(angular.bind(self, self.hide), +options.duration);
                }
                deregisterBackAction();
                deregisterBackAction = $ionicPlatform.registerBackButtonAction(noop, IONIC_BACK_PRIORITY.loading);
                templatePromise.then(function(html) {
                  if (html) {
                    var loading = self.element.children();
                    loading.html(html);
                    $compile(loading.contents())(self.scope);
                  }
                  if (self.isShown) {
                    self.element.addClass('visible');
                    ionic.requestAnimationFrame(function() {
                      if (self.isShown) {
                        self.element.addClass('active');
                        $ionicBody.addClass('loading-active');
                      }
                    });
                  }
                });
                self.isShown = true;
              };
              self.hide = function() {
                deregisterBackAction();
                if (self.isShown) {
                  if (self.hasBackdrop) {
                    $ionicBackdrop.release();
                    $ionicBackdrop.getElement().removeClass('backdrop-loading');
                  }
                  self.element.removeClass('active');
                  $ionicBody.removeClass('loading-active');
                  self.element.removeClass('visible');
                  ionic.requestAnimationFrame(function() {
                    !self.isShown && self.element.removeClass('visible');
                  });
                }
                $timeout.cancel(self.durationTimeout);
                self.isShown = false;
                var loading = self.element.children();
                loading.html("");
              };
              return self;
            });
          }
          return loaderInstance;
        }
        function showLoader(options) {
          options = extend({}, $ionicLoadingConfig || {}, options || {});
          var delay = options.delay || options.showDelay || 0;
          deregisterStateListener1();
          deregisterStateListener2();
          if (options.hideOnStateChange) {
            deregisterStateListener1 = $rootScope.$on('$stateChangeSuccess', hideLoader);
            deregisterStateListener2 = $rootScope.$on('$stateChangeError', hideLoader);
          }
          $timeout.cancel(loadingShowDelay);
          loadingShowDelay = $timeout(noop, delay);
          loadingShowDelay.then(getLoader).then(function(loader) {
            return loader.show(options);
          });
          return {
            hide: function deprecatedHide() {
              $log.error(LOADING_HIDE_DEPRECATED);
              return hideLoader.apply(this, arguments);
            },
            show: function deprecatedShow() {
              $log.error(LOADING_SHOW_DEPRECATED);
              return showLoader.apply(this, arguments);
            },
            setContent: function deprecatedSetContent(content) {
              $log.error(LOADING_SET_DEPRECATED);
              return getLoader().then(function(loader) {
                loader.show({template: content});
              });
            }
          };
        }
        function hideLoader() {
          deregisterStateListener1();
          deregisterStateListener2();
          $timeout.cancel(loadingShowDelay);
          getLoader().then(function(loader) {
            loader.hide();
          });
        }
      }]);
      IonicModule.factory('$ionicModal', ['$rootScope', '$ionicBody', '$compile', '$timeout', '$ionicPlatform', '$ionicTemplateLoader', '$$q', '$log', '$ionicClickBlock', '$window', 'IONIC_BACK_PRIORITY', function($rootScope, $ionicBody, $compile, $timeout, $ionicPlatform, $ionicTemplateLoader, $$q, $log, $ionicClickBlock, $window, IONIC_BACK_PRIORITY) {
        var ModalView = ionic.views.Modal.inherit({
          initialize: function(opts) {
            ionic.views.Modal.prototype.initialize.call(this, opts);
            this.animation = opts.animation || 'slide-in-up';
          },
          show: function(target) {
            var self = this;
            if (self.scope.$$destroyed) {
              $log.error('Cannot call ' + self.viewType + '.show() after remove(). Please create a new ' + self.viewType + ' instance.');
              return $$q.when();
            }
            $ionicClickBlock.show(600);
            stack.add(self);
            var modalEl = jqLite(self.modalEl);
            self.el.classList.remove('hide');
            $timeout(function() {
              if (!self._isShown)
                return;
              $ionicBody.addClass(self.viewType + '-open');
            }, 400, false);
            if (!self.el.parentElement) {
              modalEl.addClass(self.animation);
              $ionicBody.append(self.el);
            }
            var scrollCtrl = modalEl.data('$$ionicScrollController');
            scrollCtrl && scrollCtrl.resize();
            if (target && self.positionView) {
              self.positionView(target, modalEl);
              self._onWindowResize = function() {
                if (self._isShown)
                  self.positionView(target, modalEl);
              };
              ionic.on('resize', self._onWindowResize, window);
            }
            modalEl.addClass('ng-enter active').removeClass('ng-leave ng-leave-active');
            self._isShown = true;
            self._deregisterBackButton = $ionicPlatform.registerBackButtonAction(self.hardwareBackButtonClose ? angular.bind(self, self.hide) : noop, IONIC_BACK_PRIORITY.modal);
            ionic.views.Modal.prototype.show.call(self);
            $timeout(function() {
              if (!self._isShown)
                return;
              modalEl.addClass('ng-enter-active');
              ionic.trigger('resize');
              self.scope.$parent && self.scope.$parent.$broadcast(self.viewType + '.shown', self);
              self.el.classList.add('active');
              self.scope.$broadcast('$ionicHeader.align');
              self.scope.$broadcast('$ionicFooter.align');
              self.scope.$broadcast('$ionic.modalPresented');
            }, 20);
            return $timeout(function() {
              if (!self._isShown)
                return;
              self.$el.on('touchmove', function(e) {
                var isInScroll = ionic.DomUtil.getParentOrSelfWithClass(e.target, 'scroll');
                if (!isInScroll) {
                  e.preventDefault();
                }
              });
              self.$el.on('click', function(e) {
                if (self.backdropClickToClose && e.target === self.el && stack.isHighest(self)) {
                  self.hide();
                }
              });
            }, 400);
          },
          hide: function() {
            var self = this;
            var modalEl = jqLite(self.modalEl);
            $ionicClickBlock.show(600);
            stack.remove(self);
            self.el.classList.remove('active');
            modalEl.addClass('ng-leave');
            $timeout(function() {
              if (self._isShown)
                return;
              modalEl.addClass('ng-leave-active').removeClass('ng-enter ng-enter-active active');
              self.scope.$broadcast('$ionic.modalRemoved');
            }, 20, false);
            self.$el.off('click');
            self._isShown = false;
            self.scope.$parent && self.scope.$parent.$broadcast(self.viewType + '.hidden', self);
            self._deregisterBackButton && self._deregisterBackButton();
            ionic.views.Modal.prototype.hide.call(self);
            if (self.positionView) {
              ionic.off('resize', self._onWindowResize, window);
            }
            return $timeout(function() {
              $ionicBody.removeClass(self.viewType + '-open');
              self.el.classList.add('hide');
            }, self.hideDelay || 320);
          },
          remove: function() {
            var self = this,
                deferred,
                promise;
            self.scope.$parent && self.scope.$parent.$broadcast(self.viewType + '.removed', self);
            if (self._isShown) {
              promise = self.hide();
            } else {
              deferred = $$q.defer();
              deferred.resolve();
              promise = deferred.promise;
            }
            return promise.then(function() {
              self.scope.$destroy();
              self.$el.remove();
            });
          },
          isShown: function() {
            return !!this._isShown;
          }
        });
        var createModal = function(templateString, options) {
          var scope = options.scope && options.scope.$new() || $rootScope.$new(true);
          options.viewType = options.viewType || 'modal';
          extend(scope, {
            $hasHeader: false,
            $hasSubheader: false,
            $hasFooter: false,
            $hasSubfooter: false,
            $hasTabs: false,
            $hasTabsTop: false
          });
          var element = $compile('<ion-' + options.viewType + '>' + templateString + '</ion-' + options.viewType + '>')(scope);
          options.$el = element;
          options.el = element[0];
          options.modalEl = options.el.querySelector('.' + options.viewType);
          var modal = new ModalView(options);
          modal.scope = scope;
          if (!options.scope) {
            scope[options.viewType] = modal;
          }
          return modal;
        };
        var modalStack = [];
        var stack = {
          add: function(modal) {
            modalStack.push(modal);
          },
          remove: function(modal) {
            var index = modalStack.indexOf(modal);
            if (index > -1 && index < modalStack.length) {
              modalStack.splice(index, 1);
            }
          },
          isHighest: function(modal) {
            var index = modalStack.indexOf(modal);
            return (index > -1 && index === modalStack.length - 1);
          }
        };
        return {
          fromTemplate: function(templateString, options) {
            var modal = createModal(templateString, options || {});
            return modal;
          },
          fromTemplateUrl: function(url, options, _) {
            var cb;
            if (angular.isFunction(options)) {
              cb = options;
              options = _;
            }
            return $ionicTemplateLoader.load(url).then(function(templateString) {
              var modal = createModal(templateString, options || {});
              cb && cb(modal);
              return modal;
            });
          },
          stack: stack
        };
      }]);
      IonicModule.service('$ionicNavBarDelegate', ionic.DelegateService(['align', 'showBackButton', 'showBar', 'title', 'changeTitle', 'setTitle', 'getTitle', 'back', 'getPreviousTitle']));
      IonicModule.service('$ionicNavViewDelegate', ionic.DelegateService(['clearCache']));
      IonicModule.constant('IONIC_BACK_PRIORITY', {
        view: 100,
        sideMenu: 150,
        modal: 200,
        actionSheet: 300,
        popup: 400,
        loading: 500
      }).provider('$ionicPlatform', function() {
        return {$get: ['$q', '$ionicScrollDelegate', function($q, $ionicScrollDelegate) {
            var self = {
              onHardwareBackButton: function(cb) {
                ionic.Platform.ready(function() {
                  document.addEventListener('backbutton', cb, false);
                });
              },
              offHardwareBackButton: function(fn) {
                ionic.Platform.ready(function() {
                  document.removeEventListener('backbutton', fn);
                });
              },
              $backButtonActions: {},
              registerBackButtonAction: function(fn, priority, actionId) {
                if (!self._hasBackButtonHandler) {
                  self.$backButtonActions = {};
                  self.onHardwareBackButton(self.hardwareBackButtonClick);
                  self._hasBackButtonHandler = true;
                }
                var action = {
                  id: (actionId ? actionId : ionic.Utils.nextUid()),
                  priority: (priority ? priority : 0),
                  fn: fn
                };
                self.$backButtonActions[action.id] = action;
                return function() {
                  delete self.$backButtonActions[action.id];
                };
              },
              hardwareBackButtonClick: function(e) {
                var priorityAction,
                    actionId;
                for (actionId in self.$backButtonActions) {
                  if (!priorityAction || self.$backButtonActions[actionId].priority >= priorityAction.priority) {
                    priorityAction = self.$backButtonActions[actionId];
                  }
                }
                if (priorityAction) {
                  priorityAction.fn(e);
                  return priorityAction;
                }
              },
              is: function(type) {
                return ionic.Platform.is(type);
              },
              on: function(type, cb) {
                ionic.Platform.ready(function() {
                  document.addEventListener(type, cb, false);
                });
                return function() {
                  ionic.Platform.ready(function() {
                    document.removeEventListener(type, cb);
                  });
                };
              },
              ready: function(cb) {
                var q = $q.defer();
                ionic.Platform.ready(function() {
                  q.resolve();
                  cb && cb();
                });
                return q.promise;
              }
            };
            window.addEventListener('statusTap', function() {
              $ionicScrollDelegate.scrollTop(true);
            });
            return self;
          }]};
      });
      IonicModule.factory('$ionicPopover', ['$ionicModal', '$ionicPosition', '$document', '$window', function($ionicModal, $ionicPosition, $document, $window) {
        var POPOVER_BODY_PADDING = 6;
        var POPOVER_OPTIONS = {
          viewType: 'popover',
          hideDelay: 1,
          animation: 'none',
          positionView: positionView
        };
        function positionView(target, popoverEle) {
          var targetEle = jqLite(target.target || target);
          var buttonOffset = $ionicPosition.offset(targetEle);
          var popoverWidth = popoverEle.prop('offsetWidth');
          var popoverHeight = popoverEle.prop('offsetHeight');
          var bodyWidth = $window.innerWidth;
          var bodyHeight = $window.innerHeight;
          var popoverCSS = {left: buttonOffset.left + buttonOffset.width / 2 - popoverWidth / 2};
          var arrowEle = jqLite(popoverEle[0].querySelector('.popover-arrow'));
          if (popoverCSS.left < POPOVER_BODY_PADDING) {
            popoverCSS.left = POPOVER_BODY_PADDING;
          } else if (popoverCSS.left + popoverWidth + POPOVER_BODY_PADDING > bodyWidth) {
            popoverCSS.left = bodyWidth - popoverWidth - POPOVER_BODY_PADDING;
          }
          if (buttonOffset.top + buttonOffset.height + popoverHeight > bodyHeight && buttonOffset.top - popoverHeight > 0) {
            popoverCSS.top = buttonOffset.top - popoverHeight;
            popoverEle.addClass('popover-bottom');
          } else {
            popoverCSS.top = buttonOffset.top + buttonOffset.height;
            popoverEle.removeClass('popover-bottom');
          }
          arrowEle.css({left: buttonOffset.left + buttonOffset.width / 2 - arrowEle.prop('offsetWidth') / 2 - popoverCSS.left + 'px'});
          popoverEle.css({
            top: popoverCSS.top + 'px',
            left: popoverCSS.left + 'px',
            marginLeft: '0',
            opacity: '1'
          });
        }
        return {
          fromTemplate: function(templateString, options) {
            return $ionicModal.fromTemplate(templateString, ionic.Utils.extend({}, POPOVER_OPTIONS, options));
          },
          fromTemplateUrl: function(url, options) {
            return $ionicModal.fromTemplateUrl(url, ionic.Utils.extend({}, POPOVER_OPTIONS, options));
          }
        };
      }]);
      var POPUP_TPL = '<div class="popup-container" ng-class="cssClass">' + '<div class="popup">' + '<div class="popup-head">' + '<h3 class="popup-title" ng-bind-html="title"></h3>' + '<h5 class="popup-sub-title" ng-bind-html="subTitle" ng-if="subTitle"></h5>' + '</div>' + '<div class="popup-body">' + '</div>' + '<div class="popup-buttons" ng-show="buttons.length">' + '<button ng-repeat="button in buttons" ng-click="$buttonTapped(button, $event)" class="button" ng-class="button.type || \'button-default\'" ng-bind-html="button.text"></button>' + '</div>' + '</div>' + '</div>';
      IonicModule.factory('$ionicPopup', ['$ionicTemplateLoader', '$ionicBackdrop', '$q', '$timeout', '$rootScope', '$ionicBody', '$compile', '$ionicPlatform', '$ionicModal', 'IONIC_BACK_PRIORITY', function($ionicTemplateLoader, $ionicBackdrop, $q, $timeout, $rootScope, $ionicBody, $compile, $ionicPlatform, $ionicModal, IONIC_BACK_PRIORITY) {
        var config = {stackPushDelay: 75};
        var popupStack = [];
        var $ionicPopup = {
          show: showPopup,
          alert: showAlert,
          confirm: showConfirm,
          prompt: showPrompt,
          _createPopup: createPopup,
          _popupStack: popupStack
        };
        return $ionicPopup;
        function createPopup(options) {
          options = extend({
            scope: null,
            title: '',
            buttons: []
          }, options || {});
          var self = {};
          self.scope = (options.scope || $rootScope).$new();
          self.element = jqLite(POPUP_TPL);
          self.responseDeferred = $q.defer();
          $ionicBody.get().appendChild(self.element[0]);
          $compile(self.element)(self.scope);
          extend(self.scope, {
            title: options.title,
            buttons: options.buttons,
            subTitle: options.subTitle,
            cssClass: options.cssClass,
            $buttonTapped: function(button, event) {
              var result = (button.onTap || noop).apply(self, [event]);
              event = event.originalEvent || event;
              if (!event.defaultPrevented) {
                self.responseDeferred.resolve(result);
              }
            }
          });
          $q.when(options.templateUrl ? $ionicTemplateLoader.load(options.templateUrl) : (options.template || options.content || '')).then(function(template) {
            var popupBody = jqLite(self.element[0].querySelector('.popup-body'));
            if (template) {
              popupBody.html(template);
              $compile(popupBody.contents())(self.scope);
            } else {
              popupBody.remove();
            }
          });
          self.show = function() {
            if (self.isShown || self.removed)
              return;
            $ionicModal.stack.add(self);
            self.isShown = true;
            ionic.requestAnimationFrame(function() {
              if (!self.isShown)
                return;
              self.element.removeClass('popup-hidden');
              self.element.addClass('popup-showing active');
              focusInput(self.element);
            });
          };
          self.hide = function(callback) {
            callback = callback || noop;
            if (!self.isShown)
              return callback();
            $ionicModal.stack.remove(self);
            self.isShown = false;
            self.element.removeClass('active');
            self.element.addClass('popup-hidden');
            $timeout(callback, 250, false);
          };
          self.remove = function() {
            if (self.removed)
              return;
            self.hide(function() {
              self.element.remove();
              self.scope.$destroy();
            });
            self.removed = true;
          };
          return self;
        }
        function onHardwareBackButton() {
          var last = popupStack[popupStack.length - 1];
          last && last.responseDeferred.resolve();
        }
        function showPopup(options) {
          var popup = $ionicPopup._createPopup(options);
          var showDelay = 0;
          if (popupStack.length > 0) {
            showDelay = config.stackPushDelay;
            $timeout(popupStack[popupStack.length - 1].hide, showDelay, false);
          } else {
            $ionicBody.addClass('popup-open');
            $ionicBackdrop.retain();
            $ionicPopup._backButtonActionDone = $ionicPlatform.registerBackButtonAction(onHardwareBackButton, IONIC_BACK_PRIORITY.popup);
          }
          popup.responseDeferred.promise.close = function popupClose(result) {
            if (!popup.removed)
              popup.responseDeferred.resolve(result);
          };
          popup.responseDeferred.notify({close: popup.responseDeferred.close});
          doShow();
          return popup.responseDeferred.promise;
          function doShow() {
            popupStack.push(popup);
            $timeout(popup.show, showDelay, false);
            popup.responseDeferred.promise.then(function(result) {
              var index = popupStack.indexOf(popup);
              if (index !== -1) {
                popupStack.splice(index, 1);
              }
              popup.remove();
              if (popupStack.length > 0) {
                popupStack[popupStack.length - 1].show();
              } else {
                $ionicBackdrop.release();
                $timeout(function() {
                  if (!popupStack.length) {
                    $ionicBody.removeClass('popup-open');
                  }
                }, 400, false);
                ($ionicPopup._backButtonActionDone || noop)();
              }
              return result;
            });
          }
        }
        function focusInput(element) {
          var focusOn = element[0].querySelector('[autofocus]');
          if (focusOn) {
            focusOn.focus();
          }
        }
        function showAlert(opts) {
          return showPopup(extend({buttons: [{
              text: opts.okText || 'OK',
              type: opts.okType || 'button-positive',
              onTap: function() {
                return true;
              }
            }]}, opts || {}));
        }
        function showConfirm(opts) {
          return showPopup(extend({buttons: [{
              text: opts.cancelText || 'Cancel',
              type: opts.cancelType || 'button-default',
              onTap: function() {
                return false;
              }
            }, {
              text: opts.okText || 'OK',
              type: opts.okType || 'button-positive',
              onTap: function() {
                return true;
              }
            }]}, opts || {}));
        }
        function showPrompt(opts) {
          var scope = $rootScope.$new(true);
          scope.data = {};
          scope.data.fieldtype = opts.inputType ? opts.inputType : 'text';
          scope.data.response = opts.defaultText ? opts.defaultText : '';
          scope.data.placeholder = opts.inputPlaceholder ? opts.inputPlaceholder : '';
          scope.data.maxlength = opts.maxLength ? parseInt(opts.maxLength) : '';
          var text = '';
          if (opts.template && /<[a-z][\s\S]*>/i.test(opts.template) === false) {
            text = '<span>' + opts.template + '</span>';
            delete opts.template;
          }
          return showPopup(extend({
            template: text + '<input ng-model="data.response" ' + 'type="{{ data.fieldtype }}"' + 'maxlength="{{ data.maxlength }}"' + 'placeholder="{{ data.placeholder }}"' + '>',
            scope: scope,
            buttons: [{
              text: opts.cancelText || 'Cancel',
              type: opts.cancelType || 'button-default',
              onTap: function() {}
            }, {
              text: opts.okText || 'OK',
              type: opts.okType || 'button-positive',
              onTap: function() {
                return scope.data.response || '';
              }
            }]
          }, opts || {}));
        }
      }]);
      IonicModule.factory('$ionicPosition', ['$document', '$window', function($document, $window) {
        function getStyle(el, cssprop) {
          if (el.currentStyle) {
            return el.currentStyle[cssprop];
          } else if ($window.getComputedStyle) {
            return $window.getComputedStyle(el)[cssprop];
          }
          return el.style[cssprop];
        }
        function isStaticPositioned(element) {
          return (getStyle(element, 'position') || 'static') === 'static';
        }
        var parentOffsetEl = function(element) {
          var docDomEl = $document[0];
          var offsetParent = element.offsetParent || docDomEl;
          while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent)) {
            offsetParent = offsetParent.offsetParent;
          }
          return offsetParent || docDomEl;
        };
        return {
          position: function(element) {
            var elBCR = this.offset(element);
            var offsetParentBCR = {
              top: 0,
              left: 0
            };
            var offsetParentEl = parentOffsetEl(element[0]);
            if (offsetParentEl != $document[0]) {
              offsetParentBCR = this.offset(jqLite(offsetParentEl));
              offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;
              offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;
            }
            var boundingClientRect = element[0].getBoundingClientRect();
            return {
              width: boundingClientRect.width || element.prop('offsetWidth'),
              height: boundingClientRect.height || element.prop('offsetHeight'),
              top: elBCR.top - offsetParentBCR.top,
              left: elBCR.left - offsetParentBCR.left
            };
          },
          offset: function(element) {
            var boundingClientRect = element[0].getBoundingClientRect();
            return {
              width: boundingClientRect.width || element.prop('offsetWidth'),
              height: boundingClientRect.height || element.prop('offsetHeight'),
              top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),
              left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)
            };
          }
        };
      }]);
      IonicModule.service('$ionicScrollDelegate', ionic.DelegateService(['resize', 'scrollTop', 'scrollBottom', 'scrollTo', 'scrollBy', 'zoomTo', 'zoomBy', 'getScrollPosition', 'anchorScroll', 'freezeScroll', 'freezeAllScrolls', 'getScrollView']));
      IonicModule.service('$ionicSideMenuDelegate', ionic.DelegateService(['toggleLeft', 'toggleRight', 'getOpenRatio', 'isOpen', 'isOpenLeft', 'isOpenRight', 'canDragContent', 'edgeDragThreshold']));
      IonicModule.service('$ionicSlideBoxDelegate', ionic.DelegateService(['update', 'slide', 'select', 'enableSlide', 'previous', 'next', 'stop', 'autoPlay', 'start', 'currentIndex', 'selected', 'slidesCount', 'count', 'loop']));
      IonicModule.service('$ionicTabsDelegate', ionic.DelegateService(['select', 'selectedIndex', 'showBar']));
      (function() {
        var templatesToCache = [];
        IonicModule.factory('$ionicTemplateCache', ['$http', '$templateCache', '$timeout', function($http, $templateCache, $timeout) {
          var toCache = templatesToCache,
              hasRun;
          function $ionicTemplateCache(templates) {
            if (typeof templates === 'undefined') {
              return run();
            }
            if (isString(templates)) {
              templates = [templates];
            }
            forEach(templates, function(template) {
              toCache.push(template);
            });
            if (hasRun) {
              run();
            }
          }
          function run() {
            var template;
            $ionicTemplateCache._runCount++;
            hasRun = true;
            if (toCache.length === 0)
              return;
            var i = 0;
            while (i < 4 && (template = toCache.pop())) {
              if (isString(template))
                $http.get(template, {cache: $templateCache});
              i++;
            }
            if (toCache.length) {
              $timeout(run, 1000);
            }
          }
          $ionicTemplateCache._runCount = 0;
          return $ionicTemplateCache;
        }]).config(['$stateProvider', '$ionicConfigProvider', function($stateProvider, $ionicConfigProvider) {
          var stateProviderState = $stateProvider.state;
          $stateProvider.state = function(stateName, definition) {
            if (typeof definition === 'object') {
              var enabled = definition.prefetchTemplate !== false && templatesToCache.length < $ionicConfigProvider.templates.maxPrefetch();
              if (enabled && isString(definition.templateUrl))
                templatesToCache.push(definition.templateUrl);
              if (angular.isObject(definition.views)) {
                for (var key in definition.views) {
                  enabled = definition.views[key].prefetchTemplate !== false && templatesToCache.length < $ionicConfigProvider.templates.maxPrefetch();
                  if (enabled && isString(definition.views[key].templateUrl))
                    templatesToCache.push(definition.views[key].templateUrl);
                }
              }
            }
            return stateProviderState.call($stateProvider, stateName, definition);
          };
        }]).run(['$ionicTemplateCache', function($ionicTemplateCache) {
          $ionicTemplateCache();
        }]);
      })();
      IonicModule.factory('$ionicTemplateLoader', ['$compile', '$controller', '$http', '$q', '$rootScope', '$templateCache', function($compile, $controller, $http, $q, $rootScope, $templateCache) {
        return {
          load: fetchTemplate,
          compile: loadAndCompile
        };
        function fetchTemplate(url) {
          return $http.get(url, {cache: $templateCache}).then(function(response) {
            return response.data && response.data.trim();
          });
        }
        function loadAndCompile(options) {
          options = extend({
            template: '',
            templateUrl: '',
            scope: null,
            controller: null,
            locals: {},
            appendTo: null
          }, options || {});
          var templatePromise = options.templateUrl ? this.load(options.templateUrl) : $q.when(options.template);
          return templatePromise.then(function(template) {
            var controller;
            var scope = options.scope || $rootScope.$new();
            var element = jqLite('<div>').html(template).contents();
            if (options.controller) {
              controller = $controller(options.controller, extend(options.locals, {$scope: scope}));
              element.children().data('$ngControllerController', controller);
            }
            if (options.appendTo) {
              jqLite(options.appendTo).append(element);
            }
            $compile(element)(scope);
            return {
              element: element,
              scope: scope
            };
          });
        }
      }]);
      IonicModule.factory('$ionicViewService', ['$ionicHistory', '$log', function($ionicHistory, $log) {
        function warn(oldMethod, newMethod) {
          $log.warn('$ionicViewService' + oldMethod + ' is deprecated, please use $ionicHistory' + newMethod + ' instead: http://ionicframework.com/docs/nightly/api/service/$ionicHistory/');
        }
        warn('', '');
        var methodsMap = {
          getCurrentView: 'currentView',
          getBackView: 'backView',
          getForwardView: 'forwardView',
          getCurrentStateName: 'currentStateName',
          nextViewOptions: 'nextViewOptions',
          clearHistory: 'clearHistory'
        };
        forEach(methodsMap, function(newMethod, oldMethod) {
          methodsMap[oldMethod] = function() {
            warn('.' + oldMethod, '.' + newMethod);
            return $ionicHistory[newMethod].apply(this, arguments);
          };
        });
        return methodsMap;
      }]);
      IonicModule.factory('$ionicViewSwitcher', ['$timeout', '$document', '$q', '$ionicClickBlock', '$ionicConfig', '$ionicNavBarDelegate', function($timeout, $document, $q, $ionicClickBlock, $ionicConfig, $ionicNavBarDelegate) {
        var TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';
        var DATA_NO_CACHE = '$noCache';
        var DATA_DESTROY_ELE = '$destroyEle';
        var DATA_ELE_IDENTIFIER = '$eleId';
        var DATA_VIEW_ACCESSED = '$accessed';
        var DATA_FALLBACK_TIMER = '$fallbackTimer';
        var DATA_VIEW = '$viewData';
        var NAV_VIEW_ATTR = 'nav-view';
        var VIEW_STATUS_ACTIVE = 'active';
        var VIEW_STATUS_CACHED = 'cached';
        var VIEW_STATUS_STAGED = 'stage';
        var transitionCounter = 0;
        var nextTransition,
            nextDirection;
        ionic.transition = ionic.transition || {};
        ionic.transition.isActive = false;
        var isActiveTimer;
        var cachedAttr = ionic.DomUtil.cachedAttr;
        var transitionPromises = [];
        var defaultTimeout = 1100;
        var ionicViewSwitcher = {
          create: function(navViewCtrl, viewLocals, enteringView, leavingView, renderStart, renderEnd) {
            var enteringEle,
                leavingEle;
            var transitionId = ++transitionCounter;
            var alreadyInDom;
            var switcher = {
              init: function(registerData, callback) {
                ionicViewSwitcher.isTransitioning(true);
                switcher.loadViewElements(registerData);
                switcher.render(registerData, function() {
                  callback && callback();
                });
              },
              loadViewElements: function(registerData) {
                var x,
                    l,
                    viewEle;
                var viewElements = navViewCtrl.getViewElements();
                var enteringEleIdentifier = getViewElementIdentifier(viewLocals, enteringView);
                var navViewActiveEleId = navViewCtrl.activeEleId();
                for (x = 0, l = viewElements.length; x < l; x++) {
                  viewEle = viewElements.eq(x);
                  if (viewEle.data(DATA_ELE_IDENTIFIER) === enteringEleIdentifier) {
                    if (viewEle.data(DATA_NO_CACHE)) {
                      viewEle.data(DATA_ELE_IDENTIFIER, enteringEleIdentifier + ionic.Utils.nextUid());
                      viewEle.data(DATA_DESTROY_ELE, true);
                    } else {
                      enteringEle = viewEle;
                    }
                  } else if (isDefined(navViewActiveEleId) && viewEle.data(DATA_ELE_IDENTIFIER) === navViewActiveEleId) {
                    leavingEle = viewEle;
                  }
                  if (enteringEle && leavingEle)
                    break;
                }
                alreadyInDom = !!enteringEle;
                if (!alreadyInDom) {
                  enteringEle = registerData.ele || ionicViewSwitcher.createViewEle(viewLocals);
                  enteringEle.data(DATA_ELE_IDENTIFIER, enteringEleIdentifier);
                }
                if (renderEnd) {
                  navViewCtrl.activeEleId(enteringEleIdentifier);
                }
                registerData.ele = null;
              },
              render: function(registerData, callback) {
                if (alreadyInDom) {
                  ionic.Utils.reconnectScope(enteringEle.scope());
                } else {
                  navViewAttr(enteringEle, VIEW_STATUS_STAGED);
                  var enteringData = getTransitionData(viewLocals, enteringEle, registerData.direction, enteringView);
                  var transitionFn = $ionicConfig.transitions.views[enteringData.transition] || $ionicConfig.transitions.views.none;
                  transitionFn(enteringEle, null, enteringData.direction, true).run(0);
                  enteringEle.data(DATA_VIEW, {
                    viewId: enteringData.viewId,
                    historyId: enteringData.historyId,
                    stateName: enteringData.stateName,
                    stateParams: enteringData.stateParams
                  });
                  if (viewState(viewLocals).cache === false || viewState(viewLocals).cache === 'false' || enteringEle.attr('cache-view') == 'false' || $ionicConfig.views.maxCache() === 0) {
                    enteringEle.data(DATA_NO_CACHE, true);
                  }
                  var viewScope = navViewCtrl.appendViewElement(enteringEle, viewLocals);
                  delete enteringData.direction;
                  delete enteringData.transition;
                  viewScope.$emit('$ionicView.loaded', enteringData);
                }
                enteringEle.data(DATA_VIEW_ACCESSED, Date.now());
                callback && callback();
              },
              transition: function(direction, enableBack, allowAnimate) {
                var deferred;
                var enteringData = getTransitionData(viewLocals, enteringEle, direction, enteringView);
                var leavingData = extend(extend({}, enteringData), getViewData(leavingView));
                enteringData.transitionId = leavingData.transitionId = transitionId;
                enteringData.fromCache = !!alreadyInDom;
                enteringData.enableBack = !!enableBack;
                enteringData.renderStart = renderStart;
                enteringData.renderEnd = renderEnd;
                cachedAttr(enteringEle.parent(), 'nav-view-transition', enteringData.transition);
                cachedAttr(enteringEle.parent(), 'nav-view-direction', enteringData.direction);
                $timeout.cancel(enteringEle.data(DATA_FALLBACK_TIMER));
                var transitionFn = $ionicConfig.transitions.views[enteringData.transition] || $ionicConfig.transitions.views.none;
                var viewTransition = transitionFn(enteringEle, leavingEle, enteringData.direction, enteringData.shouldAnimate && allowAnimate && renderEnd);
                if (viewTransition.shouldAnimate) {
                  enteringEle.on(TRANSITIONEND_EVENT, completeOnTransitionEnd);
                  enteringEle.data(DATA_FALLBACK_TIMER, $timeout(transitionComplete, defaultTimeout));
                  $ionicClickBlock.show(defaultTimeout);
                }
                if (renderStart) {
                  switcher.emit('before', enteringData, leavingData);
                  navViewAttr(enteringEle, VIEW_STATUS_STAGED);
                  viewTransition.run(0);
                }
                if (renderEnd) {
                  deferred = $q.defer();
                  transitionPromises.push(deferred.promise);
                }
                if (renderStart && renderEnd) {
                  $timeout(function() {
                    ionic.requestAnimationFrame(onReflow);
                  });
                } else if (!renderEnd) {
                  navViewAttr(enteringEle, 'entering');
                  navViewAttr(leavingEle, 'leaving');
                  return {
                    run: viewTransition.run,
                    cancel: function(shouldAnimate) {
                      if (shouldAnimate) {
                        enteringEle.on(TRANSITIONEND_EVENT, cancelOnTransitionEnd);
                        enteringEle.data(DATA_FALLBACK_TIMER, $timeout(cancelTransition, defaultTimeout));
                        $ionicClickBlock.show(defaultTimeout);
                      } else {
                        cancelTransition();
                      }
                      viewTransition.shouldAnimate = shouldAnimate;
                      viewTransition.run(0);
                      viewTransition = null;
                    }
                  };
                } else if (renderEnd) {
                  onReflow();
                }
                function onReflow() {
                  navViewAttr(enteringEle, viewTransition.shouldAnimate ? 'entering' : VIEW_STATUS_ACTIVE);
                  navViewAttr(leavingEle, viewTransition.shouldAnimate ? 'leaving' : VIEW_STATUS_CACHED);
                  viewTransition.run(1);
                  $ionicNavBarDelegate._instances.forEach(function(instance) {
                    instance.triggerTransitionStart(transitionId);
                  });
                  if (!viewTransition.shouldAnimate) {
                    transitionComplete();
                  }
                }
                function completeOnTransitionEnd(ev) {
                  if (ev.target !== this)
                    return;
                  transitionComplete();
                }
                function transitionComplete() {
                  if (transitionComplete.x)
                    return;
                  transitionComplete.x = true;
                  enteringEle.off(TRANSITIONEND_EVENT, completeOnTransitionEnd);
                  $timeout.cancel(enteringEle.data(DATA_FALLBACK_TIMER));
                  leavingEle && $timeout.cancel(leavingEle.data(DATA_FALLBACK_TIMER));
                  deferred && deferred.resolve(navViewCtrl);
                  if (transitionId === transitionCounter) {
                    $q.all(transitionPromises).then(ionicViewSwitcher.transitionEnd);
                    switcher.emit('after', enteringData, leavingData);
                    switcher.cleanup(enteringData);
                  }
                  $ionicNavBarDelegate._instances.forEach(function(instance) {
                    instance.triggerTransitionEnd();
                  });
                  nextTransition = nextDirection = enteringView = leavingView = enteringEle = leavingEle = null;
                }
                function cancelOnTransitionEnd(ev) {
                  if (ev.target !== this)
                    return;
                  cancelTransition();
                }
                function cancelTransition() {
                  navViewAttr(enteringEle, VIEW_STATUS_CACHED);
                  navViewAttr(leavingEle, VIEW_STATUS_ACTIVE);
                  enteringEle.off(TRANSITIONEND_EVENT, cancelOnTransitionEnd);
                  $timeout.cancel(enteringEle.data(DATA_FALLBACK_TIMER));
                  ionicViewSwitcher.transitionEnd([navViewCtrl]);
                }
              },
              emit: function(step, enteringData, leavingData) {
                var enteringScope = enteringEle.scope(),
                    leavingScope = leavingEle && leavingEle.scope();
                if (step == 'after') {
                  if (enteringScope) {
                    enteringScope.$emit('$ionicView.enter', enteringData);
                  }
                  if (leavingScope) {
                    leavingScope.$emit('$ionicView.leave', leavingData);
                  } else if (enteringScope && leavingData && leavingData.viewId) {
                    enteringScope.$emit('$ionicNavView.leave', leavingData);
                  }
                }
                if (enteringScope) {
                  enteringScope.$emit('$ionicView.' + step + 'Enter', enteringData);
                }
                if (leavingScope) {
                  leavingScope.$emit('$ionicView.' + step + 'Leave', leavingData);
                } else if (enteringScope && leavingData && leavingData.viewId) {
                  enteringScope.$emit('$ionicNavView.' + step + 'Leave', leavingData);
                }
              },
              cleanup: function(transData) {
                if (leavingEle && transData.direction == 'back' && !$ionicConfig.views.forwardCache()) {
                  destroyViewEle(leavingEle);
                }
                var viewElements = navViewCtrl.getViewElements();
                var viewElementsLength = viewElements.length;
                var x,
                    viewElement;
                var removeOldestAccess = (viewElementsLength - 1) > $ionicConfig.views.maxCache();
                var removableEle;
                var oldestAccess = Date.now();
                for (x = 0; x < viewElementsLength; x++) {
                  viewElement = viewElements.eq(x);
                  if (removeOldestAccess && viewElement.data(DATA_VIEW_ACCESSED) < oldestAccess) {
                    oldestAccess = viewElement.data(DATA_VIEW_ACCESSED);
                    removableEle = viewElements.eq(x);
                  } else if (viewElement.data(DATA_DESTROY_ELE) && navViewAttr(viewElement) != VIEW_STATUS_ACTIVE) {
                    destroyViewEle(viewElement);
                  }
                }
                destroyViewEle(removableEle);
                if (enteringEle.data(DATA_NO_CACHE)) {
                  enteringEle.data(DATA_DESTROY_ELE, true);
                }
              },
              enteringEle: function() {
                return enteringEle;
              },
              leavingEle: function() {
                return leavingEle;
              }
            };
            return switcher;
          },
          transitionEnd: function(navViewCtrls) {
            forEach(navViewCtrls, function(navViewCtrl) {
              navViewCtrl.transitionEnd();
            });
            ionicViewSwitcher.isTransitioning(false);
            $ionicClickBlock.hide();
            transitionPromises = [];
          },
          nextTransition: function(val) {
            nextTransition = val;
          },
          nextDirection: function(val) {
            nextDirection = val;
          },
          isTransitioning: function(val) {
            if (arguments.length) {
              ionic.transition.isActive = !!val;
              $timeout.cancel(isActiveTimer);
              if (val) {
                isActiveTimer = $timeout(function() {
                  ionicViewSwitcher.isTransitioning(false);
                }, 999);
              }
            }
            return ionic.transition.isActive;
          },
          createViewEle: function(viewLocals) {
            var containerEle = $document[0].createElement('div');
            if (viewLocals && viewLocals.$template) {
              containerEle.innerHTML = viewLocals.$template;
              if (containerEle.children.length === 1) {
                containerEle.children[0].classList.add('pane');
                return jqLite(containerEle.children[0]);
              }
            }
            containerEle.className = "pane";
            return jqLite(containerEle);
          },
          viewEleIsActive: function(viewEle, isActiveAttr) {
            navViewAttr(viewEle, isActiveAttr ? VIEW_STATUS_ACTIVE : VIEW_STATUS_CACHED);
          },
          getTransitionData: getTransitionData,
          navViewAttr: navViewAttr,
          destroyViewEle: destroyViewEle
        };
        return ionicViewSwitcher;
        function getViewElementIdentifier(locals, view) {
          if (viewState(locals)['abstract'])
            return viewState(locals).name;
          if (view)
            return view.stateId || view.viewId;
          return ionic.Utils.nextUid();
        }
        function viewState(locals) {
          return locals && locals.$$state && locals.$$state.self || {};
        }
        function getTransitionData(viewLocals, enteringEle, direction, view) {
          var state = viewState(viewLocals);
          var viewTransition = nextTransition || cachedAttr(enteringEle, 'view-transition') || state.viewTransition || $ionicConfig.views.transition() || 'ios';
          var navBarTransition = $ionicConfig.navBar.transition();
          direction = nextDirection || cachedAttr(enteringEle, 'view-direction') || state.viewDirection || direction || 'none';
          return extend(getViewData(view), {
            transition: viewTransition,
            navBarTransition: navBarTransition === 'view' ? viewTransition : navBarTransition,
            direction: direction,
            shouldAnimate: (viewTransition !== 'none' && direction !== 'none')
          });
        }
        function getViewData(view) {
          view = view || {};
          return {
            viewId: view.viewId,
            historyId: view.historyId,
            stateId: view.stateId,
            stateName: view.stateName,
            stateParams: view.stateParams
          };
        }
        function navViewAttr(ele, value) {
          if (arguments.length > 1) {
            cachedAttr(ele, NAV_VIEW_ATTR, value);
          } else {
            return cachedAttr(ele, NAV_VIEW_ATTR);
          }
        }
        function destroyViewEle(ele) {
          if (ele && ele.length) {
            var viewScope = ele.scope();
            if (viewScope) {
              viewScope.$emit('$ionicView.unloaded', ele.data(DATA_VIEW));
              viewScope.$destroy();
            }
            ele.remove();
          }
        }
      }]);
      angular.module('ngIOS9UIWebViewPatch', ['ng']).config(['$provide', function($provide) {
        'use strict';
        $provide.decorator('$browser', ['$delegate', '$window', function($delegate, $window) {
          if (isIOS9UIWebView($window.navigator.userAgent)) {
            return applyIOS9Shim($delegate);
          }
          return $delegate;
          function isIOS9UIWebView(userAgent) {
            return /(iPhone|iPad|iPod).* OS 9_\d/.test(userAgent) && !/Version\/9\./.test(userAgent);
          }
          function applyIOS9Shim(browser) {
            var pendingLocationUrl = null;
            var originalUrlFn = browser.url;
            browser.url = function() {
              if (arguments.length) {
                pendingLocationUrl = arguments[0];
                return originalUrlFn.apply(browser, arguments);
              }
              return pendingLocationUrl || originalUrlFn.apply(browser, arguments);
            };
            window.addEventListener('popstate', clearPendingLocationUrl, false);
            window.addEventListener('hashchange', clearPendingLocationUrl, false);
            function clearPendingLocationUrl() {
              pendingLocationUrl = null;
            }
            return browser;
          }
        }]);
      }]);
      IonicModule.config(['$provide', function($provide) {
        $provide.decorator('$compile', ['$delegate', function($compile) {
          $compile.$$addScopeInfo = function $$addScopeInfo($element, scope, isolated, noTemplate) {
            var dataName = isolated ? (noTemplate ? '$isolateScopeNoTemplate' : '$isolateScope') : '$scope';
            $element.data(dataName, scope);
          };
          return $compile;
        }]);
      }]);
      IonicModule.config(['$provide', function($provide) {
        function $LocationDecorator($location, $timeout) {
          $location.__hash = $location.hash;
          $location.hash = function(value) {
            if (isDefined(value) && value.length > 0) {
              $timeout(function() {
                var scroll = document.querySelector('.scroll-content');
                if (scroll) {
                  scroll.scrollTop = 0;
                }
              }, 0, false);
            }
            return $location.__hash(value);
          };
          return $location;
        }
        $provide.decorator('$location', ['$delegate', '$timeout', $LocationDecorator]);
      }]);
      IonicModule.controller('$ionicHeaderBar', ['$scope', '$element', '$attrs', '$q', '$ionicConfig', '$ionicHistory', function($scope, $element, $attrs, $q, $ionicConfig, $ionicHistory) {
        var TITLE = 'title';
        var BACK_TEXT = 'back-text';
        var BACK_BUTTON = 'back-button';
        var DEFAULT_TITLE = 'default-title';
        var PREVIOUS_TITLE = 'previous-title';
        var HIDE = 'hide';
        var self = this;
        var titleText = '';
        var previousTitleText = '';
        var titleLeft = 0;
        var titleRight = 0;
        var titleCss = '';
        var isBackEnabled = false;
        var isBackShown = true;
        var isNavBackShown = true;
        var isBackElementShown = false;
        var titleTextWidth = 0;
        self.beforeEnter = function(viewData) {
          $scope.$broadcast('$ionicView.beforeEnter', viewData);
        };
        self.title = function(newTitleText) {
          if (arguments.length && newTitleText !== titleText) {
            getEle(TITLE).innerHTML = newTitleText;
            titleText = newTitleText;
            titleTextWidth = 0;
          }
          return titleText;
        };
        self.enableBack = function(shouldEnable, disableReset) {
          if (arguments.length) {
            isBackEnabled = shouldEnable;
            if (!disableReset)
              self.updateBackButton();
          }
          return isBackEnabled;
        };
        self.showBack = function(shouldShow, disableReset) {
          if (arguments.length) {
            isBackShown = shouldShow;
            if (!disableReset)
              self.updateBackButton();
          }
          return isBackShown;
        };
        self.showNavBack = function(shouldShow) {
          isNavBackShown = shouldShow;
          self.updateBackButton();
        };
        self.updateBackButton = function() {
          var ele;
          if ((isBackShown && isNavBackShown && isBackEnabled) !== isBackElementShown) {
            isBackElementShown = isBackShown && isNavBackShown && isBackEnabled;
            ele = getEle(BACK_BUTTON);
            ele && ele.classList[isBackElementShown ? 'remove' : 'add'](HIDE);
          }
          if (isBackEnabled) {
            ele = ele || getEle(BACK_BUTTON);
            if (ele) {
              if (self.backButtonIcon !== $ionicConfig.backButton.icon()) {
                ele = getEle(BACK_BUTTON + ' .icon');
                if (ele) {
                  self.backButtonIcon = $ionicConfig.backButton.icon();
                  ele.className = 'icon ' + self.backButtonIcon;
                }
              }
              if (self.backButtonText !== $ionicConfig.backButton.text()) {
                ele = getEle(BACK_BUTTON + ' .back-text');
                if (ele) {
                  ele.textContent = self.backButtonText = $ionicConfig.backButton.text();
                }
              }
            }
          }
        };
        self.titleTextWidth = function() {
          if (!titleTextWidth) {
            var bounds = ionic.DomUtil.getTextBounds(getEle(TITLE));
            titleTextWidth = Math.min(bounds && bounds.width || 30);
          }
          return titleTextWidth;
        };
        self.titleWidth = function() {
          var titleWidth = self.titleTextWidth();
          var offsetWidth = getEle(TITLE).offsetWidth;
          if (offsetWidth < titleWidth) {
            titleWidth = offsetWidth + (titleLeft - titleRight - 5);
          }
          return titleWidth;
        };
        self.titleTextX = function() {
          return ($element[0].offsetWidth / 2) - (self.titleWidth() / 2);
        };
        self.titleLeftRight = function() {
          return titleLeft - titleRight;
        };
        self.backButtonTextLeft = function() {
          var offsetLeft = 0;
          var ele = getEle(BACK_TEXT);
          while (ele) {
            offsetLeft += ele.offsetLeft;
            ele = ele.parentElement;
          }
          return offsetLeft;
        };
        self.resetBackButton = function(viewData) {
          if ($ionicConfig.backButton.previousTitleText()) {
            var previousTitleEle = getEle(PREVIOUS_TITLE);
            if (previousTitleEle) {
              previousTitleEle.classList.remove(HIDE);
              var view = (viewData && $ionicHistory.getViewById(viewData.viewId));
              var newPreviousTitleText = $ionicHistory.backTitle(view);
              if (newPreviousTitleText !== previousTitleText) {
                previousTitleText = previousTitleEle.innerHTML = newPreviousTitleText;
              }
            }
            var defaultTitleEle = getEle(DEFAULT_TITLE);
            if (defaultTitleEle) {
              defaultTitleEle.classList.remove(HIDE);
            }
          }
        };
        self.align = function(textAlign) {
          var titleEle = getEle(TITLE);
          textAlign = textAlign || $attrs.alignTitle || $ionicConfig.navBar.alignTitle();
          var widths = self.calcWidths(textAlign, false);
          if (isBackShown && previousTitleText && $ionicConfig.backButton.previousTitleText()) {
            var previousTitleWidths = self.calcWidths(textAlign, true);
            var availableTitleWidth = $element[0].offsetWidth - previousTitleWidths.titleLeft - previousTitleWidths.titleRight;
            if (self.titleTextWidth() <= availableTitleWidth) {
              widths = previousTitleWidths;
            }
          }
          return self.updatePositions(titleEle, widths.titleLeft, widths.titleRight, widths.buttonsLeft, widths.buttonsRight, widths.css, widths.showPrevTitle);
        };
        self.calcWidths = function(textAlign, isPreviousTitle) {
          var titleEle = getEle(TITLE);
          var backBtnEle = getEle(BACK_BUTTON);
          var x,
              y,
              z,
              b,
              c,
              d,
              childSize,
              bounds;
          var childNodes = $element[0].childNodes;
          var buttonsLeft = 0;
          var buttonsRight = 0;
          var isCountRightOfTitle;
          var updateTitleLeft = 0;
          var updateTitleRight = 0;
          var updateCss = '';
          var backButtonWidth = 0;
          for (x = 0; x < childNodes.length; x++) {
            c = childNodes[x];
            childSize = 0;
            if (c.nodeType == 1) {
              if (c === titleEle) {
                isCountRightOfTitle = true;
                continue;
              }
              if (c.classList.contains(HIDE)) {
                continue;
              }
              if (isBackShown && c === backBtnEle) {
                for (y = 0; y < c.childNodes.length; y++) {
                  b = c.childNodes[y];
                  if (b.nodeType == 1) {
                    if (b.classList.contains(BACK_TEXT)) {
                      for (z = 0; z < b.children.length; z++) {
                        d = b.children[z];
                        if (isPreviousTitle) {
                          if (d.classList.contains(DEFAULT_TITLE))
                            continue;
                          backButtonWidth += d.offsetWidth;
                        } else {
                          if (d.classList.contains(PREVIOUS_TITLE))
                            continue;
                          backButtonWidth += d.offsetWidth;
                        }
                      }
                    } else {
                      backButtonWidth += b.offsetWidth;
                    }
                  } else if (b.nodeType == 3 && b.nodeValue.trim()) {
                    bounds = ionic.DomUtil.getTextBounds(b);
                    backButtonWidth += bounds && bounds.width || 0;
                  }
                }
                childSize = backButtonWidth || c.offsetWidth;
              } else {
                childSize = c.offsetWidth;
              }
            } else if (c.nodeType == 3 && c.nodeValue.trim()) {
              bounds = ionic.DomUtil.getTextBounds(c);
              childSize = bounds && bounds.width || 0;
            }
            if (isCountRightOfTitle) {
              buttonsRight += childSize;
            } else {
              buttonsLeft += childSize;
            }
          }
          if (textAlign == 'left') {
            updateCss = 'title-left';
            if (buttonsLeft) {
              updateTitleLeft = buttonsLeft + 15;
            }
            if (buttonsRight) {
              updateTitleRight = buttonsRight + 15;
            }
          } else if (textAlign == 'right') {
            updateCss = 'title-right';
            if (buttonsLeft) {
              updateTitleLeft = buttonsLeft + 15;
            }
            if (buttonsRight) {
              updateTitleRight = buttonsRight + 15;
            }
          } else {
            var margin = Math.max(buttonsLeft, buttonsRight) + 10;
            if (margin > 10) {
              updateTitleLeft = updateTitleRight = margin;
            }
          }
          return {
            backButtonWidth: backButtonWidth,
            buttonsLeft: buttonsLeft,
            buttonsRight: buttonsRight,
            titleLeft: updateTitleLeft,
            titleRight: updateTitleRight,
            showPrevTitle: isPreviousTitle,
            css: updateCss
          };
        };
        self.updatePositions = function(titleEle, updateTitleLeft, updateTitleRight, buttonsLeft, buttonsRight, updateCss, showPreviousTitle) {
          var deferred = $q.defer();
          if (titleEle) {
            if (updateTitleLeft !== titleLeft) {
              titleEle.style.left = updateTitleLeft ? updateTitleLeft + 'px' : '';
              titleLeft = updateTitleLeft;
            }
            if (updateTitleRight !== titleRight) {
              titleEle.style.right = updateTitleRight ? updateTitleRight + 'px' : '';
              titleRight = updateTitleRight;
            }
            if (updateCss !== titleCss) {
              updateCss && titleEle.classList.add(updateCss);
              titleCss && titleEle.classList.remove(titleCss);
              titleCss = updateCss;
            }
          }
          if ($ionicConfig.backButton.previousTitleText()) {
            var prevTitle = getEle(PREVIOUS_TITLE);
            var defaultTitle = getEle(DEFAULT_TITLE);
            prevTitle && prevTitle.classList[showPreviousTitle ? 'remove' : 'add'](HIDE);
            defaultTitle && defaultTitle.classList[showPreviousTitle ? 'add' : 'remove'](HIDE);
          }
          ionic.requestAnimationFrame(function() {
            if (titleEle && titleEle.offsetWidth + 10 < titleEle.scrollWidth) {
              var minRight = buttonsRight + 5;
              var testRight = $element[0].offsetWidth - titleLeft - self.titleTextWidth() - 20;
              updateTitleRight = testRight < minRight ? minRight : testRight;
              if (updateTitleRight !== titleRight) {
                titleEle.style.right = updateTitleRight + 'px';
                titleRight = updateTitleRight;
              }
            }
            deferred.resolve();
          });
          return deferred.promise;
        };
        self.setCss = function(elementClassname, css) {
          ionic.DomUtil.cachedStyles(getEle(elementClassname), css);
        };
        var eleCache = {};
        function getEle(className) {
          if (!eleCache[className]) {
            eleCache[className] = $element[0].querySelector('.' + className);
          }
          return eleCache[className];
        }
        $scope.$on('$destroy', function() {
          for (var n in eleCache)
            eleCache[n] = null;
        });
      }]);
      IonicModule.controller('$ionInfiniteScroll', ['$scope', '$attrs', '$element', '$timeout', function($scope, $attrs, $element, $timeout) {
        var self = this;
        self.isLoading = false;
        $scope.icon = function() {
          return isDefined($attrs.icon) ? $attrs.icon : 'ion-load-d';
        };
        $scope.spinner = function() {
          return isDefined($attrs.spinner) ? $attrs.spinner : '';
        };
        $scope.$on('scroll.infiniteScrollComplete', function() {
          finishInfiniteScroll();
        });
        $scope.$on('$destroy', function() {
          if (self.scrollCtrl && self.scrollCtrl.$element)
            self.scrollCtrl.$element.off('scroll', self.checkBounds);
          if (self.scrollEl && self.scrollEl.removeEventListener) {
            self.scrollEl.removeEventListener('scroll', self.checkBounds);
          }
        });
        self.checkBounds = ionic.Utils.throttle(checkInfiniteBounds, 300);
        function onInfinite() {
          ionic.requestAnimationFrame(function() {
            $element[0].classList.add('active');
          });
          self.isLoading = true;
          $scope.$parent && $scope.$parent.$apply($attrs.onInfinite || '');
        }
        function finishInfiniteScroll() {
          ionic.requestAnimationFrame(function() {
            $element[0].classList.remove('active');
          });
          $timeout(function() {
            if (self.jsScrolling)
              self.scrollView.resize();
            if ((self.jsScrolling && self.scrollView.__container && self.scrollView.__container.offsetHeight > 0) || !self.jsScrolling) {
              self.checkBounds();
            }
          }, 30, false);
          self.isLoading = false;
        }
        function checkInfiniteBounds() {
          if (self.isLoading)
            return;
          var maxScroll = {};
          if (self.jsScrolling) {
            maxScroll = self.getJSMaxScroll();
            var scrollValues = self.scrollView.getValues();
            if ((maxScroll.left !== -1 && scrollValues.left >= maxScroll.left) || (maxScroll.top !== -1 && scrollValues.top >= maxScroll.top)) {
              onInfinite();
            }
          } else {
            maxScroll = self.getNativeMaxScroll();
            if ((maxScroll.left !== -1 && self.scrollEl.scrollLeft >= maxScroll.left - self.scrollEl.clientWidth) || (maxScroll.top !== -1 && self.scrollEl.scrollTop >= maxScroll.top - self.scrollEl.clientHeight)) {
              onInfinite();
            }
          }
        }
        self.getJSMaxScroll = function() {
          var maxValues = self.scrollView.getScrollMax();
          return {
            left: self.scrollView.options.scrollingX ? calculateMaxValue(maxValues.left) : -1,
            top: self.scrollView.options.scrollingY ? calculateMaxValue(maxValues.top) : -1
          };
        };
        self.getNativeMaxScroll = function() {
          var maxValues = {
            left: self.scrollEl.scrollWidth,
            top: self.scrollEl.scrollHeight
          };
          var computedStyle = window.getComputedStyle(self.scrollEl) || {};
          return {
            left: maxValues.left && (computedStyle.overflowX === 'scroll' || computedStyle.overflowX === 'auto' || self.scrollEl.style['overflow-x'] === 'scroll') ? calculateMaxValue(maxValues.left) : -1,
            top: maxValues.top && (computedStyle.overflowY === 'scroll' || computedStyle.overflowY === 'auto' || self.scrollEl.style['overflow-y'] === 'scroll') ? calculateMaxValue(maxValues.top) : -1
          };
        };
        function calculateMaxValue(maximum) {
          var distance = ($attrs.distance || '2.5%').trim();
          var isPercent = distance.indexOf('%') !== -1;
          return isPercent ? maximum * (1 - parseFloat(distance) / 100) : maximum - parseFloat(distance);
        }
        self.__finishInfiniteScroll = finishInfiniteScroll;
      }]);
      IonicModule.service('$ionicListDelegate', ionic.DelegateService(['showReorder', 'showDelete', 'canSwipeItems', 'closeOptionButtons'])).controller('$ionicList', ['$scope', '$attrs', '$ionicListDelegate', '$ionicHistory', function($scope, $attrs, $ionicListDelegate, $ionicHistory) {
        var self = this;
        var isSwipeable = true;
        var isReorderShown = false;
        var isDeleteShown = false;
        var deregisterInstance = $ionicListDelegate._registerInstance(self, $attrs.delegateHandle, function() {
          return $ionicHistory.isActiveScope($scope);
        });
        $scope.$on('$destroy', deregisterInstance);
        self.showReorder = function(show) {
          if (arguments.length) {
            isReorderShown = !!show;
          }
          return isReorderShown;
        };
        self.showDelete = function(show) {
          if (arguments.length) {
            isDeleteShown = !!show;
          }
          return isDeleteShown;
        };
        self.canSwipeItems = function(can) {
          if (arguments.length) {
            isSwipeable = !!can;
          }
          return isSwipeable;
        };
        self.closeOptionButtons = function() {
          self.listView && self.listView.clearDragEffects();
        };
      }]);
      IonicModule.controller('$ionicNavBar', ['$scope', '$element', '$attrs', '$compile', '$timeout', '$ionicNavBarDelegate', '$ionicConfig', '$ionicHistory', function($scope, $element, $attrs, $compile, $timeout, $ionicNavBarDelegate, $ionicConfig, $ionicHistory) {
        var CSS_HIDE = 'hide';
        var DATA_NAV_BAR_CTRL = '$ionNavBarController';
        var PRIMARY_BUTTONS = 'primaryButtons';
        var SECONDARY_BUTTONS = 'secondaryButtons';
        var BACK_BUTTON = 'backButton';
        var ITEM_TYPES = 'primaryButtons secondaryButtons leftButtons rightButtons title'.split(' ');
        var self = this;
        var headerBars = [];
        var navElementHtml = {};
        var isVisible = true;
        var queuedTransitionStart,
            queuedTransitionEnd,
            latestTransitionId;
        $element.parent().data(DATA_NAV_BAR_CTRL, self);
        var delegateHandle = $attrs.delegateHandle || 'navBar' + ionic.Utils.nextUid();
        var deregisterInstance = $ionicNavBarDelegate._registerInstance(self, delegateHandle);
        self.init = function() {
          $element.addClass('nav-bar-container');
          ionic.DomUtil.cachedAttr($element, 'nav-bar-transition', $ionicConfig.views.transition());
          self.createHeaderBar(false);
          self.createHeaderBar(true);
          $scope.$emit('ionNavBar.init', delegateHandle);
        };
        self.createHeaderBar = function(isActive) {
          var containerEle = jqLite('<div class="nav-bar-block">');
          ionic.DomUtil.cachedAttr(containerEle, 'nav-bar', isActive ? 'active' : 'cached');
          var alignTitle = $attrs.alignTitle || $ionicConfig.navBar.alignTitle();
          var headerBarEle = jqLite('<ion-header-bar>').addClass($attrs['class']).attr('align-title', alignTitle);
          if (isDefined($attrs.noTapScroll))
            headerBarEle.attr('no-tap-scroll', $attrs.noTapScroll);
          var titleEle = jqLite('<div class="title title-' + alignTitle + '">');
          var navEle = {};
          var lastViewItemEle = {};
          var leftButtonsEle,
              rightButtonsEle;
          navEle[BACK_BUTTON] = createNavElement(BACK_BUTTON);
          navEle[BACK_BUTTON] && headerBarEle.append(navEle[BACK_BUTTON]);
          headerBarEle.append(titleEle);
          forEach(ITEM_TYPES, function(itemType) {
            navEle[itemType] = createNavElement(itemType);
            positionItem(navEle[itemType], itemType);
          });
          for (var x = 0; x < headerBarEle[0].children.length; x++) {
            headerBarEle[0].children[x].classList.add('header-item');
          }
          containerEle.append(headerBarEle);
          $element.append($compile(containerEle)($scope.$new()));
          var headerBarCtrl = headerBarEle.data('$ionHeaderBarController');
          headerBarCtrl.backButtonIcon = $ionicConfig.backButton.icon();
          headerBarCtrl.backButtonText = $ionicConfig.backButton.text();
          var headerBarInstance = {
            isActive: isActive,
            title: function(newTitleText) {
              headerBarCtrl.title(newTitleText);
            },
            setItem: function(navBarItemEle, itemType) {
              headerBarInstance.removeItem(itemType);
              if (navBarItemEle) {
                if (itemType === 'title') {
                  headerBarInstance.title("");
                }
                positionItem(navBarItemEle, itemType);
                if (navEle[itemType]) {
                  navEle[itemType].addClass(CSS_HIDE);
                }
                lastViewItemEle[itemType] = navBarItemEle;
              } else if (navEle[itemType]) {
                navEle[itemType].removeClass(CSS_HIDE);
              }
            },
            removeItem: function(itemType) {
              if (lastViewItemEle[itemType]) {
                lastViewItemEle[itemType].scope().$destroy();
                lastViewItemEle[itemType].remove();
                lastViewItemEle[itemType] = null;
              }
            },
            containerEle: function() {
              return containerEle;
            },
            headerBarEle: function() {
              return headerBarEle;
            },
            afterLeave: function() {
              forEach(ITEM_TYPES, function(itemType) {
                headerBarInstance.removeItem(itemType);
              });
              headerBarCtrl.resetBackButton();
            },
            controller: function() {
              return headerBarCtrl;
            },
            destroy: function() {
              forEach(ITEM_TYPES, function(itemType) {
                headerBarInstance.removeItem(itemType);
              });
              containerEle.scope().$destroy();
              for (var n in navEle) {
                if (navEle[n]) {
                  navEle[n].removeData();
                  navEle[n] = null;
                }
              }
              leftButtonsEle && leftButtonsEle.removeData();
              rightButtonsEle && rightButtonsEle.removeData();
              titleEle.removeData();
              headerBarEle.removeData();
              containerEle.remove();
              containerEle = headerBarEle = titleEle = leftButtonsEle = rightButtonsEle = null;
            }
          };
          function positionItem(ele, itemType) {
            if (!ele)
              return;
            if (itemType === 'title') {
              titleEle.append(ele);
            } else if (itemType == 'rightButtons' || (itemType == SECONDARY_BUTTONS && $ionicConfig.navBar.positionSecondaryButtons() != 'left') || (itemType == PRIMARY_BUTTONS && $ionicConfig.navBar.positionPrimaryButtons() == 'right')) {
              if (!rightButtonsEle) {
                rightButtonsEle = jqLite('<div class="buttons buttons-right">');
                headerBarEle.append(rightButtonsEle);
              }
              if (itemType == SECONDARY_BUTTONS) {
                rightButtonsEle.append(ele);
              } else {
                rightButtonsEle.prepend(ele);
              }
            } else {
              if (!leftButtonsEle) {
                leftButtonsEle = jqLite('<div class="buttons buttons-left">');
                if (navEle[BACK_BUTTON]) {
                  navEle[BACK_BUTTON].after(leftButtonsEle);
                } else {
                  headerBarEle.prepend(leftButtonsEle);
                }
              }
              if (itemType == SECONDARY_BUTTONS) {
                leftButtonsEle.append(ele);
              } else {
                leftButtonsEle.prepend(ele);
              }
            }
          }
          headerBars.push(headerBarInstance);
          return headerBarInstance;
        };
        self.navElement = function(type, html) {
          if (isDefined(html)) {
            navElementHtml[type] = html;
          }
          return navElementHtml[type];
        };
        self.update = function(viewData) {
          var showNavBar = !viewData.hasHeaderBar && viewData.showNavBar;
          viewData.transition = $ionicConfig.views.transition();
          if (!showNavBar) {
            viewData.direction = 'none';
          }
          self.enable(showNavBar);
          var enteringHeaderBar = self.isInitialized ? getOffScreenHeaderBar() : getOnScreenHeaderBar();
          var leavingHeaderBar = self.isInitialized ? getOnScreenHeaderBar() : null;
          var enteringHeaderCtrl = enteringHeaderBar.controller();
          enteringHeaderCtrl.enableBack(viewData.enableBack, true);
          enteringHeaderCtrl.showBack(viewData.showBack, true);
          enteringHeaderCtrl.updateBackButton();
          self.title(viewData.title, enteringHeaderBar);
          self.showBar(showNavBar);
          if (viewData.navBarItems) {
            forEach(ITEM_TYPES, function(itemType) {
              enteringHeaderBar.setItem(viewData.navBarItems[itemType], itemType);
            });
          }
          self.transition(enteringHeaderBar, leavingHeaderBar, viewData);
          self.isInitialized = true;
          navSwipeAttr('');
        };
        self.transition = function(enteringHeaderBar, leavingHeaderBar, viewData) {
          var enteringHeaderBarCtrl = enteringHeaderBar.controller();
          var transitionFn = $ionicConfig.transitions.navBar[viewData.navBarTransition] || $ionicConfig.transitions.navBar.none;
          var transitionId = viewData.transitionId;
          enteringHeaderBarCtrl.beforeEnter(viewData);
          var navBarTransition = transitionFn(enteringHeaderBar, leavingHeaderBar, viewData.direction, viewData.shouldAnimate && self.isInitialized);
          ionic.DomUtil.cachedAttr($element, 'nav-bar-transition', viewData.navBarTransition);
          ionic.DomUtil.cachedAttr($element, 'nav-bar-direction', viewData.direction);
          if (navBarTransition.shouldAnimate && viewData.renderEnd) {
            navBarAttr(enteringHeaderBar, 'stage');
          } else {
            navBarAttr(enteringHeaderBar, 'entering');
            navBarAttr(leavingHeaderBar, 'leaving');
          }
          enteringHeaderBarCtrl.resetBackButton(viewData);
          navBarTransition.run(0);
          self.activeTransition = {
            run: function(step) {
              navBarTransition.shouldAnimate = false;
              navBarTransition.direction = 'back';
              navBarTransition.run(step);
            },
            cancel: function(shouldAnimate, speed, cancelData) {
              navSwipeAttr(speed);
              navBarAttr(leavingHeaderBar, 'active');
              navBarAttr(enteringHeaderBar, 'cached');
              navBarTransition.shouldAnimate = shouldAnimate;
              navBarTransition.run(0);
              self.activeTransition = navBarTransition = null;
              var runApply;
              if (cancelData.showBar !== self.showBar()) {
                self.showBar(cancelData.showBar);
              }
              if (cancelData.showBackButton !== self.showBackButton()) {
                self.showBackButton(cancelData.showBackButton);
              }
              if (runApply) {
                $scope.$apply();
              }
            },
            complete: function(shouldAnimate, speed) {
              navSwipeAttr(speed);
              navBarTransition.shouldAnimate = shouldAnimate;
              navBarTransition.run(1);
              queuedTransitionEnd = transitionEnd;
            }
          };
          $timeout(enteringHeaderBarCtrl.align, 16);
          queuedTransitionStart = function() {
            if (latestTransitionId !== transitionId)
              return;
            navBarAttr(enteringHeaderBar, 'entering');
            navBarAttr(leavingHeaderBar, 'leaving');
            navBarTransition.run(1);
            queuedTransitionEnd = function() {
              if (latestTransitionId == transitionId || !navBarTransition.shouldAnimate) {
                transitionEnd();
              }
            };
            queuedTransitionStart = null;
          };
          function transitionEnd() {
            for (var x = 0; x < headerBars.length; x++) {
              headerBars[x].isActive = false;
            }
            enteringHeaderBar.isActive = true;
            navBarAttr(enteringHeaderBar, 'active');
            navBarAttr(leavingHeaderBar, 'cached');
            self.activeTransition = navBarTransition = queuedTransitionEnd = null;
          }
          queuedTransitionStart();
        };
        self.triggerTransitionStart = function(triggerTransitionId) {
          latestTransitionId = triggerTransitionId;
          queuedTransitionStart && queuedTransitionStart();
        };
        self.triggerTransitionEnd = function() {
          queuedTransitionEnd && queuedTransitionEnd();
        };
        self.showBar = function(shouldShow) {
          if (arguments.length) {
            self.visibleBar(shouldShow);
            $scope.$parent.$hasHeader = !!shouldShow;
          }
          return !!$scope.$parent.$hasHeader;
        };
        self.visibleBar = function(shouldShow) {
          if (shouldShow && !isVisible) {
            $element.removeClass(CSS_HIDE);
            self.align();
          } else if (!shouldShow && isVisible) {
            $element.addClass(CSS_HIDE);
          }
          isVisible = shouldShow;
        };
        self.enable = function(val) {
          self.visibleBar(val);
          for (var x = 0; x < $ionicNavBarDelegate._instances.length; x++) {
            if ($ionicNavBarDelegate._instances[x] !== self)
              $ionicNavBarDelegate._instances[x].visibleBar(false);
          }
        };
        self.showBackButton = function(shouldShow) {
          if (arguments.length) {
            for (var x = 0; x < headerBars.length; x++) {
              headerBars[x].controller().showNavBack(!!shouldShow);
            }
            $scope.$isBackButtonShown = !!shouldShow;
          }
          return $scope.$isBackButtonShown;
        };
        self.showActiveBackButton = function(shouldShow) {
          var headerBar = getOnScreenHeaderBar();
          if (headerBar) {
            if (arguments.length) {
              return headerBar.controller().showBack(shouldShow);
            }
            return headerBar.controller().showBack();
          }
        };
        self.title = function(newTitleText, headerBar) {
          if (isDefined(newTitleText)) {
            newTitleText = newTitleText || '';
            headerBar = headerBar || getOnScreenHeaderBar();
            headerBar && headerBar.title(newTitleText);
            $scope.$title = newTitleText;
            $ionicHistory.currentTitle(newTitleText);
          }
          return $scope.$title;
        };
        self.align = function(val, headerBar) {
          headerBar = headerBar || getOnScreenHeaderBar();
          headerBar && headerBar.controller().align(val);
        };
        self.hasTabsTop = function(isTabsTop) {
          $element[isTabsTop ? 'addClass' : 'removeClass']('nav-bar-tabs-top');
        };
        self.hasBarSubheader = function(isBarSubheader) {
          $element[isBarSubheader ? 'addClass' : 'removeClass']('nav-bar-has-subheader');
        };
        self.changeTitle = function(val) {
          deprecatedWarning('changeTitle(val)', 'title(val)');
          self.title(val);
        };
        self.setTitle = function(val) {
          deprecatedWarning('setTitle(val)', 'title(val)');
          self.title(val);
        };
        self.getTitle = function() {
          deprecatedWarning('getTitle()', 'title()');
          return self.title();
        };
        self.back = function() {
          deprecatedWarning('back()', '$ionicHistory.goBack()');
          $ionicHistory.goBack();
        };
        self.getPreviousTitle = function() {
          deprecatedWarning('getPreviousTitle()', '$ionicHistory.backTitle()');
          $ionicHistory.goBack();
        };
        function deprecatedWarning(oldMethod, newMethod) {
          var warn = console.warn || console.log;
          warn && warn.call(console, 'navBarController.' + oldMethod + ' is deprecated, please use ' + newMethod + ' instead');
        }
        function createNavElement(type) {
          if (navElementHtml[type]) {
            return jqLite(navElementHtml[type]);
          }
        }
        function getOnScreenHeaderBar() {
          for (var x = 0; x < headerBars.length; x++) {
            if (headerBars[x].isActive)
              return headerBars[x];
          }
        }
        function getOffScreenHeaderBar() {
          for (var x = 0; x < headerBars.length; x++) {
            if (!headerBars[x].isActive)
              return headerBars[x];
          }
        }
        function navBarAttr(ctrl, val) {
          ctrl && ionic.DomUtil.cachedAttr(ctrl.containerEle(), 'nav-bar', val);
        }
        function navSwipeAttr(val) {
          ionic.DomUtil.cachedAttr($element, 'nav-swipe', val);
        }
        $scope.$on('$destroy', function() {
          $scope.$parent.$hasHeader = false;
          $element.parent().removeData(DATA_NAV_BAR_CTRL);
          for (var x = 0; x < headerBars.length; x++) {
            headerBars[x].destroy();
          }
          $element.remove();
          $element = headerBars = null;
          deregisterInstance();
        });
      }]);
      IonicModule.controller('$ionicNavView', ['$scope', '$element', '$attrs', '$compile', '$controller', '$ionicNavBarDelegate', '$ionicNavViewDelegate', '$ionicHistory', '$ionicViewSwitcher', '$ionicConfig', '$ionicScrollDelegate', '$ionicSideMenuDelegate', function($scope, $element, $attrs, $compile, $controller, $ionicNavBarDelegate, $ionicNavViewDelegate, $ionicHistory, $ionicViewSwitcher, $ionicConfig, $ionicScrollDelegate, $ionicSideMenuDelegate) {
        var DATA_ELE_IDENTIFIER = '$eleId';
        var DATA_DESTROY_ELE = '$destroyEle';
        var DATA_NO_CACHE = '$noCache';
        var VIEW_STATUS_ACTIVE = 'active';
        var VIEW_STATUS_CACHED = 'cached';
        var self = this;
        var direction;
        var isPrimary = false;
        var navBarDelegate;
        var activeEleId;
        var navViewAttr = $ionicViewSwitcher.navViewAttr;
        var disableRenderStartViewId,
            disableAnimation;
        self.scope = $scope;
        self.element = $element;
        self.init = function() {
          var navViewName = $attrs.name || '';
          var parent = $element.parent().inheritedData('$uiView');
          var parentViewName = ((parent && parent.state) ? parent.state.name : '');
          if (navViewName.indexOf('@') < 0)
            navViewName = navViewName + '@' + parentViewName;
          var viewData = {
            name: navViewName,
            state: null
          };
          $element.data('$uiView', viewData);
          var deregisterInstance = $ionicNavViewDelegate._registerInstance(self, $attrs.delegateHandle);
          $scope.$on('$destroy', function() {
            deregisterInstance();
            if (self.isSwipeFreeze) {
              $ionicScrollDelegate.freezeAllScrolls(false);
            }
          });
          $scope.$on('$ionicHistory.deselect', self.cacheCleanup);
          $scope.$on('$ionicTabs.top', onTabsTop);
          $scope.$on('$ionicSubheader', onBarSubheader);
          $scope.$on('$ionicTabs.beforeLeave', onTabsLeave);
          $scope.$on('$ionicTabs.afterLeave', onTabsLeave);
          $scope.$on('$ionicTabs.leave', onTabsLeave);
          ionic.Platform.ready(function() {
            if (ionic.Platform.isWebView() && ionic.Platform.isIOS()) {
              self.initSwipeBack();
            }
          });
          return viewData;
        };
        self.register = function(viewLocals) {
          var leavingView = extend({}, $ionicHistory.currentView());
          var registerData = $ionicHistory.register($scope, viewLocals);
          self.update(registerData);
          var enteringView = $ionicHistory.getViewById(registerData.viewId) || {};
          var renderStart = (disableRenderStartViewId !== registerData.viewId);
          self.render(registerData, viewLocals, enteringView, leavingView, renderStart, true);
        };
        self.update = function(registerData) {
          isPrimary = true;
          direction = registerData.direction;
          var parentNavViewCtrl = $element.parent().inheritedData('$ionNavViewController');
          if (parentNavViewCtrl) {
            parentNavViewCtrl.isPrimary(false);
            if (direction === 'enter' || direction === 'exit') {
              parentNavViewCtrl.direction(direction);
              if (direction === 'enter') {
                direction = 'none';
              }
            }
          }
        };
        self.render = function(registerData, viewLocals, enteringView, leavingView, renderStart, renderEnd) {
          var switcher = $ionicViewSwitcher.create(self, viewLocals, enteringView, leavingView, renderStart, renderEnd);
          switcher.init(registerData, function() {
            switcher.transition(self.direction(), registerData.enableBack, !disableAnimation);
            disableRenderStartViewId = disableAnimation = null;
          });
        };
        self.beforeEnter = function(transitionData) {
          if (isPrimary) {
            navBarDelegate = transitionData.navBarDelegate;
            var associatedNavBarCtrl = getAssociatedNavBarCtrl();
            associatedNavBarCtrl && associatedNavBarCtrl.update(transitionData);
            navSwipeAttr('');
          }
        };
        self.activeEleId = function(eleId) {
          if (arguments.length) {
            activeEleId = eleId;
          }
          return activeEleId;
        };
        self.transitionEnd = function() {
          var viewElements = $element.children();
          var x,
              l,
              viewElement;
          for (x = 0, l = viewElements.length; x < l; x++) {
            viewElement = viewElements.eq(x);
            if (viewElement.data(DATA_ELE_IDENTIFIER) === activeEleId) {
              navViewAttr(viewElement, VIEW_STATUS_ACTIVE);
            } else if (navViewAttr(viewElement) === 'leaving' || navViewAttr(viewElement) === VIEW_STATUS_ACTIVE || navViewAttr(viewElement) === VIEW_STATUS_CACHED) {
              if (viewElement.data(DATA_DESTROY_ELE) || viewElement.data(DATA_NO_CACHE)) {
                $ionicViewSwitcher.destroyViewEle(viewElement);
              } else {
                navViewAttr(viewElement, VIEW_STATUS_CACHED);
                ionic.Utils.disconnectScope(viewElement.scope());
              }
            }
          }
          navSwipeAttr('');
          if (self.isSwipeFreeze) {
            $ionicScrollDelegate.freezeAllScrolls(false);
          }
        };
        function onTabsLeave(ev, data) {
          var viewElements = $element.children();
          var viewElement,
              viewScope;
          for (var x = 0,
              l = viewElements.length; x < l; x++) {
            viewElement = viewElements.eq(x);
            if (navViewAttr(viewElement) == VIEW_STATUS_ACTIVE) {
              viewScope = viewElement.scope();
              viewScope && viewScope.$emit(ev.name.replace('Tabs', 'View'), data);
              break;
            }
          }
        }
        self.cacheCleanup = function() {
          var viewElements = $element.children();
          for (var x = 0,
              l = viewElements.length; x < l; x++) {
            if (viewElements.eq(x).data(DATA_DESTROY_ELE)) {
              $ionicViewSwitcher.destroyViewEle(viewElements.eq(x));
            }
          }
        };
        self.clearCache = function(stateIds) {
          var viewElements = $element.children();
          var viewElement,
              viewScope,
              x,
              l,
              y,
              eleIdentifier;
          for (x = 0, l = viewElements.length; x < l; x++) {
            viewElement = viewElements.eq(x);
            if (stateIds) {
              eleIdentifier = viewElement.data(DATA_ELE_IDENTIFIER);
              for (y = 0; y < stateIds.length; y++) {
                if (eleIdentifier === stateIds[y]) {
                  $ionicViewSwitcher.destroyViewEle(viewElement);
                }
              }
              continue;
            }
            if (navViewAttr(viewElement) == VIEW_STATUS_CACHED) {
              $ionicViewSwitcher.destroyViewEle(viewElement);
            } else if (navViewAttr(viewElement) == VIEW_STATUS_ACTIVE) {
              viewScope = viewElement.scope();
              viewScope && viewScope.$broadcast('$ionicView.clearCache');
            }
          }
        };
        self.getViewElements = function() {
          return $element.children();
        };
        self.appendViewElement = function(viewEle, viewLocals) {
          var linkFn = $compile(viewEle);
          $element.append(viewEle);
          var viewScope = $scope.$new();
          if (viewLocals && viewLocals.$$controller) {
            viewLocals.$scope = viewScope;
            var controller = $controller(viewLocals.$$controller, viewLocals);
            if (viewLocals.$$controllerAs) {
              viewScope[viewLocals.$$controllerAs] = controller;
            }
            $element.children().data('$ngControllerController', controller);
          }
          linkFn(viewScope);
          return viewScope;
        };
        self.title = function(val) {
          var associatedNavBarCtrl = getAssociatedNavBarCtrl();
          associatedNavBarCtrl && associatedNavBarCtrl.title(val);
        };
        self.enableBackButton = function(shouldEnable) {
          var associatedNavBarCtrl = getAssociatedNavBarCtrl();
          associatedNavBarCtrl && associatedNavBarCtrl.enableBackButton(shouldEnable);
        };
        self.showBackButton = function(shouldShow) {
          var associatedNavBarCtrl = getAssociatedNavBarCtrl();
          if (associatedNavBarCtrl) {
            if (arguments.length) {
              return associatedNavBarCtrl.showActiveBackButton(shouldShow);
            }
            return associatedNavBarCtrl.showActiveBackButton();
          }
          return true;
        };
        self.showBar = function(val) {
          var associatedNavBarCtrl = getAssociatedNavBarCtrl();
          if (associatedNavBarCtrl) {
            if (arguments.length) {
              return associatedNavBarCtrl.showBar(val);
            }
            return associatedNavBarCtrl.showBar();
          }
          return true;
        };
        self.isPrimary = function(val) {
          if (arguments.length) {
            isPrimary = val;
          }
          return isPrimary;
        };
        self.direction = function(val) {
          if (arguments.length) {
            direction = val;
          }
          return direction;
        };
        self.initSwipeBack = function() {
          var swipeBackHitWidth = $ionicConfig.views.swipeBackHitWidth();
          var viewTransition,
              associatedNavBarCtrl,
              backView;
          var deregDragStart,
              deregDrag,
              deregRelease;
          var windowWidth,
              startDragX,
              dragPoints;
          var cancelData = {};
          function onDragStart(ev) {
            if (!isPrimary || !$ionicConfig.views.swipeBackEnabled() || $ionicSideMenuDelegate.isOpenRight())
              return;
            startDragX = getDragX(ev);
            if (startDragX > swipeBackHitWidth)
              return;
            backView = $ionicHistory.backView();
            var currentView = $ionicHistory.currentView();
            if (!backView || backView.historyId !== currentView.historyId || currentView.canSwipeBack === false)
              return;
            if (!windowWidth)
              windowWidth = window.innerWidth;
            self.isSwipeFreeze = $ionicScrollDelegate.freezeAllScrolls(true);
            var registerData = {direction: 'back'};
            dragPoints = [];
            cancelData = {
              showBar: self.showBar(),
              showBackButton: self.showBackButton()
            };
            var switcher = $ionicViewSwitcher.create(self, registerData, backView, currentView, true, false);
            switcher.loadViewElements(registerData);
            switcher.render(registerData);
            viewTransition = switcher.transition('back', $ionicHistory.enabledBack(backView), true);
            associatedNavBarCtrl = getAssociatedNavBarCtrl();
            deregDrag = ionic.onGesture('drag', onDrag, $element[0]);
            deregRelease = ionic.onGesture('release', onRelease, $element[0]);
          }
          function onDrag(ev) {
            if (isPrimary && viewTransition) {
              var dragX = getDragX(ev);
              dragPoints.push({
                t: Date.now(),
                x: dragX
              });
              if (dragX >= windowWidth - 15) {
                onRelease(ev);
              } else {
                var step = Math.min(Math.max(getSwipeCompletion(dragX), 0), 1);
                viewTransition.run(step);
                associatedNavBarCtrl && associatedNavBarCtrl.activeTransition && associatedNavBarCtrl.activeTransition.run(step);
              }
            }
          }
          function onRelease(ev) {
            if (isPrimary && viewTransition && dragPoints && dragPoints.length > 1) {
              var now = Date.now();
              var releaseX = getDragX(ev);
              var startDrag = dragPoints[dragPoints.length - 1];
              for (var x = dragPoints.length - 2; x >= 0; x--) {
                if (now - startDrag.t > 200) {
                  break;
                }
                startDrag = dragPoints[x];
              }
              var isSwipingRight = (releaseX >= dragPoints[dragPoints.length - 2].x);
              var releaseSwipeCompletion = getSwipeCompletion(releaseX);
              var velocity = Math.abs(startDrag.x - releaseX) / (now - startDrag.t);
              disableRenderStartViewId = backView.viewId;
              disableAnimation = (releaseSwipeCompletion < 0.03 || releaseSwipeCompletion > 0.97);
              if (isSwipingRight && (releaseSwipeCompletion > 0.5 || velocity > 0.1)) {
                var speed = (velocity > 0.5 || velocity < 0.05 || releaseX > windowWidth - 45) ? 'fast' : 'slow';
                navSwipeAttr(disableAnimation ? '' : speed);
                backView.go();
                associatedNavBarCtrl && associatedNavBarCtrl.activeTransition && associatedNavBarCtrl.activeTransition.complete(!disableAnimation, speed);
              } else {
                navSwipeAttr(disableAnimation ? '' : 'fast');
                disableRenderStartViewId = null;
                viewTransition.cancel(!disableAnimation);
                associatedNavBarCtrl && associatedNavBarCtrl.activeTransition && associatedNavBarCtrl.activeTransition.cancel(!disableAnimation, 'fast', cancelData);
                disableAnimation = null;
              }
            }
            ionic.offGesture(deregDrag, 'drag', onDrag);
            ionic.offGesture(deregRelease, 'release', onRelease);
            windowWidth = viewTransition = dragPoints = null;
            self.isSwipeFreeze = $ionicScrollDelegate.freezeAllScrolls(false);
          }
          function getDragX(ev) {
            return ionic.tap.pointerCoord(ev.gesture.srcEvent).x;
          }
          function getSwipeCompletion(dragX) {
            return (dragX - startDragX) / windowWidth;
          }
          deregDragStart = ionic.onGesture('dragstart', onDragStart, $element[0]);
          $scope.$on('$destroy', function() {
            ionic.offGesture(deregDragStart, 'dragstart', onDragStart);
            ionic.offGesture(deregDrag, 'drag', onDrag);
            ionic.offGesture(deregRelease, 'release', onRelease);
            self.element = viewTransition = associatedNavBarCtrl = null;
          });
        };
        function navSwipeAttr(val) {
          ionic.DomUtil.cachedAttr($element, 'nav-swipe', val);
        }
        function onTabsTop(ev, isTabsTop) {
          var associatedNavBarCtrl = getAssociatedNavBarCtrl();
          associatedNavBarCtrl && associatedNavBarCtrl.hasTabsTop(isTabsTop);
        }
        function onBarSubheader(ev, isBarSubheader) {
          var associatedNavBarCtrl = getAssociatedNavBarCtrl();
          associatedNavBarCtrl && associatedNavBarCtrl.hasBarSubheader(isBarSubheader);
        }
        function getAssociatedNavBarCtrl() {
          if (navBarDelegate) {
            for (var x = 0; x < $ionicNavBarDelegate._instances.length; x++) {
              if ($ionicNavBarDelegate._instances[x].$$delegateHandle == navBarDelegate) {
                return $ionicNavBarDelegate._instances[x];
              }
            }
          }
          return $element.inheritedData('$ionNavBarController');
        }
      }]);
      IonicModule.controller('$ionicRefresher', ['$scope', '$attrs', '$element', '$ionicBind', '$timeout', function($scope, $attrs, $element, $ionicBind, $timeout) {
        var self = this,
            isDragging = false,
            isOverscrolling = false,
            dragOffset = 0,
            lastOverscroll = 0,
            ptrThreshold = 60,
            activated = false,
            scrollTime = 500,
            startY = null,
            deltaY = null,
            canOverscroll = true,
            scrollParent,
            scrollChild;
        if (!isDefined($attrs.pullingIcon)) {
          $attrs.$set('pullingIcon', 'ion-android-arrow-down');
        }
        $scope.showSpinner = !isDefined($attrs.refreshingIcon) && $attrs.spinner != 'none';
        $scope.showIcon = isDefined($attrs.refreshingIcon);
        $ionicBind($scope, $attrs, {
          pullingIcon: '@',
          pullingText: '@',
          refreshingIcon: '@',
          refreshingText: '@',
          spinner: '@',
          disablePullingRotation: '@',
          $onRefresh: '&onRefresh',
          $onPulling: '&onPulling'
        });
        function handleMousedown(e) {
          e.touches = e.touches || [{
            screenX: e.screenX,
            screenY: e.screenY
          }];
          startY = Math.floor(e.touches[0].screenY);
        }
        function handleTouchstart(e) {
          e.touches = e.touches || [{
            screenX: e.screenX,
            screenY: e.screenY
          }];
          startY = e.touches[0].screenY;
        }
        function handleTouchend() {
          startY = null;
          if (!canOverscroll && !isDragging) {
            return;
          }
          if (!isDragging) {
            dragOffset = 0;
            isOverscrolling = false;
            setScrollLock(false);
          } else {
            isDragging = false;
            dragOffset = 0;
            if (lastOverscroll > ptrThreshold) {
              start();
              scrollTo(ptrThreshold, scrollTime);
            } else {
              scrollTo(0, scrollTime, deactivate);
              isOverscrolling = false;
            }
          }
        }
        function handleTouchmove(e) {
          e.touches = e.touches || [{
            screenX: e.screenX,
            screenY: e.screenY
          }];
          if (!startY && e.type == 'mousemove') {
            return;
          }
          if (!canOverscroll || e.touches.length > 1) {
            return;
          }
          if (startY === null) {
            startY = e.touches[0].screenY;
          }
          deltaY = e.touches[0].screenY - startY;
          if (ionic.Platform.isAndroid() && ionic.Platform.version() === 4.4 && !ionic.Platform.isCrosswalk() && scrollParent.scrollTop === 0 && deltaY > 0) {
            isDragging = true;
            e.preventDefault();
          }
          if (deltaY - dragOffset <= 0 || scrollParent.scrollTop !== 0) {
            if (isOverscrolling) {
              isOverscrolling = false;
              setScrollLock(false);
            }
            if (isDragging) {
              nativescroll(scrollParent, deltaY - dragOffset * -1);
            }
            if (lastOverscroll !== 0) {
              overscroll(0);
            }
            return;
          } else if (deltaY > 0 && scrollParent.scrollTop === 0 && !isOverscrolling) {
            dragOffset = deltaY;
          }
          e.preventDefault();
          if (!isOverscrolling) {
            isOverscrolling = true;
            setScrollLock(true);
          }
          isDragging = true;
          overscroll((deltaY - dragOffset) / 3);
          if (!activated && lastOverscroll > ptrThreshold) {
            activated = true;
            ionic.requestAnimationFrame(activate);
          } else if (activated && lastOverscroll < ptrThreshold) {
            activated = false;
            ionic.requestAnimationFrame(deactivate);
          }
        }
        function handleScroll(e) {
          canOverscroll = (e.target.scrollTop === 0) || isDragging;
        }
        function overscroll(val) {
          scrollChild.style[ionic.CSS.TRANSFORM] = 'translateY(' + val + 'px)';
          lastOverscroll = val;
        }
        function nativescroll(target, newScrollTop) {
          target.scrollTop = newScrollTop;
          var e = document.createEvent("UIEvents");
          e.initUIEvent("scroll", true, true, window, 1);
          target.dispatchEvent(e);
        }
        function setScrollLock(enabled) {
          if (enabled) {
            ionic.requestAnimationFrame(function() {
              scrollChild.classList.add('overscroll');
              show();
            });
          } else {
            ionic.requestAnimationFrame(function() {
              scrollChild.classList.remove('overscroll');
              hide();
              deactivate();
            });
          }
        }
        $scope.$on('scroll.refreshComplete', function() {
          $timeout(function() {
            ionic.requestAnimationFrame(tail);
            scrollTo(0, scrollTime, deactivate);
            $timeout(function() {
              if (isOverscrolling) {
                isOverscrolling = false;
                setScrollLock(false);
              }
            }, scrollTime);
          }, scrollTime);
        });
        function scrollTo(Y, duration, callback) {
          var start = Date.now(),
              from = lastOverscroll;
          if (from === Y) {
            callback();
            return;
          }
          function easeOutCubic(t) {
            return (--t) * t * t + 1;
          }
          function scroll() {
            var currentTime = Date.now(),
                time = Math.min(1, ((currentTime - start) / duration)),
                easedT = easeOutCubic(time);
            overscroll(Math.floor((easedT * (Y - from)) + from));
            if (time < 1) {
              ionic.requestAnimationFrame(scroll);
            } else {
              if (Y < 5 && Y > -5) {
                isOverscrolling = false;
                setScrollLock(false);
              }
              callback && callback();
            }
          }
          ionic.requestAnimationFrame(scroll);
        }
        var touchStartEvent,
            touchMoveEvent,
            touchEndEvent;
        if (window.navigator.pointerEnabled) {
          touchStartEvent = 'pointerdown';
          touchMoveEvent = 'pointermove';
          touchEndEvent = 'pointerup';
        } else if (window.navigator.msPointerEnabled) {
          touchStartEvent = 'MSPointerDown';
          touchMoveEvent = 'MSPointerMove';
          touchEndEvent = 'MSPointerUp';
        } else {
          touchStartEvent = 'touchstart';
          touchMoveEvent = 'touchmove';
          touchEndEvent = 'touchend';
        }
        self.init = function() {
          scrollParent = $element.parent().parent()[0];
          scrollChild = $element.parent()[0];
          if (!scrollParent || !scrollParent.classList.contains('ionic-scroll') || !scrollChild || !scrollChild.classList.contains('scroll')) {
            throw new Error('Refresher must be immediate child of ion-content or ion-scroll');
          }
          ionic.on(touchStartEvent, handleTouchstart, scrollChild);
          ionic.on(touchMoveEvent, handleTouchmove, scrollChild);
          ionic.on(touchEndEvent, handleTouchend, scrollChild);
          ionic.on('mousedown', handleMousedown, scrollChild);
          ionic.on('mousemove', handleTouchmove, scrollChild);
          ionic.on('mouseup', handleTouchend, scrollChild);
          ionic.on('scroll', handleScroll, scrollParent);
          $scope.$on('$destroy', destroy);
        };
        function destroy() {
          if (scrollChild) {
            ionic.off(touchStartEvent, handleTouchstart, scrollChild);
            ionic.off(touchMoveEvent, handleTouchmove, scrollChild);
            ionic.off(touchEndEvent, handleTouchend, scrollChild);
            ionic.off('mousedown', handleMousedown, scrollChild);
            ionic.off('mousemove', handleTouchmove, scrollChild);
            ionic.off('mouseup', handleTouchend, scrollChild);
          }
          if (scrollParent) {
            ionic.off('scroll', handleScroll, scrollParent);
          }
          scrollParent = null;
          scrollChild = null;
        }
        self.getRefresherDomMethods = function() {
          return {
            activate: activate,
            deactivate: deactivate,
            start: start,
            show: show,
            hide: hide,
            tail: tail
          };
        };
        function activate() {
          $element[0].classList.add('active');
          $scope.$onPulling();
        }
        function deactivate() {
          $timeout(function() {
            $element.removeClass('active refreshing refreshing-tail');
            if (activated)
              activated = false;
          }, 150);
        }
        function start() {
          $element[0].classList.add('refreshing');
          var q = $scope.$onRefresh();
          if (q && q.then) {
            q['finally'](function() {
              $scope.$broadcast('scroll.refreshComplete');
            });
          }
        }
        function show() {
          $element[0].classList.remove('invisible');
        }
        function hide() {
          $element[0].classList.add('invisible');
        }
        function tail() {
          $element[0].classList.add('refreshing-tail');
        }
        self.__handleTouchmove = handleTouchmove;
        self.__getScrollChild = function() {
          return scrollChild;
        };
        self.__getScrollParent = function() {
          return scrollParent;
        };
      }]);
      IonicModule.controller('$ionicScroll', ['$scope', 'scrollViewOptions', '$timeout', '$window', '$location', '$document', '$ionicScrollDelegate', '$ionicHistory', function($scope, scrollViewOptions, $timeout, $window, $location, $document, $ionicScrollDelegate, $ionicHistory) {
        var self = this;
        self.__timeout = $timeout;
        self._scrollViewOptions = scrollViewOptions;
        self.isNative = function() {
          return !!scrollViewOptions.nativeScrolling;
        };
        var element = self.element = scrollViewOptions.el;
        var $element = self.$element = jqLite(element);
        var scrollView;
        if (self.isNative()) {
          scrollView = self.scrollView = new ionic.views.ScrollNative(scrollViewOptions);
        } else {
          scrollView = self.scrollView = new ionic.views.Scroll(scrollViewOptions);
        }
        ($element.parent().length ? $element.parent() : $element).data('$$ionicScrollController', self);
        var deregisterInstance = $ionicScrollDelegate._registerInstance(self, scrollViewOptions.delegateHandle, function() {
          return $ionicHistory.isActiveScope($scope);
        });
        if (!isDefined(scrollViewOptions.bouncing)) {
          ionic.Platform.ready(function() {
            if (scrollView && scrollView.options) {
              scrollView.options.bouncing = true;
              if (ionic.Platform.isAndroid()) {
                scrollView.options.bouncing = false;
                scrollView.options.deceleration = 0.95;
              }
            }
          });
        }
        var resize = angular.bind(scrollView, scrollView.resize);
        angular.element($window).on('resize', resize);
        var scrollFunc = function(e) {
          var detail = (e.originalEvent || e).detail || {};
          $scope.$onScroll && $scope.$onScroll({
            event: e,
            scrollTop: detail.scrollTop || 0,
            scrollLeft: detail.scrollLeft || 0
          });
        };
        $element.on('scroll', scrollFunc);
        $scope.$on('$destroy', function() {
          deregisterInstance();
          scrollView && scrollView.__cleanup && scrollView.__cleanup();
          angular.element($window).off('resize', resize);
          if ($element) {
            $element.off('scroll', scrollFunc);
          }
          if (self._scrollViewOptions) {
            self._scrollViewOptions.el = null;
          }
          if (scrollViewOptions) {
            scrollViewOptions.el = null;
          }
          scrollView = self.scrollView = scrollViewOptions = self._scrollViewOptions = element = self.$element = $element = null;
        });
        $timeout(function() {
          scrollView && scrollView.run && scrollView.run();
        });
        self.getScrollView = function() {
          return scrollView;
        };
        self.getScrollPosition = function() {
          return scrollView.getValues();
        };
        self.resize = function() {
          return $timeout(resize, 0, false).then(function() {
            $element && $element.triggerHandler('scroll-resize');
          });
        };
        self.scrollTop = function(shouldAnimate) {
          self.resize().then(function() {
            if (!scrollView) {
              return;
            }
            scrollView.scrollTo(0, 0, !!shouldAnimate);
          });
        };
        self.scrollBottom = function(shouldAnimate) {
          self.resize().then(function() {
            if (!scrollView) {
              return;
            }
            var max = scrollView.getScrollMax();
            scrollView.scrollTo(max.left, max.top, !!shouldAnimate);
          });
        };
        self.scrollTo = function(left, top, shouldAnimate) {
          self.resize().then(function() {
            if (!scrollView) {
              return;
            }
            scrollView.scrollTo(left, top, !!shouldAnimate);
          });
        };
        self.zoomTo = function(zoom, shouldAnimate, originLeft, originTop) {
          self.resize().then(function() {
            if (!scrollView) {
              return;
            }
            scrollView.zoomTo(zoom, !!shouldAnimate, originLeft, originTop);
          });
        };
        self.zoomBy = function(zoom, shouldAnimate, originLeft, originTop) {
          self.resize().then(function() {
            if (!scrollView) {
              return;
            }
            scrollView.zoomBy(zoom, !!shouldAnimate, originLeft, originTop);
          });
        };
        self.scrollBy = function(left, top, shouldAnimate) {
          self.resize().then(function() {
            if (!scrollView) {
              return;
            }
            scrollView.scrollBy(left, top, !!shouldAnimate);
          });
        };
        self.anchorScroll = function(shouldAnimate) {
          self.resize().then(function() {
            if (!scrollView) {
              return;
            }
            var hash = $location.hash();
            var elm = hash && $document[0].getElementById(hash);
            if (!(hash && elm)) {
              scrollView.scrollTo(0, 0, !!shouldAnimate);
              return;
            }
            var curElm = elm;
            var scrollLeft = 0,
                scrollTop = 0;
            do {
              if (curElm !== null)
                scrollLeft += curElm.offsetLeft;
              if (curElm !== null)
                scrollTop += curElm.offsetTop;
              curElm = curElm.offsetParent;
            } while (curElm.attributes != self.element.attributes && curElm.offsetParent);
            scrollView.scrollTo(scrollLeft, scrollTop, !!shouldAnimate);
          });
        };
        self.freezeScroll = scrollView.freeze;
        self.freezeScrollShut = scrollView.freezeShut;
        self.freezeAllScrolls = function(shouldFreeze) {
          for (var i = 0; i < $ionicScrollDelegate._instances.length; i++) {
            $ionicScrollDelegate._instances[i].freezeScroll(shouldFreeze);
          }
        };
        self._setRefresher = function(refresherScope, refresherElement, refresherMethods) {
          self.refresher = refresherElement;
          var refresherHeight = self.refresher.clientHeight || 60;
          scrollView.activatePullToRefresh(refresherHeight, refresherMethods);
        };
      }]);
      IonicModule.controller('$ionicSideMenus', ['$scope', '$attrs', '$ionicSideMenuDelegate', '$ionicPlatform', '$ionicBody', '$ionicHistory', '$ionicScrollDelegate', 'IONIC_BACK_PRIORITY', '$rootScope', function($scope, $attrs, $ionicSideMenuDelegate, $ionicPlatform, $ionicBody, $ionicHistory, $ionicScrollDelegate, IONIC_BACK_PRIORITY, $rootScope) {
        var self = this;
        var rightShowing,
            leftShowing,
            isDragging;
        var startX,
            lastX,
            offsetX,
            isAsideExposed;
        var enableMenuWithBackViews = true;
        self.$scope = $scope;
        self.initialize = function(options) {
          self.left = options.left;
          self.right = options.right;
          self.setContent(options.content);
          self.dragThresholdX = options.dragThresholdX || 10;
          $ionicHistory.registerHistory(self.$scope);
        };
        self.setContent = function(content) {
          if (content) {
            self.content = content;
            self.content.onDrag = function(e) {
              self._handleDrag(e);
            };
            self.content.endDrag = function(e) {
              self._endDrag(e);
            };
          }
        };
        self.isOpenLeft = function() {
          return self.getOpenAmount() > 0;
        };
        self.isOpenRight = function() {
          return self.getOpenAmount() < 0;
        };
        self.toggleLeft = function(shouldOpen) {
          if (isAsideExposed || !self.left.isEnabled)
            return;
          var openAmount = self.getOpenAmount();
          if (arguments.length === 0) {
            shouldOpen = openAmount <= 0;
          }
          self.content.enableAnimation();
          if (!shouldOpen) {
            self.openPercentage(0);
            $rootScope.$emit('$ionicSideMenuClose', 'left');
          } else {
            self.openPercentage(100);
            $rootScope.$emit('$ionicSideMenuOpen', 'left');
          }
        };
        self.toggleRight = function(shouldOpen) {
          if (isAsideExposed || !self.right.isEnabled)
            return;
          var openAmount = self.getOpenAmount();
          if (arguments.length === 0) {
            shouldOpen = openAmount >= 0;
          }
          self.content.enableAnimation();
          if (!shouldOpen) {
            self.openPercentage(0);
            $rootScope.$emit('$ionicSideMenuClose', 'right');
          } else {
            self.openPercentage(-100);
            $rootScope.$emit('$ionicSideMenuOpen', 'right');
          }
        };
        self.toggle = function(side) {
          if (side == 'right') {
            self.toggleRight();
          } else {
            self.toggleLeft();
          }
        };
        self.close = function() {
          self.openPercentage(0);
          $rootScope.$emit('$ionicSideMenuClose', 'left');
          $rootScope.$emit('$ionicSideMenuClose', 'right');
        };
        self.getOpenAmount = function() {
          return self.content && self.content.getTranslateX() || 0;
        };
        self.getOpenRatio = function() {
          var amount = self.getOpenAmount();
          if (amount >= 0) {
            return amount / self.left.width;
          }
          return amount / self.right.width;
        };
        self.isOpen = function() {
          return self.getOpenAmount() !== 0;
        };
        self.getOpenPercentage = function() {
          return self.getOpenRatio() * 100;
        };
        self.openPercentage = function(percentage) {
          var p = percentage / 100;
          if (self.left && percentage >= 0) {
            self.openAmount(self.left.width * p);
          } else if (self.right && percentage < 0) {
            self.openAmount(self.right.width * p);
          }
          $ionicBody.enableClass((percentage !== 0), 'menu-open');
          self.content.setCanScroll(percentage == 0);
        };
        self.openAmount = function(amount) {
          var maxLeft = self.left && self.left.width || 0;
          var maxRight = self.right && self.right.width || 0;
          if (!(self.left && self.left.isEnabled) && amount > 0) {
            self.content.setTranslateX(0);
            return;
          }
          if (!(self.right && self.right.isEnabled) && amount < 0) {
            self.content.setTranslateX(0);
            return;
          }
          if (leftShowing && amount > maxLeft) {
            self.content.setTranslateX(maxLeft);
            return;
          }
          if (rightShowing && amount < -maxRight) {
            self.content.setTranslateX(-maxRight);
            return;
          }
          self.content.setTranslateX(amount);
          if (amount >= 0) {
            leftShowing = true;
            rightShowing = false;
            if (amount > 0) {
              self.right && self.right.pushDown && self.right.pushDown();
              self.left && self.left.bringUp && self.left.bringUp();
            }
          } else {
            rightShowing = true;
            leftShowing = false;
            self.right && self.right.bringUp && self.right.bringUp();
            self.left && self.left.pushDown && self.left.pushDown();
          }
        };
        self.snapToRest = function(e) {
          self.content.enableAnimation();
          isDragging = false;
          var ratio = self.getOpenRatio();
          if (ratio === 0) {
            self.openPercentage(0);
            return;
          }
          var velocityThreshold = 0.3;
          var velocityX = e.gesture.velocityX;
          var direction = e.gesture.direction;
          if (ratio > 0 && ratio < 0.5 && direction == 'right' && velocityX < velocityThreshold) {
            self.openPercentage(0);
          } else if (ratio > 0.5 && direction == 'left' && velocityX < velocityThreshold) {
            self.openPercentage(100);
          } else if (ratio < 0 && ratio > -0.5 && direction == 'left' && velocityX < velocityThreshold) {
            self.openPercentage(0);
          } else if (ratio < 0.5 && direction == 'right' && velocityX < velocityThreshold) {
            self.openPercentage(-100);
          } else if (direction == 'right' && ratio >= 0 && (ratio >= 0.5 || velocityX > velocityThreshold)) {
            self.openPercentage(100);
          } else if (direction == 'left' && ratio <= 0 && (ratio <= -0.5 || velocityX > velocityThreshold)) {
            self.openPercentage(-100);
          } else {
            self.openPercentage(0);
          }
        };
        self.enableMenuWithBackViews = function(val) {
          if (arguments.length) {
            enableMenuWithBackViews = !!val;
          }
          return enableMenuWithBackViews;
        };
        self.isAsideExposed = function() {
          return !!isAsideExposed;
        };
        self.exposeAside = function(shouldExposeAside) {
          if (!(self.left && self.left.isEnabled) && !(self.right && self.right.isEnabled))
            return;
          self.close();
          isAsideExposed = shouldExposeAside;
          if ((self.left && self.left.isEnabled) && (self.right && self.right.isEnabled)) {
            self.content.setMarginLeftAndRight(isAsideExposed ? self.left.width : 0, isAsideExposed ? self.right.width : 0);
          } else if (self.left && self.left.isEnabled) {
            self.content.setMarginLeft(isAsideExposed ? self.left.width : 0);
          } else if (self.right && self.right.isEnabled) {
            self.content.setMarginRight(isAsideExposed ? self.right.width : 0);
          }
          self.$scope.$emit('$ionicExposeAside', isAsideExposed);
        };
        self.activeAsideResizing = function(isResizing) {
          $ionicBody.enableClass(isResizing, 'aside-resizing');
        };
        self._endDrag = function(e) {
          if (isAsideExposed)
            return;
          if (isDragging) {
            self.snapToRest(e);
          }
          startX = null;
          lastX = null;
          offsetX = null;
        };
        self._handleDrag = function(e) {
          if (isAsideExposed || !$scope.dragContent)
            return;
          if (!startX) {
            startX = e.gesture.touches[0].pageX;
            lastX = startX;
          } else {
            lastX = e.gesture.touches[0].pageX;
          }
          if (!isDragging && Math.abs(lastX - startX) > self.dragThresholdX) {
            startX = lastX;
            isDragging = true;
            self.content.disableAnimation();
            offsetX = self.getOpenAmount();
          }
          if (isDragging) {
            self.openAmount(offsetX + (lastX - startX));
          }
        };
        self.canDragContent = function(canDrag) {
          if (arguments.length) {
            $scope.dragContent = !!canDrag;
          }
          return $scope.dragContent;
        };
        self.edgeThreshold = 25;
        self.edgeThresholdEnabled = false;
        self.edgeDragThreshold = function(value) {
          if (arguments.length) {
            if (isNumber(value) && value > 0) {
              self.edgeThreshold = value;
              self.edgeThresholdEnabled = true;
            } else {
              self.edgeThresholdEnabled = !!value;
            }
          }
          return self.edgeThresholdEnabled;
        };
        self.isDraggableTarget = function(e) {
          var shouldOnlyAllowEdgeDrag = self.edgeThresholdEnabled && !self.isOpen();
          var startX = e.gesture.startEvent && e.gesture.startEvent.center && e.gesture.startEvent.center.pageX;
          var dragIsWithinBounds = !shouldOnlyAllowEdgeDrag || startX <= self.edgeThreshold || startX >= self.content.element.offsetWidth - self.edgeThreshold;
          var backView = $ionicHistory.backView();
          var menuEnabled = enableMenuWithBackViews ? true : !backView;
          if (!menuEnabled) {
            var currentView = $ionicHistory.currentView() || {};
            return (dragIsWithinBounds && (backView.historyId !== currentView.historyId));
          }
          return ($scope.dragContent || self.isOpen()) && dragIsWithinBounds && !e.gesture.srcEvent.defaultPrevented && menuEnabled && !e.target.tagName.match(/input|textarea|select|object|embed/i) && !e.target.isContentEditable && !(e.target.dataset ? e.target.dataset.preventScroll : e.target.getAttribute('data-prevent-scroll') == 'true');
        };
        $scope.sideMenuContentTranslateX = 0;
        var deregisterBackButtonAction = noop;
        var closeSideMenu = angular.bind(self, self.close);
        $scope.$watch(function() {
          return self.getOpenAmount() !== 0;
        }, function(isOpen) {
          deregisterBackButtonAction();
          if (isOpen) {
            deregisterBackButtonAction = $ionicPlatform.registerBackButtonAction(closeSideMenu, IONIC_BACK_PRIORITY.sideMenu);
          }
        });
        var deregisterInstance = $ionicSideMenuDelegate._registerInstance(self, $attrs.delegateHandle, function() {
          return $ionicHistory.isActiveScope($scope);
        });
        $scope.$on('$destroy', function() {
          deregisterInstance();
          deregisterBackButtonAction();
          self.$scope = null;
          if (self.content) {
            self.content.setCanScroll(true);
            self.content.element = null;
            self.content = null;
          }
        });
        self.initialize({
          left: {width: 275},
          right: {width: 275}
        });
      }]);
      (function(ionic) {
        var TRANSLATE32 = 'translate(32,32)';
        var STROKE_OPACITY = 'stroke-opacity';
        var ROUND = 'round';
        var INDEFINITE = 'indefinite';
        var DURATION = '750ms';
        var NONE = 'none';
        var SHORTCUTS = {
          a: 'animate',
          an: 'attributeName',
          at: 'animateTransform',
          c: 'circle',
          da: 'stroke-dasharray',
          os: 'stroke-dashoffset',
          f: 'fill',
          lc: 'stroke-linecap',
          rc: 'repeatCount',
          sw: 'stroke-width',
          t: 'transform',
          v: 'values'
        };
        var SPIN_ANIMATION = {
          v: '0,32,32;360,32,32',
          an: 'transform',
          type: 'rotate',
          rc: INDEFINITE,
          dur: DURATION
        };
        function createSvgElement(tagName, data, parent, spinnerName) {
          var ele = document.createElement(SHORTCUTS[tagName] || tagName);
          var k,
              x,
              y;
          for (k in data) {
            if (angular.isArray(data[k])) {
              for (x = 0; x < data[k].length; x++) {
                if (data[k][x].fn) {
                  for (y = 0; y < data[k][x].t; y++) {
                    createSvgElement(k, data[k][x].fn(y, spinnerName), ele, spinnerName);
                  }
                } else {
                  createSvgElement(k, data[k][x], ele, spinnerName);
                }
              }
            } else {
              setSvgAttribute(ele, k, data[k]);
            }
          }
          parent.appendChild(ele);
        }
        function setSvgAttribute(ele, k, v) {
          ele.setAttribute(SHORTCUTS[k] || k, v);
        }
        function animationValues(strValues, i) {
          var values = strValues.split(';');
          var back = values.slice(i);
          var front = values.slice(0, values.length - back.length);
          values = back.concat(front).reverse();
          return values.join(';') + ';' + values[0];
        }
        var IOS_SPINNER = {
          sw: 4,
          lc: ROUND,
          line: [{
            fn: function(i, spinnerName) {
              return {
                y1: spinnerName == 'ios' ? 17 : 12,
                y2: spinnerName == 'ios' ? 29 : 20,
                t: TRANSLATE32 + ' rotate(' + (30 * i + (i < 6 ? 180 : -180)) + ')',
                a: [{
                  fn: function() {
                    return {
                      an: STROKE_OPACITY,
                      dur: DURATION,
                      v: animationValues('0;.1;.15;.25;.35;.45;.55;.65;.7;.85;1', i),
                      rc: INDEFINITE
                    };
                  },
                  t: 1
                }]
              };
            },
            t: 12
          }]
        };
        var spinners = {
          android: {c: [{
              sw: 6,
              da: 128,
              os: 82,
              r: 26,
              cx: 32,
              cy: 32,
              f: NONE
            }]},
          ios: IOS_SPINNER,
          'ios-small': IOS_SPINNER,
          bubbles: {
            sw: 0,
            c: [{
              fn: function(i) {
                return {
                  cx: 24 * Math.cos(2 * Math.PI * i / 8),
                  cy: 24 * Math.sin(2 * Math.PI * i / 8),
                  t: TRANSLATE32,
                  a: [{
                    fn: function() {
                      return {
                        an: 'r',
                        dur: DURATION,
                        v: animationValues('1;2;3;4;5;6;7;8', i),
                        rc: INDEFINITE
                      };
                    },
                    t: 1
                  }]
                };
              },
              t: 8
            }]
          },
          circles: {c: [{
              fn: function(i) {
                return {
                  r: 5,
                  cx: 24 * Math.cos(2 * Math.PI * i / 8),
                  cy: 24 * Math.sin(2 * Math.PI * i / 8),
                  t: TRANSLATE32,
                  sw: 0,
                  a: [{
                    fn: function() {
                      return {
                        an: 'fill-opacity',
                        dur: DURATION,
                        v: animationValues('.3;.3;.3;.4;.7;.85;.9;1', i),
                        rc: INDEFINITE
                      };
                    },
                    t: 1
                  }]
                };
              },
              t: 8
            }]},
          crescent: {c: [{
              sw: 4,
              da: 128,
              os: 82,
              r: 26,
              cx: 32,
              cy: 32,
              f: NONE,
              at: [SPIN_ANIMATION]
            }]},
          dots: {c: [{
              fn: function(i) {
                return {
                  cx: 16 + (16 * i),
                  cy: 32,
                  sw: 0,
                  a: [{
                    fn: function() {
                      return {
                        an: 'fill-opacity',
                        dur: DURATION,
                        v: animationValues('.5;.6;.8;1;.8;.6;.5', i),
                        rc: INDEFINITE
                      };
                    },
                    t: 1
                  }, {
                    fn: function() {
                      return {
                        an: 'r',
                        dur: DURATION,
                        v: animationValues('4;5;6;5;4;3;3', i),
                        rc: INDEFINITE
                      };
                    },
                    t: 1
                  }]
                };
              },
              t: 3
            }]},
          lines: {
            sw: 7,
            lc: ROUND,
            line: [{
              fn: function(i) {
                return {
                  x1: 10 + (i * 14),
                  x2: 10 + (i * 14),
                  a: [{
                    fn: function() {
                      return {
                        an: 'y1',
                        dur: DURATION,
                        v: animationValues('16;18;28;18;16', i),
                        rc: INDEFINITE
                      };
                    },
                    t: 1
                  }, {
                    fn: function() {
                      return {
                        an: 'y2',
                        dur: DURATION,
                        v: animationValues('48;44;36;46;48', i),
                        rc: INDEFINITE
                      };
                    },
                    t: 1
                  }, {
                    fn: function() {
                      return {
                        an: STROKE_OPACITY,
                        dur: DURATION,
                        v: animationValues('1;.8;.5;.4;1', i),
                        rc: INDEFINITE
                      };
                    },
                    t: 1
                  }]
                };
              },
              t: 4
            }]
          },
          ripple: {
            f: NONE,
            'fill-rule': 'evenodd',
            sw: 3,
            circle: [{
              fn: function(i) {
                return {
                  cx: 32,
                  cy: 32,
                  a: [{
                    fn: function() {
                      return {
                        an: 'r',
                        begin: (i * -1) + 's',
                        dur: '2s',
                        v: '0;24',
                        keyTimes: '0;1',
                        keySplines: '0.1,0.2,0.3,1',
                        calcMode: 'spline',
                        rc: INDEFINITE
                      };
                    },
                    t: 1
                  }, {
                    fn: function() {
                      return {
                        an: STROKE_OPACITY,
                        begin: (i * -1) + 's',
                        dur: '2s',
                        v: '.2;1;.2;0',
                        rc: INDEFINITE
                      };
                    },
                    t: 1
                  }]
                };
              },
              t: 2
            }]
          },
          spiral: {
            defs: [{linearGradient: [{
                id: 'sGD',
                gradientUnits: 'userSpaceOnUse',
                x1: 55,
                y1: 46,
                x2: 2,
                y2: 46,
                stop: [{
                  offset: 0.1,
                  class: 'stop1'
                }, {
                  offset: 1,
                  class: 'stop2'
                }]
              }]}],
            g: [{
              sw: 4,
              lc: ROUND,
              f: NONE,
              path: [{
                stroke: 'url(#sGD)',
                d: 'M4,32 c0,15,12,28,28,28c8,0,16-4,21-9'
              }, {d: 'M60,32 C60,16,47.464,4,32,4S4,16,4,32'}],
              at: [SPIN_ANIMATION]
            }]
          }
        };
        var animations = {android: function(ele) {
            var self = {};
            this.stop = false;
            var rIndex = 0;
            var rotateCircle = 0;
            var startTime;
            var svgEle = ele.querySelector('g');
            var circleEle = ele.querySelector('circle');
            function run() {
              if (self.stop)
                return;
              var v = easeInOutCubic(Date.now() - startTime, 650);
              var scaleX = 1;
              var translateX = 0;
              var dasharray = (188 - (58 * v));
              var dashoffset = (182 - (182 * v));
              if (rIndex % 2) {
                scaleX = -1;
                translateX = -64;
                dasharray = (128 - (-58 * v));
                dashoffset = (182 * v);
              }
              var rotateLine = [0, -101, -90, -11, -180, 79, -270, -191][rIndex];
              setSvgAttribute(circleEle, 'da', Math.max(Math.min(dasharray, 188), 128));
              setSvgAttribute(circleEle, 'os', Math.max(Math.min(dashoffset, 182), 0));
              setSvgAttribute(circleEle, 't', 'scale(' + scaleX + ',1) translate(' + translateX + ',0) rotate(' + rotateLine + ',32,32)');
              rotateCircle += 4.1;
              if (rotateCircle > 359)
                rotateCircle = 0;
              setSvgAttribute(svgEle, 't', 'rotate(' + rotateCircle + ',32,32)');
              if (v >= 1) {
                rIndex++;
                if (rIndex > 7)
                  rIndex = 0;
                startTime = Date.now();
              }
              ionic.requestAnimationFrame(run);
            }
            return function() {
              startTime = Date.now();
              run();
              return self;
            };
          }};
        function easeInOutCubic(t, c) {
          t /= c / 2;
          if (t < 1)
            return 1 / 2 * t * t * t;
          t -= 2;
          return 1 / 2 * (t * t * t + 2);
        }
        IonicModule.controller('$ionicSpinner', ['$element', '$attrs', '$ionicConfig', function($element, $attrs, $ionicConfig) {
          var spinnerName,
              anim;
          this.init = function() {
            spinnerName = $attrs.icon || $ionicConfig.spinner.icon();
            var container = document.createElement('div');
            createSvgElement('svg', {
              viewBox: '0 0 64 64',
              g: [spinners[spinnerName]]
            }, container, spinnerName);
            $element.html(container.innerHTML);
            this.start();
            return spinnerName;
          };
          this.start = function() {
            animations[spinnerName] && (anim = animations[spinnerName]($element[0])());
          };
          this.stop = function() {
            animations[spinnerName] && (anim.stop = true);
          };
        }]);
      })(ionic);
      IonicModule.controller('$ionicTab', ['$scope', '$ionicHistory', '$attrs', '$location', '$state', function($scope, $ionicHistory, $attrs, $location, $state) {
        this.$scope = $scope;
        this.hrefMatchesState = function() {
          return $attrs.href && $location.path().indexOf($attrs.href.replace(/^#/, '').replace(/\/$/, '')) === 0;
        };
        this.srefMatchesState = function() {
          return $attrs.uiSref && $state.includes($attrs.uiSref.split('(')[0]);
        };
        this.navNameMatchesState = function() {
          return this.navViewName && $ionicHistory.isCurrentStateNavView(this.navViewName);
        };
        this.tabMatchesState = function() {
          return this.hrefMatchesState() || this.srefMatchesState() || this.navNameMatchesState();
        };
      }]);
      IonicModule.controller('$ionicTabs', ['$scope', '$element', '$ionicHistory', function($scope, $element, $ionicHistory) {
        var self = this;
        var selectedTab = null;
        var previousSelectedTab = null;
        var selectedTabIndex;
        var isVisible = true;
        self.tabs = [];
        self.selectedIndex = function() {
          return self.tabs.indexOf(selectedTab);
        };
        self.selectedTab = function() {
          return selectedTab;
        };
        self.previousSelectedTab = function() {
          return previousSelectedTab;
        };
        self.add = function(tab) {
          $ionicHistory.registerHistory(tab);
          self.tabs.push(tab);
        };
        self.remove = function(tab) {
          var tabIndex = self.tabs.indexOf(tab);
          if (tabIndex === -1) {
            return;
          }
          if (tab.$tabSelected) {
            self.deselect(tab);
            if (self.tabs.length === 1) {} else {
              var newTabIndex = tabIndex === self.tabs.length - 1 ? tabIndex - 1 : tabIndex + 1;
              self.select(self.tabs[newTabIndex]);
            }
          }
          self.tabs.splice(tabIndex, 1);
        };
        self.deselect = function(tab) {
          if (tab.$tabSelected) {
            previousSelectedTab = selectedTab;
            selectedTab = selectedTabIndex = null;
            tab.$tabSelected = false;
            (tab.onDeselect || noop)();
            tab.$broadcast && tab.$broadcast('$ionicHistory.deselect');
          }
        };
        self.select = function(tab, shouldEmitEvent) {
          var tabIndex;
          if (isNumber(tab)) {
            tabIndex = tab;
            if (tabIndex >= self.tabs.length)
              return;
            tab = self.tabs[tabIndex];
          } else {
            tabIndex = self.tabs.indexOf(tab);
          }
          if (arguments.length === 1) {
            shouldEmitEvent = !!(tab.navViewName || tab.uiSref);
          }
          if (selectedTab && selectedTab.$historyId == tab.$historyId) {
            if (shouldEmitEvent) {
              $ionicHistory.goToHistoryRoot(tab.$historyId);
            }
          } else if (selectedTabIndex !== tabIndex) {
            forEach(self.tabs, function(tab) {
              self.deselect(tab);
            });
            selectedTab = tab;
            selectedTabIndex = tabIndex;
            if (self.$scope && self.$scope.$parent) {
              self.$scope.$parent.$activeHistoryId = tab.$historyId;
            }
            tab.$tabSelected = true;
            (tab.onSelect || noop)();
            if (shouldEmitEvent) {
              $scope.$emit('$ionicHistory.change', {
                type: 'tab',
                tabIndex: tabIndex,
                historyId: tab.$historyId,
                navViewName: tab.navViewName,
                hasNavView: !!tab.navViewName,
                title: tab.title,
                url: tab.href,
                uiSref: tab.uiSref
              });
            }
            $scope.$broadcast("tabSelected", {
              selectedTab: tab,
              selectedTabIndex: tabIndex
            });
          }
        };
        self.hasActiveScope = function() {
          for (var x = 0; x < self.tabs.length; x++) {
            if ($ionicHistory.isActiveScope(self.tabs[x])) {
              return true;
            }
          }
          return false;
        };
        self.showBar = function(show) {
          if (arguments.length) {
            if (show) {
              $element.removeClass('tabs-item-hide');
            } else {
              $element.addClass('tabs-item-hide');
            }
            isVisible = !!show;
          }
          return isVisible;
        };
      }]);
      IonicModule.controller('$ionicView', ['$scope', '$element', '$attrs', '$compile', '$rootScope', function($scope, $element, $attrs, $compile, $rootScope) {
        var self = this;
        var navElementHtml = {};
        var navViewCtrl;
        var navBarDelegateHandle;
        var hasViewHeaderBar;
        var deregisters = [];
        var viewTitle;
        var deregIonNavBarInit = $scope.$on('ionNavBar.init', function(ev, delegateHandle) {
          ev.stopPropagation();
          navBarDelegateHandle = delegateHandle;
        });
        self.init = function() {
          deregIonNavBarInit();
          var modalCtrl = $element.inheritedData('$ionModalController');
          navViewCtrl = $element.inheritedData('$ionNavViewController');
          if (!navViewCtrl || modalCtrl)
            return;
          $scope.$on('$ionicView.beforeEnter', self.beforeEnter);
          $scope.$on('$ionicView.afterEnter', afterEnter);
          $scope.$on('$ionicView.beforeLeave', deregisterFns);
        };
        self.beforeEnter = function(ev, transData) {
          if (transData && !transData.viewNotified) {
            transData.viewNotified = true;
            if (!$rootScope.$$phase)
              $scope.$digest();
            viewTitle = isDefined($attrs.viewTitle) ? $attrs.viewTitle : $attrs.title;
            var navBarItems = {};
            for (var n in navElementHtml) {
              navBarItems[n] = generateNavBarItem(navElementHtml[n]);
            }
            navViewCtrl.beforeEnter(extend(transData, {
              title: viewTitle,
              showBack: !attrTrue('hideBackButton'),
              navBarItems: navBarItems,
              navBarDelegate: navBarDelegateHandle || null,
              showNavBar: !attrTrue('hideNavBar'),
              hasHeaderBar: !!hasViewHeaderBar
            }));
            deregisterFns();
          }
        };
        function afterEnter() {
          var viewTitleAttr = isDefined($attrs.viewTitle) && 'viewTitle' || isDefined($attrs.title) && 'title';
          if (viewTitleAttr) {
            titleUpdate($attrs[viewTitleAttr]);
            deregisters.push($attrs.$observe(viewTitleAttr, titleUpdate));
          }
          if (isDefined($attrs.hideBackButton)) {
            deregisters.push($scope.$watch($attrs.hideBackButton, function(val) {
              navViewCtrl.showBackButton(!val);
            }));
          }
          if (isDefined($attrs.hideNavBar)) {
            deregisters.push($scope.$watch($attrs.hideNavBar, function(val) {
              navViewCtrl.showBar(!val);
            }));
          }
        }
        function titleUpdate(newTitle) {
          if (isDefined(newTitle) && newTitle !== viewTitle) {
            viewTitle = newTitle;
            navViewCtrl.title(viewTitle);
          }
        }
        function deregisterFns() {
          for (var x = 0; x < deregisters.length; x++) {
            deregisters[x]();
          }
          deregisters = [];
        }
        function generateNavBarItem(html) {
          if (html) {
            return $compile(html)($scope.$new());
          }
        }
        function attrTrue(key) {
          return !!$scope.$eval($attrs[key]);
        }
        self.navElement = function(type, html) {
          navElementHtml[type] = html;
        };
      }]);
      IonicModule.directive('ionActionSheet', ['$document', function($document) {
        return {
          restrict: 'E',
          scope: true,
          replace: true,
          link: function($scope, $element) {
            var keyUp = function(e) {
              if (e.which == 27) {
                $scope.cancel();
                $scope.$apply();
              }
            };
            var backdropClick = function(e) {
              if (e.target == $element[0]) {
                $scope.cancel();
                $scope.$apply();
              }
            };
            $scope.$on('$destroy', function() {
              $element.remove();
              $document.unbind('keyup', keyUp);
            });
            $document.bind('keyup', keyUp);
            $element.bind('click', backdropClick);
          },
          template: '<div class="action-sheet-backdrop">' + '<div class="action-sheet-wrapper">' + '<div class="action-sheet" ng-class="{\'action-sheet-has-icons\': $actionSheetHasIcon}">' + '<div class="action-sheet-group action-sheet-options">' + '<div class="action-sheet-title" ng-if="titleText" ng-bind-html="titleText"></div>' + '<button class="button action-sheet-option" ng-click="buttonClicked($index)" ng-class="b.className" ng-repeat="b in buttons" ng-bind-html="b.text"></button>' + '<button class="button destructive action-sheet-destructive" ng-if="destructiveText" ng-click="destructiveButtonClicked()" ng-bind-html="destructiveText"></button>' + '</div>' + '<div class="action-sheet-group action-sheet-cancel" ng-if="cancelText">' + '<button class="button" ng-click="cancel()" ng-bind-html="cancelText"></button>' + '</div>' + '</div>' + '</div>' + '</div>'
        };
      }]);
      IonicModule.directive('ionCheckbox', ['$ionicConfig', function($ionicConfig) {
        return {
          restrict: 'E',
          replace: true,
          require: '?ngModel',
          transclude: true,
          template: '<label class="item item-checkbox">' + '<div class="checkbox checkbox-input-hidden disable-pointer-events">' + '<input type="checkbox">' + '<i class="checkbox-icon"></i>' + '</div>' + '<div class="item-content disable-pointer-events" ng-transclude></div>' + '</label>',
          compile: function(element, attr) {
            var input = element.find('input');
            forEach({
              'name': attr.name,
              'ng-value': attr.ngValue,
              'ng-model': attr.ngModel,
              'ng-checked': attr.ngChecked,
              'ng-disabled': attr.ngDisabled,
              'ng-true-value': attr.ngTrueValue,
              'ng-false-value': attr.ngFalseValue,
              'ng-change': attr.ngChange,
              'ng-required': attr.ngRequired,
              'required': attr.required
            }, function(value, name) {
              if (isDefined(value)) {
                input.attr(name, value);
              }
            });
            var checkboxWrapper = element[0].querySelector('.checkbox');
            checkboxWrapper.classList.add('checkbox-' + $ionicConfig.form.checkbox());
          }
        };
      }]);
      IonicModule.directive('collectionRepeat', CollectionRepeatDirective).factory('$ionicCollectionManager', RepeatManagerFactory);
      var ONE_PX_TRANSPARENT_IMG_SRC = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
      var WIDTH_HEIGHT_REGEX = /height:.*?px;\s*width:.*?px/;
      var DEFAULT_RENDER_BUFFER = 3;
      CollectionRepeatDirective.$inject = ['$ionicCollectionManager', '$parse', '$window', '$$rAF', '$rootScope', '$timeout'];
      function CollectionRepeatDirective($ionicCollectionManager, $parse, $window, $$rAF, $rootScope, $timeout) {
        return {
          restrict: 'A',
          priority: 1000,
          transclude: 'element',
          $$tlb: true,
          require: '^^$ionicScroll',
          link: postLink
        };
        function postLink(scope, element, attr, scrollCtrl, transclude) {
          var scrollView = scrollCtrl.scrollView;
          var node = element[0];
          var containerNode = angular.element('<div class="collection-repeat-container">')[0];
          node.parentNode.replaceChild(containerNode, node);
          if (scrollView.options.scrollingX && scrollView.options.scrollingY) {
            throw new Error("collection-repeat expected a parent x or y scrollView, not " + "an xy scrollView.");
          }
          var repeatExpr = attr.collectionRepeat;
          var match = repeatExpr.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
          if (!match) {
            throw new Error("collection-repeat expected expression in form of '_item_ in " + "_collection_[ track by _id_]' but got '" + attr.collectionRepeat + "'.");
          }
          var keyExpr = match[1];
          var listExpr = match[2];
          var listGetter = $parse(listExpr);
          var heightData = {};
          var widthData = {};
          var computedStyleDimensions = {};
          var data = [];
          var repeatManager;
          var renderBufferExpr = attr.itemRenderBuffer || attr.collectionBufferSize;
          var renderBuffer = angular.isDefined(renderBufferExpr) ? parseInt(renderBufferExpr) : DEFAULT_RENDER_BUFFER;
          var heightExpr = attr.itemHeight || attr.collectionItemHeight;
          var widthExpr = attr.itemWidth || attr.collectionItemWidth;
          var afterItemsContainer = initAfterItemsContainer();
          var changeValidator = makeChangeValidator();
          initDimensions();
          scrollCtrl.$element.on('scroll-resize', refreshDimensions);
          angular.element($window).on('resize', onResize);
          var unlistenToExposeAside = $rootScope.$on('$ionicExposeAside', ionic.animationFrameThrottle(function() {
            scrollCtrl.scrollView.resize();
            onResize();
          }));
          $timeout(refreshDimensions, 0, false);
          function onResize() {
            if (changeValidator.resizeRequiresRefresh(scrollView.__clientWidth, scrollView.__clientHeight)) {
              refreshDimensions();
            }
          }
          scope.$watchCollection(listGetter, function(newValue) {
            data = newValue || (newValue = []);
            if (!angular.isArray(newValue)) {
              throw new Error("collection-repeat expected an array for '" + listExpr + "', " + "but got a " + typeof value);
            }
            scope.$$postDigest(function() {
              getRepeatManager().setData(data);
              if (changeValidator.dataChangeRequiresRefresh(data))
                refreshDimensions();
            });
          });
          scope.$on('$destroy', function() {
            angular.element($window).off('resize', onResize);
            unlistenToExposeAside();
            scrollCtrl.$element && scrollCtrl.$element.off('scroll-resize', refreshDimensions);
            computedStyleNode && computedStyleNode.parentNode && computedStyleNode.parentNode.removeChild(computedStyleNode);
            computedStyleScope && computedStyleScope.$destroy();
            computedStyleScope = computedStyleNode = null;
            repeatManager && repeatManager.destroy();
            repeatManager = null;
          });
          function makeChangeValidator() {
            var self;
            return (self = {
              dataLength: 0,
              width: 0,
              height: 0,
              resizeRequiresRefresh: function(newWidth, newHeight) {
                var requiresRefresh = self.dataLength && newWidth && newHeight && (newWidth !== self.width || newHeight !== self.height);
                self.width = newWidth;
                self.height = newHeight;
                return !!requiresRefresh;
              },
              dataChangeRequiresRefresh: function(newData) {
                var requiresRefresh = newData.length > 0 || newData.length < self.dataLength;
                self.dataLength = newData.length;
                return !!requiresRefresh;
              }
            });
          }
          function getRepeatManager() {
            return repeatManager || (repeatManager = new $ionicCollectionManager({
              afterItemsNode: afterItemsContainer[0],
              containerNode: containerNode,
              heightData: heightData,
              widthData: widthData,
              forceRefreshImages: !!(isDefined(attr.forceRefreshImages) && attr.forceRefreshImages !== 'false'),
              keyExpression: keyExpr,
              renderBuffer: renderBuffer,
              scope: scope,
              scrollView: scrollCtrl.scrollView,
              transclude: transclude
            }));
          }
          function initAfterItemsContainer() {
            var container = angular.element(scrollView.__content.querySelector('.collection-repeat-after-container'));
            if (!container.length) {
              var elementIsAfterRepeater = false;
              var afterNodes = [].filter.call(scrollView.__content.childNodes, function(node) {
                if (ionic.DomUtil.contains(node, containerNode)) {
                  elementIsAfterRepeater = true;
                  return false;
                }
                return elementIsAfterRepeater;
              });
              container = angular.element('<span class="collection-repeat-after-container">');
              if (scrollView.options.scrollingX) {
                container.addClass('horizontal');
              }
              container.append(afterNodes);
              scrollView.__content.appendChild(container[0]);
            }
            return container;
          }
          function initDimensions() {
            if (heightExpr) {
              parseDimensionAttr(heightExpr, heightData);
            } else {
              heightData.computed = true;
            }
            if (widthExpr) {
              parseDimensionAttr(widthExpr, widthData);
            } else {
              widthData.computed = true;
            }
          }
          function refreshDimensions() {
            var hasData = data.length > 0;
            if (hasData && (heightData.computed || widthData.computed)) {
              computeStyleDimensions();
            }
            if (hasData && heightData.computed) {
              heightData.value = computedStyleDimensions.height;
              if (!heightData.value) {
                throw new Error('collection-repeat tried to compute the height of repeated elements "' + repeatExpr + '", but was unable to. Please provide the "item-height" attribute. ' + 'http://ionicframework.com/docs/api/directive/collectionRepeat/');
              }
            } else if (!heightData.dynamic && heightData.getValue) {
              heightData.value = heightData.getValue();
            }
            if (hasData && widthData.computed) {
              widthData.value = computedStyleDimensions.width;
              if (!widthData.value) {
                throw new Error('collection-repeat tried to compute the width of repeated elements "' + repeatExpr + '", but was unable to. Please provide the "item-width" attribute. ' + 'http://ionicframework.com/docs/api/directive/collectionRepeat/');
              }
            } else if (!widthData.dynamic && widthData.getValue) {
              widthData.value = widthData.getValue();
            }
            getRepeatManager().refreshLayout();
          }
          function parseDimensionAttr(attrValue, dimensionData) {
            if (!attrValue)
              return;
            var parsedValue;
            try {
              parsedValue = $parse(attrValue);
            } catch (e) {
              if (attrValue.trim().match(/\d+(px|%)$/)) {
                attrValue = '"' + attrValue + '"';
              }
              parsedValue = $parse(attrValue);
            }
            var constantAttrValue = attrValue.replace(/(\'|\"|px|%)/g, '').trim();
            var isConstant = constantAttrValue.length && !/([a-zA-Z]|\$|:|\?)/.test(constantAttrValue);
            dimensionData.attrValue = attrValue;
            if (isConstant) {
              if (attrValue.indexOf('%') > -1) {
                var decimalValue = parseFloat(parsedValue()) / 100;
                dimensionData.getValue = dimensionData === heightData ? function() {
                  return Math.floor(decimalValue * scrollView.__clientHeight);
                } : function() {
                  return Math.floor(decimalValue * scrollView.__clientWidth);
                };
              } else {
                dimensionData.value = parseInt(parsedValue());
              }
            } else {
              dimensionData.dynamic = true;
              dimensionData.getValue = dimensionData === heightData ? function heightGetter(scope, locals) {
                var result = parsedValue(scope, locals);
                if (result.charAt && result.charAt(result.length - 1) === '%') {
                  return Math.floor(parseFloat(result) / 100 * scrollView.__clientHeight);
                }
                return parseInt(result);
              } : function widthGetter(scope, locals) {
                var result = parsedValue(scope, locals);
                if (result.charAt && result.charAt(result.length - 1) === '%') {
                  return Math.floor(parseFloat(result) / 100 * scrollView.__clientWidth);
                }
                return parseInt(result);
              };
            }
          }
          var computedStyleNode;
          var computedStyleScope;
          function computeStyleDimensions() {
            if (!computedStyleNode) {
              transclude(computedStyleScope = scope.$new(), function(clone) {
                clone[0].removeAttribute('collection-repeat');
                computedStyleNode = clone[0];
              });
            }
            computedStyleScope[keyExpr] = (listGetter(scope) || [])[0];
            if (!$rootScope.$$phase)
              computedStyleScope.$digest();
            containerNode.appendChild(computedStyleNode);
            var style = $window.getComputedStyle(computedStyleNode);
            computedStyleDimensions.width = parseInt(style.width);
            computedStyleDimensions.height = parseInt(style.height);
            containerNode.removeChild(computedStyleNode);
          }
        }
      }
      RepeatManagerFactory.$inject = ['$rootScope', '$window', '$$rAF'];
      function RepeatManagerFactory($rootScope, $window, $$rAF) {
        var EMPTY_DIMENSION = {
          primaryPos: 0,
          secondaryPos: 0,
          primarySize: 0,
          secondarySize: 0,
          rowPrimarySize: 0
        };
        return function RepeatController(options) {
          var afterItemsNode = options.afterItemsNode;
          var containerNode = options.containerNode;
          var forceRefreshImages = options.forceRefreshImages;
          var heightData = options.heightData;
          var widthData = options.widthData;
          var keyExpression = options.keyExpression;
          var renderBuffer = options.renderBuffer;
          var scope = options.scope;
          var scrollView = options.scrollView;
          var transclude = options.transclude;
          var data = [];
          var getterLocals = {};
          var heightFn = heightData.getValue || function() {
            return heightData.value;
          };
          var heightGetter = function(index, value) {
            getterLocals[keyExpression] = value;
            getterLocals.$index = index;
            return heightFn(scope, getterLocals);
          };
          var widthFn = widthData.getValue || function() {
            return widthData.value;
          };
          var widthGetter = function(index, value) {
            getterLocals[keyExpression] = value;
            getterLocals.$index = index;
            return widthFn(scope, getterLocals);
          };
          var isVertical = !!scrollView.options.scrollingY;
          var isGridView = isVertical ? (widthData.dynamic || widthData.value !== scrollView.__clientWidth) : (heightData.dynamic || heightData.value !== scrollView.__clientHeight);
          var isStaticView = !heightData.dynamic && !widthData.dynamic;
          var PRIMARY = 'PRIMARY';
          var SECONDARY = 'SECONDARY';
          var TRANSLATE_TEMPLATE_STR = isVertical ? 'translate3d(SECONDARYpx,PRIMARYpx,0)' : 'translate3d(PRIMARYpx,SECONDARYpx,0)';
          var WIDTH_HEIGHT_TEMPLATE_STR = isVertical ? 'height: PRIMARYpx; width: SECONDARYpx;' : 'height: SECONDARYpx; width: PRIMARYpx;';
          var estimatedHeight;
          var estimatedWidth;
          var repeaterBeforeSize = 0;
          var repeaterAfterSize = 0;
          var renderStartIndex = -1;
          var renderEndIndex = -1;
          var renderAfterBoundary = -1;
          var renderBeforeBoundary = -1;
          var itemsPool = [];
          var itemsLeaving = [];
          var itemsEntering = [];
          var itemsShownMap = {};
          var nextItemId = 0;
          var scrollViewSetDimensions = isVertical ? function() {
            scrollView.setDimensions(null, null, null, view.getContentSize(), true);
          } : function() {
            scrollView.setDimensions(null, null, view.getContentSize(), null, true);
          };
          var view = isVertical ? new VerticalViewType() : new HorizontalViewType();
          (isGridView ? GridViewType : ListViewType).call(view);
          (isStaticView ? StaticViewType : DynamicViewType).call(view);
          var contentSizeStr = isVertical ? 'getContentHeight' : 'getContentWidth';
          var originalGetContentSize = scrollView.options[contentSizeStr];
          scrollView.options[contentSizeStr] = angular.bind(view, view.getContentSize);
          scrollView.__$callback = scrollView.__callback;
          scrollView.__callback = function(transformLeft, transformTop, zoom, wasResize) {
            var scrollValue = view.getScrollValue();
            if (renderStartIndex === -1 || scrollValue + view.scrollPrimarySize > renderAfterBoundary || scrollValue < renderBeforeBoundary) {
              render();
            }
            scrollView.__$callback(transformLeft, transformTop, zoom, wasResize);
          };
          var isLayoutReady = false;
          var isDataReady = false;
          this.refreshLayout = function() {
            if (data.length) {
              estimatedHeight = heightGetter(0, data[0]);
              estimatedWidth = widthGetter(0, data[0]);
            } else {
              estimatedHeight = 100;
              estimatedWidth = 100;
            }
            var style = getComputedStyle(afterItemsNode) || {};
            var firstStyle = afterItemsNode.firstElementChild && getComputedStyle(afterItemsNode.firstElementChild) || {};
            var lastStyle = afterItemsNode.lastElementChild && getComputedStyle(afterItemsNode.lastElementChild) || {};
            repeaterAfterSize = (parseInt(style[isVertical ? 'height' : 'width']) || 0) + (firstStyle && parseInt(firstStyle[isVertical ? 'marginTop' : 'marginLeft']) || 0) + (lastStyle && parseInt(lastStyle[isVertical ? 'marginBottom' : 'marginRight']) || 0);
            repeaterBeforeSize = 0;
            var current = containerNode;
            do {
              repeaterBeforeSize += current[isVertical ? 'offsetTop' : 'offsetLeft'];
            } while (ionic.DomUtil.contains(scrollView.__content, current = current.offsetParent));
            var containerPrevNode = containerNode.previousElementSibling;
            var beforeStyle = containerPrevNode ? $window.getComputedStyle(containerPrevNode) : {};
            var beforeMargin = parseInt(beforeStyle[isVertical ? 'marginBottom' : 'marginRight'] || 0);
            containerNode.style[ionic.CSS.TRANSFORM] = TRANSLATE_TEMPLATE_STR.replace(PRIMARY, -beforeMargin).replace(SECONDARY, 0);
            repeaterBeforeSize -= beforeMargin;
            if (!scrollView.__clientHeight || !scrollView.__clientWidth) {
              scrollView.__clientWidth = scrollView.__container.clientWidth;
              scrollView.__clientHeight = scrollView.__container.clientHeight;
            }
            (view.onRefreshLayout || angular.noop)();
            view.refreshDirection();
            scrollViewSetDimensions();
            if (!isLayoutReady) {
              var poolSize = Math.max(20, renderBuffer * 3);
              for (var i = 0; i < poolSize; i++) {
                itemsPool.push(new RepeatItem());
              }
            }
            isLayoutReady = true;
            if (isLayoutReady && isDataReady) {
              if (scrollView.__scrollLeft > scrollView.__maxScrollLeft || scrollView.__scrollTop > scrollView.__maxScrollTop) {
                scrollView.resize();
              }
              forceRerender(true);
            }
          };
          this.setData = function(newData) {
            data = newData;
            (view.onRefreshData || angular.noop)();
            isDataReady = true;
          };
          this.destroy = function() {
            render.destroyed = true;
            itemsPool.forEach(function(item) {
              item.scope.$destroy();
              item.scope = item.element = item.node = item.images = null;
            });
            itemsPool.length = itemsEntering.length = itemsLeaving.length = 0;
            itemsShownMap = {};
            scrollView.options[contentSizeStr] = originalGetContentSize;
            scrollView.__callback = scrollView.__$callback;
            scrollView.resize();
            (view.onDestroy || angular.noop)();
          };
          function forceRerender() {
            return render(true);
          }
          function render(forceRerender) {
            if (render.destroyed)
              return;
            var i;
            var ii;
            var item;
            var dim;
            var scope;
            var scrollValue = view.getScrollValue();
            var scrollValueEnd = scrollValue + view.scrollPrimarySize;
            view.updateRenderRange(scrollValue, scrollValueEnd);
            renderStartIndex = Math.max(0, renderStartIndex - renderBuffer);
            renderEndIndex = Math.min(data.length - 1, renderEndIndex + renderBuffer);
            for (i in itemsShownMap) {
              if (i < renderStartIndex || i > renderEndIndex) {
                item = itemsShownMap[i];
                delete itemsShownMap[i];
                itemsLeaving.push(item);
                item.isShown = false;
              }
            }
            for (i = renderStartIndex; i <= renderEndIndex; i++) {
              if (i >= data.length || (itemsShownMap[i] && !forceRerender))
                continue;
              item = itemsShownMap[i] || (itemsShownMap[i] = itemsLeaving.length ? itemsLeaving.pop() : itemsPool.length ? itemsPool.shift() : new RepeatItem());
              itemsEntering.push(item);
              item.isShown = true;
              scope = item.scope;
              scope.$index = i;
              scope[keyExpression] = data[i];
              scope.$first = (i === 0);
              scope.$last = (i === (data.length - 1));
              scope.$middle = !(scope.$first || scope.$last);
              scope.$odd = !(scope.$even = (i & 1) === 0);
              if (scope.$$disconnected)
                ionic.Utils.reconnectScope(item.scope);
              dim = view.getDimensions(i);
              if (item.secondaryPos !== dim.secondaryPos || item.primaryPos !== dim.primaryPos) {
                item.node.style[ionic.CSS.TRANSFORM] = TRANSLATE_TEMPLATE_STR.replace(PRIMARY, (item.primaryPos = dim.primaryPos)).replace(SECONDARY, (item.secondaryPos = dim.secondaryPos));
              }
              if (item.secondarySize !== dim.secondarySize || item.primarySize !== dim.primarySize) {
                item.node.style.cssText = item.node.style.cssText.replace(WIDTH_HEIGHT_REGEX, WIDTH_HEIGHT_TEMPLATE_STR.replace(PRIMARY, (item.primarySize = dim.primarySize) + 1).replace(SECONDARY, (item.secondarySize = dim.secondarySize)));
              }
            }
            if (renderEndIndex === data.length - 1) {
              dim = view.getDimensions(data.length - 1) || EMPTY_DIMENSION;
              afterItemsNode.style[ionic.CSS.TRANSFORM] = TRANSLATE_TEMPLATE_STR.replace(PRIMARY, dim.primaryPos + dim.primarySize).replace(SECONDARY, 0);
            }
            while (itemsLeaving.length) {
              item = itemsLeaving.pop();
              item.scope.$broadcast('$collectionRepeatLeave');
              ionic.Utils.disconnectScope(item.scope);
              itemsPool.push(item);
              item.node.style[ionic.CSS.TRANSFORM] = 'translate3d(-9999px,-9999px,0)';
              item.primaryPos = item.secondaryPos = null;
            }
            if (forceRefreshImages) {
              for (i = 0, ii = itemsEntering.length; i < ii && (item = itemsEntering[i]); i++) {
                if (!item.images)
                  continue;
                for (var j = 0,
                    jj = item.images.length,
                    img; j < jj && (img = item.images[j]); j++) {
                  var src = img.src;
                  img.src = ONE_PX_TRANSPARENT_IMG_SRC;
                  img.src = src;
                }
              }
            }
            if (forceRerender) {
              var rootScopePhase = $rootScope.$$phase;
              while (itemsEntering.length) {
                item = itemsEntering.pop();
                if (!rootScopePhase)
                  item.scope.$digest();
              }
            } else {
              digestEnteringItems();
            }
          }
          function digestEnteringItems() {
            var item;
            if (digestEnteringItems.running)
              return;
            digestEnteringItems.running = true;
            $$rAF(function process() {
              var rootScopePhase = $rootScope.$$phase;
              while (itemsEntering.length) {
                item = itemsEntering.pop();
                if (item.isShown) {
                  if (!rootScopePhase)
                    item.scope.$digest();
                }
              }
              digestEnteringItems.running = false;
            });
          }
          function RepeatItem() {
            var self = this;
            this.scope = scope.$new();
            this.id = 'item' + (nextItemId++);
            transclude(this.scope, function(clone) {
              self.element = clone;
              self.element.data('$$collectionRepeatItem', self);
              self.node = clone[0];
              self.node.style[ionic.CSS.TRANSFORM] = 'translate3d(-9999px,-9999px,0)';
              self.node.style.cssText += ' height: 0px; width: 0px;';
              ionic.Utils.disconnectScope(self.scope);
              containerNode.appendChild(self.node);
              self.images = clone[0].getElementsByTagName('img');
            });
          }
          function VerticalViewType() {
            this.getItemPrimarySize = heightGetter;
            this.getItemSecondarySize = widthGetter;
            this.getScrollValue = function() {
              return Math.max(0, Math.min(scrollView.__scrollTop - repeaterBeforeSize, scrollView.__maxScrollTop - repeaterBeforeSize - repeaterAfterSize));
            };
            this.refreshDirection = function() {
              this.scrollPrimarySize = scrollView.__clientHeight;
              this.scrollSecondarySize = scrollView.__clientWidth;
              this.estimatedPrimarySize = estimatedHeight;
              this.estimatedSecondarySize = estimatedWidth;
              this.estimatedItemsAcross = isGridView && Math.floor(scrollView.__clientWidth / estimatedWidth) || 1;
            };
          }
          function HorizontalViewType() {
            this.getItemPrimarySize = widthGetter;
            this.getItemSecondarySize = heightGetter;
            this.getScrollValue = function() {
              return Math.max(0, Math.min(scrollView.__scrollLeft - repeaterBeforeSize, scrollView.__maxScrollLeft - repeaterBeforeSize - repeaterAfterSize));
            };
            this.refreshDirection = function() {
              this.scrollPrimarySize = scrollView.__clientWidth;
              this.scrollSecondarySize = scrollView.__clientHeight;
              this.estimatedPrimarySize = estimatedWidth;
              this.estimatedSecondarySize = estimatedHeight;
              this.estimatedItemsAcross = isGridView && Math.floor(scrollView.__clientHeight / estimatedHeight) || 1;
            };
          }
          function GridViewType() {
            this.getEstimatedSecondaryPos = function(index) {
              return (index % this.estimatedItemsAcross) * this.estimatedSecondarySize;
            };
            this.getEstimatedPrimaryPos = function(index) {
              return Math.floor(index / this.estimatedItemsAcross) * this.estimatedPrimarySize;
            };
            this.getEstimatedIndex = function(scrollValue) {
              return Math.floor(scrollValue / this.estimatedPrimarySize) * this.estimatedItemsAcross;
            };
          }
          function ListViewType() {
            this.getEstimatedSecondaryPos = function() {
              return 0;
            };
            this.getEstimatedPrimaryPos = function(index) {
              return index * this.estimatedPrimarySize;
            };
            this.getEstimatedIndex = function(scrollValue) {
              return Math.floor((scrollValue) / this.estimatedPrimarySize);
            };
          }
          function StaticViewType() {
            this.getContentSize = function() {
              return this.getEstimatedPrimaryPos(data.length - 1) + this.estimatedPrimarySize + repeaterBeforeSize + repeaterAfterSize;
            };
            var dim = {};
            this.getDimensions = function(index) {
              dim.primaryPos = this.getEstimatedPrimaryPos(index);
              dim.secondaryPos = this.getEstimatedSecondaryPos(index);
              dim.primarySize = this.estimatedPrimarySize;
              dim.secondarySize = this.estimatedSecondarySize;
              return dim;
            };
            this.updateRenderRange = function(scrollValue, scrollValueEnd) {
              renderStartIndex = Math.max(0, this.getEstimatedIndex(scrollValue));
              renderEndIndex = Math.min(data.length - 1, this.getEstimatedIndex(scrollValueEnd) + this.estimatedItemsAcross - 1);
              renderBeforeBoundary = Math.max(0, this.getEstimatedPrimaryPos(renderStartIndex));
              renderAfterBoundary = this.getEstimatedPrimaryPos(renderEndIndex) + this.estimatedPrimarySize;
            };
          }
          function DynamicViewType() {
            var self = this;
            var debouncedScrollViewSetDimensions = ionic.debounce(scrollViewSetDimensions, 25, true);
            var calculateDimensions = isGridView ? calculateDimensionsGrid : calculateDimensionsList;
            var dimensionsIndex;
            var dimensions = [];
            function calculateDimensionsList(toIndex) {
              var i,
                  prevDimension,
                  dim;
              for (i = Math.max(0, dimensionsIndex); i <= toIndex && (dim = dimensions[i]); i++) {
                prevDimension = dimensions[i - 1] || EMPTY_DIMENSION;
                dim.primarySize = self.getItemPrimarySize(i, data[i]);
                dim.secondarySize = self.scrollSecondarySize;
                dim.primaryPos = prevDimension.primaryPos + prevDimension.primarySize;
                dim.secondaryPos = 0;
              }
            }
            function calculateDimensionsGrid(toIndex) {
              var i,
                  prevDimension,
                  dim;
              for (i = Math.max(dimensionsIndex, 0); i <= toIndex && (dim = dimensions[i]); i++) {
                prevDimension = dimensions[i - 1] || EMPTY_DIMENSION;
                dim.secondarySize = Math.min(self.getItemSecondarySize(i, data[i]), self.scrollSecondarySize);
                dim.secondaryPos = prevDimension.secondaryPos + prevDimension.secondarySize;
                if (i === 0 || dim.secondaryPos + dim.secondarySize > self.scrollSecondarySize) {
                  dim.secondaryPos = 0;
                  dim.primarySize = self.getItemPrimarySize(i, data[i]);
                  dim.primaryPos = prevDimension.primaryPos + prevDimension.rowPrimarySize;
                  dim.rowStartIndex = i;
                  dim.rowPrimarySize = dim.primarySize;
                } else {
                  dim.primarySize = self.getItemPrimarySize(i, data[i]);
                  dim.primaryPos = prevDimension.primaryPos;
                  dim.rowStartIndex = prevDimension.rowStartIndex;
                  dimensions[dim.rowStartIndex].rowPrimarySize = dim.rowPrimarySize = Math.max(dimensions[dim.rowStartIndex].rowPrimarySize, dim.primarySize);
                  dim.rowPrimarySize = Math.max(dim.primarySize, dim.rowPrimarySize);
                }
              }
            }
            this.getContentSize = function() {
              var dim = dimensions[dimensionsIndex] || EMPTY_DIMENSION;
              return ((dim.primaryPos + dim.primarySize) || 0) + this.getEstimatedPrimaryPos(data.length - dimensionsIndex - 1) + repeaterBeforeSize + repeaterAfterSize;
            };
            this.onDestroy = function() {
              dimensions.length = 0;
            };
            this.onRefreshData = function() {
              var i;
              var ii;
              for (i = dimensions.length, ii = data.length; i < ii; i++) {
                dimensions.push({});
              }
              dimensionsIndex = -1;
            };
            this.onRefreshLayout = function() {
              dimensionsIndex = -1;
            };
            this.getDimensions = function(index) {
              index = Math.min(index, data.length - 1);
              if (dimensionsIndex < index) {
                if (index > data.length * 0.9) {
                  calculateDimensions(data.length - 1);
                  dimensionsIndex = data.length - 1;
                  scrollViewSetDimensions();
                } else {
                  calculateDimensions(index);
                  dimensionsIndex = index;
                  debouncedScrollViewSetDimensions();
                }
              }
              return dimensions[index];
            };
            var oldRenderStartIndex = -1;
            var oldScrollValue = -1;
            this.updateRenderRange = function(scrollValue, scrollValueEnd) {
              var i;
              var len;
              var dim;
              this.getDimensions(this.getEstimatedIndex(scrollValueEnd) * 2);
              if (oldRenderStartIndex === -1 || scrollValue === 0) {
                i = 0;
              } else if (scrollValue >= oldScrollValue) {
                for (i = oldRenderStartIndex, len = data.length; i < len; i++) {
                  if ((dim = this.getDimensions(i)) && dim.primaryPos + dim.rowPrimarySize >= scrollValue) {
                    break;
                  }
                }
              } else {
                for (i = oldRenderStartIndex; i >= 0; i--) {
                  if ((dim = this.getDimensions(i)) && dim.primaryPos <= scrollValue) {
                    i = isGridView ? dim.rowStartIndex : i;
                    break;
                  }
                }
              }
              renderStartIndex = Math.min(Math.max(0, i), data.length - 1);
              renderBeforeBoundary = renderStartIndex !== -1 ? this.getDimensions(renderStartIndex).primaryPos : -1;
              var lastRowDim;
              for (i = renderStartIndex + 1, len = data.length; i < len; i++) {
                if ((dim = this.getDimensions(i)) && dim.primaryPos + dim.rowPrimarySize > scrollValueEnd) {
                  if (isGridView) {
                    lastRowDim = dim;
                    while (i < len - 1 && (dim = this.getDimensions(i + 1)).primaryPos === lastRowDim.primaryPos) {
                      i++;
                    }
                  }
                  break;
                }
              }
              renderEndIndex = Math.min(i, data.length - 1);
              renderAfterBoundary = renderEndIndex !== -1 ? ((dim = this.getDimensions(renderEndIndex)).primaryPos + (dim.rowPrimarySize || dim.primarySize)) : -1;
              oldScrollValue = scrollValue;
              oldRenderStartIndex = renderStartIndex;
            };
          }
        };
      }
      IonicModule.directive('ionContent', ['$timeout', '$controller', '$ionicBind', '$ionicConfig', function($timeout, $controller, $ionicBind, $ionicConfig) {
        return {
          restrict: 'E',
          require: '^?ionNavView',
          scope: true,
          priority: 800,
          compile: function(element, attr) {
            var innerElement;
            var scrollCtrl;
            element.addClass('scroll-content ionic-scroll');
            if (attr.scroll != 'false') {
              innerElement = jqLite('<div class="scroll"></div>');
              innerElement.append(element.contents());
              element.append(innerElement);
            } else {
              element.addClass('scroll-content-false');
            }
            var nativeScrolling = attr.overflowScroll !== "false" && (attr.overflowScroll === "true" || !$ionicConfig.scrolling.jsScrolling());
            if (nativeScrolling) {
              nativeScrolling = !element[0].querySelector('[collection-repeat]');
            }
            return {pre: prelink};
            function prelink($scope, $element, $attr) {
              var parentScope = $scope.$parent;
              $scope.$watch(function() {
                return (parentScope.$hasHeader ? ' has-header' : '') + (parentScope.$hasSubheader ? ' has-subheader' : '') + (parentScope.$hasFooter ? ' has-footer' : '') + (parentScope.$hasSubfooter ? ' has-subfooter' : '') + (parentScope.$hasTabs ? ' has-tabs' : '') + (parentScope.$hasTabsTop ? ' has-tabs-top' : '');
              }, function(className, oldClassName) {
                $element.removeClass(oldClassName);
                $element.addClass(className);
              });
              $scope.$hasHeader = $scope.$hasSubheader = $scope.$hasFooter = $scope.$hasSubfooter = $scope.$hasTabs = $scope.$hasTabsTop = false;
              $ionicBind($scope, $attr, {
                $onScroll: '&onScroll',
                $onScrollComplete: '&onScrollComplete',
                hasBouncing: '@',
                padding: '@',
                direction: '@',
                scrollbarX: '@',
                scrollbarY: '@',
                startX: '@',
                startY: '@',
                scrollEventInterval: '@'
              });
              $scope.direction = $scope.direction || 'y';
              if (isDefined($attr.padding)) {
                $scope.$watch($attr.padding, function(newVal) {
                  (innerElement || $element).toggleClass('padding', !!newVal);
                });
              }
              if ($attr.scroll === "false") {} else {
                var scrollViewOptions = {};
                if (nativeScrolling) {
                  $element.addClass('overflow-scroll');
                  scrollViewOptions = {
                    el: $element[0],
                    delegateHandle: attr.delegateHandle,
                    startX: $scope.$eval($scope.startX) || 0,
                    startY: $scope.$eval($scope.startY) || 0,
                    nativeScrolling: true
                  };
                } else {
                  scrollViewOptions = {
                    el: $element[0],
                    delegateHandle: attr.delegateHandle,
                    locking: (attr.locking || 'true') === 'true',
                    bouncing: $scope.$eval($scope.hasBouncing),
                    startX: $scope.$eval($scope.startX) || 0,
                    startY: $scope.$eval($scope.startY) || 0,
                    scrollbarX: $scope.$eval($scope.scrollbarX) !== false,
                    scrollbarY: $scope.$eval($scope.scrollbarY) !== false,
                    scrollingX: $scope.direction.indexOf('x') >= 0,
                    scrollingY: $scope.direction.indexOf('y') >= 0,
                    scrollEventInterval: parseInt($scope.scrollEventInterval, 10) || 10,
                    scrollingComplete: onScrollComplete
                  };
                }
                scrollCtrl = $controller('$ionicScroll', {
                  $scope: $scope,
                  scrollViewOptions: scrollViewOptions
                });
                $scope.scrollCtrl = scrollCtrl;
                $scope.$on('$destroy', function() {
                  if (scrollViewOptions) {
                    scrollViewOptions.scrollingComplete = noop;
                    delete scrollViewOptions.el;
                  }
                  innerElement = null;
                  $element = null;
                  attr.$$element = null;
                });
              }
              function onScrollComplete() {
                $scope.$onScrollComplete({
                  scrollTop: scrollCtrl.scrollView.__scrollTop,
                  scrollLeft: scrollCtrl.scrollView.__scrollLeft
                });
              }
            }
          }
        };
      }]);
      IonicModule.directive('exposeAsideWhen', ['$window', function($window) {
        return {
          restrict: 'A',
          require: '^ionSideMenus',
          link: function($scope, $element, $attr, sideMenuCtrl) {
            var prevInnerWidth = $window.innerWidth;
            var prevInnerHeight = $window.innerHeight;
            ionic.on('resize', function() {
              if (prevInnerWidth === $window.innerWidth && prevInnerHeight === $window.innerHeight) {
                return;
              }
              prevInnerWidth = $window.innerWidth;
              prevInnerHeight = $window.innerHeight;
              onResize();
            }, $window);
            function checkAsideExpose() {
              var mq = $attr.exposeAsideWhen == 'large' ? '(min-width:768px)' : $attr.exposeAsideWhen;
              sideMenuCtrl.exposeAside($window.matchMedia(mq).matches);
              sideMenuCtrl.activeAsideResizing(false);
            }
            function onResize() {
              sideMenuCtrl.activeAsideResizing(true);
              debouncedCheck();
            }
            var debouncedCheck = ionic.debounce(function() {
              $scope.$apply(checkAsideExpose);
            }, 300, false);
            $scope.$evalAsync(checkAsideExpose);
          }
        };
      }]);
      var GESTURE_DIRECTIVES = 'onHold onTap onDoubleTap onTouch onRelease onDragStart onDrag onDragEnd onDragUp onDragRight onDragDown onDragLeft onSwipe onSwipeUp onSwipeRight onSwipeDown onSwipeLeft'.split(' ');
      GESTURE_DIRECTIVES.forEach(function(name) {
        IonicModule.directive(name, gestureDirective(name));
      });
      function gestureDirective(directiveName) {
        return ['$ionicGesture', '$parse', function($ionicGesture, $parse) {
          var eventType = directiveName.substr(2).toLowerCase();
          return function(scope, element, attr) {
            var fn = $parse(attr[directiveName]);
            var listener = function(ev) {
              scope.$apply(function() {
                fn(scope, {$event: ev});
              });
            };
            var gesture = $ionicGesture.on(eventType, listener, element);
            scope.$on('$destroy', function() {
              $ionicGesture.off(gesture, eventType, listener);
            });
          };
        }];
      }
      IonicModule.directive('ionHeaderBar', headerFooterBarDirective(true)).directive('ionFooterBar', headerFooterBarDirective(false));
      function tapScrollToTopDirective() {
        return ['$ionicScrollDelegate', function($ionicScrollDelegate) {
          return {
            restrict: 'E',
            link: function($scope, $element, $attr) {
              if ($attr.noTapScroll == 'true') {
                return;
              }
              ionic.on('tap', onTap, $element[0]);
              $scope.$on('$destroy', function() {
                ionic.off('tap', onTap, $element[0]);
              });
              function onTap(e) {
                var depth = 3;
                var current = e.target;
                while (depth-- && current) {
                  if (current.classList.contains('button') || current.tagName.match(/input|textarea|select/i) || current.isContentEditable) {
                    return;
                  }
                  current = current.parentNode;
                }
                var touch = e.gesture && e.gesture.touches[0] || e.detail.touches[0];
                var bounds = $element[0].getBoundingClientRect();
                if (ionic.DomUtil.rectContains(touch.pageX, touch.pageY, bounds.left, bounds.top - 20, bounds.left + bounds.width, bounds.top + bounds.height)) {
                  $ionicScrollDelegate.scrollTop(true);
                }
              }
            }
          };
        }];
      }
      function headerFooterBarDirective(isHeader) {
        return ['$document', '$timeout', function($document, $timeout) {
          return {
            restrict: 'E',
            controller: '$ionicHeaderBar',
            compile: function(tElement) {
              tElement.addClass(isHeader ? 'bar bar-header' : 'bar bar-footer');
              $timeout(function() {
                if (isHeader && $document[0].getElementsByClassName('tabs-top').length)
                  tElement.addClass('has-tabs-top');
              });
              return {pre: prelink};
              function prelink($scope, $element, $attr, ctrl) {
                if (isHeader) {
                  $scope.$watch(function() {
                    return $element[0].className;
                  }, function(value) {
                    var isShown = value.indexOf('ng-hide') === -1;
                    var isSubheader = value.indexOf('bar-subheader') !== -1;
                    $scope.$hasHeader = isShown && !isSubheader;
                    $scope.$hasSubheader = isShown && isSubheader;
                    $scope.$emit('$ionicSubheader', $scope.$hasSubheader);
                  });
                  $scope.$on('$destroy', function() {
                    delete $scope.$hasHeader;
                    delete $scope.$hasSubheader;
                  });
                  ctrl.align();
                  $scope.$on('$ionicHeader.align', function() {
                    ionic.requestAnimationFrame(function() {
                      ctrl.align();
                    });
                  });
                } else {
                  $scope.$watch(function() {
                    return $element[0].className;
                  }, function(value) {
                    var isShown = value.indexOf('ng-hide') === -1;
                    var isSubfooter = value.indexOf('bar-subfooter') !== -1;
                    $scope.$hasFooter = isShown && !isSubfooter;
                    $scope.$hasSubfooter = isShown && isSubfooter;
                  });
                  $scope.$on('$destroy', function() {
                    delete $scope.$hasFooter;
                    delete $scope.$hasSubfooter;
                  });
                  $scope.$watch('$hasTabs', function(val) {
                    $element.toggleClass('has-tabs', !!val);
                  });
                  ctrl.align();
                  $scope.$on('$ionicFooter.align', function() {
                    ionic.requestAnimationFrame(function() {
                      ctrl.align();
                    });
                  });
                }
              }
            }
          };
        }];
      }
      IonicModule.directive('ionInfiniteScroll', ['$timeout', function($timeout) {
        return {
          restrict: 'E',
          require: ['?^$ionicScroll', 'ionInfiniteScroll'],
          template: function($element, $attrs) {
            if ($attrs.icon)
              return '<i class="icon {{icon()}} icon-refreshing {{scrollingType}}"></i>';
            return '<ion-spinner icon="{{spinner()}}"></ion-spinner>';
          },
          scope: true,
          controller: '$ionInfiniteScroll',
          link: function($scope, $element, $attrs, ctrls) {
            var infiniteScrollCtrl = ctrls[1];
            var scrollCtrl = infiniteScrollCtrl.scrollCtrl = ctrls[0];
            var jsScrolling = infiniteScrollCtrl.jsScrolling = !scrollCtrl.isNative();
            if (jsScrolling) {
              infiniteScrollCtrl.scrollView = scrollCtrl.scrollView;
              $scope.scrollingType = 'js-scrolling';
              scrollCtrl.$element.on('scroll', infiniteScrollCtrl.checkBounds);
            } else {
              var scrollEl = ionic.DomUtil.getParentOrSelfWithClass($element[0].parentNode, 'overflow-scroll');
              infiniteScrollCtrl.scrollEl = scrollEl;
              if (!scrollEl) {
                throw 'Infinite scroll must be used inside a scrollable div';
              }
              infiniteScrollCtrl.scrollEl.addEventListener('scroll', infiniteScrollCtrl.checkBounds);
            }
            var doImmediateCheck = isDefined($attrs.immediateCheck) ? $scope.$eval($attrs.immediateCheck) : true;
            if (doImmediateCheck) {
              $timeout(function() {
                infiniteScrollCtrl.checkBounds();
              });
            }
          }
        };
      }]);
      var labelIds = -1;
      IonicModule.directive('ionInput', [function() {
        return {
          restrict: 'E',
          controller: ['$scope', '$element', function($scope, $element) {
            this.$scope = $scope;
            this.$element = $element;
            this.setInputAriaLabeledBy = function(id) {
              var inputs = $element[0].querySelectorAll('input,textarea');
              inputs.length && inputs[0].setAttribute('aria-labelledby', id);
            };
            this.focus = function() {
              var inputs = $element[0].querySelectorAll('input,textarea');
              inputs.length && inputs[0].focus();
            };
          }]
        };
      }]);
      IonicModule.directive('ionLabel', [function() {
        return {
          restrict: 'E',
          require: '?^ionInput',
          compile: function() {
            return function link($scope, $element, $attrs, ionInputCtrl) {
              var element = $element[0];
              $element.addClass('input-label');
              $element.attr('aria-label', $element.text());
              var id = element.id || '_label-' + ++labelIds;
              if (!element.id) {
                $element.attr('id', id);
              }
              if (ionInputCtrl) {
                ionInputCtrl.setInputAriaLabeledBy(id);
                $element.on('click', function() {
                  ionInputCtrl.focus();
                });
              }
            };
          }
        };
      }]);
      IonicModule.directive('inputLabel', [function() {
        return {
          restrict: 'C',
          require: '?^ionInput',
          compile: function() {
            return function link($scope, $element, $attrs, ionInputCtrl) {
              var element = $element[0];
              $element.attr('aria-label', $element.text());
              var id = element.id || '_label-' + ++labelIds;
              if (!element.id) {
                $element.attr('id', id);
              }
              if (ionInputCtrl) {
                ionInputCtrl.setInputAriaLabeledBy(id);
              }
            };
          }
        };
      }]);
      IonicModule.directive('ionItem', ['$$rAF', function($$rAF) {
        return {
          restrict: 'E',
          controller: ['$scope', '$element', function($scope, $element) {
            this.$scope = $scope;
            this.$element = $element;
          }],
          scope: true,
          compile: function($element, $attrs) {
            var isAnchor = isDefined($attrs.href) || isDefined($attrs.ngHref) || isDefined($attrs.uiSref);
            var isComplexItem = isAnchor || /ion-(delete|option|reorder)-button/i.test($element.html());
            if (isComplexItem) {
              var innerElement = jqLite(isAnchor ? '<a></a>' : '<div></div>');
              innerElement.addClass('item-content');
              if (isDefined($attrs.href) || isDefined($attrs.ngHref)) {
                innerElement.attr('ng-href', '{{$href()}}');
                if (isDefined($attrs.target)) {
                  innerElement.attr('target', '{{$target()}}');
                }
              }
              innerElement.append($element.contents());
              $element.addClass('item item-complex').append(innerElement);
            } else {
              $element.addClass('item');
            }
            return function link($scope, $element, $attrs) {
              $scope.$href = function() {
                return $attrs.href || $attrs.ngHref;
              };
              $scope.$target = function() {
                return $attrs.target;
              };
              var content = $element[0].querySelector('.item-content');
              if (content) {
                $scope.$on('$collectionRepeatLeave', function() {
                  if (content && content.$$ionicOptionsOpen) {
                    content.style[ionic.CSS.TRANSFORM] = '';
                    content.style[ionic.CSS.TRANSITION] = 'none';
                    $$rAF(function() {
                      content.style[ionic.CSS.TRANSITION] = '';
                    });
                    content.$$ionicOptionsOpen = false;
                  }
                });
              }
            };
          }
        };
      }]);
      var ITEM_TPL_DELETE_BUTTON = '<div class="item-left-edit item-delete enable-pointer-events">' + '</div>';
      IonicModule.directive('ionDeleteButton', function() {
        function stopPropagation(ev) {
          ev.stopPropagation();
        }
        return {
          restrict: 'E',
          require: ['^^ionItem', '^?ionList'],
          priority: Number.MAX_VALUE,
          compile: function($element, $attr) {
            $attr.$set('class', ($attr['class'] || '') + ' button icon button-icon', true);
            return function($scope, $element, $attr, ctrls) {
              var itemCtrl = ctrls[0];
              var listCtrl = ctrls[1];
              var container = jqLite(ITEM_TPL_DELETE_BUTTON);
              container.append($element);
              itemCtrl.$element.append(container).addClass('item-left-editable');
              $element.on('click', stopPropagation);
              init();
              $scope.$on('$ionic.reconnectScope', init);
              function init() {
                listCtrl = listCtrl || $element.controller('ionList');
                if (listCtrl && listCtrl.showDelete()) {
                  container.addClass('visible active');
                }
              }
            };
          }
        };
      });
      IonicModule.directive('itemFloatingLabel', function() {
        return {
          restrict: 'C',
          link: function(scope, element) {
            var el = element[0];
            var input = el.querySelector('input, textarea');
            var inputLabel = el.querySelector('.input-label');
            if (!input || !inputLabel)
              return;
            var onInput = function() {
              if (input.value) {
                inputLabel.classList.add('has-input');
              } else {
                inputLabel.classList.remove('has-input');
              }
            };
            input.addEventListener('input', onInput);
            var ngModelCtrl = jqLite(input).controller('ngModel');
            if (ngModelCtrl) {
              ngModelCtrl.$render = function() {
                input.value = ngModelCtrl.$viewValue || '';
                onInput();
              };
            }
            scope.$on('$destroy', function() {
              input.removeEventListener('input', onInput);
            });
          }
        };
      });
      var ITEM_TPL_OPTION_BUTTONS = '<div class="item-options invisible">' + '</div>';
      IonicModule.directive('ionOptionButton', [function() {
        function stopPropagation(e) {
          e.stopPropagation();
        }
        return {
          restrict: 'E',
          require: '^ionItem',
          priority: Number.MAX_VALUE,
          compile: function($element, $attr) {
            $attr.$set('class', ($attr['class'] || '') + ' button', true);
            return function($scope, $element, $attr, itemCtrl) {
              if (!itemCtrl.optionsContainer) {
                itemCtrl.optionsContainer = jqLite(ITEM_TPL_OPTION_BUTTONS);
                itemCtrl.$element.append(itemCtrl.optionsContainer);
              }
              itemCtrl.optionsContainer.append($element);
              itemCtrl.$element.addClass('item-right-editable');
              $element.on('click', stopPropagation);
            };
          }
        };
      }]);
      var ITEM_TPL_REORDER_BUTTON = '<div data-prevent-scroll="true" class="item-right-edit item-reorder enable-pointer-events">' + '</div>';
      IonicModule.directive('ionReorderButton', ['$parse', function($parse) {
        return {
          restrict: 'E',
          require: ['^ionItem', '^?ionList'],
          priority: Number.MAX_VALUE,
          compile: function($element, $attr) {
            $attr.$set('class', ($attr['class'] || '') + ' button icon button-icon', true);
            $element[0].setAttribute('data-prevent-scroll', true);
            return function($scope, $element, $attr, ctrls) {
              var itemCtrl = ctrls[0];
              var listCtrl = ctrls[1];
              var onReorderFn = $parse($attr.onReorder);
              $scope.$onReorder = function(oldIndex, newIndex) {
                onReorderFn($scope, {
                  $fromIndex: oldIndex,
                  $toIndex: newIndex
                });
              };
              if (!$attr.ngClick && !$attr.onClick && !$attr.onclick) {
                $element[0].onclick = function(e) {
                  e.stopPropagation();
                  return false;
                };
              }
              var container = jqLite(ITEM_TPL_REORDER_BUTTON);
              container.append($element);
              itemCtrl.$element.append(container).addClass('item-right-editable');
              if (listCtrl && listCtrl.showReorder()) {
                container.addClass('visible active');
              }
            };
          }
        };
      }]);
      IonicModule.directive('keyboardAttach', function() {
        return function(scope, element) {
          ionic.on('native.keyboardshow', onShow, window);
          ionic.on('native.keyboardhide', onHide, window);
          ionic.on('native.showkeyboard', onShow, window);
          ionic.on('native.hidekeyboard', onHide, window);
          var scrollCtrl;
          function onShow(e) {
            if (ionic.Platform.isAndroid() && !ionic.Platform.isFullScreen) {
              return;
            }
            var keyboardHeight = e.keyboardHeight || (e.detail && e.detail.keyboardHeight);
            element.css('bottom', keyboardHeight + "px");
            scrollCtrl = element.controller('$ionicScroll');
            if (scrollCtrl) {
              scrollCtrl.scrollView.__container.style.bottom = keyboardHeight + keyboardAttachGetClientHeight(element[0]) + "px";
            }
          }
          function onHide() {
            if (ionic.Platform.isAndroid() && !ionic.Platform.isFullScreen) {
              return;
            }
            element.css('bottom', '');
            if (scrollCtrl) {
              scrollCtrl.scrollView.__container.style.bottom = '';
            }
          }
          scope.$on('$destroy', function() {
            ionic.off('native.keyboardshow', onShow, window);
            ionic.off('native.keyboardhide', onHide, window);
            ionic.off('native.showkeyboard', onShow, window);
            ionic.off('native.hidekeyboard', onHide, window);
          });
        };
      });
      function keyboardAttachGetClientHeight(element) {
        return element.clientHeight;
      }
      IonicModule.directive('ionList', ['$timeout', function($timeout) {
        return {
          restrict: 'E',
          require: ['ionList', '^?$ionicScroll'],
          controller: '$ionicList',
          compile: function($element, $attr) {
            var listEl = jqLite('<div class="list">').append($element.contents()).addClass($attr.type);
            $element.append(listEl);
            return function($scope, $element, $attrs, ctrls) {
              var listCtrl = ctrls[0];
              var scrollCtrl = ctrls[1];
              $timeout(init);
              function init() {
                var listView = listCtrl.listView = new ionic.views.ListView({
                  el: $element[0],
                  listEl: $element.children()[0],
                  scrollEl: scrollCtrl && scrollCtrl.element,
                  scrollView: scrollCtrl && scrollCtrl.scrollView,
                  onReorder: function(el, oldIndex, newIndex) {
                    var itemScope = jqLite(el).scope();
                    if (itemScope && itemScope.$onReorder) {
                      $timeout(function() {
                        itemScope.$onReorder(oldIndex, newIndex);
                      });
                    }
                  },
                  canSwipe: function() {
                    return listCtrl.canSwipeItems();
                  }
                });
                $scope.$on('$destroy', function() {
                  if (listView) {
                    listView.deregister && listView.deregister();
                    listView = null;
                  }
                });
                if (isDefined($attr.canSwipe)) {
                  $scope.$watch('!!(' + $attr.canSwipe + ')', function(value) {
                    listCtrl.canSwipeItems(value);
                  });
                }
                if (isDefined($attr.showDelete)) {
                  $scope.$watch('!!(' + $attr.showDelete + ')', function(value) {
                    listCtrl.showDelete(value);
                  });
                }
                if (isDefined($attr.showReorder)) {
                  $scope.$watch('!!(' + $attr.showReorder + ')', function(value) {
                    listCtrl.showReorder(value);
                  });
                }
                $scope.$watch(function() {
                  return listCtrl.showDelete();
                }, function(isShown, wasShown) {
                  if (!isShown && !wasShown) {
                    return;
                  }
                  if (isShown)
                    listCtrl.closeOptionButtons();
                  listCtrl.canSwipeItems(!isShown);
                  $element.children().toggleClass('list-left-editing', isShown);
                  $element.toggleClass('disable-pointer-events', isShown);
                  var deleteButton = jqLite($element[0].getElementsByClassName('item-delete'));
                  setButtonShown(deleteButton, listCtrl.showDelete);
                });
                $scope.$watch(function() {
                  return listCtrl.showReorder();
                }, function(isShown, wasShown) {
                  if (!isShown && !wasShown) {
                    return;
                  }
                  if (isShown)
                    listCtrl.closeOptionButtons();
                  listCtrl.canSwipeItems(!isShown);
                  $element.children().toggleClass('list-right-editing', isShown);
                  $element.toggleClass('disable-pointer-events', isShown);
                  var reorderButton = jqLite($element[0].getElementsByClassName('item-reorder'));
                  setButtonShown(reorderButton, listCtrl.showReorder);
                });
                function setButtonShown(el, shown) {
                  shown() && el.addClass('visible') || el.removeClass('active');
                  ionic.requestAnimationFrame(function() {
                    shown() && el.addClass('active') || el.removeClass('visible');
                  });
                }
              }
            };
          }
        };
      }]);
      IonicModule.directive('menuClose', ['$ionicHistory', '$timeout', function($ionicHistory, $timeout) {
        return {
          restrict: 'AC',
          link: function($scope, $element) {
            $element.bind('click', function() {
              var sideMenuCtrl = $element.inheritedData('$ionSideMenusController');
              if (sideMenuCtrl) {
                $ionicHistory.nextViewOptions({
                  historyRoot: true,
                  disableAnimate: true,
                  expire: 300
                });
                $timeout(function() {
                  $ionicHistory.nextViewOptions({
                    historyRoot: false,
                    disableAnimate: false
                  });
                }, 300);
                sideMenuCtrl.close();
              }
            });
          }
        };
      }]);
      IonicModule.directive('menuToggle', function() {
        return {
          restrict: 'AC',
          link: function($scope, $element, $attr) {
            $scope.$on('$ionicView.beforeEnter', function(ev, viewData) {
              if (viewData.enableBack) {
                var sideMenuCtrl = $element.inheritedData('$ionSideMenusController');
                if (!sideMenuCtrl.enableMenuWithBackViews()) {
                  $element.addClass('hide');
                }
              } else {
                $element.removeClass('hide');
              }
            });
            $element.bind('click', function() {
              var sideMenuCtrl = $element.inheritedData('$ionSideMenusController');
              sideMenuCtrl && sideMenuCtrl.toggle($attr.menuToggle);
            });
          }
        };
      });
      IonicModule.directive('ionModal', [function() {
        return {
          restrict: 'E',
          transclude: true,
          replace: true,
          controller: [function() {}],
          template: '<div class="modal-backdrop">' + '<div class="modal-backdrop-bg"></div>' + '<div class="modal-wrapper" ng-transclude></div>' + '</div>'
        };
      }]);
      IonicModule.directive('ionModalView', function() {
        return {
          restrict: 'E',
          compile: function(element) {
            element.addClass('modal');
          }
        };
      });
      IonicModule.directive('ionNavBackButton', ['$ionicConfig', '$document', function($ionicConfig, $document) {
        return {
          restrict: 'E',
          require: '^ionNavBar',
          compile: function(tElement, tAttrs) {
            var buttonEle = $document[0].createElement('button');
            for (var n in tAttrs.$attr) {
              buttonEle.setAttribute(tAttrs.$attr[n], tAttrs[n]);
            }
            if (!tAttrs.ngClick) {
              buttonEle.setAttribute('ng-click', '$ionicGoBack()');
            }
            buttonEle.className = 'button back-button hide buttons ' + (tElement.attr('class') || '');
            buttonEle.innerHTML = tElement.html() || '';
            var childNode;
            var hasIcon = hasIconClass(tElement[0]);
            var hasInnerText;
            var hasButtonText;
            var hasPreviousTitle;
            for (var x = 0; x < tElement[0].childNodes.length; x++) {
              childNode = tElement[0].childNodes[x];
              if (childNode.nodeType === 1) {
                if (hasIconClass(childNode)) {
                  hasIcon = true;
                } else if (childNode.classList.contains('default-title')) {
                  hasButtonText = true;
                } else if (childNode.classList.contains('previous-title')) {
                  hasPreviousTitle = true;
                }
              } else if (!hasInnerText && childNode.nodeType === 3) {
                hasInnerText = !!childNode.nodeValue.trim();
              }
            }
            function hasIconClass(ele) {
              return /ion-|icon/.test(ele.className);
            }
            var defaultIcon = $ionicConfig.backButton.icon();
            if (!hasIcon && defaultIcon && defaultIcon !== 'none') {
              buttonEle.innerHTML = '<i class="icon ' + defaultIcon + '"></i> ' + buttonEle.innerHTML;
              buttonEle.className += ' button-clear';
            }
            if (!hasInnerText) {
              var buttonTextEle = $document[0].createElement('span');
              buttonTextEle.className = 'back-text';
              if (!hasButtonText && $ionicConfig.backButton.text()) {
                buttonTextEle.innerHTML += '<span class="default-title">' + $ionicConfig.backButton.text() + '</span>';
              }
              if (!hasPreviousTitle && $ionicConfig.backButton.previousTitleText()) {
                buttonTextEle.innerHTML += '<span class="previous-title"></span>';
              }
              buttonEle.appendChild(buttonTextEle);
            }
            tElement.attr('class', 'hide');
            tElement.empty();
            return {pre: function($scope, $element, $attr, navBarCtrl) {
                navBarCtrl.navElement('backButton', buttonEle.outerHTML);
                buttonEle = null;
              }};
          }
        };
      }]);
      IonicModule.directive('ionNavBar', function() {
        return {
          restrict: 'E',
          controller: '$ionicNavBar',
          scope: true,
          link: function($scope, $element, $attr, ctrl) {
            ctrl.init();
          }
        };
      });
      IonicModule.directive('ionNavButtons', ['$document', function($document) {
        return {
          require: '^ionNavBar',
          restrict: 'E',
          compile: function(tElement, tAttrs) {
            var side = 'left';
            if (/^primary|secondary|right$/i.test(tAttrs.side || '')) {
              side = tAttrs.side.toLowerCase();
            }
            var spanEle = $document[0].createElement('span');
            spanEle.className = side + '-buttons';
            spanEle.innerHTML = tElement.html();
            var navElementType = side + 'Buttons';
            tElement.attr('class', 'hide');
            tElement.empty();
            return {pre: function($scope, $element, $attrs, navBarCtrl) {
                var parentViewCtrl = $element.parent().data('$ionViewController');
                if (parentViewCtrl) {
                  parentViewCtrl.navElement(navElementType, spanEle.outerHTML);
                } else {
                  navBarCtrl.navElement(navElementType, spanEle.outerHTML);
                }
                spanEle = null;
              }};
          }
        };
      }]);
      IonicModule.directive('navDirection', ['$ionicViewSwitcher', function($ionicViewSwitcher) {
        return {
          restrict: 'A',
          priority: 1000,
          link: function($scope, $element, $attr) {
            $element.bind('click', function() {
              $ionicViewSwitcher.nextDirection($attr.navDirection);
            });
          }
        };
      }]);
      IonicModule.directive('ionNavTitle', ['$document', function($document) {
        return {
          require: '^ionNavBar',
          restrict: 'E',
          compile: function(tElement, tAttrs) {
            var navElementType = 'title';
            var spanEle = $document[0].createElement('span');
            for (var n in tAttrs.$attr) {
              spanEle.setAttribute(tAttrs.$attr[n], tAttrs[n]);
            }
            spanEle.classList.add('nav-bar-title');
            spanEle.innerHTML = tElement.html();
            tElement.attr('class', 'hide');
            tElement.empty();
            return {pre: function($scope, $element, $attrs, navBarCtrl) {
                var parentViewCtrl = $element.parent().data('$ionViewController');
                if (parentViewCtrl) {
                  parentViewCtrl.navElement(navElementType, spanEle.outerHTML);
                } else {
                  navBarCtrl.navElement(navElementType, spanEle.outerHTML);
                }
                spanEle = null;
              }};
          }
        };
      }]);
      IonicModule.directive('navTransition', ['$ionicViewSwitcher', function($ionicViewSwitcher) {
        return {
          restrict: 'A',
          priority: 1000,
          link: function($scope, $element, $attr) {
            $element.bind('click', function() {
              $ionicViewSwitcher.nextTransition($attr.navTransition);
            });
          }
        };
      }]);
      IonicModule.directive('ionNavView', ['$state', '$ionicConfig', function($state, $ionicConfig) {
        return {
          restrict: 'E',
          terminal: true,
          priority: 2000,
          transclude: true,
          controller: '$ionicNavView',
          compile: function(tElement, tAttrs, transclude) {
            tElement.addClass('view-container');
            ionic.DomUtil.cachedAttr(tElement, 'nav-view-transition', $ionicConfig.views.transition());
            return function($scope, $element, $attr, navViewCtrl) {
              var latestLocals;
              transclude($scope, function(clone) {
                $element.append(clone);
              });
              var viewData = navViewCtrl.init();
              $scope.$on('$stateChangeSuccess', function() {
                updateView(false);
              });
              $scope.$on('$viewContentLoading', function() {
                updateView(false);
              });
              updateView(true);
              function updateView(firstTime) {
                var viewLocals = $state.$current && $state.$current.locals[viewData.name];
                if (!viewLocals || (!firstTime && viewLocals === latestLocals))
                  return;
                latestLocals = viewLocals;
                viewData.state = viewLocals.$$state;
                navViewCtrl.register(viewLocals);
              }
            };
          }
        };
      }]);
      IonicModule.config(['$provide', function($provide) {
        $provide.decorator('ngClickDirective', ['$delegate', function($delegate) {
          $delegate.shift();
          return $delegate;
        }]);
      }]).factory('$ionicNgClick', ['$parse', function($parse) {
        return function(scope, element, clickExpr) {
          var clickHandler = angular.isFunction(clickExpr) ? clickExpr : $parse(clickExpr);
          element.on('click', function(event) {
            scope.$apply(function() {
              clickHandler(scope, {$event: (event)});
            });
          });
          element.onclick = noop;
        };
      }]).directive('ngClick', ['$ionicNgClick', function($ionicNgClick) {
        return function(scope, element, attr) {
          $ionicNgClick(scope, element, attr.ngClick);
        };
      }]).directive('ionStopEvent', function() {
        return {
          restrict: 'A',
          link: function(scope, element, attr) {
            element.bind(attr.ionStopEvent, eventStopPropagation);
          }
        };
      });
      function eventStopPropagation(e) {
        e.stopPropagation();
      }
      IonicModule.directive('ionPane', function() {
        return {
          restrict: 'E',
          link: function(scope, element) {
            element.addClass('pane');
          }
        };
      });
      IonicModule.directive('ionPopover', [function() {
        return {
          restrict: 'E',
          transclude: true,
          replace: true,
          controller: [function() {}],
          template: '<div class="popover-backdrop">' + '<div class="popover-wrapper" ng-transclude></div>' + '</div>'
        };
      }]);
      IonicModule.directive('ionPopoverView', function() {
        return {
          restrict: 'E',
          compile: function(element) {
            element.append(jqLite('<div class="popover-arrow">'));
            element.addClass('popover');
          }
        };
      });
      IonicModule.directive('ionRadio', function() {
        return {
          restrict: 'E',
          replace: true,
          require: '?ngModel',
          transclude: true,
          template: '<label class="item item-radio">' + '<input type="radio" name="radio-group">' + '<div class="radio-content">' + '<div class="item-content disable-pointer-events" ng-transclude></div>' + '<i class="radio-icon disable-pointer-events icon ion-checkmark"></i>' + '</div>' + '</label>',
          compile: function(element, attr) {
            if (attr.icon) {
              var iconElm = element.find('i');
              iconElm.removeClass('ion-checkmark').addClass(attr.icon);
            }
            var input = element.find('input');
            forEach({
              'name': attr.name,
              'value': attr.value,
              'disabled': attr.disabled,
              'ng-value': attr.ngValue,
              'ng-model': attr.ngModel,
              'ng-disabled': attr.ngDisabled,
              'ng-change': attr.ngChange,
              'ng-required': attr.ngRequired,
              'required': attr.required
            }, function(value, name) {
              if (isDefined(value)) {
                input.attr(name, value);
              }
            });
            return function(scope, element, attr) {
              scope.getValue = function() {
                return scope.ngValue || attr.value;
              };
            };
          }
        };
      });
      IonicModule.directive('ionRefresher', [function() {
        return {
          restrict: 'E',
          replace: true,
          require: ['?^$ionicScroll', 'ionRefresher'],
          controller: '$ionicRefresher',
          template: '<div class="scroll-refresher invisible" collection-repeat-ignore>' + '<div class="ionic-refresher-content" ' + 'ng-class="{\'ionic-refresher-with-text\': pullingText || refreshingText}">' + '<div class="icon-pulling" ng-class="{\'pulling-rotation-disabled\':disablePullingRotation}">' + '<i class="icon {{pullingIcon}}"></i>' + '</div>' + '<div class="text-pulling" ng-bind-html="pullingText"></div>' + '<div class="icon-refreshing">' + '<ion-spinner ng-if="showSpinner" icon="{{spinner}}"></ion-spinner>' + '<i ng-if="showIcon" class="icon {{refreshingIcon}}"></i>' + '</div>' + '<div class="text-refreshing" ng-bind-html="refreshingText"></div>' + '</div>' + '</div>',
          link: function($scope, $element, $attrs, ctrls) {
            var scrollCtrl = ctrls[0],
                refresherCtrl = ctrls[1];
            if (!scrollCtrl || scrollCtrl.isNative()) {
              refresherCtrl.init();
            } else {
              $element[0].classList.add('js-scrolling');
              scrollCtrl._setRefresher($scope, $element[0], refresherCtrl.getRefresherDomMethods());
              $scope.$on('scroll.refreshComplete', function() {
                $scope.$evalAsync(function() {
                  scrollCtrl.scrollView.finishPullToRefresh();
                });
              });
            }
          }
        };
      }]);
      IonicModule.directive('ionScroll', ['$timeout', '$controller', '$ionicBind', '$ionicConfig', function($timeout, $controller, $ionicBind, $ionicConfig) {
        return {
          restrict: 'E',
          scope: true,
          controller: function() {},
          compile: function(element, attr) {
            element.addClass('scroll-view ionic-scroll');
            var innerElement = jqLite('<div class="scroll"></div>');
            innerElement.append(element.contents());
            element.append(innerElement);
            var nativeScrolling = attr.overflowScroll !== "false" && (attr.overflowScroll === "true" || !$ionicConfig.scrolling.jsScrolling());
            return {pre: prelink};
            function prelink($scope, $element, $attr) {
              $ionicBind($scope, $attr, {
                direction: '@',
                paging: '@',
                $onScroll: '&onScroll',
                scroll: '@',
                scrollbarX: '@',
                scrollbarY: '@',
                zooming: '@',
                minZoom: '@',
                maxZoom: '@'
              });
              $scope.direction = $scope.direction || 'y';
              if (isDefined($attr.padding)) {
                $scope.$watch($attr.padding, function(newVal) {
                  innerElement.toggleClass('padding', !!newVal);
                });
              }
              if ($scope.$eval($scope.paging) === true) {
                innerElement.addClass('scroll-paging');
              }
              if (!$scope.direction) {
                $scope.direction = 'y';
              }
              var isPaging = $scope.$eval($scope.paging) === true;
              if (nativeScrolling) {
                $element.addClass('overflow-scroll');
              }
              $element.addClass('scroll-' + $scope.direction);
              var scrollViewOptions = {
                el: $element[0],
                delegateHandle: $attr.delegateHandle,
                locking: ($attr.locking || 'true') === 'true',
                bouncing: $scope.$eval($attr.hasBouncing),
                paging: isPaging,
                scrollbarX: $scope.$eval($scope.scrollbarX) !== false,
                scrollbarY: $scope.$eval($scope.scrollbarY) !== false,
                scrollingX: $scope.direction.indexOf('x') >= 0,
                scrollingY: $scope.direction.indexOf('y') >= 0,
                zooming: $scope.$eval($scope.zooming) === true,
                maxZoom: $scope.$eval($scope.maxZoom) || 3,
                minZoom: $scope.$eval($scope.minZoom) || 0.5,
                preventDefault: true,
                nativeScrolling: nativeScrolling
              };
              if (isPaging) {
                scrollViewOptions.speedMultiplier = 0.8;
                scrollViewOptions.bouncing = false;
              }
              $controller('$ionicScroll', {
                $scope: $scope,
                scrollViewOptions: scrollViewOptions
              });
            }
          }
        };
      }]);
      IonicModule.directive('ionSideMenu', function() {
        return {
          restrict: 'E',
          require: '^ionSideMenus',
          scope: true,
          compile: function(element, attr) {
            angular.isUndefined(attr.isEnabled) && attr.$set('isEnabled', 'true');
            angular.isUndefined(attr.width) && attr.$set('width', '275');
            element.addClass('menu menu-' + attr.side);
            return function($scope, $element, $attr, sideMenuCtrl) {
              $scope.side = $attr.side || 'left';
              var sideMenu = sideMenuCtrl[$scope.side] = new ionic.views.SideMenu({
                width: attr.width,
                el: $element[0],
                isEnabled: true
              });
              $scope.$watch($attr.width, function(val) {
                var numberVal = +val;
                if (numberVal && numberVal == val) {
                  sideMenu.setWidth(+val);
                }
              });
              $scope.$watch($attr.isEnabled, function(val) {
                sideMenu.setIsEnabled(!!val);
              });
            };
          }
        };
      });
      IonicModule.directive('ionSideMenuContent', ['$timeout', '$ionicGesture', '$window', function($timeout, $ionicGesture, $window) {
        return {
          restrict: 'EA',
          require: '^ionSideMenus',
          scope: true,
          compile: function(element, attr) {
            element.addClass('menu-content pane');
            return {pre: prelink};
            function prelink($scope, $element, $attr, sideMenuCtrl) {
              var startCoord = null;
              var primaryScrollAxis = null;
              if (isDefined(attr.dragContent)) {
                $scope.$watch(attr.dragContent, function(value) {
                  sideMenuCtrl.canDragContent(value);
                });
              } else {
                sideMenuCtrl.canDragContent(true);
              }
              if (isDefined(attr.edgeDragThreshold)) {
                $scope.$watch(attr.edgeDragThreshold, function(value) {
                  sideMenuCtrl.edgeDragThreshold(value);
                });
              }
              function onContentTap(gestureEvt) {
                if (sideMenuCtrl.getOpenAmount() !== 0) {
                  sideMenuCtrl.close();
                  gestureEvt.gesture.srcEvent.preventDefault();
                  startCoord = null;
                  primaryScrollAxis = null;
                } else if (!startCoord) {
                  startCoord = ionic.tap.pointerCoord(gestureEvt.gesture.srcEvent);
                }
              }
              function onDragX(e) {
                if (!sideMenuCtrl.isDraggableTarget(e))
                  return;
                if (getPrimaryScrollAxis(e) == 'x') {
                  sideMenuCtrl._handleDrag(e);
                  e.gesture.srcEvent.preventDefault();
                }
              }
              function onDragY(e) {
                if (getPrimaryScrollAxis(e) == 'x') {
                  e.gesture.srcEvent.preventDefault();
                }
              }
              function onDragRelease(e) {
                sideMenuCtrl._endDrag(e);
                startCoord = null;
                primaryScrollAxis = null;
              }
              function getPrimaryScrollAxis(gestureEvt) {
                if (primaryScrollAxis) {
                  return primaryScrollAxis;
                }
                if (gestureEvt && gestureEvt.gesture) {
                  if (!startCoord) {
                    startCoord = ionic.tap.pointerCoord(gestureEvt.gesture.srcEvent);
                  } else {
                    var endCoord = ionic.tap.pointerCoord(gestureEvt.gesture.srcEvent);
                    var xDistance = Math.abs(endCoord.x - startCoord.x);
                    var yDistance = Math.abs(endCoord.y - startCoord.y);
                    var scrollAxis = (xDistance < yDistance ? 'y' : 'x');
                    if (Math.max(xDistance, yDistance) > 30) {
                      primaryScrollAxis = scrollAxis;
                    }
                    return scrollAxis;
                  }
                }
                return 'y';
              }
              var content = {
                element: element[0],
                onDrag: function() {},
                endDrag: function() {},
                setCanScroll: function(canScroll) {
                  var c = $element[0].querySelector('.scroll');
                  if (!c) {
                    return;
                  }
                  var content = angular.element(c.parentElement);
                  if (!content) {
                    return;
                  }
                  var scrollScope = content.scope();
                  scrollScope.scrollCtrl && scrollScope.scrollCtrl.freezeScrollShut(!canScroll);
                },
                getTranslateX: function() {
                  return $scope.sideMenuContentTranslateX || 0;
                },
                setTranslateX: ionic.animationFrameThrottle(function(amount) {
                  var xTransform = content.offsetX + amount;
                  $element[0].style[ionic.CSS.TRANSFORM] = 'translate3d(' + xTransform + 'px,0,0)';
                  $timeout(function() {
                    $scope.sideMenuContentTranslateX = amount;
                  });
                }),
                setMarginLeft: ionic.animationFrameThrottle(function(amount) {
                  if (amount) {
                    amount = parseInt(amount, 10);
                    $element[0].style[ionic.CSS.TRANSFORM] = 'translate3d(' + amount + 'px,0,0)';
                    $element[0].style.width = ($window.innerWidth - amount) + 'px';
                    content.offsetX = amount;
                  } else {
                    $element[0].style[ionic.CSS.TRANSFORM] = 'translate3d(0,0,0)';
                    $element[0].style.width = '';
                    content.offsetX = 0;
                  }
                }),
                setMarginRight: ionic.animationFrameThrottle(function(amount) {
                  if (amount) {
                    amount = parseInt(amount, 10);
                    $element[0].style.width = ($window.innerWidth - amount) + 'px';
                    content.offsetX = amount;
                  } else {
                    $element[0].style.width = '';
                    content.offsetX = 0;
                  }
                  $element[0].style[ionic.CSS.TRANSFORM] = 'translate3d(0,0,0)';
                }),
                setMarginLeftAndRight: ionic.animationFrameThrottle(function(amountLeft, amountRight) {
                  amountLeft = amountLeft && parseInt(amountLeft, 10) || 0;
                  amountRight = amountRight && parseInt(amountRight, 10) || 0;
                  var amount = amountLeft + amountRight;
                  if (amount > 0) {
                    $element[0].style[ionic.CSS.TRANSFORM] = 'translate3d(' + amountLeft + 'px,0,0)';
                    $element[0].style.width = ($window.innerWidth - amount) + 'px';
                    content.offsetX = amountLeft;
                  } else {
                    $element[0].style[ionic.CSS.TRANSFORM] = 'translate3d(0,0,0)';
                    $element[0].style.width = '';
                    content.offsetX = 0;
                  }
                }),
                enableAnimation: function() {
                  $scope.animationEnabled = true;
                  $element[0].classList.add('menu-animated');
                },
                disableAnimation: function() {
                  $scope.animationEnabled = false;
                  $element[0].classList.remove('menu-animated');
                },
                offsetX: 0
              };
              sideMenuCtrl.setContent(content);
              var gestureOpts = {stop_browser_behavior: false};
              gestureOpts.prevent_default_directions = ['left', 'right'];
              var contentTapGesture = $ionicGesture.on('tap', onContentTap, $element, gestureOpts);
              var dragRightGesture = $ionicGesture.on('dragright', onDragX, $element, gestureOpts);
              var dragLeftGesture = $ionicGesture.on('dragleft', onDragX, $element, gestureOpts);
              var dragUpGesture = $ionicGesture.on('dragup', onDragY, $element, gestureOpts);
              var dragDownGesture = $ionicGesture.on('dragdown', onDragY, $element, gestureOpts);
              var releaseGesture = $ionicGesture.on('release', onDragRelease, $element, gestureOpts);
              $scope.$on('$destroy', function() {
                if (content) {
                  content.element = null;
                  content = null;
                }
                $ionicGesture.off(dragLeftGesture, 'dragleft', onDragX);
                $ionicGesture.off(dragRightGesture, 'dragright', onDragX);
                $ionicGesture.off(dragUpGesture, 'dragup', onDragY);
                $ionicGesture.off(dragDownGesture, 'dragdown', onDragY);
                $ionicGesture.off(releaseGesture, 'release', onDragRelease);
                $ionicGesture.off(contentTapGesture, 'tap', onContentTap);
              });
            }
          }
        };
      }]);
      IonicModule.directive('ionSideMenus', ['$ionicBody', function($ionicBody) {
        return {
          restrict: 'ECA',
          controller: '$ionicSideMenus',
          compile: function(element, attr) {
            attr.$set('class', (attr['class'] || '') + ' view');
            return {pre: prelink};
            function prelink($scope, $element, $attrs, ctrl) {
              ctrl.enableMenuWithBackViews($scope.$eval($attrs.enableMenuWithBackViews));
              $scope.$on('$ionicExposeAside', function(evt, isAsideExposed) {
                if (!$scope.$exposeAside)
                  $scope.$exposeAside = {};
                $scope.$exposeAside.active = isAsideExposed;
                $ionicBody.enableClass(isAsideExposed, 'aside-open');
              });
              $scope.$on('$ionicView.beforeEnter', function(ev, d) {
                if (d.historyId) {
                  $scope.$activeHistoryId = d.historyId;
                }
              });
              $scope.$on('$destroy', function() {
                $ionicBody.removeClass('menu-open', 'aside-open');
              });
            }
          }
        };
      }]);
      IonicModule.directive('ionSlideBox', ['$animate', '$timeout', '$compile', '$ionicSlideBoxDelegate', '$ionicHistory', '$ionicScrollDelegate', function($animate, $timeout, $compile, $ionicSlideBoxDelegate, $ionicHistory, $ionicScrollDelegate) {
        return {
          restrict: 'E',
          replace: true,
          transclude: true,
          scope: {
            autoPlay: '=',
            doesContinue: '@',
            slideInterval: '@',
            showPager: '@',
            pagerClick: '&',
            disableScroll: '@',
            onSlideChanged: '&',
            activeSlide: '=?',
            bounce: '@'
          },
          controller: ['$scope', '$element', '$attrs', function($scope, $element, $attrs) {
            var _this = this;
            var continuous = $scope.$eval($scope.doesContinue) === true;
            var bouncing = ($scope.$eval($scope.bounce) !== false);
            var shouldAutoPlay = isDefined($attrs.autoPlay) ? !!$scope.autoPlay : false;
            var slideInterval = shouldAutoPlay ? $scope.$eval($scope.slideInterval) || 4000 : 0;
            var slider = new ionic.views.Slider({
              el: $element[0],
              auto: slideInterval,
              continuous: continuous,
              startSlide: $scope.activeSlide,
              bouncing: bouncing,
              slidesChanged: function() {
                $scope.currentSlide = slider.currentIndex();
                $timeout(function() {});
              },
              callback: function(slideIndex) {
                $scope.currentSlide = slideIndex;
                $scope.onSlideChanged({
                  index: $scope.currentSlide,
                  $index: $scope.currentSlide
                });
                $scope.$parent.$broadcast('slideBox.slideChanged', slideIndex);
                $scope.activeSlide = slideIndex;
                $timeout(function() {});
              },
              onDrag: function() {
                freezeAllScrolls(true);
              },
              onDragEnd: function() {
                freezeAllScrolls(false);
              }
            });
            function freezeAllScrolls(shouldFreeze) {
              if (shouldFreeze && !_this.isScrollFreeze) {
                $ionicScrollDelegate.freezeAllScrolls(shouldFreeze);
              } else if (!shouldFreeze && _this.isScrollFreeze) {
                $ionicScrollDelegate.freezeAllScrolls(false);
              }
              _this.isScrollFreeze = shouldFreeze;
            }
            slider.enableSlide($scope.$eval($attrs.disableScroll) !== true);
            $scope.$watch('activeSlide', function(nv) {
              if (isDefined(nv)) {
                slider.slide(nv);
              }
            });
            $scope.$on('slideBox.nextSlide', function() {
              slider.next();
            });
            $scope.$on('slideBox.prevSlide', function() {
              slider.prev();
            });
            $scope.$on('slideBox.setSlide', function(e, index) {
              slider.slide(index);
            });
            this.__slider = slider;
            var deregisterInstance = $ionicSlideBoxDelegate._registerInstance(slider, $attrs.delegateHandle, function() {
              return $ionicHistory.isActiveScope($scope);
            });
            $scope.$on('$destroy', function() {
              deregisterInstance();
              slider.kill();
            });
            this.slidesCount = function() {
              return slider.slidesCount();
            };
            this.onPagerClick = function(index) {
              $scope.pagerClick({index: index});
            };
            $timeout(function() {
              slider.load();
            });
          }],
          template: '<div class="slider">' + '<div class="slider-slides" ng-transclude>' + '</div>' + '</div>',
          link: function($scope, $element, $attr) {
            $animate.enabled($element, false);
            if (!isDefined($attr.showPager)) {
              $scope.showPager = true;
              getPager().toggleClass('hide', !true);
            }
            $attr.$observe('showPager', function(show) {
              if (show === undefined)
                return;
              show = $scope.$eval(show);
              getPager().toggleClass('hide', !show);
            });
            var pager;
            function getPager() {
              if (!pager) {
                var childScope = $scope.$new();
                pager = jqLite('<ion-pager></ion-pager>');
                $element.append(pager);
                pager = $compile(pager)(childScope);
              }
              return pager;
            }
          }
        };
      }]).directive('ionSlide', function() {
        return {
          restrict: 'E',
          require: '?^ionSlideBox',
          compile: function(element) {
            element.addClass('slider-slide');
          }
        };
      }).directive('ionPager', function() {
        return {
          restrict: 'E',
          replace: true,
          require: '^ionSlideBox',
          template: '<div class="slider-pager"><span class="slider-pager-page" ng-repeat="slide in numSlides() track by $index" ng-class="{active: $index == currentSlide}" ng-click="pagerClick($index)"><i class="icon ion-record"></i></span></div>',
          link: function($scope, $element, $attr, slideBox) {
            var selectPage = function(index) {
              var children = $element[0].children;
              var length = children.length;
              for (var i = 0; i < length; i++) {
                if (i == index) {
                  children[i].classList.add('active');
                } else {
                  children[i].classList.remove('active');
                }
              }
            };
            $scope.pagerClick = function(index) {
              slideBox.onPagerClick(index);
            };
            $scope.numSlides = function() {
              return new Array(slideBox.slidesCount());
            };
            $scope.$watch('currentSlide', function(v) {
              selectPage(v);
            });
          }
        };
      });
      IonicModule.directive('ionSlides', ['$animate', '$timeout', '$compile', function($animate, $timeout, $compile) {
        return {
          restrict: 'E',
          transclude: true,
          scope: {
            options: '=',
            slider: '='
          },
          template: '<div class="swiper-container">' + '<div class="swiper-wrapper" ng-transclude>' + '</div>' + '<div ng-hide="!showPager" class="swiper-pagination"></div>' + '</div>',
          controller: ['$scope', '$element', function($scope, $element) {
            var _this = this;
            var _watchHandler = null;
            var _enterHandler = null;
            var _afterLeaveHandler = null;
            var _modalRemovedHandler = null;
            var _modalPresentedHandler = null;
            this.update = function() {
              $timeout(function() {
                if (!_this.__slider) {
                  return;
                }
                _this.__slider.update();
                if (_this._options.loop) {
                  _this.__slider.createLoop();
                }
                var slidesLength = _this.__slider.slides.length;
                if (slidesLength > 10) {
                  $scope.showPager = false;
                }
                if (_this.__slider.activeIndex > slidesLength - 1) {
                  _this.__slider.slideTo(slidesLength - 1);
                }
              });
            };
            this.rapidUpdate = ionic.debounce(function() {
              _this.update();
            }, 50);
            this.updateLoop = ionic.debounce(function() {
              if (_this._options.loop) {
                _this.__slider.updateLoop();
              }
            }, 50);
            this.watchForChanges = function() {
              if (!_watchHandler) {
                _watchHandler = $scope.$watch(function() {
                  void 0;
                  _this.updateLoop();
                });
              }
            };
            this.stopWatching = function() {
              if (_watchHandler) {
                void 0;
                _watchHandler();
                _watchHandler = null;
              }
            };
            this.cleanUpEventHandlers = function() {
              if (_enterHandler) {
                _enterHandler();
                _enterHandler = null;
              }
              if (_afterLeaveHandler) {
                _afterLeaveHandler();
                _afterLeaveHandler = null;
              }
              if (_modalRemovedHandler) {
                _modalRemovedHandler();
                _modalRemovedHandler = null;
              }
              if (_modalPresentedHandler) {
                _modalPresentedHandler();
                _modalPresentedHandler = null;
              }
            };
            this.getSlider = function() {
              return _this.__slider;
            };
            var options = $scope.options || {};
            var newOptions = angular.extend({
              pagination: $element.children().children()[1],
              paginationClickable: true,
              lazyLoading: true,
              preloadImages: false
            }, options);
            this._options = newOptions;
            $timeout(function() {
              var slider = new ionic.views.Swiper($element.children()[0], newOptions, $scope, $compile);
              _this.__slider = slider;
              $scope.slider = _this.__slider;
              $scope.$on('$destroy', function() {
                slider.destroy();
                _this.__slider = null;
                _this.stopWatching();
                _this.cleanUpEventHandlers();
              });
              _this.watchForChanges();
              _enterHandler = $scope.$on("$ionicView.enter", function() {
                _this.watchForChanges();
              });
              _afterLeaveHandler = $scope.$on("$ionicView.afterLeave", function() {
                _this.stopWatching();
              });
              _modalRemovedHandler = $scope.$on("$ionic.modalRemoved", function() {
                _this.stopWatching();
              });
              _modalPresentedHandler = $scope.$on("$ionic.modalPresented", function() {
                _this.watchForChanges();
              });
            });
          }],
          link: function($scope) {
            $scope.showPager = true;
          }
        };
      }]).directive('ionSlidePage', [function() {
        return {
          restrict: 'E',
          require: '?^ionSlides',
          transclude: true,
          replace: true,
          template: '<div class="swiper-slide" ng-transclude></div>',
          link: function($scope, $element, $attr, ionSlidesCtrl) {
            ionSlidesCtrl.rapidUpdate();
            $scope.$on('$destroy', function() {
              ionSlidesCtrl.rapidUpdate();
            });
          }
        };
      }]);
      IonicModule.directive('ionSpinner', function() {
        return {
          restrict: 'E',
          controller: '$ionicSpinner',
          link: function($scope, $element, $attrs, ctrl) {
            var spinnerName = ctrl.init();
            $element.addClass('spinner spinner-' + spinnerName);
            $element.on('$destroy', function onDestroy() {
              ctrl.stop();
            });
          }
        };
      });
      IonicModule.directive('ionTab', ['$compile', '$ionicConfig', '$ionicBind', '$ionicViewSwitcher', function($compile, $ionicConfig, $ionicBind, $ionicViewSwitcher) {
        function attrStr(k, v) {
          return isDefined(v) ? ' ' + k + '="' + v + '"' : '';
        }
        return {
          restrict: 'E',
          require: ['^ionTabs', 'ionTab'],
          controller: '$ionicTab',
          scope: true,
          compile: function(element, attr) {
            var tabNavTemplate = '<ion-tab-nav' + attrStr('ng-click', attr.ngClick) + attrStr('title', attr.title) + attrStr('icon', attr.icon) + attrStr('icon-on', attr.iconOn) + attrStr('icon-off', attr.iconOff) + attrStr('badge', attr.badge) + attrStr('badge-style', attr.badgeStyle) + attrStr('hidden', attr.hidden) + attrStr('disabled', attr.disabled) + attrStr('class', attr['class']) + '></ion-tab-nav>';
            var tabContentEle = document.createElement('div');
            for (var x = 0; x < element[0].children.length; x++) {
              tabContentEle.appendChild(element[0].children[x].cloneNode(true));
            }
            var childElementCount = tabContentEle.childElementCount;
            element.empty();
            var navViewName,
                isNavView;
            if (childElementCount) {
              if (tabContentEle.children[0].tagName === 'ION-NAV-VIEW') {
                navViewName = tabContentEle.children[0].getAttribute('name');
                tabContentEle.children[0].classList.add('view-container');
                isNavView = true;
              }
              if (childElementCount === 1) {
                tabContentEle = tabContentEle.children[0];
              }
              if (!isNavView)
                tabContentEle.classList.add('pane');
              tabContentEle.classList.add('tab-content');
            }
            return function link($scope, $element, $attr, ctrls) {
              var childScope;
              var childElement;
              var tabsCtrl = ctrls[0];
              var tabCtrl = ctrls[1];
              var isTabContentAttached = false;
              $scope.$tabSelected = false;
              $ionicBind($scope, $attr, {
                onSelect: '&',
                onDeselect: '&',
                title: '@',
                uiSref: '@',
                href: '@'
              });
              tabsCtrl.add($scope);
              $scope.$on('$destroy', function() {
                if (!$scope.$tabsDestroy) {
                  tabsCtrl.remove($scope);
                }
                tabNavElement.isolateScope().$destroy();
                tabNavElement.remove();
                tabNavElement = tabContentEle = childElement = null;
              });
              $element[0].removeAttribute('title');
              if (navViewName) {
                tabCtrl.navViewName = $scope.navViewName = navViewName;
              }
              $scope.$on('$stateChangeSuccess', selectIfMatchesState);
              selectIfMatchesState();
              function selectIfMatchesState() {
                if (tabCtrl.tabMatchesState()) {
                  tabsCtrl.select($scope, false);
                }
              }
              var tabNavElement = jqLite(tabNavTemplate);
              tabNavElement.data('$ionTabsController', tabsCtrl);
              tabNavElement.data('$ionTabController', tabCtrl);
              tabsCtrl.$tabsElement.append($compile(tabNavElement)($scope));
              function tabSelected(isSelected) {
                if (isSelected && childElementCount) {
                  if (!isTabContentAttached) {
                    childScope = $scope.$new();
                    childElement = jqLite(tabContentEle);
                    $ionicViewSwitcher.viewEleIsActive(childElement, true);
                    tabsCtrl.$element.append(childElement);
                    $compile(childElement)(childScope);
                    isTabContentAttached = true;
                  }
                  $ionicViewSwitcher.viewEleIsActive(childElement, true);
                } else if (isTabContentAttached && childElement) {
                  if ($ionicConfig.views.maxCache() > 0) {
                    $ionicViewSwitcher.viewEleIsActive(childElement, false);
                  } else {
                    destroyTab();
                  }
                }
              }
              function destroyTab() {
                childScope && childScope.$destroy();
                isTabContentAttached && childElement && childElement.remove();
                tabContentEle.innerHTML = '';
                isTabContentAttached = childScope = childElement = null;
              }
              $scope.$watch('$tabSelected', tabSelected);
              $scope.$on('$ionicView.afterEnter', function() {
                $ionicViewSwitcher.viewEleIsActive(childElement, $scope.$tabSelected);
              });
              $scope.$on('$ionicView.clearCache', function() {
                if (!$scope.$tabSelected) {
                  destroyTab();
                }
              });
            };
          }
        };
      }]);
      IonicModule.directive('ionTabNav', [function() {
        return {
          restrict: 'E',
          replace: true,
          require: ['^ionTabs', '^ionTab'],
          template: '<a ng-class="{\'has-badge\':badge, \'tab-hidden\':isHidden()}" ' + ' ng-disabled="disabled()" class="tab-item">' + '<span class="badge {{badgeStyle}}" ng-if="badge">{{badge}}</span>' + '<i class="icon"></i>' + '<span class="tab-title" ng-bind-html="title"></span>' + '</a>',
          scope: {
            title: '@',
            icon: '@',
            iconOn: '@',
            iconOff: '@',
            badge: '=',
            hidden: '@',
            disabled: '&',
            badgeStyle: '@',
            'class': '@'
          },
          link: function($scope, $element, $attrs, ctrls) {
            var tabsCtrl = ctrls[0],
                tabCtrl = ctrls[1];
            $element[0].removeAttribute('title');
            $scope.selectTab = function(e) {
              e.preventDefault();
              tabsCtrl.select(tabCtrl.$scope, true);
            };
            if (!$attrs.ngClick) {
              $element.on('click', function(event) {
                $scope.$apply(function() {
                  $scope.selectTab(event);
                });
              });
            }
            $scope.isHidden = function() {
              if ($attrs.hidden === 'true' || $attrs.hidden === true)
                return true;
              return false;
            };
            $scope.getIconOn = function() {
              return $scope.iconOn || $scope.icon;
            };
            $scope.getIconOff = function() {
              return $scope.iconOff || $scope.icon;
            };
            $scope.isTabActive = function() {
              return tabsCtrl.selectedTab() === tabCtrl.$scope;
            };
            $scope.$watch("icon", function() {
              styleTab();
            });
            $scope.$watch("iconOff", function() {
              styleTab();
            });
            $scope.$watch("iconOn", function() {
              styleTab();
            });
            function styleTab() {
              if (tabsCtrl.selectedTab() === tabCtrl.$scope) {
                $element.addClass('tab-item-active');
                $element.find('i').removeClass($scope.getIconOff());
                $element.find('i').addClass($scope.getIconOn());
              } else {
                $element.removeClass('tab-item-active');
                $element.find('i').removeClass($scope.getIconOn());
                $element.find('i').addClass($scope.getIconOff());
              }
            }
            $scope.$on("tabSelected", styleTab);
            styleTab();
          }
        };
      }]);
      IonicModule.directive('ionTabs', ['$ionicTabsDelegate', '$ionicConfig', function($ionicTabsDelegate, $ionicConfig) {
        return {
          restrict: 'E',
          scope: true,
          controller: '$ionicTabs',
          compile: function(tElement) {
            var innerElement = jqLite('<div class="tab-nav tabs">');
            innerElement.append(tElement.contents());
            tElement.append(innerElement).addClass('tabs-' + $ionicConfig.tabs.position() + ' tabs-' + $ionicConfig.tabs.style());
            return {
              pre: prelink,
              post: postLink
            };
            function prelink($scope, $element, $attr, tabsCtrl) {
              var deregisterInstance = $ionicTabsDelegate._registerInstance(tabsCtrl, $attr.delegateHandle, tabsCtrl.hasActiveScope);
              tabsCtrl.$scope = $scope;
              tabsCtrl.$element = $element;
              tabsCtrl.$tabsElement = jqLite($element[0].querySelector('.tabs'));
              $scope.$watch(function() {
                return $element[0].className;
              }, function(value) {
                var isTabsTop = value.indexOf('tabs-top') !== -1;
                var isHidden = value.indexOf('tabs-item-hide') !== -1;
                $scope.$hasTabs = !isTabsTop && !isHidden;
                $scope.$hasTabsTop = isTabsTop && !isHidden;
                $scope.$emit('$ionicTabs.top', $scope.$hasTabsTop);
              });
              function emitLifecycleEvent(ev, data) {
                ev.stopPropagation();
                var previousSelectedTab = tabsCtrl.previousSelectedTab();
                if (previousSelectedTab) {
                  previousSelectedTab.$broadcast(ev.name.replace('NavView', 'Tabs'), data);
                }
              }
              $scope.$on('$ionicNavView.beforeLeave', emitLifecycleEvent);
              $scope.$on('$ionicNavView.afterLeave', emitLifecycleEvent);
              $scope.$on('$ionicNavView.leave', emitLifecycleEvent);
              $scope.$on('$destroy', function() {
                $scope.$tabsDestroy = true;
                deregisterInstance();
                tabsCtrl.$tabsElement = tabsCtrl.$element = tabsCtrl.$scope = innerElement = null;
                delete $scope.$hasTabs;
                delete $scope.$hasTabsTop;
              });
            }
            function postLink($scope, $element, $attr, tabsCtrl) {
              if (!tabsCtrl.selectedTab()) {
                tabsCtrl.select(0);
              }
            }
          }
        };
      }]);
      IonicModule.directive('ionTitle', [function() {
        return {
          restrict: 'E',
          compile: function(element) {
            element.addClass('title');
          }
        };
      }]);
      IonicModule.directive('ionToggle', ['$timeout', '$ionicConfig', function($timeout, $ionicConfig) {
        return {
          restrict: 'E',
          replace: true,
          require: '?ngModel',
          transclude: true,
          template: '<div class="item item-toggle">' + '<div ng-transclude></div>' + '<label class="toggle">' + '<input type="checkbox">' + '<div class="track">' + '<div class="handle"></div>' + '</div>' + '</label>' + '</div>',
          compile: function(element, attr) {
            var input = element.find('input');
            forEach({
              'name': attr.name,
              'ng-value': attr.ngValue,
              'ng-model': attr.ngModel,
              'ng-checked': attr.ngChecked,
              'ng-disabled': attr.ngDisabled,
              'ng-true-value': attr.ngTrueValue,
              'ng-false-value': attr.ngFalseValue,
              'ng-change': attr.ngChange,
              'ng-required': attr.ngRequired,
              'required': attr.required
            }, function(value, name) {
              if (isDefined(value)) {
                input.attr(name, value);
              }
            });
            if (attr.toggleClass) {
              element[0].getElementsByTagName('label')[0].classList.add(attr.toggleClass);
            }
            element.addClass('toggle-' + $ionicConfig.form.toggle());
            return function($scope, $element) {
              var el = $element[0].getElementsByTagName('label')[0];
              var checkbox = el.children[0];
              var track = el.children[1];
              var handle = track.children[0];
              var ngModelController = jqLite(checkbox).controller('ngModel');
              $scope.toggle = new ionic.views.Toggle({
                el: el,
                track: track,
                checkbox: checkbox,
                handle: handle,
                onChange: function() {
                  if (ngModelController) {
                    ngModelController.$setViewValue(checkbox.checked);
                    $scope.$apply();
                  }
                }
              });
              $scope.$on('$destroy', function() {
                $scope.toggle.destroy();
              });
            };
          }
        };
      }]);
      IonicModule.directive('ionView', function() {
        return {
          restrict: 'EA',
          priority: 1000,
          controller: '$ionicView',
          compile: function(tElement) {
            tElement.addClass('pane');
            tElement[0].removeAttribute('title');
            return function link($scope, $element, $attrs, viewCtrl) {
              viewCtrl.init();
            };
          }
        };
      });
    })();
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("1b", [], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    angular.module("ui.bootstrap", ["ui.bootstrap.tpls", "ui.bootstrap.collapse", "ui.bootstrap.tabindex", "ui.bootstrap.accordion", "ui.bootstrap.alert", "ui.bootstrap.buttons", "ui.bootstrap.carousel", "ui.bootstrap.dateparser", "ui.bootstrap.isClass", "ui.bootstrap.datepicker", "ui.bootstrap.position", "ui.bootstrap.datepickerPopup", "ui.bootstrap.debounce", "ui.bootstrap.dropdown", "ui.bootstrap.stackedMap", "ui.bootstrap.modal", "ui.bootstrap.paging", "ui.bootstrap.pager", "ui.bootstrap.pagination", "ui.bootstrap.tooltip", "ui.bootstrap.popover", "ui.bootstrap.progressbar", "ui.bootstrap.rating", "ui.bootstrap.tabs", "ui.bootstrap.timepicker", "ui.bootstrap.typeahead"]);
    angular.module("ui.bootstrap.tpls", ["uib/template/accordion/accordion-group.html", "uib/template/accordion/accordion.html", "uib/template/alert/alert.html", "uib/template/carousel/carousel.html", "uib/template/carousel/slide.html", "uib/template/datepicker/datepicker.html", "uib/template/datepicker/day.html", "uib/template/datepicker/month.html", "uib/template/datepicker/year.html", "uib/template/datepickerPopup/popup.html", "uib/template/modal/window.html", "uib/template/pager/pager.html", "uib/template/pagination/pagination.html", "uib/template/tooltip/tooltip-html-popup.html", "uib/template/tooltip/tooltip-popup.html", "uib/template/tooltip/tooltip-template-popup.html", "uib/template/popover/popover-html.html", "uib/template/popover/popover-template.html", "uib/template/popover/popover.html", "uib/template/progressbar/bar.html", "uib/template/progressbar/progress.html", "uib/template/progressbar/progressbar.html", "uib/template/rating/rating.html", "uib/template/tabs/tab.html", "uib/template/tabs/tabset.html", "uib/template/timepicker/timepicker.html", "uib/template/typeahead/typeahead-match.html", "uib/template/typeahead/typeahead-popup.html"]);
    angular.module('ui.bootstrap.collapse', []).directive('uibCollapse', ['$animate', '$q', '$parse', '$injector', function($animate, $q, $parse, $injector) {
      var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;
      return {link: function(scope, element, attrs) {
          var expandingExpr = $parse(attrs.expanding),
              expandedExpr = $parse(attrs.expanded),
              collapsingExpr = $parse(attrs.collapsing),
              collapsedExpr = $parse(attrs.collapsed),
              horizontal = false,
              css = {},
              cssTo = {};
          init();
          function init() {
            horizontal = !!('horizontal' in attrs);
            if (horizontal) {
              css = {
                width: 'auto',
                height: 'inherit'
              };
              cssTo = {width: '0'};
            } else {
              css = {
                width: 'inherit',
                height: 'auto'
              };
              cssTo = {height: '0'};
            }
            if (!scope.$eval(attrs.uibCollapse)) {
              element.addClass('in').addClass('collapse').attr('aria-expanded', true).attr('aria-hidden', false).css(css);
            }
          }
          function getScrollFromElement(element) {
            if (horizontal) {
              return {width: element.scrollWidth + 'px'};
            }
            return {height: element.scrollHeight + 'px'};
          }
          function expand() {
            if (element.hasClass('collapse') && element.hasClass('in')) {
              return;
            }
            $q.resolve(expandingExpr(scope)).then(function() {
              element.removeClass('collapse').addClass('collapsing').attr('aria-expanded', true).attr('aria-hidden', false);
              if ($animateCss) {
                $animateCss(element, {
                  addClass: 'in',
                  easing: 'ease',
                  to: getScrollFromElement(element[0])
                }).start()['finally'](expandDone);
              } else {
                $animate.addClass(element, 'in', {to: getScrollFromElement(element[0])}).then(expandDone);
              }
            });
          }
          function expandDone() {
            element.removeClass('collapsing').addClass('collapse').css(css);
            expandedExpr(scope);
          }
          function collapse() {
            if (!element.hasClass('collapse') && !element.hasClass('in')) {
              return collapseDone();
            }
            $q.resolve(collapsingExpr(scope)).then(function() {
              element.css(getScrollFromElement(element[0])).removeClass('collapse').addClass('collapsing').attr('aria-expanded', false).attr('aria-hidden', true);
              if ($animateCss) {
                $animateCss(element, {
                  removeClass: 'in',
                  to: cssTo
                }).start()['finally'](collapseDone);
              } else {
                $animate.removeClass(element, 'in', {to: cssTo}).then(collapseDone);
              }
            });
          }
          function collapseDone() {
            element.css(cssTo);
            element.removeClass('collapsing').addClass('collapse');
            collapsedExpr(scope);
          }
          scope.$watch(attrs.uibCollapse, function(shouldCollapse) {
            if (shouldCollapse) {
              collapse();
            } else {
              expand();
            }
          });
        }};
    }]);
    angular.module('ui.bootstrap.tabindex', []).directive('uibTabindexToggle', function() {
      return {
        restrict: 'A',
        link: function(scope, elem, attrs) {
          attrs.$observe('disabled', function(disabled) {
            attrs.$set('tabindex', disabled ? -1 : null);
          });
        }
      };
    });
    angular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse', 'ui.bootstrap.tabindex']).constant('uibAccordionConfig', {closeOthers: true}).controller('UibAccordionController', ['$scope', '$attrs', 'uibAccordionConfig', function($scope, $attrs, accordionConfig) {
      this.groups = [];
      this.closeOthers = function(openGroup) {
        var closeOthers = angular.isDefined($attrs.closeOthers) ? $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
        if (closeOthers) {
          angular.forEach(this.groups, function(group) {
            if (group !== openGroup) {
              group.isOpen = false;
            }
          });
        }
      };
      this.addGroup = function(groupScope) {
        var that = this;
        this.groups.push(groupScope);
        groupScope.$on('$destroy', function(event) {
          that.removeGroup(groupScope);
        });
      };
      this.removeGroup = function(group) {
        var index = this.groups.indexOf(group);
        if (index !== -1) {
          this.groups.splice(index, 1);
        }
      };
    }]).directive('uibAccordion', function() {
      return {
        controller: 'UibAccordionController',
        controllerAs: 'accordion',
        transclude: true,
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'uib/template/accordion/accordion.html';
        }
      };
    }).directive('uibAccordionGroup', function() {
      return {
        require: '^uibAccordion',
        transclude: true,
        restrict: 'A',
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'uib/template/accordion/accordion-group.html';
        },
        scope: {
          heading: '@',
          panelClass: '@?',
          isOpen: '=?',
          isDisabled: '=?'
        },
        controller: function() {
          this.setHeading = function(element) {
            this.heading = element;
          };
        },
        link: function(scope, element, attrs, accordionCtrl) {
          element.addClass('panel');
          accordionCtrl.addGroup(scope);
          scope.openClass = attrs.openClass || 'panel-open';
          scope.panelClass = attrs.panelClass || 'panel-default';
          scope.$watch('isOpen', function(value) {
            element.toggleClass(scope.openClass, !!value);
            if (value) {
              accordionCtrl.closeOthers(scope);
            }
          });
          scope.toggleOpen = function($event) {
            if (!scope.isDisabled) {
              if (!$event || $event.which === 32) {
                scope.isOpen = !scope.isOpen;
              }
            }
          };
          var id = 'accordiongroup-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
          scope.headingId = id + '-tab';
          scope.panelId = id + '-panel';
        }
      };
    }).directive('uibAccordionHeading', function() {
      return {
        transclude: true,
        template: '',
        replace: true,
        require: '^uibAccordionGroup',
        link: function(scope, element, attrs, accordionGroupCtrl, transclude) {
          accordionGroupCtrl.setHeading(transclude(scope, angular.noop));
        }
      };
    }).directive('uibAccordionTransclude', function() {
      return {
        require: '^uibAccordionGroup',
        link: function(scope, element, attrs, controller) {
          scope.$watch(function() {
            return controller[attrs.uibAccordionTransclude];
          }, function(heading) {
            if (heading) {
              var elem = angular.element(element[0].querySelector(getHeaderSelectors()));
              elem.html('');
              elem.append(heading);
            }
          });
        }
      };
      function getHeaderSelectors() {
        return 'uib-accordion-header,' + 'data-uib-accordion-header,' + 'x-uib-accordion-header,' + 'uib\\:accordion-header,' + '[uib-accordion-header],' + '[data-uib-accordion-header],' + '[x-uib-accordion-header]';
      }
    });
    angular.module('ui.bootstrap.alert', []).controller('UibAlertController', ['$scope', '$element', '$attrs', '$interpolate', '$timeout', function($scope, $element, $attrs, $interpolate, $timeout) {
      $scope.closeable = !!$attrs.close;
      $element.addClass('alert');
      $attrs.$set('role', 'alert');
      if ($scope.closeable) {
        $element.addClass('alert-dismissible');
      }
      var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ? $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;
      if (dismissOnTimeout) {
        $timeout(function() {
          $scope.close();
        }, parseInt(dismissOnTimeout, 10));
      }
    }]).directive('uibAlert', function() {
      return {
        controller: 'UibAlertController',
        controllerAs: 'alert',
        restrict: 'A',
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'uib/template/alert/alert.html';
        },
        transclude: true,
        scope: {close: '&'}
      };
    });
    angular.module('ui.bootstrap.buttons', []).constant('uibButtonConfig', {
      activeClass: 'active',
      toggleEvent: 'click'
    }).controller('UibButtonsController', ['uibButtonConfig', function(buttonConfig) {
      this.activeClass = buttonConfig.activeClass || 'active';
      this.toggleEvent = buttonConfig.toggleEvent || 'click';
    }]).directive('uibBtnRadio', ['$parse', function($parse) {
      return {
        require: ['uibBtnRadio', 'ngModel'],
        controller: 'UibButtonsController',
        controllerAs: 'buttons',
        link: function(scope, element, attrs, ctrls) {
          var buttonsCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];
          var uncheckableExpr = $parse(attrs.uibUncheckable);
          element.find('input').css({display: 'none'});
          ngModelCtrl.$render = function() {
            element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));
          };
          element.on(buttonsCtrl.toggleEvent, function() {
            if (attrs.disabled) {
              return;
            }
            var isActive = element.hasClass(buttonsCtrl.activeClass);
            if (!isActive || angular.isDefined(attrs.uncheckable)) {
              scope.$apply(function() {
                ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio));
                ngModelCtrl.$render();
              });
            }
          });
          if (attrs.uibUncheckable) {
            scope.$watch(uncheckableExpr, function(uncheckable) {
              attrs.$set('uncheckable', uncheckable ? '' : undefined);
            });
          }
        }
      };
    }]).directive('uibBtnCheckbox', function() {
      return {
        require: ['uibBtnCheckbox', 'ngModel'],
        controller: 'UibButtonsController',
        controllerAs: 'button',
        link: function(scope, element, attrs, ctrls) {
          var buttonsCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];
          element.find('input').css({display: 'none'});
          function getTrueValue() {
            return getCheckboxValue(attrs.btnCheckboxTrue, true);
          }
          function getFalseValue() {
            return getCheckboxValue(attrs.btnCheckboxFalse, false);
          }
          function getCheckboxValue(attribute, defaultValue) {
            return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;
          }
          ngModelCtrl.$render = function() {
            element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
          };
          element.on(buttonsCtrl.toggleEvent, function() {
            if (attrs.disabled) {
              return;
            }
            scope.$apply(function() {
              ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
              ngModelCtrl.$render();
            });
          });
        }
      };
    });
    angular.module('ui.bootstrap.carousel', []).controller('UibCarouselController', ['$scope', '$element', '$interval', '$timeout', '$animate', function($scope, $element, $interval, $timeout, $animate) {
      var self = this,
          slides = self.slides = $scope.slides = [],
          SLIDE_DIRECTION = 'uib-slideDirection',
          currentIndex = $scope.active,
          currentInterval,
          isPlaying,
          bufferedTransitions = [];
      var destroyed = false;
      $element.addClass('carousel');
      self.addSlide = function(slide, element) {
        slides.push({
          slide: slide,
          element: element
        });
        slides.sort(function(a, b) {
          return +a.slide.index - +b.slide.index;
        });
        if (slide.index === $scope.active || slides.length === 1 && !angular.isNumber($scope.active)) {
          if ($scope.$currentTransition) {
            $scope.$currentTransition = null;
          }
          currentIndex = slide.index;
          $scope.active = slide.index;
          setActive(currentIndex);
          self.select(slides[findSlideIndex(slide)]);
          if (slides.length === 1) {
            $scope.play();
          }
        }
      };
      self.getCurrentIndex = function() {
        for (var i = 0; i < slides.length; i++) {
          if (slides[i].slide.index === currentIndex) {
            return i;
          }
        }
      };
      self.next = $scope.next = function() {
        var newIndex = (self.getCurrentIndex() + 1) % slides.length;
        if (newIndex === 0 && $scope.noWrap()) {
          $scope.pause();
          return;
        }
        return self.select(slides[newIndex], 'next');
      };
      self.prev = $scope.prev = function() {
        var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;
        if ($scope.noWrap() && newIndex === slides.length - 1) {
          $scope.pause();
          return;
        }
        return self.select(slides[newIndex], 'prev');
      };
      self.removeSlide = function(slide) {
        var index = findSlideIndex(slide);
        var bufferedIndex = bufferedTransitions.indexOf(slides[index]);
        if (bufferedIndex !== -1) {
          bufferedTransitions.splice(bufferedIndex, 1);
        }
        slides.splice(index, 1);
        if (slides.length > 0 && currentIndex === index) {
          if (index >= slides.length) {
            currentIndex = slides.length - 1;
            $scope.active = currentIndex;
            setActive(currentIndex);
            self.select(slides[slides.length - 1]);
          } else {
            currentIndex = index;
            $scope.active = currentIndex;
            setActive(currentIndex);
            self.select(slides[index]);
          }
        } else if (currentIndex > index) {
          currentIndex--;
          $scope.active = currentIndex;
        }
        if (slides.length === 0) {
          currentIndex = null;
          $scope.active = null;
          clearBufferedTransitions();
        }
      };
      self.select = $scope.select = function(nextSlide, direction) {
        var nextIndex = findSlideIndex(nextSlide.slide);
        if (direction === undefined) {
          direction = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';
        }
        if (nextSlide.slide.index !== currentIndex && !$scope.$currentTransition) {
          goNext(nextSlide.slide, nextIndex, direction);
        } else if (nextSlide && nextSlide.slide.index !== currentIndex && $scope.$currentTransition) {
          bufferedTransitions.push(slides[nextIndex]);
        }
      };
      $scope.indexOfSlide = function(slide) {
        return +slide.slide.index;
      };
      $scope.isActive = function(slide) {
        return $scope.active === slide.slide.index;
      };
      $scope.isPrevDisabled = function() {
        return $scope.active === 0 && $scope.noWrap();
      };
      $scope.isNextDisabled = function() {
        return $scope.active === slides.length - 1 && $scope.noWrap();
      };
      $scope.pause = function() {
        if (!$scope.noPause) {
          isPlaying = false;
          resetTimer();
        }
      };
      $scope.play = function() {
        if (!isPlaying) {
          isPlaying = true;
          restartTimer();
        }
      };
      $element.on('mouseenter', $scope.pause);
      $element.on('mouseleave', $scope.play);
      $scope.$on('$destroy', function() {
        destroyed = true;
        resetTimer();
      });
      $scope.$watch('noTransition', function(noTransition) {
        $animate.enabled($element, !noTransition);
      });
      $scope.$watch('interval', restartTimer);
      $scope.$watchCollection('slides', resetTransition);
      $scope.$watch('active', function(index) {
        if (angular.isNumber(index) && currentIndex !== index) {
          for (var i = 0; i < slides.length; i++) {
            if (slides[i].slide.index === index) {
              index = i;
              break;
            }
          }
          var slide = slides[index];
          if (slide) {
            setActive(index);
            self.select(slides[index]);
            currentIndex = index;
          }
        }
      });
      function clearBufferedTransitions() {
        while (bufferedTransitions.length) {
          bufferedTransitions.shift();
        }
      }
      function getSlideByIndex(index) {
        for (var i = 0,
            l = slides.length; i < l; ++i) {
          if (slides[i].index === index) {
            return slides[i];
          }
        }
      }
      function setActive(index) {
        for (var i = 0; i < slides.length; i++) {
          slides[i].slide.active = i === index;
        }
      }
      function goNext(slide, index, direction) {
        if (destroyed) {
          return;
        }
        angular.extend(slide, {direction: direction});
        angular.extend(slides[currentIndex].slide || {}, {direction: direction});
        if ($animate.enabled($element) && !$scope.$currentTransition && slides[index].element && self.slides.length > 1) {
          slides[index].element.data(SLIDE_DIRECTION, slide.direction);
          var currentIdx = self.getCurrentIndex();
          if (angular.isNumber(currentIdx) && slides[currentIdx].element) {
            slides[currentIdx].element.data(SLIDE_DIRECTION, slide.direction);
          }
          $scope.$currentTransition = true;
          $animate.on('addClass', slides[index].element, function(element, phase) {
            if (phase === 'close') {
              $scope.$currentTransition = null;
              $animate.off('addClass', element);
              if (bufferedTransitions.length) {
                var nextSlide = bufferedTransitions.pop().slide;
                var nextIndex = nextSlide.index;
                var nextDirection = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';
                clearBufferedTransitions();
                goNext(nextSlide, nextIndex, nextDirection);
              }
            }
          });
        }
        $scope.active = slide.index;
        currentIndex = slide.index;
        setActive(index);
        restartTimer();
      }
      function findSlideIndex(slide) {
        for (var i = 0; i < slides.length; i++) {
          if (slides[i].slide === slide) {
            return i;
          }
        }
      }
      function resetTimer() {
        if (currentInterval) {
          $interval.cancel(currentInterval);
          currentInterval = null;
        }
      }
      function resetTransition(slides) {
        if (!slides.length) {
          $scope.$currentTransition = null;
          clearBufferedTransitions();
        }
      }
      function restartTimer() {
        resetTimer();
        var interval = +$scope.interval;
        if (!isNaN(interval) && interval > 0) {
          currentInterval = $interval(timerFn, interval);
        }
      }
      function timerFn() {
        var interval = +$scope.interval;
        if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {
          $scope.next();
        } else {
          $scope.pause();
        }
      }
    }]).directive('uibCarousel', function() {
      return {
        transclude: true,
        controller: 'UibCarouselController',
        controllerAs: 'carousel',
        restrict: 'A',
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'uib/template/carousel/carousel.html';
        },
        scope: {
          active: '=',
          interval: '=',
          noTransition: '=',
          noPause: '=',
          noWrap: '&'
        }
      };
    }).directive('uibSlide', ['$animate', function($animate) {
      return {
        require: '^uibCarousel',
        restrict: 'A',
        transclude: true,
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'uib/template/carousel/slide.html';
        },
        scope: {
          actual: '=?',
          index: '=?'
        },
        link: function(scope, element, attrs, carouselCtrl) {
          element.addClass('item');
          carouselCtrl.addSlide(scope, element);
          scope.$on('$destroy', function() {
            carouselCtrl.removeSlide(scope);
          });
          scope.$watch('active', function(active) {
            $animate[active ? 'addClass' : 'removeClass'](element, 'active');
          });
        }
      };
    }]).animation('.item', ['$animateCss', function($animateCss) {
      var SLIDE_DIRECTION = 'uib-slideDirection';
      function removeClass(element, className, callback) {
        element.removeClass(className);
        if (callback) {
          callback();
        }
      }
      return {
        beforeAddClass: function(element, className, done) {
          if (className === 'active') {
            var stopped = false;
            var direction = element.data(SLIDE_DIRECTION);
            var directionClass = direction === 'next' ? 'left' : 'right';
            var removeClassFn = removeClass.bind(this, element, directionClass + ' ' + direction, done);
            element.addClass(direction);
            $animateCss(element, {addClass: directionClass}).start().done(removeClassFn);
            return function() {
              stopped = true;
            };
          }
          done();
        },
        beforeRemoveClass: function(element, className, done) {
          if (className === 'active') {
            var stopped = false;
            var direction = element.data(SLIDE_DIRECTION);
            var directionClass = direction === 'next' ? 'left' : 'right';
            var removeClassFn = removeClass.bind(this, element, directionClass, done);
            $animateCss(element, {addClass: directionClass}).start().done(removeClassFn);
            return function() {
              stopped = true;
            };
          }
          done();
        }
      };
    }]);
    angular.module('ui.bootstrap.dateparser', []).service('uibDateParser', ['$log', '$locale', 'dateFilter', 'orderByFilter', function($log, $locale, dateFilter, orderByFilter) {
      var SPECIAL_CHARACTERS_REGEXP = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
      var localeId;
      var formatCodeToRegex;
      this.init = function() {
        localeId = $locale.id;
        this.parsers = {};
        this.formatters = {};
        formatCodeToRegex = [{
          key: 'yyyy',
          regex: '\\d{4}',
          apply: function(value) {
            this.year = +value;
          },
          formatter: function(date) {
            var _date = new Date();
            _date.setFullYear(Math.abs(date.getFullYear()));
            return dateFilter(_date, 'yyyy');
          }
        }, {
          key: 'yy',
          regex: '\\d{2}',
          apply: function(value) {
            value = +value;
            this.year = value < 69 ? value + 2000 : value + 1900;
          },
          formatter: function(date) {
            var _date = new Date();
            _date.setFullYear(Math.abs(date.getFullYear()));
            return dateFilter(_date, 'yy');
          }
        }, {
          key: 'y',
          regex: '\\d{1,4}',
          apply: function(value) {
            this.year = +value;
          },
          formatter: function(date) {
            var _date = new Date();
            _date.setFullYear(Math.abs(date.getFullYear()));
            return dateFilter(_date, 'y');
          }
        }, {
          key: 'M!',
          regex: '0?[1-9]|1[0-2]',
          apply: function(value) {
            this.month = value - 1;
          },
          formatter: function(date) {
            var value = date.getMonth();
            if (/^[0-9]$/.test(value)) {
              return dateFilter(date, 'MM');
            }
            return dateFilter(date, 'M');
          }
        }, {
          key: 'MMMM',
          regex: $locale.DATETIME_FORMATS.MONTH.join('|'),
          apply: function(value) {
            this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value);
          },
          formatter: function(date) {
            return dateFilter(date, 'MMMM');
          }
        }, {
          key: 'MMM',
          regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),
          apply: function(value) {
            this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value);
          },
          formatter: function(date) {
            return dateFilter(date, 'MMM');
          }
        }, {
          key: 'MM',
          regex: '0[1-9]|1[0-2]',
          apply: function(value) {
            this.month = value - 1;
          },
          formatter: function(date) {
            return dateFilter(date, 'MM');
          }
        }, {
          key: 'M',
          regex: '[1-9]|1[0-2]',
          apply: function(value) {
            this.month = value - 1;
          },
          formatter: function(date) {
            return dateFilter(date, 'M');
          }
        }, {
          key: 'd!',
          regex: '[0-2]?[0-9]{1}|3[0-1]{1}',
          apply: function(value) {
            this.date = +value;
          },
          formatter: function(date) {
            var value = date.getDate();
            if (/^[1-9]$/.test(value)) {
              return dateFilter(date, 'dd');
            }
            return dateFilter(date, 'd');
          }
        }, {
          key: 'dd',
          regex: '[0-2][0-9]{1}|3[0-1]{1}',
          apply: function(value) {
            this.date = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 'dd');
          }
        }, {
          key: 'd',
          regex: '[1-2]?[0-9]{1}|3[0-1]{1}',
          apply: function(value) {
            this.date = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 'd');
          }
        }, {
          key: 'EEEE',
          regex: $locale.DATETIME_FORMATS.DAY.join('|'),
          formatter: function(date) {
            return dateFilter(date, 'EEEE');
          }
        }, {
          key: 'EEE',
          regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|'),
          formatter: function(date) {
            return dateFilter(date, 'EEE');
          }
        }, {
          key: 'HH',
          regex: '(?:0|1)[0-9]|2[0-3]',
          apply: function(value) {
            this.hours = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 'HH');
          }
        }, {
          key: 'hh',
          regex: '0[0-9]|1[0-2]',
          apply: function(value) {
            this.hours = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 'hh');
          }
        }, {
          key: 'H',
          regex: '1?[0-9]|2[0-3]',
          apply: function(value) {
            this.hours = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 'H');
          }
        }, {
          key: 'h',
          regex: '[0-9]|1[0-2]',
          apply: function(value) {
            this.hours = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 'h');
          }
        }, {
          key: 'mm',
          regex: '[0-5][0-9]',
          apply: function(value) {
            this.minutes = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 'mm');
          }
        }, {
          key: 'm',
          regex: '[0-9]|[1-5][0-9]',
          apply: function(value) {
            this.minutes = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 'm');
          }
        }, {
          key: 'sss',
          regex: '[0-9][0-9][0-9]',
          apply: function(value) {
            this.milliseconds = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 'sss');
          }
        }, {
          key: 'ss',
          regex: '[0-5][0-9]',
          apply: function(value) {
            this.seconds = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 'ss');
          }
        }, {
          key: 's',
          regex: '[0-9]|[1-5][0-9]',
          apply: function(value) {
            this.seconds = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 's');
          }
        }, {
          key: 'a',
          regex: $locale.DATETIME_FORMATS.AMPMS.join('|'),
          apply: function(value) {
            if (this.hours === 12) {
              this.hours = 0;
            }
            if (value === 'PM') {
              this.hours += 12;
            }
          },
          formatter: function(date) {
            return dateFilter(date, 'a');
          }
        }, {
          key: 'Z',
          regex: '[+-]\\d{4}',
          apply: function(value) {
            var matches = value.match(/([+-])(\d{2})(\d{2})/),
                sign = matches[1],
                hours = matches[2],
                minutes = matches[3];
            this.hours += toInt(sign + hours);
            this.minutes += toInt(sign + minutes);
          },
          formatter: function(date) {
            return dateFilter(date, 'Z');
          }
        }, {
          key: 'ww',
          regex: '[0-4][0-9]|5[0-3]',
          formatter: function(date) {
            return dateFilter(date, 'ww');
          }
        }, {
          key: 'w',
          regex: '[0-9]|[1-4][0-9]|5[0-3]',
          formatter: function(date) {
            return dateFilter(date, 'w');
          }
        }, {
          key: 'GGGG',
          regex: $locale.DATETIME_FORMATS.ERANAMES.join('|').replace(/\s/g, '\\s'),
          formatter: function(date) {
            return dateFilter(date, 'GGGG');
          }
        }, {
          key: 'GGG',
          regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
          formatter: function(date) {
            return dateFilter(date, 'GGG');
          }
        }, {
          key: 'GG',
          regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
          formatter: function(date) {
            return dateFilter(date, 'GG');
          }
        }, {
          key: 'G',
          regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
          formatter: function(date) {
            return dateFilter(date, 'G');
          }
        }];
      };
      this.init();
      function createParser(format) {
        var map = [],
            regex = format.split('');
        var quoteIndex = format.indexOf('\'');
        if (quoteIndex > -1) {
          var inLiteral = false;
          format = format.split('');
          for (var i = quoteIndex; i < format.length; i++) {
            if (inLiteral) {
              if (format[i] === '\'') {
                if (i + 1 < format.length && format[i + 1] === '\'') {
                  format[i + 1] = '$';
                  regex[i + 1] = '';
                } else {
                  regex[i] = '';
                  inLiteral = false;
                }
              }
              format[i] = '$';
            } else {
              if (format[i] === '\'') {
                format[i] = '$';
                regex[i] = '';
                inLiteral = true;
              }
            }
          }
          format = format.join('');
        }
        angular.forEach(formatCodeToRegex, function(data) {
          var index = format.indexOf(data.key);
          if (index > -1) {
            format = format.split('');
            regex[index] = '(' + data.regex + ')';
            format[index] = '$';
            for (var i = index + 1,
                n = index + data.key.length; i < n; i++) {
              regex[i] = '';
              format[i] = '$';
            }
            format = format.join('');
            map.push({
              index: index,
              key: data.key,
              apply: data.apply,
              matcher: data.regex
            });
          }
        });
        return {
          regex: new RegExp('^' + regex.join('') + '$'),
          map: orderByFilter(map, 'index')
        };
      }
      function createFormatter(format) {
        var formatters = [];
        var i = 0;
        var formatter,
            literalIdx;
        while (i < format.length) {
          if (angular.isNumber(literalIdx)) {
            if (format.charAt(i) === '\'') {
              if (i + 1 >= format.length || format.charAt(i + 1) !== '\'') {
                formatters.push(constructLiteralFormatter(format, literalIdx, i));
                literalIdx = null;
              }
            } else if (i === format.length) {
              while (literalIdx < format.length) {
                formatter = constructFormatterFromIdx(format, literalIdx);
                formatters.push(formatter);
                literalIdx = formatter.endIdx;
              }
            }
            i++;
            continue;
          }
          if (format.charAt(i) === '\'') {
            literalIdx = i;
            i++;
            continue;
          }
          formatter = constructFormatterFromIdx(format, i);
          formatters.push(formatter.parser);
          i = formatter.endIdx;
        }
        return formatters;
      }
      function constructLiteralFormatter(format, literalIdx, endIdx) {
        return function() {
          return format.substr(literalIdx + 1, endIdx - literalIdx - 1);
        };
      }
      function constructFormatterFromIdx(format, i) {
        var currentPosStr = format.substr(i);
        for (var j = 0; j < formatCodeToRegex.length; j++) {
          if (new RegExp('^' + formatCodeToRegex[j].key).test(currentPosStr)) {
            var data = formatCodeToRegex[j];
            return {
              endIdx: i + data.key.length,
              parser: data.formatter
            };
          }
        }
        return {
          endIdx: i + 1,
          parser: function() {
            return currentPosStr.charAt(0);
          }
        };
      }
      this.filter = function(date, format) {
        if (!angular.isDate(date) || isNaN(date) || !format) {
          return '';
        }
        format = $locale.DATETIME_FORMATS[format] || format;
        if ($locale.id !== localeId) {
          this.init();
        }
        if (!this.formatters[format]) {
          this.formatters[format] = createFormatter(format);
        }
        var formatters = this.formatters[format];
        return formatters.reduce(function(str, formatter) {
          return str + formatter(date);
        }, '');
      };
      this.parse = function(input, format, baseDate) {
        if (!angular.isString(input) || !format) {
          return input;
        }
        format = $locale.DATETIME_FORMATS[format] || format;
        format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\$&');
        if ($locale.id !== localeId) {
          this.init();
        }
        if (!this.parsers[format]) {
          this.parsers[format] = createParser(format, 'apply');
        }
        var parser = this.parsers[format],
            regex = parser.regex,
            map = parser.map,
            results = input.match(regex),
            tzOffset = false;
        if (results && results.length) {
          var fields,
              dt;
          if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {
            fields = {
              year: baseDate.getFullYear(),
              month: baseDate.getMonth(),
              date: baseDate.getDate(),
              hours: baseDate.getHours(),
              minutes: baseDate.getMinutes(),
              seconds: baseDate.getSeconds(),
              milliseconds: baseDate.getMilliseconds()
            };
          } else {
            if (baseDate) {
              $log.warn('dateparser:', 'baseDate is not a valid date');
            }
            fields = {
              year: 1900,
              month: 0,
              date: 1,
              hours: 0,
              minutes: 0,
              seconds: 0,
              milliseconds: 0
            };
          }
          for (var i = 1,
              n = results.length; i < n; i++) {
            var mapper = map[i - 1];
            if (mapper.matcher === 'Z') {
              tzOffset = true;
            }
            if (mapper.apply) {
              mapper.apply.call(fields, results[i]);
            }
          }
          var datesetter = tzOffset ? Date.prototype.setUTCFullYear : Date.prototype.setFullYear;
          var timesetter = tzOffset ? Date.prototype.setUTCHours : Date.prototype.setHours;
          if (isValid(fields.year, fields.month, fields.date)) {
            if (angular.isDate(baseDate) && !isNaN(baseDate.getTime()) && !tzOffset) {
              dt = new Date(baseDate);
              datesetter.call(dt, fields.year, fields.month, fields.date);
              timesetter.call(dt, fields.hours, fields.minutes, fields.seconds, fields.milliseconds);
            } else {
              dt = new Date(0);
              datesetter.call(dt, fields.year, fields.month, fields.date);
              timesetter.call(dt, fields.hours || 0, fields.minutes || 0, fields.seconds || 0, fields.milliseconds || 0);
            }
          }
          return dt;
        }
      };
      function isValid(year, month, date) {
        if (date < 1) {
          return false;
        }
        if (month === 1 && date > 28) {
          return date === 29 && (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0);
        }
        if (month === 3 || month === 5 || month === 8 || month === 10) {
          return date < 31;
        }
        return true;
      }
      function toInt(str) {
        return parseInt(str, 10);
      }
      this.toTimezone = toTimezone;
      this.fromTimezone = fromTimezone;
      this.timezoneToOffset = timezoneToOffset;
      this.addDateMinutes = addDateMinutes;
      this.convertTimezoneToLocal = convertTimezoneToLocal;
      function toTimezone(date, timezone) {
        return date && timezone ? convertTimezoneToLocal(date, timezone) : date;
      }
      function fromTimezone(date, timezone) {
        return date && timezone ? convertTimezoneToLocal(date, timezone, true) : date;
      }
      function timezoneToOffset(timezone, fallback) {
        timezone = timezone.replace(/:/g, '');
        var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
        return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
      }
      function addDateMinutes(date, minutes) {
        date = new Date(date.getTime());
        date.setMinutes(date.getMinutes() + minutes);
        return date;
      }
      function convertTimezoneToLocal(date, timezone, reverse) {
        reverse = reverse ? -1 : 1;
        var dateTimezoneOffset = date.getTimezoneOffset();
        var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
        return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));
      }
    }]);
    angular.module('ui.bootstrap.isClass', []).directive('uibIsClass', ['$animate', function($animate) {
      var ON_REGEXP = /^\s*([\s\S]+?)\s+on\s+([\s\S]+?)\s*$/;
      var IS_REGEXP = /^\s*([\s\S]+?)\s+for\s+([\s\S]+?)\s*$/;
      var dataPerTracked = {};
      return {
        restrict: 'A',
        compile: function(tElement, tAttrs) {
          var linkedScopes = [];
          var instances = [];
          var expToData = {};
          var lastActivated = null;
          var onExpMatches = tAttrs.uibIsClass.match(ON_REGEXP);
          var onExp = onExpMatches[2];
          var expsStr = onExpMatches[1];
          var exps = expsStr.split(',');
          return linkFn;
          function linkFn(scope, element, attrs) {
            linkedScopes.push(scope);
            instances.push({
              scope: scope,
              element: element
            });
            exps.forEach(function(exp, k) {
              addForExp(exp, scope);
            });
            scope.$on('$destroy', removeScope);
          }
          function addForExp(exp, scope) {
            var matches = exp.match(IS_REGEXP);
            var clazz = scope.$eval(matches[1]);
            var compareWithExp = matches[2];
            var data = expToData[exp];
            if (!data) {
              var watchFn = function(compareWithVal) {
                var newActivated = null;
                instances.some(function(instance) {
                  var thisVal = instance.scope.$eval(onExp);
                  if (thisVal === compareWithVal) {
                    newActivated = instance;
                    return true;
                  }
                });
                if (data.lastActivated !== newActivated) {
                  if (data.lastActivated) {
                    $animate.removeClass(data.lastActivated.element, clazz);
                  }
                  if (newActivated) {
                    $animate.addClass(newActivated.element, clazz);
                  }
                  data.lastActivated = newActivated;
                }
              };
              expToData[exp] = data = {
                lastActivated: null,
                scope: scope,
                watchFn: watchFn,
                compareWithExp: compareWithExp,
                watcher: scope.$watch(compareWithExp, watchFn)
              };
            }
            data.watchFn(scope.$eval(compareWithExp));
          }
          function removeScope(e) {
            var removedScope = e.targetScope;
            var index = linkedScopes.indexOf(removedScope);
            linkedScopes.splice(index, 1);
            instances.splice(index, 1);
            if (linkedScopes.length) {
              var newWatchScope = linkedScopes[0];
              angular.forEach(expToData, function(data) {
                if (data.scope === removedScope) {
                  data.watcher = newWatchScope.$watch(data.compareWithExp, data.watchFn);
                  data.scope = newWatchScope;
                }
              });
            } else {
              expToData = {};
            }
          }
        }
      };
    }]);
    angular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.isClass']).value('$datepickerSuppressError', false).value('$datepickerLiteralWarning', true).constant('uibDatepickerConfig', {
      datepickerMode: 'day',
      formatDay: 'dd',
      formatMonth: 'MMMM',
      formatYear: 'yyyy',
      formatDayHeader: 'EEE',
      formatDayTitle: 'MMMM yyyy',
      formatMonthTitle: 'yyyy',
      maxDate: null,
      maxMode: 'year',
      minDate: null,
      minMode: 'day',
      monthColumns: 3,
      ngModelOptions: {},
      shortcutPropagation: false,
      showWeeks: true,
      yearColumns: 5,
      yearRows: 4
    }).controller('UibDatepickerController', ['$scope', '$element', '$attrs', '$parse', '$interpolate', '$locale', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerLiteralWarning', '$datepickerSuppressError', 'uibDateParser', function($scope, $element, $attrs, $parse, $interpolate, $locale, $log, dateFilter, datepickerConfig, $datepickerLiteralWarning, $datepickerSuppressError, dateParser) {
      var self = this,
          ngModelCtrl = {$setViewValue: angular.noop},
          ngModelOptions = {},
          watchListeners = [];
      $element.addClass('uib-datepicker');
      $attrs.$set('role', 'application');
      if (!$scope.datepickerOptions) {
        $scope.datepickerOptions = {};
      }
      this.modes = ['day', 'month', 'year'];
      ['customClass', 'dateDisabled', 'datepickerMode', 'formatDay', 'formatDayHeader', 'formatDayTitle', 'formatMonth', 'formatMonthTitle', 'formatYear', 'maxDate', 'maxMode', 'minDate', 'minMode', 'monthColumns', 'showWeeks', 'shortcutPropagation', 'startingDay', 'yearColumns', 'yearRows'].forEach(function(key) {
        switch (key) {
          case 'customClass':
          case 'dateDisabled':
            $scope[key] = $scope.datepickerOptions[key] || angular.noop;
            break;
          case 'datepickerMode':
            $scope.datepickerMode = angular.isDefined($scope.datepickerOptions.datepickerMode) ? $scope.datepickerOptions.datepickerMode : datepickerConfig.datepickerMode;
            break;
          case 'formatDay':
          case 'formatDayHeader':
          case 'formatDayTitle':
          case 'formatMonth':
          case 'formatMonthTitle':
          case 'formatYear':
            self[key] = angular.isDefined($scope.datepickerOptions[key]) ? $interpolate($scope.datepickerOptions[key])($scope.$parent) : datepickerConfig[key];
            break;
          case 'monthColumns':
          case 'showWeeks':
          case 'shortcutPropagation':
          case 'yearColumns':
          case 'yearRows':
            self[key] = angular.isDefined($scope.datepickerOptions[key]) ? $scope.datepickerOptions[key] : datepickerConfig[key];
            break;
          case 'startingDay':
            if (angular.isDefined($scope.datepickerOptions.startingDay)) {
              self.startingDay = $scope.datepickerOptions.startingDay;
            } else if (angular.isNumber(datepickerConfig.startingDay)) {
              self.startingDay = datepickerConfig.startingDay;
            } else {
              self.startingDay = ($locale.DATETIME_FORMATS.FIRSTDAYOFWEEK + 8) % 7;
            }
            break;
          case 'maxDate':
          case 'minDate':
            $scope.$watch('datepickerOptions.' + key, function(value) {
              if (value) {
                if (angular.isDate(value)) {
                  self[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.timezone);
                } else {
                  if ($datepickerLiteralWarning) {
                    $log.warn('Literal date support has been deprecated, please switch to date object usage');
                  }
                  self[key] = new Date(dateFilter(value, 'medium'));
                }
              } else {
                self[key] = datepickerConfig[key] ? dateParser.fromTimezone(new Date(datepickerConfig[key]), ngModelOptions.timezone) : null;
              }
              self.refreshView();
            });
            break;
          case 'maxMode':
          case 'minMode':
            if ($scope.datepickerOptions[key]) {
              $scope.$watch(function() {
                return $scope.datepickerOptions[key];
              }, function(value) {
                self[key] = $scope[key] = angular.isDefined(value) ? value : datepickerOptions[key];
                if (key === 'minMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) < self.modes.indexOf(self[key]) || key === 'maxMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) > self.modes.indexOf(self[key])) {
                  $scope.datepickerMode = self[key];
                  $scope.datepickerOptions.datepickerMode = self[key];
                }
              });
            } else {
              self[key] = $scope[key] = datepickerConfig[key] || null;
            }
            break;
        }
      });
      $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);
      $scope.disabled = angular.isDefined($attrs.disabled) || false;
      if (angular.isDefined($attrs.ngDisabled)) {
        watchListeners.push($scope.$parent.$watch($attrs.ngDisabled, function(disabled) {
          $scope.disabled = disabled;
          self.refreshView();
        }));
      }
      $scope.isActive = function(dateObject) {
        if (self.compare(dateObject.date, self.activeDate) === 0) {
          $scope.activeDateId = dateObject.uid;
          return true;
        }
        return false;
      };
      this.init = function(ngModelCtrl_) {
        ngModelCtrl = ngModelCtrl_;
        ngModelOptions = ngModelCtrl_.$options || $scope.datepickerOptions.ngModelOptions || datepickerConfig.ngModelOptions;
        if ($scope.datepickerOptions.initDate) {
          self.activeDate = dateParser.fromTimezone($scope.datepickerOptions.initDate, ngModelOptions.timezone) || new Date();
          $scope.$watch('datepickerOptions.initDate', function(initDate) {
            if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {
              self.activeDate = dateParser.fromTimezone(initDate, ngModelOptions.timezone);
              self.refreshView();
            }
          });
        } else {
          self.activeDate = new Date();
        }
        var date = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : new Date();
        this.activeDate = !isNaN(date) ? dateParser.fromTimezone(date, ngModelOptions.timezone) : dateParser.fromTimezone(new Date(), ngModelOptions.timezone);
        ngModelCtrl.$render = function() {
          self.render();
        };
      };
      this.render = function() {
        if (ngModelCtrl.$viewValue) {
          var date = new Date(ngModelCtrl.$viewValue),
              isValid = !isNaN(date);
          if (isValid) {
            this.activeDate = dateParser.fromTimezone(date, ngModelOptions.timezone);
          } else if (!$datepickerSuppressError) {
            $log.error('Datepicker directive: "ng-model" value must be a Date object');
          }
        }
        this.refreshView();
      };
      this.refreshView = function() {
        if (this.element) {
          $scope.selectedDt = null;
          this._refreshView();
          if ($scope.activeDt) {
            $scope.activeDateId = $scope.activeDt.uid;
          }
          var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
          date = dateParser.fromTimezone(date, ngModelOptions.timezone);
          ngModelCtrl.$setValidity('dateDisabled', !date || this.element && !this.isDisabled(date));
        }
      };
      this.createDateObject = function(date, format) {
        var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
        model = dateParser.fromTimezone(model, ngModelOptions.timezone);
        var today = new Date();
        today = dateParser.fromTimezone(today, ngModelOptions.timezone);
        var time = this.compare(date, today);
        var dt = {
          date: date,
          label: dateParser.filter(date, format),
          selected: model && this.compare(date, model) === 0,
          disabled: this.isDisabled(date),
          past: time < 0,
          current: time === 0,
          future: time > 0,
          customClass: this.customClass(date) || null
        };
        if (model && this.compare(date, model) === 0) {
          $scope.selectedDt = dt;
        }
        if (self.activeDate && this.compare(dt.date, self.activeDate) === 0) {
          $scope.activeDt = dt;
        }
        return dt;
      };
      this.isDisabled = function(date) {
        return $scope.disabled || this.minDate && this.compare(date, this.minDate) < 0 || this.maxDate && this.compare(date, this.maxDate) > 0 || $scope.dateDisabled && $scope.dateDisabled({
          date: date,
          mode: $scope.datepickerMode
        });
      };
      this.customClass = function(date) {
        return $scope.customClass({
          date: date,
          mode: $scope.datepickerMode
        });
      };
      this.split = function(arr, size) {
        var arrays = [];
        while (arr.length > 0) {
          arrays.push(arr.splice(0, size));
        }
        return arrays;
      };
      $scope.select = function(date) {
        if ($scope.datepickerMode === self.minMode) {
          var dt = ngModelCtrl.$viewValue ? dateParser.fromTimezone(new Date(ngModelCtrl.$viewValue), ngModelOptions.timezone) : new Date(0, 0, 0, 0, 0, 0, 0);
          dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
          dt = dateParser.toTimezone(dt, ngModelOptions.timezone);
          ngModelCtrl.$setViewValue(dt);
          ngModelCtrl.$render();
        } else {
          self.activeDate = date;
          setMode(self.modes[self.modes.indexOf($scope.datepickerMode) - 1]);
          $scope.$emit('uib:datepicker.mode');
        }
        $scope.$broadcast('uib:datepicker.focus');
      };
      $scope.move = function(direction) {
        var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),
            month = self.activeDate.getMonth() + direction * (self.step.months || 0);
        self.activeDate.setFullYear(year, month, 1);
        self.refreshView();
      };
      $scope.toggleMode = function(direction) {
        direction = direction || 1;
        if ($scope.datepickerMode === self.maxMode && direction === 1 || $scope.datepickerMode === self.minMode && direction === -1) {
          return;
        }
        setMode(self.modes[self.modes.indexOf($scope.datepickerMode) + direction]);
        $scope.$emit('uib:datepicker.mode');
      };
      $scope.keys = {
        13: 'enter',
        32: 'space',
        33: 'pageup',
        34: 'pagedown',
        35: 'end',
        36: 'home',
        37: 'left',
        38: 'up',
        39: 'right',
        40: 'down'
      };
      var focusElement = function() {
        self.element[0].focus();
      };
      $scope.$on('uib:datepicker.focus', focusElement);
      $scope.keydown = function(evt) {
        var key = $scope.keys[evt.which];
        if (!key || evt.shiftKey || evt.altKey || $scope.disabled) {
          return;
        }
        evt.preventDefault();
        if (!self.shortcutPropagation) {
          evt.stopPropagation();
        }
        if (key === 'enter' || key === 'space') {
          if (self.isDisabled(self.activeDate)) {
            return;
          }
          $scope.select(self.activeDate);
        } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {
          $scope.toggleMode(key === 'up' ? 1 : -1);
        } else {
          self.handleKeyDown(key, evt);
          self.refreshView();
        }
      };
      $element.on('keydown', function(evt) {
        $scope.$apply(function() {
          $scope.keydown(evt);
        });
      });
      $scope.$on('$destroy', function() {
        while (watchListeners.length) {
          watchListeners.shift()();
        }
      });
      function setMode(mode) {
        $scope.datepickerMode = mode;
        $scope.datepickerOptions.datepickerMode = mode;
      }
    }]).controller('UibDaypickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
      var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      this.step = {months: 1};
      this.element = $element;
      function getDaysInMonth(year, month) {
        return month === 1 && year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0) ? 29 : DAYS_IN_MONTH[month];
      }
      this.init = function(ctrl) {
        angular.extend(ctrl, this);
        scope.showWeeks = ctrl.showWeeks;
        ctrl.refreshView();
      };
      this.getDates = function(startDate, n) {
        var dates = new Array(n),
            current = new Date(startDate),
            i = 0,
            date;
        while (i < n) {
          date = new Date(current);
          dates[i++] = date;
          current.setDate(current.getDate() + 1);
        }
        return dates;
      };
      this._refreshView = function() {
        var year = this.activeDate.getFullYear(),
            month = this.activeDate.getMonth(),
            firstDayOfMonth = new Date(this.activeDate);
        firstDayOfMonth.setFullYear(year, month, 1);
        var difference = this.startingDay - firstDayOfMonth.getDay(),
            numDisplayedFromPreviousMonth = difference > 0 ? 7 - difference : -difference,
            firstDate = new Date(firstDayOfMonth);
        if (numDisplayedFromPreviousMonth > 0) {
          firstDate.setDate(-numDisplayedFromPreviousMonth + 1);
        }
        var days = this.getDates(firstDate, 42);
        for (var i = 0; i < 42; i++) {
          days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {
            secondary: days[i].getMonth() !== month,
            uid: scope.uniqueId + '-' + i
          });
        }
        scope.labels = new Array(7);
        for (var j = 0; j < 7; j++) {
          scope.labels[j] = {
            abbr: dateFilter(days[j].date, this.formatDayHeader),
            full: dateFilter(days[j].date, 'EEEE')
          };
        }
        scope.title = dateFilter(this.activeDate, this.formatDayTitle);
        scope.rows = this.split(days, 7);
        if (scope.showWeeks) {
          scope.weekNumbers = [];
          var thursdayIndex = (4 + 7 - this.startingDay) % 7,
              numWeeks = scope.rows.length;
          for (var curWeek = 0; curWeek < numWeeks; curWeek++) {
            scope.weekNumbers.push(getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));
          }
        }
      };
      this.compare = function(date1, date2) {
        var _date1 = new Date(date1.getFullYear(), date1.getMonth(), date1.getDate());
        var _date2 = new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
        _date1.setFullYear(date1.getFullYear());
        _date2.setFullYear(date2.getFullYear());
        return _date1 - _date2;
      };
      function getISO8601WeekNumber(date) {
        var checkDate = new Date(date);
        checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
        var time = checkDate.getTime();
        checkDate.setMonth(0);
        checkDate.setDate(1);
        return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
      }
      this.handleKeyDown = function(key, evt) {
        var date = this.activeDate.getDate();
        if (key === 'left') {
          date = date - 1;
        } else if (key === 'up') {
          date = date - 7;
        } else if (key === 'right') {
          date = date + 1;
        } else if (key === 'down') {
          date = date + 7;
        } else if (key === 'pageup' || key === 'pagedown') {
          var month = this.activeDate.getMonth() + (key === 'pageup' ? -1 : 1);
          this.activeDate.setMonth(month, 1);
          date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);
        } else if (key === 'home') {
          date = 1;
        } else if (key === 'end') {
          date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth());
        }
        this.activeDate.setDate(date);
      };
    }]).controller('UibMonthpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
      this.step = {years: 1};
      this.element = $element;
      this.init = function(ctrl) {
        angular.extend(ctrl, this);
        ctrl.refreshView();
      };
      this._refreshView = function() {
        var months = new Array(12),
            year = this.activeDate.getFullYear(),
            date;
        for (var i = 0; i < 12; i++) {
          date = new Date(this.activeDate);
          date.setFullYear(year, i, 1);
          months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {uid: scope.uniqueId + '-' + i});
        }
        scope.title = dateFilter(this.activeDate, this.formatMonthTitle);
        scope.rows = this.split(months, this.monthColumns);
        scope.yearHeaderColspan = this.monthColumns > 3 ? this.monthColumns - 2 : 1;
      };
      this.compare = function(date1, date2) {
        var _date1 = new Date(date1.getFullYear(), date1.getMonth());
        var _date2 = new Date(date2.getFullYear(), date2.getMonth());
        _date1.setFullYear(date1.getFullYear());
        _date2.setFullYear(date2.getFullYear());
        return _date1 - _date2;
      };
      this.handleKeyDown = function(key, evt) {
        var date = this.activeDate.getMonth();
        if (key === 'left') {
          date = date - 1;
        } else if (key === 'up') {
          date = date - this.monthColumns;
        } else if (key === 'right') {
          date = date + 1;
        } else if (key === 'down') {
          date = date + this.monthColumns;
        } else if (key === 'pageup' || key === 'pagedown') {
          var year = this.activeDate.getFullYear() + (key === 'pageup' ? -1 : 1);
          this.activeDate.setFullYear(year);
        } else if (key === 'home') {
          date = 0;
        } else if (key === 'end') {
          date = 11;
        }
        this.activeDate.setMonth(date);
      };
    }]).controller('UibYearpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
      var columns,
          range;
      this.element = $element;
      function getStartingYear(year) {
        return parseInt((year - 1) / range, 10) * range + 1;
      }
      this.yearpickerInit = function() {
        columns = this.yearColumns;
        range = this.yearRows * columns;
        this.step = {years: range};
      };
      this._refreshView = function() {
        var years = new Array(range),
            date;
        for (var i = 0,
            start = getStartingYear(this.activeDate.getFullYear()); i < range; i++) {
          date = new Date(this.activeDate);
          date.setFullYear(start + i, 0, 1);
          years[i] = angular.extend(this.createDateObject(date, this.formatYear), {uid: scope.uniqueId + '-' + i});
        }
        scope.title = [years[0].label, years[range - 1].label].join(' - ');
        scope.rows = this.split(years, columns);
        scope.columns = columns;
      };
      this.compare = function(date1, date2) {
        return date1.getFullYear() - date2.getFullYear();
      };
      this.handleKeyDown = function(key, evt) {
        var date = this.activeDate.getFullYear();
        if (key === 'left') {
          date = date - 1;
        } else if (key === 'up') {
          date = date - columns;
        } else if (key === 'right') {
          date = date + 1;
        } else if (key === 'down') {
          date = date + columns;
        } else if (key === 'pageup' || key === 'pagedown') {
          date += (key === 'pageup' ? -1 : 1) * range;
        } else if (key === 'home') {
          date = getStartingYear(this.activeDate.getFullYear());
        } else if (key === 'end') {
          date = getStartingYear(this.activeDate.getFullYear()) + range - 1;
        }
        this.activeDate.setFullYear(date);
      };
    }]).directive('uibDatepicker', function() {
      return {
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'uib/template/datepicker/datepicker.html';
        },
        scope: {datepickerOptions: '=?'},
        require: ['uibDatepicker', '^ngModel'],
        restrict: 'A',
        controller: 'UibDatepickerController',
        controllerAs: 'datepicker',
        link: function(scope, element, attrs, ctrls) {
          var datepickerCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];
          datepickerCtrl.init(ngModelCtrl);
        }
      };
    }).directive('uibDaypicker', function() {
      return {
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'uib/template/datepicker/day.html';
        },
        require: ['^uibDatepicker', 'uibDaypicker'],
        restrict: 'A',
        controller: 'UibDaypickerController',
        link: function(scope, element, attrs, ctrls) {
          var datepickerCtrl = ctrls[0],
              daypickerCtrl = ctrls[1];
          daypickerCtrl.init(datepickerCtrl);
        }
      };
    }).directive('uibMonthpicker', function() {
      return {
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'uib/template/datepicker/month.html';
        },
        require: ['^uibDatepicker', 'uibMonthpicker'],
        restrict: 'A',
        controller: 'UibMonthpickerController',
        link: function(scope, element, attrs, ctrls) {
          var datepickerCtrl = ctrls[0],
              monthpickerCtrl = ctrls[1];
          monthpickerCtrl.init(datepickerCtrl);
        }
      };
    }).directive('uibYearpicker', function() {
      return {
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'uib/template/datepicker/year.html';
        },
        require: ['^uibDatepicker', 'uibYearpicker'],
        restrict: 'A',
        controller: 'UibYearpickerController',
        link: function(scope, element, attrs, ctrls) {
          var ctrl = ctrls[0];
          angular.extend(ctrl, ctrls[1]);
          ctrl.yearpickerInit();
          ctrl.refreshView();
        }
      };
    });
    angular.module('ui.bootstrap.position', []).factory('$uibPosition', ['$document', '$window', function($document, $window) {
      var SCROLLBAR_WIDTH;
      var BODY_SCROLLBAR_WIDTH;
      var OVERFLOW_REGEX = {
        normal: /(auto|scroll)/,
        hidden: /(auto|scroll|hidden)/
      };
      var PLACEMENT_REGEX = {
        auto: /\s?auto?\s?/i,
        primary: /^(top|bottom|left|right)$/,
        secondary: /^(top|bottom|left|right|center)$/,
        vertical: /^(top|bottom)$/
      };
      var BODY_REGEX = /(HTML|BODY)/;
      return {
        getRawNode: function(elem) {
          return elem.nodeName ? elem : elem[0] || elem;
        },
        parseStyle: function(value) {
          value = parseFloat(value);
          return isFinite(value) ? value : 0;
        },
        offsetParent: function(elem) {
          elem = this.getRawNode(elem);
          var offsetParent = elem.offsetParent || $document[0].documentElement;
          function isStaticPositioned(el) {
            return ($window.getComputedStyle(el).position || 'static') === 'static';
          }
          while (offsetParent && offsetParent !== $document[0].documentElement && isStaticPositioned(offsetParent)) {
            offsetParent = offsetParent.offsetParent;
          }
          return offsetParent || $document[0].documentElement;
        },
        scrollbarWidth: function(isBody) {
          if (isBody) {
            if (angular.isUndefined(BODY_SCROLLBAR_WIDTH)) {
              var bodyElem = $document.find('body');
              bodyElem.addClass('uib-position-body-scrollbar-measure');
              BODY_SCROLLBAR_WIDTH = $window.innerWidth - bodyElem[0].clientWidth;
              BODY_SCROLLBAR_WIDTH = isFinite(BODY_SCROLLBAR_WIDTH) ? BODY_SCROLLBAR_WIDTH : 0;
              bodyElem.removeClass('uib-position-body-scrollbar-measure');
            }
            return BODY_SCROLLBAR_WIDTH;
          }
          if (angular.isUndefined(SCROLLBAR_WIDTH)) {
            var scrollElem = angular.element('<div class="uib-position-scrollbar-measure"></div>');
            $document.find('body').append(scrollElem);
            SCROLLBAR_WIDTH = scrollElem[0].offsetWidth - scrollElem[0].clientWidth;
            SCROLLBAR_WIDTH = isFinite(SCROLLBAR_WIDTH) ? SCROLLBAR_WIDTH : 0;
            scrollElem.remove();
          }
          return SCROLLBAR_WIDTH;
        },
        scrollbarPadding: function(elem) {
          elem = this.getRawNode(elem);
          var elemStyle = $window.getComputedStyle(elem);
          var paddingRight = this.parseStyle(elemStyle.paddingRight);
          var paddingBottom = this.parseStyle(elemStyle.paddingBottom);
          var scrollParent = this.scrollParent(elem, false, true);
          var scrollbarWidth = this.scrollbarWidth(scrollParent, BODY_REGEX.test(scrollParent.tagName));
          return {
            scrollbarWidth: scrollbarWidth,
            widthOverflow: scrollParent.scrollWidth > scrollParent.clientWidth,
            right: paddingRight + scrollbarWidth,
            originalRight: paddingRight,
            heightOverflow: scrollParent.scrollHeight > scrollParent.clientHeight,
            bottom: paddingBottom + scrollbarWidth,
            originalBottom: paddingBottom
          };
        },
        isScrollable: function(elem, includeHidden) {
          elem = this.getRawNode(elem);
          var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;
          var elemStyle = $window.getComputedStyle(elem);
          return overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX);
        },
        scrollParent: function(elem, includeHidden, includeSelf) {
          elem = this.getRawNode(elem);
          var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;
          var documentEl = $document[0].documentElement;
          var elemStyle = $window.getComputedStyle(elem);
          if (includeSelf && overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX)) {
            return elem;
          }
          var excludeStatic = elemStyle.position === 'absolute';
          var scrollParent = elem.parentElement || documentEl;
          if (scrollParent === documentEl || elemStyle.position === 'fixed') {
            return documentEl;
          }
          while (scrollParent.parentElement && scrollParent !== documentEl) {
            var spStyle = $window.getComputedStyle(scrollParent);
            if (excludeStatic && spStyle.position !== 'static') {
              excludeStatic = false;
            }
            if (!excludeStatic && overflowRegex.test(spStyle.overflow + spStyle.overflowY + spStyle.overflowX)) {
              break;
            }
            scrollParent = scrollParent.parentElement;
          }
          return scrollParent;
        },
        position: function(elem, includeMagins) {
          elem = this.getRawNode(elem);
          var elemOffset = this.offset(elem);
          if (includeMagins) {
            var elemStyle = $window.getComputedStyle(elem);
            elemOffset.top -= this.parseStyle(elemStyle.marginTop);
            elemOffset.left -= this.parseStyle(elemStyle.marginLeft);
          }
          var parent = this.offsetParent(elem);
          var parentOffset = {
            top: 0,
            left: 0
          };
          if (parent !== $document[0].documentElement) {
            parentOffset = this.offset(parent);
            parentOffset.top += parent.clientTop - parent.scrollTop;
            parentOffset.left += parent.clientLeft - parent.scrollLeft;
          }
          return {
            width: Math.round(angular.isNumber(elemOffset.width) ? elemOffset.width : elem.offsetWidth),
            height: Math.round(angular.isNumber(elemOffset.height) ? elemOffset.height : elem.offsetHeight),
            top: Math.round(elemOffset.top - parentOffset.top),
            left: Math.round(elemOffset.left - parentOffset.left)
          };
        },
        offset: function(elem) {
          elem = this.getRawNode(elem);
          var elemBCR = elem.getBoundingClientRect();
          return {
            width: Math.round(angular.isNumber(elemBCR.width) ? elemBCR.width : elem.offsetWidth),
            height: Math.round(angular.isNumber(elemBCR.height) ? elemBCR.height : elem.offsetHeight),
            top: Math.round(elemBCR.top + ($window.pageYOffset || $document[0].documentElement.scrollTop)),
            left: Math.round(elemBCR.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft))
          };
        },
        viewportOffset: function(elem, useDocument, includePadding) {
          elem = this.getRawNode(elem);
          includePadding = includePadding !== false ? true : false;
          var elemBCR = elem.getBoundingClientRect();
          var offsetBCR = {
            top: 0,
            left: 0,
            bottom: 0,
            right: 0
          };
          var offsetParent = useDocument ? $document[0].documentElement : this.scrollParent(elem);
          var offsetParentBCR = offsetParent.getBoundingClientRect();
          offsetBCR.top = offsetParentBCR.top + offsetParent.clientTop;
          offsetBCR.left = offsetParentBCR.left + offsetParent.clientLeft;
          if (offsetParent === $document[0].documentElement) {
            offsetBCR.top += $window.pageYOffset;
            offsetBCR.left += $window.pageXOffset;
          }
          offsetBCR.bottom = offsetBCR.top + offsetParent.clientHeight;
          offsetBCR.right = offsetBCR.left + offsetParent.clientWidth;
          if (includePadding) {
            var offsetParentStyle = $window.getComputedStyle(offsetParent);
            offsetBCR.top += this.parseStyle(offsetParentStyle.paddingTop);
            offsetBCR.bottom -= this.parseStyle(offsetParentStyle.paddingBottom);
            offsetBCR.left += this.parseStyle(offsetParentStyle.paddingLeft);
            offsetBCR.right -= this.parseStyle(offsetParentStyle.paddingRight);
          }
          return {
            top: Math.round(elemBCR.top - offsetBCR.top),
            bottom: Math.round(offsetBCR.bottom - elemBCR.bottom),
            left: Math.round(elemBCR.left - offsetBCR.left),
            right: Math.round(offsetBCR.right - elemBCR.right)
          };
        },
        parsePlacement: function(placement) {
          var autoPlace = PLACEMENT_REGEX.auto.test(placement);
          if (autoPlace) {
            placement = placement.replace(PLACEMENT_REGEX.auto, '');
          }
          placement = placement.split('-');
          placement[0] = placement[0] || 'top';
          if (!PLACEMENT_REGEX.primary.test(placement[0])) {
            placement[0] = 'top';
          }
          placement[1] = placement[1] || 'center';
          if (!PLACEMENT_REGEX.secondary.test(placement[1])) {
            placement[1] = 'center';
          }
          if (autoPlace) {
            placement[2] = true;
          } else {
            placement[2] = false;
          }
          return placement;
        },
        positionElements: function(hostElem, targetElem, placement, appendToBody) {
          hostElem = this.getRawNode(hostElem);
          targetElem = this.getRawNode(targetElem);
          var targetWidth = angular.isDefined(targetElem.offsetWidth) ? targetElem.offsetWidth : targetElem.prop('offsetWidth');
          var targetHeight = angular.isDefined(targetElem.offsetHeight) ? targetElem.offsetHeight : targetElem.prop('offsetHeight');
          placement = this.parsePlacement(placement);
          var hostElemPos = appendToBody ? this.offset(hostElem) : this.position(hostElem);
          var targetElemPos = {
            top: 0,
            left: 0,
            placement: ''
          };
          if (placement[2]) {
            var viewportOffset = this.viewportOffset(hostElem, appendToBody);
            var targetElemStyle = $window.getComputedStyle(targetElem);
            var adjustedSize = {
              width: targetWidth + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginLeft) + this.parseStyle(targetElemStyle.marginRight))),
              height: targetHeight + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginTop) + this.parseStyle(targetElemStyle.marginBottom)))
            };
            placement[0] = placement[0] === 'top' && adjustedSize.height > viewportOffset.top && adjustedSize.height <= viewportOffset.bottom ? 'bottom' : placement[0] === 'bottom' && adjustedSize.height > viewportOffset.bottom && adjustedSize.height <= viewportOffset.top ? 'top' : placement[0] === 'left' && adjustedSize.width > viewportOffset.left && adjustedSize.width <= viewportOffset.right ? 'right' : placement[0] === 'right' && adjustedSize.width > viewportOffset.right && adjustedSize.width <= viewportOffset.left ? 'left' : placement[0];
            placement[1] = placement[1] === 'top' && adjustedSize.height - hostElemPos.height > viewportOffset.bottom && adjustedSize.height - hostElemPos.height <= viewportOffset.top ? 'bottom' : placement[1] === 'bottom' && adjustedSize.height - hostElemPos.height > viewportOffset.top && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom ? 'top' : placement[1] === 'left' && adjustedSize.width - hostElemPos.width > viewportOffset.right && adjustedSize.width - hostElemPos.width <= viewportOffset.left ? 'right' : placement[1] === 'right' && adjustedSize.width - hostElemPos.width > viewportOffset.left && adjustedSize.width - hostElemPos.width <= viewportOffset.right ? 'left' : placement[1];
            if (placement[1] === 'center') {
              if (PLACEMENT_REGEX.vertical.test(placement[0])) {
                var xOverflow = hostElemPos.width / 2 - targetWidth / 2;
                if (viewportOffset.left + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.right) {
                  placement[1] = 'left';
                } else if (viewportOffset.right + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.left) {
                  placement[1] = 'right';
                }
              } else {
                var yOverflow = hostElemPos.height / 2 - adjustedSize.height / 2;
                if (viewportOffset.top + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom) {
                  placement[1] = 'top';
                } else if (viewportOffset.bottom + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.top) {
                  placement[1] = 'bottom';
                }
              }
            }
          }
          switch (placement[0]) {
            case 'top':
              targetElemPos.top = hostElemPos.top - targetHeight;
              break;
            case 'bottom':
              targetElemPos.top = hostElemPos.top + hostElemPos.height;
              break;
            case 'left':
              targetElemPos.left = hostElemPos.left - targetWidth;
              break;
            case 'right':
              targetElemPos.left = hostElemPos.left + hostElemPos.width;
              break;
          }
          switch (placement[1]) {
            case 'top':
              targetElemPos.top = hostElemPos.top;
              break;
            case 'bottom':
              targetElemPos.top = hostElemPos.top + hostElemPos.height - targetHeight;
              break;
            case 'left':
              targetElemPos.left = hostElemPos.left;
              break;
            case 'right':
              targetElemPos.left = hostElemPos.left + hostElemPos.width - targetWidth;
              break;
            case 'center':
              if (PLACEMENT_REGEX.vertical.test(placement[0])) {
                targetElemPos.left = hostElemPos.left + hostElemPos.width / 2 - targetWidth / 2;
              } else {
                targetElemPos.top = hostElemPos.top + hostElemPos.height / 2 - targetHeight / 2;
              }
              break;
          }
          targetElemPos.top = Math.round(targetElemPos.top);
          targetElemPos.left = Math.round(targetElemPos.left);
          targetElemPos.placement = placement[1] === 'center' ? placement[0] : placement[0] + '-' + placement[1];
          return targetElemPos;
        },
        adjustTop: function(placementClasses, containerPosition, initialHeight, currentHeight) {
          if (placementClasses.indexOf('top') !== -1 && initialHeight !== currentHeight) {
            return {top: containerPosition.top - currentHeight + 'px'};
          }
        },
        positionArrow: function(elem, placement) {
          elem = this.getRawNode(elem);
          var innerElem = elem.querySelector('.tooltip-inner, .popover-inner');
          if (!innerElem) {
            return;
          }
          var isTooltip = angular.element(innerElem).hasClass('tooltip-inner');
          var arrowElem = isTooltip ? elem.querySelector('.tooltip-arrow') : elem.querySelector('.arrow');
          if (!arrowElem) {
            return;
          }
          var arrowCss = {
            top: '',
            bottom: '',
            left: '',
            right: ''
          };
          placement = this.parsePlacement(placement);
          if (placement[1] === 'center') {
            angular.element(arrowElem).css(arrowCss);
            return;
          }
          var borderProp = 'border-' + placement[0] + '-width';
          var borderWidth = $window.getComputedStyle(arrowElem)[borderProp];
          var borderRadiusProp = 'border-';
          if (PLACEMENT_REGEX.vertical.test(placement[0])) {
            borderRadiusProp += placement[0] + '-' + placement[1];
          } else {
            borderRadiusProp += placement[1] + '-' + placement[0];
          }
          borderRadiusProp += '-radius';
          var borderRadius = $window.getComputedStyle(isTooltip ? innerElem : elem)[borderRadiusProp];
          switch (placement[0]) {
            case 'top':
              arrowCss.bottom = isTooltip ? '0' : '-' + borderWidth;
              break;
            case 'bottom':
              arrowCss.top = isTooltip ? '0' : '-' + borderWidth;
              break;
            case 'left':
              arrowCss.right = isTooltip ? '0' : '-' + borderWidth;
              break;
            case 'right':
              arrowCss.left = isTooltip ? '0' : '-' + borderWidth;
              break;
          }
          arrowCss[placement[1]] = borderRadius;
          angular.element(arrowElem).css(arrowCss);
        }
      };
    }]);
    angular.module('ui.bootstrap.datepickerPopup', ['ui.bootstrap.datepicker', 'ui.bootstrap.position']).value('$datepickerPopupLiteralWarning', true).constant('uibDatepickerPopupConfig', {
      altInputFormats: [],
      appendToBody: false,
      clearText: 'Clear',
      closeOnDateSelection: true,
      closeText: 'Done',
      currentText: 'Today',
      datepickerPopup: 'yyyy-MM-dd',
      datepickerPopupTemplateUrl: 'uib/template/datepickerPopup/popup.html',
      datepickerTemplateUrl: 'uib/template/datepicker/datepicker.html',
      html5Types: {
        date: 'yyyy-MM-dd',
        'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',
        'month': 'yyyy-MM'
      },
      onOpenFocus: true,
      showButtonBar: true,
      placement: 'auto bottom-left'
    }).controller('UibDatepickerPopupController', ['$scope', '$element', '$attrs', '$compile', '$log', '$parse', '$window', '$document', '$rootScope', '$uibPosition', 'dateFilter', 'uibDateParser', 'uibDatepickerPopupConfig', '$timeout', 'uibDatepickerConfig', '$datepickerPopupLiteralWarning', function($scope, $element, $attrs, $compile, $log, $parse, $window, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout, datepickerConfig, $datepickerPopupLiteralWarning) {
      var cache = {},
          isHtml5DateInput = false;
      var dateFormat,
          closeOnDateSelection,
          appendToBody,
          onOpenFocus,
          datepickerPopupTemplateUrl,
          datepickerTemplateUrl,
          popupEl,
          datepickerEl,
          scrollParentEl,
          ngModel,
          ngModelOptions,
          $popup,
          altInputFormats,
          watchListeners = [];
      this.init = function(_ngModel_) {
        ngModel = _ngModel_;
        ngModelOptions = _ngModel_.$options;
        closeOnDateSelection = angular.isDefined($attrs.closeOnDateSelection) ? $scope.$parent.$eval($attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection;
        appendToBody = angular.isDefined($attrs.datepickerAppendToBody) ? $scope.$parent.$eval($attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody;
        onOpenFocus = angular.isDefined($attrs.onOpenFocus) ? $scope.$parent.$eval($attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus;
        datepickerPopupTemplateUrl = angular.isDefined($attrs.datepickerPopupTemplateUrl) ? $attrs.datepickerPopupTemplateUrl : datepickerPopupConfig.datepickerPopupTemplateUrl;
        datepickerTemplateUrl = angular.isDefined($attrs.datepickerTemplateUrl) ? $attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl;
        altInputFormats = angular.isDefined($attrs.altInputFormats) ? $scope.$parent.$eval($attrs.altInputFormats) : datepickerPopupConfig.altInputFormats;
        $scope.showButtonBar = angular.isDefined($attrs.showButtonBar) ? $scope.$parent.$eval($attrs.showButtonBar) : datepickerPopupConfig.showButtonBar;
        if (datepickerPopupConfig.html5Types[$attrs.type]) {
          dateFormat = datepickerPopupConfig.html5Types[$attrs.type];
          isHtml5DateInput = true;
        } else {
          dateFormat = $attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup;
          $attrs.$observe('uibDatepickerPopup', function(value, oldValue) {
            var newDateFormat = value || datepickerPopupConfig.datepickerPopup;
            if (newDateFormat !== dateFormat) {
              dateFormat = newDateFormat;
              ngModel.$modelValue = null;
              if (!dateFormat) {
                throw new Error('uibDatepickerPopup must have a date format specified.');
              }
            }
          });
        }
        if (!dateFormat) {
          throw new Error('uibDatepickerPopup must have a date format specified.');
        }
        if (isHtml5DateInput && $attrs.uibDatepickerPopup) {
          throw new Error('HTML5 date input types do not support custom formats.');
        }
        popupEl = angular.element('<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>');
        popupEl.attr({
          'ng-model': 'date',
          'ng-change': 'dateSelection(date)',
          'template-url': datepickerPopupTemplateUrl
        });
        datepickerEl = angular.element(popupEl.children()[0]);
        datepickerEl.attr('template-url', datepickerTemplateUrl);
        if (!$scope.datepickerOptions) {
          $scope.datepickerOptions = {};
        }
        if (isHtml5DateInput) {
          if ($attrs.type === 'month') {
            $scope.datepickerOptions.datepickerMode = 'month';
            $scope.datepickerOptions.minMode = 'month';
          }
        }
        datepickerEl.attr('datepicker-options', 'datepickerOptions');
        if (!isHtml5DateInput) {
          ngModel.$$parserName = 'date';
          ngModel.$validators.date = validator;
          ngModel.$parsers.unshift(parseDate);
          ngModel.$formatters.push(function(value) {
            if (ngModel.$isEmpty(value)) {
              $scope.date = value;
              return value;
            }
            if (angular.isNumber(value)) {
              value = new Date(value);
            }
            $scope.date = value;
            return dateParser.filter($scope.date, dateFormat);
          });
        } else {
          ngModel.$formatters.push(function(value) {
            $scope.date = value;
            return value;
          });
        }
        ngModel.$viewChangeListeners.push(function() {
          $scope.date = parseDateString(ngModel.$viewValue);
        });
        $element.on('keydown', inputKeydownBind);
        $popup = $compile(popupEl)($scope);
        popupEl.remove();
        if (appendToBody) {
          $document.find('body').append($popup);
        } else {
          $element.after($popup);
        }
        $scope.$on('$destroy', function() {
          if ($scope.isOpen === true) {
            if (!$rootScope.$$phase) {
              $scope.$apply(function() {
                $scope.isOpen = false;
              });
            }
          }
          $popup.remove();
          $element.off('keydown', inputKeydownBind);
          $document.off('click', documentClickBind);
          if (scrollParentEl) {
            scrollParentEl.off('scroll', positionPopup);
          }
          angular.element($window).off('resize', positionPopup);
          while (watchListeners.length) {
            watchListeners.shift()();
          }
        });
      };
      $scope.getText = function(key) {
        return $scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];
      };
      $scope.isDisabled = function(date) {
        if (date === 'today') {
          date = new Date();
        }
        var dates = {};
        angular.forEach(['minDate', 'maxDate'], function(key) {
          if (!$scope.datepickerOptions[key]) {
            dates[key] = null;
          } else if (angular.isDate($scope.datepickerOptions[key])) {
            dates[key] = new Date($scope.datepickerOptions[key]);
          } else {
            if ($datepickerPopupLiteralWarning) {
              $log.warn('Literal date support has been deprecated, please switch to date object usage');
            }
            dates[key] = new Date(dateFilter($scope.datepickerOptions[key], 'medium'));
          }
        });
        return $scope.datepickerOptions && dates.minDate && $scope.compare(date, dates.minDate) < 0 || dates.maxDate && $scope.compare(date, dates.maxDate) > 0;
      };
      $scope.compare = function(date1, date2) {
        return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
      };
      $scope.dateSelection = function(dt) {
        $scope.date = dt;
        var date = $scope.date ? dateParser.filter($scope.date, dateFormat) : null;
        $element.val(date);
        ngModel.$setViewValue(date);
        if (closeOnDateSelection) {
          $scope.isOpen = false;
          $element[0].focus();
        }
      };
      $scope.keydown = function(evt) {
        if (evt.which === 27) {
          evt.stopPropagation();
          $scope.isOpen = false;
          $element[0].focus();
        }
      };
      $scope.select = function(date, evt) {
        evt.stopPropagation();
        if (date === 'today') {
          var today = new Date();
          if (angular.isDate($scope.date)) {
            date = new Date($scope.date);
            date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());
          } else {
            date = new Date(today.setHours(0, 0, 0, 0));
          }
        }
        $scope.dateSelection(date);
      };
      $scope.close = function(evt) {
        evt.stopPropagation();
        $scope.isOpen = false;
        $element[0].focus();
      };
      $scope.disabled = angular.isDefined($attrs.disabled) || false;
      if ($attrs.ngDisabled) {
        watchListeners.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(disabled) {
          $scope.disabled = disabled;
        }));
      }
      $scope.$watch('isOpen', function(value) {
        if (value) {
          if (!$scope.disabled) {
            $timeout(function() {
              positionPopup();
              if (onOpenFocus) {
                $scope.$broadcast('uib:datepicker.focus');
              }
              $document.on('click', documentClickBind);
              var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;
              if (appendToBody || $position.parsePlacement(placement)[2]) {
                scrollParentEl = scrollParentEl || angular.element($position.scrollParent($element));
                if (scrollParentEl) {
                  scrollParentEl.on('scroll', positionPopup);
                }
              } else {
                scrollParentEl = null;
              }
              angular.element($window).on('resize', positionPopup);
            }, 0, false);
          } else {
            $scope.isOpen = false;
          }
        } else {
          $document.off('click', documentClickBind);
          if (scrollParentEl) {
            scrollParentEl.off('scroll', positionPopup);
          }
          angular.element($window).off('resize', positionPopup);
        }
      });
      function cameltoDash(string) {
        return string.replace(/([A-Z])/g, function($1) {
          return '-' + $1.toLowerCase();
        });
      }
      function parseDateString(viewValue) {
        var date = dateParser.parse(viewValue, dateFormat, $scope.date);
        if (isNaN(date)) {
          for (var i = 0; i < altInputFormats.length; i++) {
            date = dateParser.parse(viewValue, altInputFormats[i], $scope.date);
            if (!isNaN(date)) {
              return date;
            }
          }
        }
        return date;
      }
      function parseDate(viewValue) {
        if (angular.isNumber(viewValue)) {
          viewValue = new Date(viewValue);
        }
        if (!viewValue) {
          return null;
        }
        if (angular.isDate(viewValue) && !isNaN(viewValue)) {
          return viewValue;
        }
        if (angular.isString(viewValue)) {
          var date = parseDateString(viewValue);
          if (!isNaN(date)) {
            return date;
          }
        }
        return ngModel.$options && ngModel.$options.allowInvalid ? viewValue : undefined;
      }
      function validator(modelValue, viewValue) {
        var value = modelValue || viewValue;
        if (!$attrs.ngRequired && !value) {
          return true;
        }
        if (angular.isNumber(value)) {
          value = new Date(value);
        }
        if (!value) {
          return true;
        }
        if (angular.isDate(value) && !isNaN(value)) {
          return true;
        }
        if (angular.isString(value)) {
          return !isNaN(parseDateString(value));
        }
        return false;
      }
      function documentClickBind(event) {
        if (!$scope.isOpen && $scope.disabled) {
          return;
        }
        var popup = $popup[0];
        var dpContainsTarget = $element[0].contains(event.target);
        var popupContainsTarget = popup.contains !== undefined && popup.contains(event.target);
        if ($scope.isOpen && !(dpContainsTarget || popupContainsTarget)) {
          $scope.$apply(function() {
            $scope.isOpen = false;
          });
        }
      }
      function inputKeydownBind(evt) {
        if (evt.which === 27 && $scope.isOpen) {
          evt.preventDefault();
          evt.stopPropagation();
          $scope.$apply(function() {
            $scope.isOpen = false;
          });
          $element[0].focus();
        } else if (evt.which === 40 && !$scope.isOpen) {
          evt.preventDefault();
          evt.stopPropagation();
          $scope.$apply(function() {
            $scope.isOpen = true;
          });
        }
      }
      function positionPopup() {
        if ($scope.isOpen) {
          var dpElement = angular.element($popup[0].querySelector('.uib-datepicker-popup'));
          var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;
          var position = $position.positionElements($element, dpElement, placement, appendToBody);
          dpElement.css({
            top: position.top + 'px',
            left: position.left + 'px'
          });
          if (dpElement.hasClass('uib-position-measure')) {
            dpElement.removeClass('uib-position-measure');
          }
        }
      }
      $scope.$on('uib:datepicker.mode', function() {
        $timeout(positionPopup, 0, false);
      });
    }]).directive('uibDatepickerPopup', function() {
      return {
        require: ['ngModel', 'uibDatepickerPopup'],
        controller: 'UibDatepickerPopupController',
        scope: {
          datepickerOptions: '=?',
          isOpen: '=?',
          currentText: '@',
          clearText: '@',
          closeText: '@'
        },
        link: function(scope, element, attrs, ctrls) {
          var ngModel = ctrls[0],
              ctrl = ctrls[1];
          ctrl.init(ngModel);
        }
      };
    }).directive('uibDatepickerPopupWrap', function() {
      return {
        restrict: 'A',
        transclude: true,
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'uib/template/datepickerPopup/popup.html';
        }
      };
    });
    angular.module('ui.bootstrap.debounce', []).factory('$$debounce', ['$timeout', function($timeout) {
      return function(callback, debounceTime) {
        var timeoutPromise;
        return function() {
          var self = this;
          var args = Array.prototype.slice.call(arguments);
          if (timeoutPromise) {
            $timeout.cancel(timeoutPromise);
          }
          timeoutPromise = $timeout(function() {
            callback.apply(self, args);
          }, debounceTime);
        };
      };
    }]);
    angular.module('ui.bootstrap.dropdown', ['ui.bootstrap.position']).constant('uibDropdownConfig', {
      appendToOpenClass: 'uib-dropdown-open',
      openClass: 'open'
    }).service('uibDropdownService', ['$document', '$rootScope', function($document, $rootScope) {
      var openScope = null;
      this.open = function(dropdownScope, element) {
        if (!openScope) {
          $document.on('click', closeDropdown);
        }
        if (openScope && openScope !== dropdownScope) {
          openScope.isOpen = false;
        }
        openScope = dropdownScope;
      };
      this.close = function(dropdownScope, element) {
        if (openScope === dropdownScope) {
          openScope = null;
          $document.off('click', closeDropdown);
          var dropdownMenu = dropdownScope.getDropdownElement();
          if (dropdownMenu) {
            dropdownMenu.off('keydown', this.keybindFilter);
          }
        }
      };
      var closeDropdown = function(evt) {
        if (!openScope) {
          return;
        }
        if (evt && openScope.getAutoClose() === 'disabled') {
          return;
        }
        if (evt && evt.which === 3) {
          return;
        }
        var toggleElement = openScope.getToggleElement();
        if (evt && toggleElement && toggleElement[0].contains(evt.target)) {
          return;
        }
        var dropdownElement = openScope.getDropdownElement();
        if (evt && openScope.getAutoClose() === 'outsideClick' && dropdownElement && dropdownElement[0].contains(evt.target)) {
          return;
        }
        openScope.isOpen = false;
        openScope.focusToggleElement();
        if (!$rootScope.$$phase) {
          openScope.$apply();
        }
      };
      this.keybindFilter = function(evt) {
        if (evt.which === 27) {
          evt.stopPropagation();
          openScope.focusToggleElement();
          closeDropdown();
        } else if (openScope.isKeynavEnabled() && [38, 40].indexOf(evt.which) !== -1 && openScope.isOpen) {
          evt.preventDefault();
          evt.stopPropagation();
          openScope.focusDropdownEntry(evt.which);
        }
      };
    }]).controller('UibDropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {
      var self = this,
          scope = $scope.$new(),
          templateScope,
          appendToOpenClass = dropdownConfig.appendToOpenClass,
          openClass = dropdownConfig.openClass,
          getIsOpen,
          setIsOpen = angular.noop,
          toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,
          appendToBody = false,
          appendTo = null,
          keynavEnabled = false,
          selectedOption = null,
          body = $document.find('body');
      $element.addClass('dropdown');
      this.init = function() {
        if ($attrs.isOpen) {
          getIsOpen = $parse($attrs.isOpen);
          setIsOpen = getIsOpen.assign;
          $scope.$watch(getIsOpen, function(value) {
            scope.isOpen = !!value;
          });
        }
        if (angular.isDefined($attrs.dropdownAppendTo)) {
          var appendToEl = $parse($attrs.dropdownAppendTo)(scope);
          if (appendToEl) {
            appendTo = angular.element(appendToEl);
          }
        }
        appendToBody = angular.isDefined($attrs.dropdownAppendToBody);
        keynavEnabled = angular.isDefined($attrs.keyboardNav);
        if (appendToBody && !appendTo) {
          appendTo = body;
        }
        if (appendTo && self.dropdownMenu) {
          appendTo.append(self.dropdownMenu);
          $element.on('$destroy', function handleDestroyEvent() {
            self.dropdownMenu.remove();
          });
        }
      };
      this.toggle = function(open) {
        scope.isOpen = arguments.length ? !!open : !scope.isOpen;
        if (angular.isFunction(setIsOpen)) {
          setIsOpen(scope, scope.isOpen);
        }
        return scope.isOpen;
      };
      this.isOpen = function() {
        return scope.isOpen;
      };
      scope.getToggleElement = function() {
        return self.toggleElement;
      };
      scope.getAutoClose = function() {
        return $attrs.autoClose || 'always';
      };
      scope.getElement = function() {
        return $element;
      };
      scope.isKeynavEnabled = function() {
        return keynavEnabled;
      };
      scope.focusDropdownEntry = function(keyCode) {
        var elems = self.dropdownMenu ? angular.element(self.dropdownMenu).find('a') : $element.find('ul').eq(0).find('a');
        switch (keyCode) {
          case 40:
            {
              if (!angular.isNumber(self.selectedOption)) {
                self.selectedOption = 0;
              } else {
                self.selectedOption = self.selectedOption === elems.length - 1 ? self.selectedOption : self.selectedOption + 1;
              }
              break;
            }
          case 38:
            {
              if (!angular.isNumber(self.selectedOption)) {
                self.selectedOption = elems.length - 1;
              } else {
                self.selectedOption = self.selectedOption === 0 ? 0 : self.selectedOption - 1;
              }
              break;
            }
        }
        elems[self.selectedOption].focus();
      };
      scope.getDropdownElement = function() {
        return self.dropdownMenu;
      };
      scope.focusToggleElement = function() {
        if (self.toggleElement) {
          self.toggleElement[0].focus();
        }
      };
      scope.$watch('isOpen', function(isOpen, wasOpen) {
        if (appendTo && self.dropdownMenu) {
          var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true),
              css,
              rightalign,
              scrollbarPadding,
              scrollbarWidth = 0;
          css = {
            top: pos.top + 'px',
            display: isOpen ? 'block' : 'none'
          };
          rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');
          if (!rightalign) {
            css.left = pos.left + 'px';
            css.right = 'auto';
          } else {
            css.left = 'auto';
            scrollbarPadding = $position.scrollbarPadding(appendTo);
            if (scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {
              scrollbarWidth = scrollbarPadding.scrollbarWidth;
            }
            css.right = window.innerWidth - scrollbarWidth - (pos.left + $element.prop('offsetWidth')) + 'px';
          }
          if (!appendToBody) {
            var appendOffset = $position.offset(appendTo);
            css.top = pos.top - appendOffset.top + 'px';
            if (!rightalign) {
              css.left = pos.left - appendOffset.left + 'px';
            } else {
              css.right = window.innerWidth - (pos.left - appendOffset.left + $element.prop('offsetWidth')) + 'px';
            }
          }
          self.dropdownMenu.css(css);
        }
        var openContainer = appendTo ? appendTo : $element;
        var hasOpenClass = openContainer.hasClass(appendTo ? appendToOpenClass : openClass);
        if (hasOpenClass === !isOpen) {
          $animate[isOpen ? 'addClass' : 'removeClass'](openContainer, appendTo ? appendToOpenClass : openClass).then(function() {
            if (angular.isDefined(isOpen) && isOpen !== wasOpen) {
              toggleInvoker($scope, {open: !!isOpen});
            }
          });
        }
        if (isOpen) {
          if (self.dropdownMenuTemplateUrl) {
            $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {
              templateScope = scope.$new();
              $compile(tplContent.trim())(templateScope, function(dropdownElement) {
                var newEl = dropdownElement;
                self.dropdownMenu.replaceWith(newEl);
                self.dropdownMenu = newEl;
                self.dropdownMenu.on('keydown', uibDropdownService.keybindFilter);
              });
            });
          } else {
            if (self.dropdownMenu) {
              self.dropdownMenu.on('keydown', uibDropdownService.keybindFilter);
            }
          }
          scope.focusToggleElement();
          uibDropdownService.open(scope, $element);
        } else {
          uibDropdownService.close(scope, $element);
          if (self.dropdownMenuTemplateUrl) {
            if (templateScope) {
              templateScope.$destroy();
            }
            var newEl = angular.element('<ul class="dropdown-menu"></ul>');
            self.dropdownMenu.replaceWith(newEl);
            self.dropdownMenu = newEl;
          }
          self.selectedOption = null;
        }
        if (angular.isFunction(setIsOpen)) {
          setIsOpen($scope, isOpen);
        }
      });
    }]).directive('uibDropdown', function() {
      return {
        controller: 'UibDropdownController',
        link: function(scope, element, attrs, dropdownCtrl) {
          dropdownCtrl.init();
        }
      };
    }).directive('uibDropdownMenu', function() {
      return {
        restrict: 'A',
        require: '?^uibDropdown',
        link: function(scope, element, attrs, dropdownCtrl) {
          if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {
            return;
          }
          element.addClass('dropdown-menu');
          var tplUrl = attrs.templateUrl;
          if (tplUrl) {
            dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;
          }
          if (!dropdownCtrl.dropdownMenu) {
            dropdownCtrl.dropdownMenu = element;
          }
        }
      };
    }).directive('uibDropdownToggle', function() {
      return {
        require: '?^uibDropdown',
        link: function(scope, element, attrs, dropdownCtrl) {
          if (!dropdownCtrl) {
            return;
          }
          element.addClass('dropdown-toggle');
          dropdownCtrl.toggleElement = element;
          var toggleDropdown = function(event) {
            event.preventDefault();
            if (!element.hasClass('disabled') && !attrs.disabled) {
              scope.$apply(function() {
                dropdownCtrl.toggle();
              });
            }
          };
          element.bind('click', toggleDropdown);
          element.attr({
            'aria-haspopup': true,
            'aria-expanded': false
          });
          scope.$watch(dropdownCtrl.isOpen, function(isOpen) {
            element.attr('aria-expanded', !!isOpen);
          });
          scope.$on('$destroy', function() {
            element.unbind('click', toggleDropdown);
          });
        }
      };
    });
    angular.module('ui.bootstrap.stackedMap', []).factory('$$stackedMap', function() {
      return {createNew: function() {
          var stack = [];
          return {
            add: function(key, value) {
              stack.push({
                key: key,
                value: value
              });
            },
            get: function(key) {
              for (var i = 0; i < stack.length; i++) {
                if (key === stack[i].key) {
                  return stack[i];
                }
              }
            },
            keys: function() {
              var keys = [];
              for (var i = 0; i < stack.length; i++) {
                keys.push(stack[i].key);
              }
              return keys;
            },
            top: function() {
              return stack[stack.length - 1];
            },
            remove: function(key) {
              var idx = -1;
              for (var i = 0; i < stack.length; i++) {
                if (key === stack[i].key) {
                  idx = i;
                  break;
                }
              }
              return stack.splice(idx, 1)[0];
            },
            removeTop: function() {
              return stack.pop();
            },
            length: function() {
              return stack.length;
            }
          };
        }};
    });
    angular.module('ui.bootstrap.modal', ['ui.bootstrap.stackedMap', 'ui.bootstrap.position']).factory('$$multiMap', function() {
      return {createNew: function() {
          var map = {};
          return {
            entries: function() {
              return Object.keys(map).map(function(key) {
                return {
                  key: key,
                  value: map[key]
                };
              });
            },
            get: function(key) {
              return map[key];
            },
            hasKey: function(key) {
              return !!map[key];
            },
            keys: function() {
              return Object.keys(map);
            },
            put: function(key, value) {
              if (!map[key]) {
                map[key] = [];
              }
              map[key].push(value);
            },
            remove: function(key, value) {
              var values = map[key];
              if (!values) {
                return;
              }
              var idx = values.indexOf(value);
              if (idx !== -1) {
                values.splice(idx, 1);
              }
              if (!values.length) {
                delete map[key];
              }
            }
          };
        }};
    }).provider('$uibResolve', function() {
      var resolve = this;
      this.resolver = null;
      this.setResolver = function(resolver) {
        this.resolver = resolver;
      };
      this.$get = ['$injector', '$q', function($injector, $q) {
        var resolver = resolve.resolver ? $injector.get(resolve.resolver) : null;
        return {resolve: function(invocables, locals, parent, self) {
            if (resolver) {
              return resolver.resolve(invocables, locals, parent, self);
            }
            var promises = [];
            angular.forEach(invocables, function(value) {
              if (angular.isFunction(value) || angular.isArray(value)) {
                promises.push($q.resolve($injector.invoke(value)));
              } else if (angular.isString(value)) {
                promises.push($q.resolve($injector.get(value)));
              } else {
                promises.push($q.resolve(value));
              }
            });
            return $q.all(promises).then(function(resolves) {
              var resolveObj = {};
              var resolveIter = 0;
              angular.forEach(invocables, function(value, key) {
                resolveObj[key] = resolves[resolveIter++];
              });
              return resolveObj;
            });
          }};
      }];
    }).directive('uibModalBackdrop', ['$animate', '$injector', '$uibModalStack', function($animate, $injector, $modalStack) {
      return {
        restrict: 'A',
        compile: function(tElement, tAttrs) {
          tElement.addClass(tAttrs.backdropClass);
          return linkFn;
        }
      };
      function linkFn(scope, element, attrs) {
        if (attrs.modalInClass) {
          $animate.addClass(element, attrs.modalInClass);
          scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
            var done = setIsAsync();
            if (scope.modalOptions.animation) {
              $animate.removeClass(element, attrs.modalInClass).then(done);
            } else {
              done();
            }
          });
        }
      }
    }]).directive('uibModalWindow', ['$uibModalStack', '$q', '$animateCss', '$document', function($modalStack, $q, $animateCss, $document) {
      return {
        scope: {index: '@'},
        restrict: 'A',
        transclude: true,
        templateUrl: function(tElement, tAttrs) {
          return tAttrs.templateUrl || 'uib/template/modal/window.html';
        },
        link: function(scope, element, attrs) {
          element.addClass(attrs.windowTopClass || '');
          scope.size = attrs.size;
          scope.close = function(evt) {
            var modal = $modalStack.getTop();
            if (modal && modal.value.backdrop && modal.value.backdrop !== 'static' && evt.target === evt.currentTarget) {
              evt.preventDefault();
              evt.stopPropagation();
              $modalStack.dismiss(modal.key, 'backdrop click');
            }
          };
          element.on('click', scope.close);
          scope.$isRendered = true;
          var modalRenderDeferObj = $q.defer();
          scope.$$postDigest(function() {
            modalRenderDeferObj.resolve();
          });
          modalRenderDeferObj.promise.then(function() {
            var animationPromise = null;
            if (attrs.modalInClass) {
              animationPromise = $animateCss(element, {addClass: attrs.modalInClass}).start();
              scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
                var done = setIsAsync();
                $animateCss(element, {removeClass: attrs.modalInClass}).start().then(done);
              });
            }
            $q.when(animationPromise).then(function() {
              var modal = $modalStack.getTop();
              if (modal) {
                $modalStack.modalRendered(modal.key);
              }
              if (!($document[0].activeElement && element[0].contains($document[0].activeElement))) {
                var inputWithAutofocus = element[0].querySelector('[autofocus]');
                if (inputWithAutofocus) {
                  inputWithAutofocus.focus();
                } else {
                  element[0].focus();
                }
              }
            });
          });
        }
      };
    }]).directive('uibModalAnimationClass', function() {
      return {compile: function(tElement, tAttrs) {
          if (tAttrs.modalAnimation) {
            tElement.addClass(tAttrs.uibModalAnimationClass);
          }
        }};
    }).directive('uibModalTransclude', ['$animate', function($animate) {
      return {link: function(scope, element, attrs, controller, transclude) {
          transclude(scope.$parent, function(clone) {
            element.empty();
            $animate.enter(clone, element);
          });
        }};
    }]).factory('$uibModalStack', ['$animate', '$animateCss', '$document', '$compile', '$rootScope', '$q', '$$multiMap', '$$stackedMap', '$uibPosition', function($animate, $animateCss, $document, $compile, $rootScope, $q, $$multiMap, $$stackedMap, $uibPosition) {
      var OPENED_MODAL_CLASS = 'modal-open';
      var backdropDomEl,
          backdropScope;
      var openedWindows = $$stackedMap.createNew();
      var openedClasses = $$multiMap.createNew();
      var $modalStack = {NOW_CLOSING_EVENT: 'modal.stack.now-closing'};
      var topModalIndex = 0;
      var previousTopOpenedModal = null;
      var tabbableSelector = 'a[href], area[href], input:not([disabled]):not([tabindex=\'-1\']), ' + 'button:not([disabled]):not([tabindex=\'-1\']),select:not([disabled]):not([tabindex=\'-1\']), textarea:not([disabled]):not([tabindex=\'-1\']), ' + 'iframe, object, embed, *[tabindex]:not([tabindex=\'-1\']), *[contenteditable=true]';
      var scrollbarPadding;
      function isVisible(element) {
        return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);
      }
      function backdropIndex() {
        var topBackdropIndex = -1;
        var opened = openedWindows.keys();
        for (var i = 0; i < opened.length; i++) {
          if (openedWindows.get(opened[i]).value.backdrop) {
            topBackdropIndex = i;
          }
        }
        if (topBackdropIndex > -1 && topBackdropIndex < topModalIndex) {
          topBackdropIndex = topModalIndex;
        }
        return topBackdropIndex;
      }
      $rootScope.$watch(backdropIndex, function(newBackdropIndex) {
        if (backdropScope) {
          backdropScope.index = newBackdropIndex;
        }
      });
      function removeModalWindow(modalInstance, elementToReceiveFocus) {
        var modalWindow = openedWindows.get(modalInstance).value;
        var appendToElement = modalWindow.appendTo;
        openedWindows.remove(modalInstance);
        previousTopOpenedModal = openedWindows.top();
        if (previousTopOpenedModal) {
          topModalIndex = parseInt(previousTopOpenedModal.value.modalDomEl.attr('index'), 10);
        }
        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {
          var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;
          openedClasses.remove(modalBodyClass, modalInstance);
          var areAnyOpen = openedClasses.hasKey(modalBodyClass);
          appendToElement.toggleClass(modalBodyClass, areAnyOpen);
          if (!areAnyOpen && scrollbarPadding && scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {
            if (scrollbarPadding.originalRight) {
              appendToElement.css({paddingRight: scrollbarPadding.originalRight + 'px'});
            } else {
              appendToElement.css({paddingRight: ''});
            }
            scrollbarPadding = null;
          }
          toggleTopWindowClass(true);
        }, modalWindow.closedDeferred);
        checkRemoveBackdrop();
        if (elementToReceiveFocus && elementToReceiveFocus.focus) {
          elementToReceiveFocus.focus();
        } else if (appendToElement.focus) {
          appendToElement.focus();
        }
      }
      function toggleTopWindowClass(toggleSwitch) {
        var modalWindow;
        if (openedWindows.length() > 0) {
          modalWindow = openedWindows.top().value;
          modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || '', toggleSwitch);
        }
      }
      function checkRemoveBackdrop() {
        if (backdropDomEl && backdropIndex() === -1) {
          var backdropScopeRef = backdropScope;
          removeAfterAnimate(backdropDomEl, backdropScope, function() {
            backdropScopeRef = null;
          });
          backdropDomEl = undefined;
          backdropScope = undefined;
        }
      }
      function removeAfterAnimate(domEl, scope, done, closedDeferred) {
        var asyncDeferred;
        var asyncPromise = null;
        var setIsAsync = function() {
          if (!asyncDeferred) {
            asyncDeferred = $q.defer();
            asyncPromise = asyncDeferred.promise;
          }
          return function asyncDone() {
            asyncDeferred.resolve();
          };
        };
        scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);
        return $q.when(asyncPromise).then(afterAnimating);
        function afterAnimating() {
          if (afterAnimating.done) {
            return;
          }
          afterAnimating.done = true;
          $animate.leave(domEl).then(function() {
            if (done) {
              done();
            }
            domEl.remove();
            if (closedDeferred) {
              closedDeferred.resolve();
            }
          });
          scope.$destroy();
        }
      }
      $document.on('keydown', keydownListener);
      $rootScope.$on('$destroy', function() {
        $document.off('keydown', keydownListener);
      });
      function keydownListener(evt) {
        if (evt.isDefaultPrevented()) {
          return evt;
        }
        var modal = openedWindows.top();
        if (modal) {
          switch (evt.which) {
            case 27:
              {
                if (modal.value.keyboard) {
                  evt.preventDefault();
                  $rootScope.$apply(function() {
                    $modalStack.dismiss(modal.key, 'escape key press');
                  });
                }
                break;
              }
            case 9:
              {
                var list = $modalStack.loadFocusElementList(modal);
                var focusChanged = false;
                if (evt.shiftKey) {
                  if ($modalStack.isFocusInFirstItem(evt, list) || $modalStack.isModalFocused(evt, modal)) {
                    focusChanged = $modalStack.focusLastFocusableElement(list);
                  }
                } else {
                  if ($modalStack.isFocusInLastItem(evt, list)) {
                    focusChanged = $modalStack.focusFirstFocusableElement(list);
                  }
                }
                if (focusChanged) {
                  evt.preventDefault();
                  evt.stopPropagation();
                }
                break;
              }
          }
        }
      }
      $modalStack.open = function(modalInstance, modal) {
        var modalOpener = $document[0].activeElement,
            modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;
        toggleTopWindowClass(false);
        previousTopOpenedModal = openedWindows.top();
        openedWindows.add(modalInstance, {
          deferred: modal.deferred,
          renderDeferred: modal.renderDeferred,
          closedDeferred: modal.closedDeferred,
          modalScope: modal.scope,
          backdrop: modal.backdrop,
          keyboard: modal.keyboard,
          openedClass: modal.openedClass,
          windowTopClass: modal.windowTopClass,
          animation: modal.animation,
          appendTo: modal.appendTo
        });
        openedClasses.put(modalBodyClass, modalInstance);
        var appendToElement = modal.appendTo,
            currBackdropIndex = backdropIndex();
        if (!appendToElement.length) {
          throw new Error('appendTo element not found. Make sure that the element passed is in DOM.');
        }
        if (currBackdropIndex >= 0 && !backdropDomEl) {
          backdropScope = $rootScope.$new(true);
          backdropScope.modalOptions = modal;
          backdropScope.index = currBackdropIndex;
          backdropDomEl = angular.element('<div uib-modal-backdrop="modal-backdrop"></div>');
          backdropDomEl.attr({
            'class': 'modal-backdrop',
            'ng-style': '{\'z-index\': 1040 + (index && 1 || 0) + index*10}',
            'uib-modal-animation-class': 'fade',
            'modal-in-class': 'in'
          });
          if (modal.backdropClass) {
            backdropDomEl.addClass(modal.backdropClass);
          }
          if (modal.animation) {
            backdropDomEl.attr('modal-animation', 'true');
          }
          $compile(backdropDomEl)(backdropScope);
          $animate.enter(backdropDomEl, appendToElement);
          if ($uibPosition.isScrollable(appendToElement)) {
            scrollbarPadding = $uibPosition.scrollbarPadding(appendToElement);
            if (scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {
              appendToElement.css({paddingRight: scrollbarPadding.right + 'px'});
            }
          }
        }
        topModalIndex = previousTopOpenedModal ? parseInt(previousTopOpenedModal.value.modalDomEl.attr('index'), 10) + 1 : 0;
        var angularDomEl = angular.element('<div uib-modal-window="modal-window"></div>');
        angularDomEl.attr({
          'class': 'modal',
          'template-url': modal.windowTemplateUrl,
          'window-top-class': modal.windowTopClass,
          'role': 'dialog',
          'size': modal.size,
          'index': topModalIndex,
          'animate': 'animate',
          'ng-style': '{\'z-index\': 1050 + index*10, display: \'block\'}',
          'tabindex': -1,
          'uib-modal-animation-class': 'fade',
          'modal-in-class': 'in'
        }).html(modal.content);
        if (modal.windowClass) {
          angularDomEl.addClass(modal.windowClass);
        }
        if (modal.animation) {
          angularDomEl.attr('modal-animation', 'true');
        }
        appendToElement.addClass(modalBodyClass);
        $animate.enter($compile(angularDomEl)(modal.scope), appendToElement);
        openedWindows.top().value.modalDomEl = angularDomEl;
        openedWindows.top().value.modalOpener = modalOpener;
      };
      function broadcastClosing(modalWindow, resultOrReason, closing) {
        return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;
      }
      $modalStack.close = function(modalInstance, result) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow && broadcastClosing(modalWindow, result, true)) {
          modalWindow.value.modalScope.$$uibDestructionScheduled = true;
          modalWindow.value.deferred.resolve(result);
          removeModalWindow(modalInstance, modalWindow.value.modalOpener);
          return true;
        }
        return !modalWindow;
      };
      $modalStack.dismiss = function(modalInstance, reason) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow && broadcastClosing(modalWindow, reason, false)) {
          modalWindow.value.modalScope.$$uibDestructionScheduled = true;
          modalWindow.value.deferred.reject(reason);
          removeModalWindow(modalInstance, modalWindow.value.modalOpener);
          return true;
        }
        return !modalWindow;
      };
      $modalStack.dismissAll = function(reason) {
        var topModal = this.getTop();
        while (topModal && this.dismiss(topModal.key, reason)) {
          topModal = this.getTop();
        }
      };
      $modalStack.getTop = function() {
        return openedWindows.top();
      };
      $modalStack.modalRendered = function(modalInstance) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow) {
          modalWindow.value.renderDeferred.resolve();
        }
      };
      $modalStack.focusFirstFocusableElement = function(list) {
        if (list.length > 0) {
          list[0].focus();
          return true;
        }
        return false;
      };
      $modalStack.focusLastFocusableElement = function(list) {
        if (list.length > 0) {
          list[list.length - 1].focus();
          return true;
        }
        return false;
      };
      $modalStack.isModalFocused = function(evt, modalWindow) {
        if (evt && modalWindow) {
          var modalDomEl = modalWindow.value.modalDomEl;
          if (modalDomEl && modalDomEl.length) {
            return (evt.target || evt.srcElement) === modalDomEl[0];
          }
        }
        return false;
      };
      $modalStack.isFocusInFirstItem = function(evt, list) {
        if (list.length > 0) {
          return (evt.target || evt.srcElement) === list[0];
        }
        return false;
      };
      $modalStack.isFocusInLastItem = function(evt, list) {
        if (list.length > 0) {
          return (evt.target || evt.srcElement) === list[list.length - 1];
        }
        return false;
      };
      $modalStack.loadFocusElementList = function(modalWindow) {
        if (modalWindow) {
          var modalDomE1 = modalWindow.value.modalDomEl;
          if (modalDomE1 && modalDomE1.length) {
            var elements = modalDomE1[0].querySelectorAll(tabbableSelector);
            return elements ? Array.prototype.filter.call(elements, function(element) {
              return isVisible(element);
            }) : elements;
          }
        }
      };
      return $modalStack;
    }]).provider('$uibModal', function() {
      var $modalProvider = {
        options: {
          animation: true,
          backdrop: true,
          keyboard: true
        },
        $get: ['$rootScope', '$q', '$document', '$templateRequest', '$controller', '$uibResolve', '$uibModalStack', function($rootScope, $q, $document, $templateRequest, $controller, $uibResolve, $modalStack) {
          var $modal = {};
          function getTemplatePromise(options) {
            return options.template ? $q.when(options.template) : $templateRequest(angular.isFunction(options.templateUrl) ? options.templateUrl() : options.templateUrl);
          }
          var promiseChain = null;
          $modal.getPromiseChain = function() {
            return promiseChain;
          };
          $modal.open = function(modalOptions) {
            var modalResultDeferred = $q.defer();
            var modalOpenedDeferred = $q.defer();
            var modalClosedDeferred = $q.defer();
            var modalRenderDeferred = $q.defer();
            var modalInstance = {
              result: modalResultDeferred.promise,
              opened: modalOpenedDeferred.promise,
              closed: modalClosedDeferred.promise,
              rendered: modalRenderDeferred.promise,
              close: function(result) {
                return $modalStack.close(modalInstance, result);
              },
              dismiss: function(reason) {
                return $modalStack.dismiss(modalInstance, reason);
              }
            };
            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);
            modalOptions.resolve = modalOptions.resolve || {};
            modalOptions.appendTo = modalOptions.appendTo || $document.find('body').eq(0);
            if (!modalOptions.template && !modalOptions.templateUrl) {
              throw new Error('One of template or templateUrl options is required.');
            }
            var templateAndResolvePromise = $q.all([getTemplatePromise(modalOptions), $uibResolve.resolve(modalOptions.resolve, {}, null, null)]);
            function resolveWithTemplate() {
              return templateAndResolvePromise;
            }
            var samePromise;
            samePromise = promiseChain = $q.all([promiseChain]).then(resolveWithTemplate, resolveWithTemplate).then(function resolveSuccess(tplAndVars) {
              var providedScope = modalOptions.scope || $rootScope;
              var modalScope = providedScope.$new();
              modalScope.$close = modalInstance.close;
              modalScope.$dismiss = modalInstance.dismiss;
              modalScope.$on('$destroy', function() {
                if (!modalScope.$$uibDestructionScheduled) {
                  modalScope.$dismiss('$uibUnscheduledDestruction');
                }
              });
              var ctrlInstance,
                  ctrlInstantiate,
                  ctrlLocals = {};
              if (modalOptions.controller) {
                ctrlLocals.$scope = modalScope;
                ctrlLocals.$scope.$resolve = {};
                ctrlLocals.$uibModalInstance = modalInstance;
                angular.forEach(tplAndVars[1], function(value, key) {
                  ctrlLocals[key] = value;
                  ctrlLocals.$scope.$resolve[key] = value;
                });
                ctrlInstantiate = $controller(modalOptions.controller, ctrlLocals, true, modalOptions.controllerAs);
                if (modalOptions.controllerAs && modalOptions.bindToController) {
                  ctrlInstance = ctrlInstantiate.instance;
                  ctrlInstance.$close = modalScope.$close;
                  ctrlInstance.$dismiss = modalScope.$dismiss;
                  angular.extend(ctrlInstance, {$resolve: ctrlLocals.$scope.$resolve}, providedScope);
                }
                ctrlInstance = ctrlInstantiate();
                if (angular.isFunction(ctrlInstance.$onInit)) {
                  ctrlInstance.$onInit();
                }
              }
              $modalStack.open(modalInstance, {
                scope: modalScope,
                deferred: modalResultDeferred,
                renderDeferred: modalRenderDeferred,
                closedDeferred: modalClosedDeferred,
                content: tplAndVars[0],
                animation: modalOptions.animation,
                backdrop: modalOptions.backdrop,
                keyboard: modalOptions.keyboard,
                backdropClass: modalOptions.backdropClass,
                windowTopClass: modalOptions.windowTopClass,
                windowClass: modalOptions.windowClass,
                windowTemplateUrl: modalOptions.windowTemplateUrl,
                size: modalOptions.size,
                openedClass: modalOptions.openedClass,
                appendTo: modalOptions.appendTo
              });
              modalOpenedDeferred.resolve(true);
            }, function resolveError(reason) {
              modalOpenedDeferred.reject(reason);
              modalResultDeferred.reject(reason);
            })['finally'](function() {
              if (promiseChain === samePromise) {
                promiseChain = null;
              }
            });
            return modalInstance;
          };
          return $modal;
        }]
      };
      return $modalProvider;
    });
    angular.module('ui.bootstrap.paging', []).factory('uibPaging', ['$parse', function($parse) {
      return {create: function(ctrl, $scope, $attrs) {
          ctrl.setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;
          ctrl.ngModelCtrl = {$setViewValue: angular.noop};
          ctrl._watchers = [];
          ctrl.init = function(ngModelCtrl, config) {
            ctrl.ngModelCtrl = ngModelCtrl;
            ctrl.config = config;
            ngModelCtrl.$render = function() {
              ctrl.render();
            };
            if ($attrs.itemsPerPage) {
              ctrl._watchers.push($scope.$parent.$watch($attrs.itemsPerPage, function(value) {
                ctrl.itemsPerPage = parseInt(value, 10);
                $scope.totalPages = ctrl.calculateTotalPages();
                ctrl.updatePage();
              }));
            } else {
              ctrl.itemsPerPage = config.itemsPerPage;
            }
            $scope.$watch('totalItems', function(newTotal, oldTotal) {
              if (angular.isDefined(newTotal) || newTotal !== oldTotal) {
                $scope.totalPages = ctrl.calculateTotalPages();
                ctrl.updatePage();
              }
            });
          };
          ctrl.calculateTotalPages = function() {
            var totalPages = ctrl.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / ctrl.itemsPerPage);
            return Math.max(totalPages || 0, 1);
          };
          ctrl.render = function() {
            $scope.page = parseInt(ctrl.ngModelCtrl.$viewValue, 10) || 1;
          };
          $scope.selectPage = function(page, evt) {
            if (evt) {
              evt.preventDefault();
            }
            var clickAllowed = !$scope.ngDisabled || !evt;
            if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {
              if (evt && evt.target) {
                evt.target.blur();
              }
              ctrl.ngModelCtrl.$setViewValue(page);
              ctrl.ngModelCtrl.$render();
            }
          };
          $scope.getText = function(key) {
            return $scope[key + 'Text'] || ctrl.config[key + 'Text'];
          };
          $scope.noPrevious = function() {
            return $scope.page === 1;
          };
          $scope.noNext = function() {
            return $scope.page === $scope.totalPages;
          };
          ctrl.updatePage = function() {
            ctrl.setNumPages($scope.$parent, $scope.totalPages);
            if ($scope.page > $scope.totalPages) {
              $scope.selectPage($scope.totalPages);
            } else {
              ctrl.ngModelCtrl.$render();
            }
          };
          $scope.$on('$destroy', function() {
            while (ctrl._watchers.length) {
              ctrl._watchers.shift()();
            }
          });
        }};
    }]);
    angular.module('ui.bootstrap.pager', ['ui.bootstrap.paging', 'ui.bootstrap.tabindex']).controller('UibPagerController', ['$scope', '$attrs', 'uibPaging', 'uibPagerConfig', function($scope, $attrs, uibPaging, uibPagerConfig) {
      $scope.align = angular.isDefined($attrs.align) ? $scope.$parent.$eval($attrs.align) : uibPagerConfig.align;
      uibPaging.create(this, $scope, $attrs);
    }]).constant('uibPagerConfig', {
      itemsPerPage: 10,
      previousText: '« Previous',
      nextText: 'Next »',
      align: true
    }).directive('uibPager', ['uibPagerConfig', function(uibPagerConfig) {
      return {
        scope: {
          totalItems: '=',
          previousText: '@',
          nextText: '@',
          ngDisabled: '='
        },
        require: ['uibPager', '?ngModel'],
        restrict: 'A',
        controller: 'UibPagerController',
        controllerAs: 'pager',
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'uib/template/pager/pager.html';
        },
        link: function(scope, element, attrs, ctrls) {
          element.addClass('pager');
          var paginationCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];
          if (!ngModelCtrl) {
            return;
          }
          paginationCtrl.init(ngModelCtrl, uibPagerConfig);
        }
      };
    }]);
    angular.module('ui.bootstrap.pagination', ['ui.bootstrap.paging', 'ui.bootstrap.tabindex']).controller('UibPaginationController', ['$scope', '$attrs', '$parse', 'uibPaging', 'uibPaginationConfig', function($scope, $attrs, $parse, uibPaging, uibPaginationConfig) {
      var ctrl = this;
      var maxSize = angular.isDefined($attrs.maxSize) ? $scope.$parent.$eval($attrs.maxSize) : uibPaginationConfig.maxSize,
          rotate = angular.isDefined($attrs.rotate) ? $scope.$parent.$eval($attrs.rotate) : uibPaginationConfig.rotate,
          forceEllipses = angular.isDefined($attrs.forceEllipses) ? $scope.$parent.$eval($attrs.forceEllipses) : uibPaginationConfig.forceEllipses,
          boundaryLinkNumbers = angular.isDefined($attrs.boundaryLinkNumbers) ? $scope.$parent.$eval($attrs.boundaryLinkNumbers) : uibPaginationConfig.boundaryLinkNumbers,
          pageLabel = angular.isDefined($attrs.pageLabel) ? function(idx) {
            return $scope.$parent.$eval($attrs.pageLabel, {$page: idx});
          } : angular.identity;
      $scope.boundaryLinks = angular.isDefined($attrs.boundaryLinks) ? $scope.$parent.$eval($attrs.boundaryLinks) : uibPaginationConfig.boundaryLinks;
      $scope.directionLinks = angular.isDefined($attrs.directionLinks) ? $scope.$parent.$eval($attrs.directionLinks) : uibPaginationConfig.directionLinks;
      uibPaging.create(this, $scope, $attrs);
      if ($attrs.maxSize) {
        ctrl._watchers.push($scope.$parent.$watch($parse($attrs.maxSize), function(value) {
          maxSize = parseInt(value, 10);
          ctrl.render();
        }));
      }
      function makePage(number, text, isActive) {
        return {
          number: number,
          text: text,
          active: isActive
        };
      }
      function getPages(currentPage, totalPages) {
        var pages = [];
        var startPage = 1,
            endPage = totalPages;
        var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;
        if (isMaxSized) {
          if (rotate) {
            startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1);
            endPage = startPage + maxSize - 1;
            if (endPage > totalPages) {
              endPage = totalPages;
              startPage = endPage - maxSize + 1;
            }
          } else {
            startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1;
            endPage = Math.min(startPage + maxSize - 1, totalPages);
          }
        }
        for (var number = startPage; number <= endPage; number++) {
          var page = makePage(number, pageLabel(number), number === currentPage);
          pages.push(page);
        }
        if (isMaxSized && maxSize > 0 && (!rotate || forceEllipses || boundaryLinkNumbers)) {
          if (startPage > 1) {
            if (!boundaryLinkNumbers || startPage > 3) {
              var previousPageSet = makePage(startPage - 1, '...', false);
              pages.unshift(previousPageSet);
            }
            if (boundaryLinkNumbers) {
              if (startPage === 3) {
                var secondPageLink = makePage(2, '2', false);
                pages.unshift(secondPageLink);
              }
              var firstPageLink = makePage(1, '1', false);
              pages.unshift(firstPageLink);
            }
          }
          if (endPage < totalPages) {
            if (!boundaryLinkNumbers || endPage < totalPages - 2) {
              var nextPageSet = makePage(endPage + 1, '...', false);
              pages.push(nextPageSet);
            }
            if (boundaryLinkNumbers) {
              if (endPage === totalPages - 2) {
                var secondToLastPageLink = makePage(totalPages - 1, totalPages - 1, false);
                pages.push(secondToLastPageLink);
              }
              var lastPageLink = makePage(totalPages, totalPages, false);
              pages.push(lastPageLink);
            }
          }
        }
        return pages;
      }
      var originalRender = this.render;
      this.render = function() {
        originalRender();
        if ($scope.page > 0 && $scope.page <= $scope.totalPages) {
          $scope.pages = getPages($scope.page, $scope.totalPages);
        }
      };
    }]).constant('uibPaginationConfig', {
      itemsPerPage: 10,
      boundaryLinks: false,
      boundaryLinkNumbers: false,
      directionLinks: true,
      firstText: 'First',
      previousText: 'Previous',
      nextText: 'Next',
      lastText: 'Last',
      rotate: true,
      forceEllipses: false
    }).directive('uibPagination', ['$parse', 'uibPaginationConfig', function($parse, uibPaginationConfig) {
      return {
        scope: {
          totalItems: '=',
          firstText: '@',
          previousText: '@',
          nextText: '@',
          lastText: '@',
          ngDisabled: '='
        },
        require: ['uibPagination', '?ngModel'],
        restrict: 'A',
        controller: 'UibPaginationController',
        controllerAs: 'pagination',
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'uib/template/pagination/pagination.html';
        },
        link: function(scope, element, attrs, ctrls) {
          element.addClass('pagination');
          var paginationCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];
          if (!ngModelCtrl) {
            return;
          }
          paginationCtrl.init(ngModelCtrl, uibPaginationConfig);
        }
      };
    }]);
    angular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.stackedMap']).provider('$uibTooltip', function() {
      var defaultOptions = {
        placement: 'top',
        placementClassPrefix: '',
        animation: true,
        popupDelay: 0,
        popupCloseDelay: 0,
        useContentExp: false
      };
      var triggerMap = {
        'mouseenter': 'mouseleave',
        'click': 'click',
        'outsideClick': 'outsideClick',
        'focus': 'blur',
        'none': ''
      };
      var globalOptions = {};
      this.options = function(value) {
        angular.extend(globalOptions, value);
      };
      this.setTriggers = function setTriggers(triggers) {
        angular.extend(triggerMap, triggers);
      };
      function snake_case(name) {
        var regexp = /[A-Z]/g;
        var separator = '-';
        return name.replace(regexp, function(letter, pos) {
          return (pos ? separator : '') + letter.toLowerCase();
        });
      }
      this.$get = ['$window', '$compile', '$timeout', '$document', '$uibPosition', '$interpolate', '$rootScope', '$parse', '$$stackedMap', function($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {
        var openedTooltips = $$stackedMap.createNew();
        $document.on('keypress', keypressListener);
        $rootScope.$on('$destroy', function() {
          $document.off('keypress', keypressListener);
        });
        function keypressListener(e) {
          if (e.which === 27) {
            var last = openedTooltips.top();
            if (last) {
              last.value.close();
              openedTooltips.removeTop();
              last = null;
            }
          }
        }
        return function $tooltip(ttType, prefix, defaultTriggerShow, options) {
          options = angular.extend({}, defaultOptions, globalOptions, options);
          function getTriggers(trigger) {
            var show = (trigger || options.trigger || defaultTriggerShow).split(' ');
            var hide = show.map(function(trigger) {
              return triggerMap[trigger] || trigger;
            });
            return {
              show: show,
              hide: hide
            };
          }
          var directiveName = snake_case(ttType);
          var startSym = $interpolate.startSymbol();
          var endSym = $interpolate.endSymbol();
          var template = '<div ' + directiveName + '-popup ' + 'uib-title="' + startSym + 'title' + endSym + '" ' + (options.useContentExp ? 'content-exp="contentExp()" ' : 'content="' + startSym + 'content' + endSym + '" ') + 'origin-scope="origScope" ' + 'class="uib-position-measure ' + prefix + '" ' + 'tooltip-animation-class="fade"' + 'uib-tooltip-classes ' + 'ng-class="{ in: isOpen }" ' + '>' + '</div>';
          return {compile: function(tElem, tAttrs) {
              var tooltipLinker = $compile(template);
              return function link(scope, element, attrs, tooltipCtrl) {
                var tooltip;
                var tooltipLinkedScope;
                var transitionTimeout;
                var showTimeout;
                var hideTimeout;
                var positionTimeout;
                var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;
                var triggers = getTriggers(undefined);
                var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);
                var ttScope = scope.$new(true);
                var repositionScheduled = false;
                var isOpenParse = angular.isDefined(attrs[prefix + 'IsOpen']) ? $parse(attrs[prefix + 'IsOpen']) : false;
                var contentParse = options.useContentExp ? $parse(attrs[ttType]) : false;
                var observers = [];
                var lastPlacement;
                var positionTooltip = function() {
                  if (!tooltip || !tooltip.html()) {
                    return;
                  }
                  if (!positionTimeout) {
                    positionTimeout = $timeout(function() {
                      var ttPosition = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);
                      var initialHeight = angular.isDefined(tooltip.offsetHeight) ? tooltip.offsetHeight : tooltip.prop('offsetHeight');
                      var elementPos = appendToBody ? $position.offset(element) : $position.position(element);
                      tooltip.css({
                        top: ttPosition.top + 'px',
                        left: ttPosition.left + 'px'
                      });
                      var placementClasses = ttPosition.placement.split('-');
                      if (!tooltip.hasClass(placementClasses[0])) {
                        tooltip.removeClass(lastPlacement.split('-')[0]);
                        tooltip.addClass(placementClasses[0]);
                      }
                      if (!tooltip.hasClass(options.placementClassPrefix + ttPosition.placement)) {
                        tooltip.removeClass(options.placementClassPrefix + lastPlacement);
                        tooltip.addClass(options.placementClassPrefix + ttPosition.placement);
                      }
                      $timeout(function() {
                        var currentHeight = angular.isDefined(tooltip.offsetHeight) ? tooltip.offsetHeight : tooltip.prop('offsetHeight');
                        var adjustment = $position.adjustTop(placementClasses, elementPos, initialHeight, currentHeight);
                        if (adjustment) {
                          tooltip.css(adjustment);
                        }
                      }, 0, false);
                      if (tooltip.hasClass('uib-position-measure')) {
                        $position.positionArrow(tooltip, ttPosition.placement);
                        tooltip.removeClass('uib-position-measure');
                      } else if (lastPlacement !== ttPosition.placement) {
                        $position.positionArrow(tooltip, ttPosition.placement);
                      }
                      lastPlacement = ttPosition.placement;
                      positionTimeout = null;
                    }, 0, false);
                  }
                };
                ttScope.origScope = scope;
                ttScope.isOpen = false;
                openedTooltips.add(ttScope, {close: hide});
                function toggleTooltipBind() {
                  if (!ttScope.isOpen) {
                    showTooltipBind();
                  } else {
                    hideTooltipBind();
                  }
                }
                function showTooltipBind() {
                  if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {
                    return;
                  }
                  cancelHide();
                  prepareTooltip();
                  if (ttScope.popupDelay) {
                    if (!showTimeout) {
                      showTimeout = $timeout(show, ttScope.popupDelay, false);
                    }
                  } else {
                    show();
                  }
                }
                function hideTooltipBind() {
                  cancelShow();
                  if (ttScope.popupCloseDelay) {
                    if (!hideTimeout) {
                      hideTimeout = $timeout(hide, ttScope.popupCloseDelay, false);
                    }
                  } else {
                    hide();
                  }
                }
                function show() {
                  cancelShow();
                  cancelHide();
                  if (!ttScope.content) {
                    return angular.noop;
                  }
                  createTooltip();
                  ttScope.$evalAsync(function() {
                    ttScope.isOpen = true;
                    assignIsOpen(true);
                    positionTooltip();
                  });
                }
                function cancelShow() {
                  if (showTimeout) {
                    $timeout.cancel(showTimeout);
                    showTimeout = null;
                  }
                  if (positionTimeout) {
                    $timeout.cancel(positionTimeout);
                    positionTimeout = null;
                  }
                }
                function hide() {
                  if (!ttScope) {
                    return;
                  }
                  ttScope.$evalAsync(function() {
                    if (ttScope) {
                      ttScope.isOpen = false;
                      assignIsOpen(false);
                      if (ttScope.animation) {
                        if (!transitionTimeout) {
                          transitionTimeout = $timeout(removeTooltip, 150, false);
                        }
                      } else {
                        removeTooltip();
                      }
                    }
                  });
                }
                function cancelHide() {
                  if (hideTimeout) {
                    $timeout.cancel(hideTimeout);
                    hideTimeout = null;
                  }
                  if (transitionTimeout) {
                    $timeout.cancel(transitionTimeout);
                    transitionTimeout = null;
                  }
                }
                function createTooltip() {
                  if (tooltip) {
                    return;
                  }
                  tooltipLinkedScope = ttScope.$new();
                  tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {
                    if (appendToBody) {
                      $document.find('body').append(tooltip);
                    } else {
                      element.after(tooltip);
                    }
                  });
                  prepObservers();
                }
                function removeTooltip() {
                  cancelShow();
                  cancelHide();
                  unregisterObservers();
                  if (tooltip) {
                    tooltip.remove();
                    tooltip = null;
                  }
                  if (tooltipLinkedScope) {
                    tooltipLinkedScope.$destroy();
                    tooltipLinkedScope = null;
                  }
                }
                function prepareTooltip() {
                  ttScope.title = attrs[prefix + 'Title'];
                  if (contentParse) {
                    ttScope.content = contentParse(scope);
                  } else {
                    ttScope.content = attrs[ttType];
                  }
                  ttScope.popupClass = attrs[prefix + 'Class'];
                  ttScope.placement = angular.isDefined(attrs[prefix + 'Placement']) ? attrs[prefix + 'Placement'] : options.placement;
                  var placement = $position.parsePlacement(ttScope.placement);
                  lastPlacement = placement[1] ? placement[0] + '-' + placement[1] : placement[0];
                  var delay = parseInt(attrs[prefix + 'PopupDelay'], 10);
                  var closeDelay = parseInt(attrs[prefix + 'PopupCloseDelay'], 10);
                  ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;
                  ttScope.popupCloseDelay = !isNaN(closeDelay) ? closeDelay : options.popupCloseDelay;
                }
                function assignIsOpen(isOpen) {
                  if (isOpenParse && angular.isFunction(isOpenParse.assign)) {
                    isOpenParse.assign(scope, isOpen);
                  }
                }
                ttScope.contentExp = function() {
                  return ttScope.content;
                };
                attrs.$observe('disabled', function(val) {
                  if (val) {
                    cancelShow();
                  }
                  if (val && ttScope.isOpen) {
                    hide();
                  }
                });
                if (isOpenParse) {
                  scope.$watch(isOpenParse, function(val) {
                    if (ttScope && !val === ttScope.isOpen) {
                      toggleTooltipBind();
                    }
                  });
                }
                function prepObservers() {
                  observers.length = 0;
                  if (contentParse) {
                    observers.push(scope.$watch(contentParse, function(val) {
                      ttScope.content = val;
                      if (!val && ttScope.isOpen) {
                        hide();
                      }
                    }));
                    observers.push(tooltipLinkedScope.$watch(function() {
                      if (!repositionScheduled) {
                        repositionScheduled = true;
                        tooltipLinkedScope.$$postDigest(function() {
                          repositionScheduled = false;
                          if (ttScope && ttScope.isOpen) {
                            positionTooltip();
                          }
                        });
                      }
                    }));
                  } else {
                    observers.push(attrs.$observe(ttType, function(val) {
                      ttScope.content = val;
                      if (!val && ttScope.isOpen) {
                        hide();
                      } else {
                        positionTooltip();
                      }
                    }));
                  }
                  observers.push(attrs.$observe(prefix + 'Title', function(val) {
                    ttScope.title = val;
                    if (ttScope.isOpen) {
                      positionTooltip();
                    }
                  }));
                  observers.push(attrs.$observe(prefix + 'Placement', function(val) {
                    ttScope.placement = val ? val : options.placement;
                    if (ttScope.isOpen) {
                      positionTooltip();
                    }
                  }));
                }
                function unregisterObservers() {
                  if (observers.length) {
                    angular.forEach(observers, function(observer) {
                      observer();
                    });
                    observers.length = 0;
                  }
                }
                function bodyHideTooltipBind(e) {
                  if (!ttScope || !ttScope.isOpen || !tooltip) {
                    return;
                  }
                  if (!element[0].contains(e.target) && !tooltip[0].contains(e.target)) {
                    hideTooltipBind();
                  }
                }
                var unregisterTriggers = function() {
                  triggers.show.forEach(function(trigger) {
                    if (trigger === 'outsideClick') {
                      element.off('click', toggleTooltipBind);
                    } else {
                      element.off(trigger, showTooltipBind);
                      element.off(trigger, toggleTooltipBind);
                    }
                  });
                  triggers.hide.forEach(function(trigger) {
                    if (trigger === 'outsideClick') {
                      $document.off('click', bodyHideTooltipBind);
                    } else {
                      element.off(trigger, hideTooltipBind);
                    }
                  });
                };
                function prepTriggers() {
                  var showTriggers = [],
                      hideTriggers = [];
                  var val = scope.$eval(attrs[prefix + 'Trigger']);
                  unregisterTriggers();
                  if (angular.isObject(val)) {
                    Object.keys(val).forEach(function(key) {
                      showTriggers.push(key);
                      hideTriggers.push(val[key]);
                    });
                    triggers = {
                      show: showTriggers,
                      hide: hideTriggers
                    };
                  } else {
                    triggers = getTriggers(val);
                  }
                  if (triggers.show !== 'none') {
                    triggers.show.forEach(function(trigger, idx) {
                      if (trigger === 'outsideClick') {
                        element.on('click', toggleTooltipBind);
                        $document.on('click', bodyHideTooltipBind);
                      } else if (trigger === triggers.hide[idx]) {
                        element.on(trigger, toggleTooltipBind);
                      } else if (trigger) {
                        element.on(trigger, showTooltipBind);
                        element.on(triggers.hide[idx], hideTooltipBind);
                      }
                      element.on('keypress', function(e) {
                        if (e.which === 27) {
                          hideTooltipBind();
                        }
                      });
                    });
                  }
                }
                prepTriggers();
                var animation = scope.$eval(attrs[prefix + 'Animation']);
                ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;
                var appendToBodyVal;
                var appendKey = prefix + 'AppendToBody';
                if (appendKey in attrs && attrs[appendKey] === undefined) {
                  appendToBodyVal = true;
                } else {
                  appendToBodyVal = scope.$eval(attrs[appendKey]);
                }
                appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;
                scope.$on('$destroy', function onDestroyTooltip() {
                  unregisterTriggers();
                  removeTooltip();
                  openedTooltips.remove(ttScope);
                  ttScope = null;
                });
              };
            }};
        };
      }];
    }).directive('uibTooltipTemplateTransclude', ['$animate', '$sce', '$compile', '$templateRequest', function($animate, $sce, $compile, $templateRequest) {
      return {link: function(scope, elem, attrs) {
          var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);
          var changeCounter = 0,
              currentScope,
              previousElement,
              currentElement;
          var cleanupLastIncludeContent = function() {
            if (previousElement) {
              previousElement.remove();
              previousElement = null;
            }
            if (currentScope) {
              currentScope.$destroy();
              currentScope = null;
            }
            if (currentElement) {
              $animate.leave(currentElement).then(function() {
                previousElement = null;
              });
              previousElement = currentElement;
              currentElement = null;
            }
          };
          scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function(src) {
            var thisChangeId = ++changeCounter;
            if (src) {
              $templateRequest(src, true).then(function(response) {
                if (thisChangeId !== changeCounter) {
                  return;
                }
                var newScope = origScope.$new();
                var template = response;
                var clone = $compile(template)(newScope, function(clone) {
                  cleanupLastIncludeContent();
                  $animate.enter(clone, elem);
                });
                currentScope = newScope;
                currentElement = clone;
                currentScope.$emit('$includeContentLoaded', src);
              }, function() {
                if (thisChangeId === changeCounter) {
                  cleanupLastIncludeContent();
                  scope.$emit('$includeContentError', src);
                }
              });
              scope.$emit('$includeContentRequested', src);
            } else {
              cleanupLastIncludeContent();
            }
          });
          scope.$on('$destroy', cleanupLastIncludeContent);
        }};
    }]).directive('uibTooltipClasses', ['$uibPosition', function($uibPosition) {
      return {
        restrict: 'A',
        link: function(scope, element, attrs) {
          if (scope.placement) {
            var position = $uibPosition.parsePlacement(scope.placement);
            element.addClass(position[0]);
          }
          if (scope.popupClass) {
            element.addClass(scope.popupClass);
          }
          if (scope.animation) {
            element.addClass(attrs.tooltipAnimationClass);
          }
        }
      };
    }]).directive('uibTooltipPopup', function() {
      return {
        restrict: 'A',
        scope: {content: '@'},
        templateUrl: 'uib/template/tooltip/tooltip-popup.html'
      };
    }).directive('uibTooltip', ['$uibTooltip', function($uibTooltip) {
      return $uibTooltip('uibTooltip', 'tooltip', 'mouseenter');
    }]).directive('uibTooltipTemplatePopup', function() {
      return {
        restrict: 'A',
        scope: {
          contentExp: '&',
          originScope: '&'
        },
        templateUrl: 'uib/template/tooltip/tooltip-template-popup.html'
      };
    }).directive('uibTooltipTemplate', ['$uibTooltip', function($uibTooltip) {
      return $uibTooltip('uibTooltipTemplate', 'tooltip', 'mouseenter', {useContentExp: true});
    }]).directive('uibTooltipHtmlPopup', function() {
      return {
        restrict: 'A',
        scope: {contentExp: '&'},
        templateUrl: 'uib/template/tooltip/tooltip-html-popup.html'
      };
    }).directive('uibTooltipHtml', ['$uibTooltip', function($uibTooltip) {
      return $uibTooltip('uibTooltipHtml', 'tooltip', 'mouseenter', {useContentExp: true});
    }]);
    angular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip']).directive('uibPopoverTemplatePopup', function() {
      return {
        restrict: 'A',
        scope: {
          uibTitle: '@',
          contentExp: '&',
          originScope: '&'
        },
        templateUrl: 'uib/template/popover/popover-template.html'
      };
    }).directive('uibPopoverTemplate', ['$uibTooltip', function($uibTooltip) {
      return $uibTooltip('uibPopoverTemplate', 'popover', 'click', {useContentExp: true});
    }]).directive('uibPopoverHtmlPopup', function() {
      return {
        restrict: 'A',
        scope: {
          contentExp: '&',
          uibTitle: '@'
        },
        templateUrl: 'uib/template/popover/popover-html.html'
      };
    }).directive('uibPopoverHtml', ['$uibTooltip', function($uibTooltip) {
      return $uibTooltip('uibPopoverHtml', 'popover', 'click', {useContentExp: true});
    }]).directive('uibPopoverPopup', function() {
      return {
        restrict: 'A',
        scope: {
          uibTitle: '@',
          content: '@'
        },
        templateUrl: 'uib/template/popover/popover.html'
      };
    }).directive('uibPopover', ['$uibTooltip', function($uibTooltip) {
      return $uibTooltip('uibPopover', 'popover', 'click');
    }]);
    angular.module('ui.bootstrap.progressbar', []).constant('uibProgressConfig', {
      animate: true,
      max: 100
    }).controller('UibProgressController', ['$scope', '$attrs', 'uibProgressConfig', function($scope, $attrs, progressConfig) {
      var self = this,
          animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;
      this.bars = [];
      $scope.max = getMaxOrDefault();
      this.addBar = function(bar, element, attrs) {
        if (!animate) {
          element.css({'transition': 'none'});
        }
        this.bars.push(bar);
        bar.max = getMaxOrDefault();
        bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';
        bar.$watch('value', function(value) {
          bar.recalculatePercentage();
        });
        bar.recalculatePercentage = function() {
          var totalPercentage = self.bars.reduce(function(total, bar) {
            bar.percent = +(100 * bar.value / bar.max).toFixed(2);
            return total + bar.percent;
          }, 0);
          if (totalPercentage > 100) {
            bar.percent -= totalPercentage - 100;
          }
        };
        bar.$on('$destroy', function() {
          element = null;
          self.removeBar(bar);
        });
      };
      this.removeBar = function(bar) {
        this.bars.splice(this.bars.indexOf(bar), 1);
        this.bars.forEach(function(bar) {
          bar.recalculatePercentage();
        });
      };
      $scope.$watch('maxParam', function(maxParam) {
        self.bars.forEach(function(bar) {
          bar.max = getMaxOrDefault();
          bar.recalculatePercentage();
        });
      });
      function getMaxOrDefault() {
        return angular.isDefined($scope.maxParam) ? $scope.maxParam : progressConfig.max;
      }
    }]).directive('uibProgress', function() {
      return {
        replace: true,
        transclude: true,
        controller: 'UibProgressController',
        require: 'uibProgress',
        scope: {maxParam: '=?max'},
        templateUrl: 'uib/template/progressbar/progress.html'
      };
    }).directive('uibBar', function() {
      return {
        replace: true,
        transclude: true,
        require: '^uibProgress',
        scope: {
          value: '=',
          type: '@'
        },
        templateUrl: 'uib/template/progressbar/bar.html',
        link: function(scope, element, attrs, progressCtrl) {
          progressCtrl.addBar(scope, element, attrs);
        }
      };
    }).directive('uibProgressbar', function() {
      return {
        replace: true,
        transclude: true,
        controller: 'UibProgressController',
        scope: {
          value: '=',
          maxParam: '=?max',
          type: '@'
        },
        templateUrl: 'uib/template/progressbar/progressbar.html',
        link: function(scope, element, attrs, progressCtrl) {
          progressCtrl.addBar(scope, angular.element(element.children()[0]), {title: attrs.title});
        }
      };
    });
    angular.module('ui.bootstrap.rating', []).constant('uibRatingConfig', {
      max: 5,
      stateOn: null,
      stateOff: null,
      enableReset: true,
      titles: ['one', 'two', 'three', 'four', 'five']
    }).controller('UibRatingController', ['$scope', '$attrs', 'uibRatingConfig', function($scope, $attrs, ratingConfig) {
      var ngModelCtrl = {$setViewValue: angular.noop},
          self = this;
      this.init = function(ngModelCtrl_) {
        ngModelCtrl = ngModelCtrl_;
        ngModelCtrl.$render = this.render;
        ngModelCtrl.$formatters.push(function(value) {
          if (angular.isNumber(value) && value << 0 !== value) {
            value = Math.round(value);
          }
          return value;
        });
        this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;
        this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;
        this.enableReset = angular.isDefined($attrs.enableReset) ? $scope.$parent.$eval($attrs.enableReset) : ratingConfig.enableReset;
        var tmpTitles = angular.isDefined($attrs.titles) ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles;
        this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ? tmpTitles : ratingConfig.titles;
        var ratingStates = angular.isDefined($attrs.ratingStates) ? $scope.$parent.$eval($attrs.ratingStates) : new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);
        $scope.range = this.buildTemplateObjects(ratingStates);
      };
      this.buildTemplateObjects = function(states) {
        for (var i = 0,
            n = states.length; i < n; i++) {
          states[i] = angular.extend({index: i}, {
            stateOn: this.stateOn,
            stateOff: this.stateOff,
            title: this.getTitle(i)
          }, states[i]);
        }
        return states;
      };
      this.getTitle = function(index) {
        if (index >= this.titles.length) {
          return index + 1;
        }
        return this.titles[index];
      };
      $scope.rate = function(value) {
        if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {
          var newViewValue = self.enableReset && ngModelCtrl.$viewValue === value ? 0 : value;
          ngModelCtrl.$setViewValue(newViewValue);
          ngModelCtrl.$render();
        }
      };
      $scope.enter = function(value) {
        if (!$scope.readonly) {
          $scope.value = value;
        }
        $scope.onHover({value: value});
      };
      $scope.reset = function() {
        $scope.value = ngModelCtrl.$viewValue;
        $scope.onLeave();
      };
      $scope.onKeydown = function(evt) {
        if (/(37|38|39|40)/.test(evt.which)) {
          evt.preventDefault();
          evt.stopPropagation();
          $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));
        }
      };
      this.render = function() {
        $scope.value = ngModelCtrl.$viewValue;
        $scope.title = self.getTitle($scope.value - 1);
      };
    }]).directive('uibRating', function() {
      return {
        require: ['uibRating', 'ngModel'],
        restrict: 'A',
        scope: {
          readonly: '=?readOnly',
          onHover: '&',
          onLeave: '&'
        },
        controller: 'UibRatingController',
        templateUrl: 'uib/template/rating/rating.html',
        link: function(scope, element, attrs, ctrls) {
          var ratingCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];
          ratingCtrl.init(ngModelCtrl);
        }
      };
    });
    angular.module('ui.bootstrap.tabs', []).controller('UibTabsetController', ['$scope', function($scope) {
      var ctrl = this,
          oldIndex;
      ctrl.tabs = [];
      ctrl.select = function(index, evt) {
        if (!destroyed) {
          var previousIndex = findTabIndex(oldIndex);
          var previousSelected = ctrl.tabs[previousIndex];
          if (previousSelected) {
            previousSelected.tab.onDeselect({
              $event: evt,
              $selectedIndex: index
            });
            if (evt && evt.isDefaultPrevented()) {
              return;
            }
            previousSelected.tab.active = false;
          }
          var selected = ctrl.tabs[index];
          if (selected) {
            selected.tab.onSelect({$event: evt});
            selected.tab.active = true;
            ctrl.active = selected.index;
            oldIndex = selected.index;
          } else if (!selected && angular.isDefined(oldIndex)) {
            ctrl.active = null;
            oldIndex = null;
          }
        }
      };
      ctrl.addTab = function addTab(tab) {
        ctrl.tabs.push({
          tab: tab,
          index: tab.index
        });
        ctrl.tabs.sort(function(t1, t2) {
          if (t1.index > t2.index) {
            return 1;
          }
          if (t1.index < t2.index) {
            return -1;
          }
          return 0;
        });
        if (tab.index === ctrl.active || !angular.isDefined(ctrl.active) && ctrl.tabs.length === 1) {
          var newActiveIndex = findTabIndex(tab.index);
          ctrl.select(newActiveIndex);
        }
      };
      ctrl.removeTab = function removeTab(tab) {
        var index;
        for (var i = 0; i < ctrl.tabs.length; i++) {
          if (ctrl.tabs[i].tab === tab) {
            index = i;
            break;
          }
        }
        if (ctrl.tabs[index].index === ctrl.active) {
          var newActiveTabIndex = index === ctrl.tabs.length - 1 ? index - 1 : index + 1 % ctrl.tabs.length;
          ctrl.select(newActiveTabIndex);
        }
        ctrl.tabs.splice(index, 1);
      };
      $scope.$watch('tabset.active', function(val) {
        if (angular.isDefined(val) && val !== oldIndex) {
          ctrl.select(findTabIndex(val));
        }
      });
      var destroyed;
      $scope.$on('$destroy', function() {
        destroyed = true;
      });
      function findTabIndex(index) {
        for (var i = 0; i < ctrl.tabs.length; i++) {
          if (ctrl.tabs[i].index === index) {
            return i;
          }
        }
      }
    }]).directive('uibTabset', function() {
      return {
        transclude: true,
        replace: true,
        scope: {},
        bindToController: {
          active: '=?',
          type: '@'
        },
        controller: 'UibTabsetController',
        controllerAs: 'tabset',
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'uib/template/tabs/tabset.html';
        },
        link: function(scope, element, attrs) {
          scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;
          scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;
        }
      };
    }).directive('uibTab', ['$parse', function($parse) {
      return {
        require: '^uibTabset',
        replace: true,
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'uib/template/tabs/tab.html';
        },
        transclude: true,
        scope: {
          heading: '@',
          index: '=?',
          classes: '@?',
          onSelect: '&select',
          onDeselect: '&deselect'
        },
        controller: function() {},
        controllerAs: 'tab',
        link: function(scope, elm, attrs, tabsetCtrl, transclude) {
          scope.disabled = false;
          if (attrs.disable) {
            scope.$parent.$watch($parse(attrs.disable), function(value) {
              scope.disabled = !!value;
            });
          }
          if (angular.isUndefined(attrs.index)) {
            if (tabsetCtrl.tabs && tabsetCtrl.tabs.length) {
              scope.index = Math.max.apply(null, tabsetCtrl.tabs.map(function(t) {
                return t.index;
              })) + 1;
            } else {
              scope.index = 0;
            }
          }
          if (angular.isUndefined(attrs.classes)) {
            scope.classes = '';
          }
          scope.select = function(evt) {
            if (!scope.disabled) {
              var index;
              for (var i = 0; i < tabsetCtrl.tabs.length; i++) {
                if (tabsetCtrl.tabs[i].tab === scope) {
                  index = i;
                  break;
                }
              }
              tabsetCtrl.select(index, evt);
            }
          };
          tabsetCtrl.addTab(scope);
          scope.$on('$destroy', function() {
            tabsetCtrl.removeTab(scope);
          });
          scope.$transcludeFn = transclude;
        }
      };
    }]).directive('uibTabHeadingTransclude', function() {
      return {
        restrict: 'A',
        require: '^uibTab',
        link: function(scope, elm) {
          scope.$watch('headingElement', function updateHeadingElement(heading) {
            if (heading) {
              elm.html('');
              elm.append(heading);
            }
          });
        }
      };
    }).directive('uibTabContentTransclude', function() {
      return {
        restrict: 'A',
        require: '^uibTabset',
        link: function(scope, elm, attrs) {
          var tab = scope.$eval(attrs.uibTabContentTransclude).tab;
          tab.$transcludeFn(tab.$parent, function(contents) {
            angular.forEach(contents, function(node) {
              if (isTabHeading(node)) {
                tab.headingElement = node;
              } else {
                elm.append(node);
              }
            });
          });
        }
      };
      function isTabHeading(node) {
        return node.tagName && (node.hasAttribute('uib-tab-heading') || node.hasAttribute('data-uib-tab-heading') || node.hasAttribute('x-uib-tab-heading') || node.tagName.toLowerCase() === 'uib-tab-heading' || node.tagName.toLowerCase() === 'data-uib-tab-heading' || node.tagName.toLowerCase() === 'x-uib-tab-heading' || node.tagName.toLowerCase() === 'uib:tab-heading');
      }
    });
    angular.module('ui.bootstrap.timepicker', []).constant('uibTimepickerConfig', {
      hourStep: 1,
      minuteStep: 1,
      secondStep: 1,
      showMeridian: true,
      showSeconds: false,
      meridians: null,
      readonlyInput: false,
      mousewheel: true,
      arrowkeys: true,
      showSpinners: true,
      templateUrl: 'uib/template/timepicker/timepicker.html'
    }).controller('UibTimepickerController', ['$scope', '$element', '$attrs', '$parse', '$log', '$locale', 'uibTimepickerConfig', function($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {
      var selected = new Date(),
          watchers = [],
          ngModelCtrl = {$setViewValue: angular.noop},
          meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS,
          padHours = angular.isDefined($attrs.padHours) ? $scope.$parent.$eval($attrs.padHours) : true;
      $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0;
      $element.removeAttr('tabindex');
      this.init = function(ngModelCtrl_, inputs) {
        ngModelCtrl = ngModelCtrl_;
        ngModelCtrl.$render = this.render;
        ngModelCtrl.$formatters.unshift(function(modelValue) {
          return modelValue ? new Date(modelValue) : null;
        });
        var hoursInputEl = inputs.eq(0),
            minutesInputEl = inputs.eq(1),
            secondsInputEl = inputs.eq(2);
        var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;
        if (mousewheel) {
          this.setupMousewheelEvents(hoursInputEl, minutesInputEl, secondsInputEl);
        }
        var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;
        if (arrowkeys) {
          this.setupArrowkeyEvents(hoursInputEl, minutesInputEl, secondsInputEl);
        }
        $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;
        this.setupInputEvents(hoursInputEl, minutesInputEl, secondsInputEl);
      };
      var hourStep = timepickerConfig.hourStep;
      if ($attrs.hourStep) {
        watchers.push($scope.$parent.$watch($parse($attrs.hourStep), function(value) {
          hourStep = +value;
        }));
      }
      var minuteStep = timepickerConfig.minuteStep;
      if ($attrs.minuteStep) {
        watchers.push($scope.$parent.$watch($parse($attrs.minuteStep), function(value) {
          minuteStep = +value;
        }));
      }
      var min;
      watchers.push($scope.$parent.$watch($parse($attrs.min), function(value) {
        var dt = new Date(value);
        min = isNaN(dt) ? undefined : dt;
      }));
      var max;
      watchers.push($scope.$parent.$watch($parse($attrs.max), function(value) {
        var dt = new Date(value);
        max = isNaN(dt) ? undefined : dt;
      }));
      var disabled = false;
      if ($attrs.ngDisabled) {
        watchers.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(value) {
          disabled = value;
        }));
      }
      $scope.noIncrementHours = function() {
        var incrementedSelected = addMinutes(selected, hourStep * 60);
        return disabled || incrementedSelected > max || incrementedSelected < selected && incrementedSelected < min;
      };
      $scope.noDecrementHours = function() {
        var decrementedSelected = addMinutes(selected, -hourStep * 60);
        return disabled || decrementedSelected < min || decrementedSelected > selected && decrementedSelected > max;
      };
      $scope.noIncrementMinutes = function() {
        var incrementedSelected = addMinutes(selected, minuteStep);
        return disabled || incrementedSelected > max || incrementedSelected < selected && incrementedSelected < min;
      };
      $scope.noDecrementMinutes = function() {
        var decrementedSelected = addMinutes(selected, -minuteStep);
        return disabled || decrementedSelected < min || decrementedSelected > selected && decrementedSelected > max;
      };
      $scope.noIncrementSeconds = function() {
        var incrementedSelected = addSeconds(selected, secondStep);
        return disabled || incrementedSelected > max || incrementedSelected < selected && incrementedSelected < min;
      };
      $scope.noDecrementSeconds = function() {
        var decrementedSelected = addSeconds(selected, -secondStep);
        return disabled || decrementedSelected < min || decrementedSelected > selected && decrementedSelected > max;
      };
      $scope.noToggleMeridian = function() {
        if (selected.getHours() < 12) {
          return disabled || addMinutes(selected, 12 * 60) > max;
        }
        return disabled || addMinutes(selected, -12 * 60) < min;
      };
      var secondStep = timepickerConfig.secondStep;
      if ($attrs.secondStep) {
        watchers.push($scope.$parent.$watch($parse($attrs.secondStep), function(value) {
          secondStep = +value;
        }));
      }
      $scope.showSeconds = timepickerConfig.showSeconds;
      if ($attrs.showSeconds) {
        watchers.push($scope.$parent.$watch($parse($attrs.showSeconds), function(value) {
          $scope.showSeconds = !!value;
        }));
      }
      $scope.showMeridian = timepickerConfig.showMeridian;
      if ($attrs.showMeridian) {
        watchers.push($scope.$parent.$watch($parse($attrs.showMeridian), function(value) {
          $scope.showMeridian = !!value;
          if (ngModelCtrl.$error.time) {
            var hours = getHoursFromTemplate(),
                minutes = getMinutesFromTemplate();
            if (angular.isDefined(hours) && angular.isDefined(minutes)) {
              selected.setHours(hours);
              refresh();
            }
          } else {
            updateTemplate();
          }
        }));
      }
      function getHoursFromTemplate() {
        var hours = +$scope.hours;
        var valid = $scope.showMeridian ? hours > 0 && hours < 13 : hours >= 0 && hours < 24;
        if (!valid || $scope.hours === '') {
          return undefined;
        }
        if ($scope.showMeridian) {
          if (hours === 12) {
            hours = 0;
          }
          if ($scope.meridian === meridians[1]) {
            hours = hours + 12;
          }
        }
        return hours;
      }
      function getMinutesFromTemplate() {
        var minutes = +$scope.minutes;
        var valid = minutes >= 0 && minutes < 60;
        if (!valid || $scope.minutes === '') {
          return undefined;
        }
        return minutes;
      }
      function getSecondsFromTemplate() {
        var seconds = +$scope.seconds;
        return seconds >= 0 && seconds < 60 ? seconds : undefined;
      }
      function pad(value, noPad) {
        if (value === null) {
          return '';
        }
        return angular.isDefined(value) && value.toString().length < 2 && !noPad ? '0' + value : value.toString();
      }
      this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
        var isScrollingUp = function(e) {
          if (e.originalEvent) {
            e = e.originalEvent;
          }
          var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;
          return e.detail || delta > 0;
        };
        hoursInputEl.bind('mousewheel wheel', function(e) {
          if (!disabled) {
            $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());
          }
          e.preventDefault();
        });
        minutesInputEl.bind('mousewheel wheel', function(e) {
          if (!disabled) {
            $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());
          }
          e.preventDefault();
        });
        secondsInputEl.bind('mousewheel wheel', function(e) {
          if (!disabled) {
            $scope.$apply(isScrollingUp(e) ? $scope.incrementSeconds() : $scope.decrementSeconds());
          }
          e.preventDefault();
        });
      };
      this.setupArrowkeyEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
        hoursInputEl.bind('keydown', function(e) {
          if (!disabled) {
            if (e.which === 38) {
              e.preventDefault();
              $scope.incrementHours();
              $scope.$apply();
            } else if (e.which === 40) {
              e.preventDefault();
              $scope.decrementHours();
              $scope.$apply();
            }
          }
        });
        minutesInputEl.bind('keydown', function(e) {
          if (!disabled) {
            if (e.which === 38) {
              e.preventDefault();
              $scope.incrementMinutes();
              $scope.$apply();
            } else if (e.which === 40) {
              e.preventDefault();
              $scope.decrementMinutes();
              $scope.$apply();
            }
          }
        });
        secondsInputEl.bind('keydown', function(e) {
          if (!disabled) {
            if (e.which === 38) {
              e.preventDefault();
              $scope.incrementSeconds();
              $scope.$apply();
            } else if (e.which === 40) {
              e.preventDefault();
              $scope.decrementSeconds();
              $scope.$apply();
            }
          }
        });
      };
      this.setupInputEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
        if ($scope.readonlyInput) {
          $scope.updateHours = angular.noop;
          $scope.updateMinutes = angular.noop;
          $scope.updateSeconds = angular.noop;
          return;
        }
        var invalidate = function(invalidHours, invalidMinutes, invalidSeconds) {
          ngModelCtrl.$setViewValue(null);
          ngModelCtrl.$setValidity('time', false);
          if (angular.isDefined(invalidHours)) {
            $scope.invalidHours = invalidHours;
          }
          if (angular.isDefined(invalidMinutes)) {
            $scope.invalidMinutes = invalidMinutes;
          }
          if (angular.isDefined(invalidSeconds)) {
            $scope.invalidSeconds = invalidSeconds;
          }
        };
        $scope.updateHours = function() {
          var hours = getHoursFromTemplate(),
              minutes = getMinutesFromTemplate();
          ngModelCtrl.$setDirty();
          if (angular.isDefined(hours) && angular.isDefined(minutes)) {
            selected.setHours(hours);
            selected.setMinutes(minutes);
            if (selected < min || selected > max) {
              invalidate(true);
            } else {
              refresh('h');
            }
          } else {
            invalidate(true);
          }
        };
        hoursInputEl.bind('blur', function(e) {
          ngModelCtrl.$setTouched();
          if (modelIsEmpty()) {
            makeValid();
          } else if ($scope.hours === null || $scope.hours === '') {
            invalidate(true);
          } else if (!$scope.invalidHours && $scope.hours < 10) {
            $scope.$apply(function() {
              $scope.hours = pad($scope.hours, !padHours);
            });
          }
        });
        $scope.updateMinutes = function() {
          var minutes = getMinutesFromTemplate(),
              hours = getHoursFromTemplate();
          ngModelCtrl.$setDirty();
          if (angular.isDefined(minutes) && angular.isDefined(hours)) {
            selected.setHours(hours);
            selected.setMinutes(minutes);
            if (selected < min || selected > max) {
              invalidate(undefined, true);
            } else {
              refresh('m');
            }
          } else {
            invalidate(undefined, true);
          }
        };
        minutesInputEl.bind('blur', function(e) {
          ngModelCtrl.$setTouched();
          if (modelIsEmpty()) {
            makeValid();
          } else if ($scope.minutes === null) {
            invalidate(undefined, true);
          } else if (!$scope.invalidMinutes && $scope.minutes < 10) {
            $scope.$apply(function() {
              $scope.minutes = pad($scope.minutes);
            });
          }
        });
        $scope.updateSeconds = function() {
          var seconds = getSecondsFromTemplate();
          ngModelCtrl.$setDirty();
          if (angular.isDefined(seconds)) {
            selected.setSeconds(seconds);
            refresh('s');
          } else {
            invalidate(undefined, undefined, true);
          }
        };
        secondsInputEl.bind('blur', function(e) {
          if (modelIsEmpty()) {
            makeValid();
          } else if (!$scope.invalidSeconds && $scope.seconds < 10) {
            $scope.$apply(function() {
              $scope.seconds = pad($scope.seconds);
            });
          }
        });
      };
      this.render = function() {
        var date = ngModelCtrl.$viewValue;
        if (isNaN(date)) {
          ngModelCtrl.$setValidity('time', false);
          $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
        } else {
          if (date) {
            selected = date;
          }
          if (selected < min || selected > max) {
            ngModelCtrl.$setValidity('time', false);
            $scope.invalidHours = true;
            $scope.invalidMinutes = true;
          } else {
            makeValid();
          }
          updateTemplate();
        }
      };
      function refresh(keyboardChange) {
        makeValid();
        ngModelCtrl.$setViewValue(new Date(selected));
        updateTemplate(keyboardChange);
      }
      function makeValid() {
        ngModelCtrl.$setValidity('time', true);
        $scope.invalidHours = false;
        $scope.invalidMinutes = false;
        $scope.invalidSeconds = false;
      }
      function updateTemplate(keyboardChange) {
        if (!ngModelCtrl.$modelValue) {
          $scope.hours = null;
          $scope.minutes = null;
          $scope.seconds = null;
          $scope.meridian = meridians[0];
        } else {
          var hours = selected.getHours(),
              minutes = selected.getMinutes(),
              seconds = selected.getSeconds();
          if ($scope.showMeridian) {
            hours = hours === 0 || hours === 12 ? 12 : hours % 12;
          }
          $scope.hours = keyboardChange === 'h' ? hours : pad(hours, !padHours);
          if (keyboardChange !== 'm') {
            $scope.minutes = pad(minutes);
          }
          $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
          if (keyboardChange !== 's') {
            $scope.seconds = pad(seconds);
          }
          $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
        }
      }
      function addSecondsToSelected(seconds) {
        selected = addSeconds(selected, seconds);
        refresh();
      }
      function addMinutes(selected, minutes) {
        return addSeconds(selected, minutes * 60);
      }
      function addSeconds(date, seconds) {
        var dt = new Date(date.getTime() + seconds * 1000);
        var newDate = new Date(date);
        newDate.setHours(dt.getHours(), dt.getMinutes(), dt.getSeconds());
        return newDate;
      }
      function modelIsEmpty() {
        return ($scope.hours === null || $scope.hours === '') && ($scope.minutes === null || $scope.minutes === '') && (!$scope.showSeconds || $scope.showSeconds && ($scope.seconds === null || $scope.seconds === ''));
      }
      $scope.showSpinners = angular.isDefined($attrs.showSpinners) ? $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;
      $scope.incrementHours = function() {
        if (!$scope.noIncrementHours()) {
          addSecondsToSelected(hourStep * 60 * 60);
        }
      };
      $scope.decrementHours = function() {
        if (!$scope.noDecrementHours()) {
          addSecondsToSelected(-hourStep * 60 * 60);
        }
      };
      $scope.incrementMinutes = function() {
        if (!$scope.noIncrementMinutes()) {
          addSecondsToSelected(minuteStep * 60);
        }
      };
      $scope.decrementMinutes = function() {
        if (!$scope.noDecrementMinutes()) {
          addSecondsToSelected(-minuteStep * 60);
        }
      };
      $scope.incrementSeconds = function() {
        if (!$scope.noIncrementSeconds()) {
          addSecondsToSelected(secondStep);
        }
      };
      $scope.decrementSeconds = function() {
        if (!$scope.noDecrementSeconds()) {
          addSecondsToSelected(-secondStep);
        }
      };
      $scope.toggleMeridian = function() {
        var minutes = getMinutesFromTemplate(),
            hours = getHoursFromTemplate();
        if (!$scope.noToggleMeridian()) {
          if (angular.isDefined(minutes) && angular.isDefined(hours)) {
            addSecondsToSelected(12 * 60 * (selected.getHours() < 12 ? 60 : -60));
          } else {
            $scope.meridian = $scope.meridian === meridians[0] ? meridians[1] : meridians[0];
          }
        }
      };
      $scope.blur = function() {
        ngModelCtrl.$setTouched();
      };
      $scope.$on('$destroy', function() {
        while (watchers.length) {
          watchers.shift()();
        }
      });
    }]).directive('uibTimepicker', ['uibTimepickerConfig', function(uibTimepickerConfig) {
      return {
        require: ['uibTimepicker', '?^ngModel'],
        restrict: 'A',
        controller: 'UibTimepickerController',
        controllerAs: 'timepicker',
        scope: {},
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || uibTimepickerConfig.templateUrl;
        },
        link: function(scope, element, attrs, ctrls) {
          var timepickerCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];
          if (ngModelCtrl) {
            timepickerCtrl.init(ngModelCtrl, element.find('input'));
          }
        }
      };
    }]);
    angular.module('ui.bootstrap.typeahead', ['ui.bootstrap.debounce', 'ui.bootstrap.position']).factory('uibTypeaheadParser', ['$parse', function($parse) {
      var TYPEAHEAD_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/;
      return {parse: function(input) {
          var match = input.match(TYPEAHEAD_REGEXP);
          if (!match) {
            throw new Error('Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_"' + ' but got "' + input + '".');
          }
          return {
            itemName: match[3],
            source: $parse(match[4]),
            viewMapper: $parse(match[2] || match[1]),
            modelMapper: $parse(match[1])
          };
        }};
    }]).controller('UibTypeaheadController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$$debounce', '$uibPosition', 'uibTypeaheadParser', function(originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $$debounce, $position, typeaheadParser) {
      var HOT_KEYS = [9, 13, 27, 38, 40];
      var eventDebounceTime = 200;
      var modelCtrl,
          ngModelOptions;
      var minLength = originalScope.$eval(attrs.typeaheadMinLength);
      if (!minLength && minLength !== 0) {
        minLength = 1;
      }
      originalScope.$watch(attrs.typeaheadMinLength, function(newVal) {
        minLength = !newVal && newVal !== 0 ? 1 : newVal;
      });
      var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;
      var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;
      originalScope.$watch(attrs.typeaheadEditable, function(newVal) {
        isEditable = newVal !== false;
      });
      var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;
      var isSelectEvent = attrs.typeaheadShouldSelect ? $parse(attrs.typeaheadShouldSelect) : function(scope, vals) {
        var evt = vals.$event;
        return evt.which === 13 || evt.which === 9;
      };
      var onSelectCallback = $parse(attrs.typeaheadOnSelect);
      var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;
      var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;
      var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;
      var appendToBody = attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;
      var appendTo = attrs.typeaheadAppendTo ? originalScope.$eval(attrs.typeaheadAppendTo) : null;
      var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;
      var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;
      var isOpenSetter = $parse(attrs.typeaheadIsOpen).assign || angular.noop;
      var showHint = originalScope.$eval(attrs.typeaheadShowHint) || false;
      var parsedModel = $parse(attrs.ngModel);
      var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');
      var $setModelValue = function(scope, newValue) {
        if (angular.isFunction(parsedModel(originalScope)) && ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {
          return invokeModelSetter(scope, {$$$p: newValue});
        }
        return parsedModel.assign(scope, newValue);
      };
      var parserResult = typeaheadParser.parse(attrs.uibTypeahead);
      var hasFocus;
      var selected;
      var scope = originalScope.$new();
      var offDestroy = originalScope.$on('$destroy', function() {
        scope.$destroy();
      });
      scope.$on('$destroy', offDestroy);
      var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
      element.attr({
        'aria-autocomplete': 'list',
        'aria-expanded': false,
        'aria-owns': popupId
      });
      var inputsContainer,
          hintInputElem;
      if (showHint) {
        inputsContainer = angular.element('<div></div>');
        inputsContainer.css('position', 'relative');
        element.after(inputsContainer);
        hintInputElem = element.clone();
        hintInputElem.attr('placeholder', '');
        hintInputElem.attr('tabindex', '-1');
        hintInputElem.val('');
        hintInputElem.css({
          'position': 'absolute',
          'top': '0px',
          'left': '0px',
          'border-color': 'transparent',
          'box-shadow': 'none',
          'opacity': 1,
          'background': 'none 0% 0% / auto repeat scroll padding-box border-box rgb(255, 255, 255)',
          'color': '#999'
        });
        element.css({
          'position': 'relative',
          'vertical-align': 'top',
          'background-color': 'transparent'
        });
        if (hintInputElem.attr('id')) {
          hintInputElem.removeAttr('id');
        }
        inputsContainer.append(hintInputElem);
        hintInputElem.after(element);
      }
      var popUpEl = angular.element('<div uib-typeahead-popup></div>');
      popUpEl.attr({
        id: popupId,
        matches: 'matches',
        active: 'activeIdx',
        select: 'select(activeIdx, evt)',
        'move-in-progress': 'moveInProgress',
        query: 'query',
        position: 'position',
        'assign-is-open': 'assignIsOpen(isOpen)',
        debounce: 'debounceUpdate'
      });
      if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
        popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);
      }
      if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {
        popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);
      }
      var resetHint = function() {
        if (showHint) {
          hintInputElem.val('');
        }
      };
      var resetMatches = function() {
        scope.matches = [];
        scope.activeIdx = -1;
        element.attr('aria-expanded', false);
        resetHint();
      };
      var getMatchId = function(index) {
        return popupId + '-option-' + index;
      };
      scope.$watch('activeIdx', function(index) {
        if (index < 0) {
          element.removeAttr('aria-activedescendant');
        } else {
          element.attr('aria-activedescendant', getMatchId(index));
        }
      });
      var inputIsExactMatch = function(inputValue, index) {
        if (scope.matches.length > index && inputValue) {
          return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();
        }
        return false;
      };
      var getMatchesAsync = function(inputValue, evt) {
        var locals = {$viewValue: inputValue};
        isLoadingSetter(originalScope, true);
        isNoResultsSetter(originalScope, false);
        $q.when(parserResult.source(originalScope, locals)).then(function(matches) {
          var onCurrentRequest = inputValue === modelCtrl.$viewValue;
          if (onCurrentRequest && hasFocus) {
            if (matches && matches.length > 0) {
              scope.activeIdx = focusFirst ? 0 : -1;
              isNoResultsSetter(originalScope, false);
              scope.matches.length = 0;
              for (var i = 0; i < matches.length; i++) {
                locals[parserResult.itemName] = matches[i];
                scope.matches.push({
                  id: getMatchId(i),
                  label: parserResult.viewMapper(scope, locals),
                  model: matches[i]
                });
              }
              scope.query = inputValue;
              recalculatePosition();
              element.attr('aria-expanded', true);
              if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {
                if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {
                  $$debounce(function() {
                    scope.select(0, evt);
                  }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);
                } else {
                  scope.select(0, evt);
                }
              }
              if (showHint) {
                var firstLabel = scope.matches[0].label;
                if (angular.isString(inputValue) && inputValue.length > 0 && firstLabel.slice(0, inputValue.length).toUpperCase() === inputValue.toUpperCase()) {
                  hintInputElem.val(inputValue + firstLabel.slice(inputValue.length));
                } else {
                  hintInputElem.val('');
                }
              }
            } else {
              resetMatches();
              isNoResultsSetter(originalScope, true);
            }
          }
          if (onCurrentRequest) {
            isLoadingSetter(originalScope, false);
          }
        }, function() {
          resetMatches();
          isLoadingSetter(originalScope, false);
          isNoResultsSetter(originalScope, true);
        });
      };
      if (appendToBody) {
        angular.element($window).on('resize', fireRecalculating);
        $document.find('body').on('scroll', fireRecalculating);
      }
      var debouncedRecalculate = $$debounce(function() {
        if (scope.matches.length) {
          recalculatePosition();
        }
        scope.moveInProgress = false;
      }, eventDebounceTime);
      scope.moveInProgress = false;
      function fireRecalculating() {
        if (!scope.moveInProgress) {
          scope.moveInProgress = true;
          scope.$digest();
        }
        debouncedRecalculate();
      }
      function recalculatePosition() {
        scope.position = appendToBody ? $position.offset(element) : $position.position(element);
        scope.position.top += element.prop('offsetHeight');
      }
      scope.query = undefined;
      var timeoutPromise;
      var scheduleSearchWithTimeout = function(inputValue) {
        timeoutPromise = $timeout(function() {
          getMatchesAsync(inputValue);
        }, waitTime);
      };
      var cancelPreviousTimeout = function() {
        if (timeoutPromise) {
          $timeout.cancel(timeoutPromise);
        }
      };
      resetMatches();
      scope.assignIsOpen = function(isOpen) {
        isOpenSetter(originalScope, isOpen);
      };
      scope.select = function(activeIdx, evt) {
        var locals = {};
        var model,
            item;
        selected = true;
        locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
        model = parserResult.modelMapper(originalScope, locals);
        $setModelValue(originalScope, model);
        modelCtrl.$setValidity('editable', true);
        modelCtrl.$setValidity('parse', true);
        onSelectCallback(originalScope, {
          $item: item,
          $model: model,
          $label: parserResult.viewMapper(originalScope, locals),
          $event: evt
        });
        resetMatches();
        if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {
          $timeout(function() {
            element[0].focus();
          }, 0, false);
        }
      };
      element.on('keydown', function(evt) {
        if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
          return;
        }
        var shouldSelect = isSelectEvent(originalScope, {$event: evt});
        if (scope.activeIdx === -1 && shouldSelect || evt.which === 9 && !!evt.shiftKey) {
          resetMatches();
          scope.$digest();
          return;
        }
        evt.preventDefault();
        var target;
        switch (evt.which) {
          case 27:
            evt.stopPropagation();
            resetMatches();
            originalScope.$digest();
            break;
          case 38:
            scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;
            scope.$digest();
            target = popUpEl[0].querySelectorAll('.uib-typeahead-match')[scope.activeIdx];
            target.parentNode.scrollTop = target.offsetTop;
            break;
          case 40:
            scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
            scope.$digest();
            target = popUpEl[0].querySelectorAll('.uib-typeahead-match')[scope.activeIdx];
            target.parentNode.scrollTop = target.offsetTop;
            break;
          default:
            if (shouldSelect) {
              scope.$apply(function() {
                if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {
                  $$debounce(function() {
                    scope.select(scope.activeIdx, evt);
                  }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);
                } else {
                  scope.select(scope.activeIdx, evt);
                }
              });
            }
        }
      });
      element.bind('focus', function(evt) {
        hasFocus = true;
        if (minLength === 0 && !modelCtrl.$viewValue) {
          $timeout(function() {
            getMatchesAsync(modelCtrl.$viewValue, evt);
          }, 0);
        }
      });
      element.bind('blur', function(evt) {
        if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {
          selected = true;
          scope.$apply(function() {
            if (angular.isObject(scope.debounceUpdate) && angular.isNumber(scope.debounceUpdate.blur)) {
              $$debounce(function() {
                scope.select(scope.activeIdx, evt);
              }, scope.debounceUpdate.blur);
            } else {
              scope.select(scope.activeIdx, evt);
            }
          });
        }
        if (!isEditable && modelCtrl.$error.editable) {
          modelCtrl.$setViewValue();
          scope.$apply(function() {
            modelCtrl.$setValidity('editable', true);
            modelCtrl.$setValidity('parse', true);
          });
          element.val('');
        }
        hasFocus = false;
        selected = false;
      });
      var dismissClickHandler = function(evt) {
        if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {
          resetMatches();
          if (!$rootScope.$$phase) {
            originalScope.$digest();
          }
        }
      };
      $document.on('click', dismissClickHandler);
      originalScope.$on('$destroy', function() {
        $document.off('click', dismissClickHandler);
        if (appendToBody || appendTo) {
          $popup.remove();
        }
        if (appendToBody) {
          angular.element($window).off('resize', fireRecalculating);
          $document.find('body').off('scroll', fireRecalculating);
        }
        popUpEl.remove();
        if (showHint) {
          inputsContainer.remove();
        }
      });
      var $popup = $compile(popUpEl)(scope);
      if (appendToBody) {
        $document.find('body').append($popup);
      } else if (appendTo) {
        angular.element(appendTo).eq(0).append($popup);
      } else {
        element.after($popup);
      }
      this.init = function(_modelCtrl, _ngModelOptions) {
        modelCtrl = _modelCtrl;
        ngModelOptions = _ngModelOptions;
        scope.debounceUpdate = modelCtrl.$options && $parse(modelCtrl.$options.debounce)(originalScope);
        modelCtrl.$parsers.unshift(function(inputValue) {
          hasFocus = true;
          if (minLength === 0 || inputValue && inputValue.length >= minLength) {
            if (waitTime > 0) {
              cancelPreviousTimeout();
              scheduleSearchWithTimeout(inputValue);
            } else {
              getMatchesAsync(inputValue);
            }
          } else {
            isLoadingSetter(originalScope, false);
            cancelPreviousTimeout();
            resetMatches();
          }
          if (isEditable) {
            return inputValue;
          }
          if (!inputValue) {
            modelCtrl.$setValidity('editable', true);
            return null;
          }
          modelCtrl.$setValidity('editable', false);
          return undefined;
        });
        modelCtrl.$formatters.push(function(modelValue) {
          var candidateViewValue,
              emptyViewValue;
          var locals = {};
          if (!isEditable) {
            modelCtrl.$setValidity('editable', true);
          }
          if (inputFormatter) {
            locals.$model = modelValue;
            return inputFormatter(originalScope, locals);
          }
          locals[parserResult.itemName] = modelValue;
          candidateViewValue = parserResult.viewMapper(originalScope, locals);
          locals[parserResult.itemName] = undefined;
          emptyViewValue = parserResult.viewMapper(originalScope, locals);
          return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;
        });
      };
    }]).directive('uibTypeahead', function() {
      return {
        controller: 'UibTypeaheadController',
        require: ['ngModel', '^?ngModelOptions', 'uibTypeahead'],
        link: function(originalScope, element, attrs, ctrls) {
          ctrls[2].init(ctrls[0], ctrls[1]);
        }
      };
    }).directive('uibTypeaheadPopup', ['$$debounce', function($$debounce) {
      return {
        scope: {
          matches: '=',
          query: '=',
          active: '=',
          position: '&',
          moveInProgress: '=',
          select: '&',
          assignIsOpen: '&',
          debounce: '&'
        },
        replace: true,
        templateUrl: function(element, attrs) {
          return attrs.popupTemplateUrl || 'uib/template/typeahead/typeahead-popup.html';
        },
        link: function(scope, element, attrs) {
          scope.templateUrl = attrs.templateUrl;
          scope.isOpen = function() {
            var isDropdownOpen = scope.matches.length > 0;
            scope.assignIsOpen({isOpen: isDropdownOpen});
            return isDropdownOpen;
          };
          scope.isActive = function(matchIdx) {
            return scope.active === matchIdx;
          };
          scope.selectActive = function(matchIdx) {
            scope.active = matchIdx;
          };
          scope.selectMatch = function(activeIdx, evt) {
            var debounce = scope.debounce();
            if (angular.isNumber(debounce) || angular.isObject(debounce)) {
              $$debounce(function() {
                scope.select({
                  activeIdx: activeIdx,
                  evt: evt
                });
              }, angular.isNumber(debounce) ? debounce : debounce['default']);
            } else {
              scope.select({
                activeIdx: activeIdx,
                evt: evt
              });
            }
          };
        }
      };
    }]).directive('uibTypeaheadMatch', ['$templateRequest', '$compile', '$parse', function($templateRequest, $compile, $parse) {
      return {
        scope: {
          index: '=',
          match: '=',
          query: '='
        },
        link: function(scope, element, attrs) {
          var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'uib/template/typeahead/typeahead-match.html';
          $templateRequest(tplUrl).then(function(tplContent) {
            var tplEl = angular.element(tplContent.trim());
            element.replaceWith(tplEl);
            $compile(tplEl)(scope);
          });
        }
      };
    }]).filter('uibTypeaheadHighlight', ['$sce', '$injector', '$log', function($sce, $injector, $log) {
      var isSanitizePresent;
      isSanitizePresent = $injector.has('$sanitize');
      function escapeRegexp(queryToEscape) {
        return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
      }
      function containsHtml(matchItem) {
        return /<.*>/g.test(matchItem);
      }
      return function(matchItem, query) {
        if (!isSanitizePresent && containsHtml(matchItem)) {
          $log.warn('Unsafe use of typeahead please use ngSanitize');
        }
        matchItem = query ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem;
        if (!isSanitizePresent) {
          matchItem = $sce.trustAsHtml(matchItem);
        }
        return matchItem;
      };
    }]);
    angular.module("uib/template/accordion/accordion-group.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/accordion/accordion-group.html", "<div role=\"tab\" id=\"{{::headingId}}\" aria-selected=\"{{isOpen}}\" class=\"panel-heading\" ng-keypress=\"toggleOpen($event)\">\n" + "  <h4 class=\"panel-title\">\n" + "    <a role=\"button\" data-toggle=\"collapse\" href aria-expanded=\"{{isOpen}}\" aria-controls=\"{{::panelId}}\" tabindex=\"0\" class=\"accordion-toggle\" ng-click=\"toggleOpen()\" uib-accordion-transclude=\"heading\" ng-disabled=\"isDisabled\" uib-tabindex-toggle><span uib-accordion-header ng-class=\"{'text-muted': isDisabled}\">{{heading}}</span></a>\n" + "  </h4>\n" + "</div>\n" + "<div id=\"{{::panelId}}\" aria-labelledby=\"{{::headingId}}\" aria-hidden=\"{{!isOpen}}\" role=\"tabpanel\" class=\"panel-collapse collapse\" uib-collapse=\"!isOpen\">\n" + "  <div class=\"panel-body\" ng-transclude></div>\n" + "</div>\n" + "");
    }]);
    angular.module("uib/template/accordion/accordion.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/accordion/accordion.html", "<div role=\"tablist\" class=\"panel-group\" ng-transclude></div>");
    }]);
    angular.module("uib/template/alert/alert.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/alert/alert.html", "<button ng-show=\"closeable\" type=\"button\" class=\"close\" ng-click=\"close({$event: $event})\">\n" + "  <span aria-hidden=\"true\">&times;</span>\n" + "  <span class=\"sr-only\">Close</span>\n" + "</button>\n" + "<div ng-transclude></div>\n" + "");
    }]);
    angular.module("uib/template/carousel/carousel.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/carousel/carousel.html", "<div class=\"carousel-inner\" ng-transclude></div>\n" + "<a role=\"button\" href class=\"left carousel-control\" ng-click=\"prev()\" ng-class=\"{ disabled: isPrevDisabled() }\" ng-show=\"slides.length > 1\">\n" + "  <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></span>\n" + "  <span class=\"sr-only\">previous</span>\n" + "</a>\n" + "<a role=\"button\" href class=\"right carousel-control\" ng-click=\"next()\" ng-class=\"{ disabled: isNextDisabled() }\" ng-show=\"slides.length > 1\">\n" + "  <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></span>\n" + "  <span class=\"sr-only\">next</span>\n" + "</a>\n" + "<ol class=\"carousel-indicators\" ng-show=\"slides.length > 1\">\n" + "  <li ng-repeat=\"slide in slides | orderBy:indexOfSlide track by $index\" ng-class=\"{ active: isActive(slide) }\" ng-click=\"select(slide)\">\n" + "    <span class=\"sr-only\">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if=\"isActive(slide)\">, currently active</span></span>\n" + "  </li>\n" + "</ol>\n" + "");
    }]);
    angular.module("uib/template/carousel/slide.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/carousel/slide.html", "<div class=\"text-center\" ng-transclude></div>\n" + "");
    }]);
    angular.module("uib/template/datepicker/datepicker.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/datepicker/datepicker.html", "<div ng-switch=\"datepickerMode\">\n" + "  <div uib-daypicker ng-switch-when=\"day\" tabindex=\"0\" class=\"uib-daypicker\"></div>\n" + "  <div uib-monthpicker ng-switch-when=\"month\" tabindex=\"0\" class=\"uib-monthpicker\"></div>\n" + "  <div uib-yearpicker ng-switch-when=\"year\" tabindex=\"0\" class=\"uib-yearpicker\"></div>\n" + "</div>\n" + "");
    }]);
    angular.module("uib/template/datepicker/day.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/datepicker/day.html", "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" + "  <thead>\n" + "    <tr>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" + "      <th colspan=\"{{::5 + showWeeks}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" + "    </tr>\n" + "    <tr>\n" + "      <th ng-if=\"showWeeks\" class=\"text-center\"></th>\n" + "      <th ng-repeat=\"label in ::labels track by $index\" class=\"text-center\"><small aria-label=\"{{::label.full}}\">{{::label.abbr}}</small></th>\n" + "    </tr>\n" + "  </thead>\n" + "  <tbody>\n" + "    <tr class=\"uib-weeks\" ng-repeat=\"row in rows track by $index\">\n" + "      <td ng-if=\"showWeeks\" class=\"text-center h6\"><em>{{ weekNumbers[$index] }}</em></td>\n" + "      <td ng-repeat=\"dt in row\" class=\"uib-day text-center\" role=\"gridcell\"\n" + "        id=\"{{::dt.uid}}\"\n" + "        ng-class=\"::dt.customClass\">\n" + "        <button type=\"button\" class=\"btn btn-default btn-sm\"\n" + "          uib-is-class=\"\n" + "            'btn-info' for selectedDt,\n" + "            'active' for activeDt\n" + "            on dt\"\n" + "          ng-click=\"select(dt.date)\"\n" + "          ng-disabled=\"::dt.disabled\"\n" + "          tabindex=\"-1\"><span ng-class=\"::{'text-muted': dt.secondary, 'text-info': dt.current}\">{{::dt.label}}</span></button>\n" + "      </td>\n" + "    </tr>\n" + "  </tbody>\n" + "</table>\n" + "");
    }]);
    angular.module("uib/template/datepicker/month.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/datepicker/month.html", "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" + "  <thead>\n" + "    <tr>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" + "      <th colspan=\"{{::yearHeaderColspan}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" + "    </tr>\n" + "  </thead>\n" + "  <tbody>\n" + "    <tr class=\"uib-months\" ng-repeat=\"row in rows track by $index\">\n" + "      <td ng-repeat=\"dt in row\" class=\"uib-month text-center\" role=\"gridcell\"\n" + "        id=\"{{::dt.uid}}\"\n" + "        ng-class=\"::dt.customClass\">\n" + "        <button type=\"button\" class=\"btn btn-default\"\n" + "          uib-is-class=\"\n" + "            'btn-info' for selectedDt,\n" + "            'active' for activeDt\n" + "            on dt\"\n" + "          ng-click=\"select(dt.date)\"\n" + "          ng-disabled=\"::dt.disabled\"\n" + "          tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" + "      </td>\n" + "    </tr>\n" + "  </tbody>\n" + "</table>\n" + "");
    }]);
    angular.module("uib/template/datepicker/year.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/datepicker/year.html", "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" + "  <thead>\n" + "    <tr>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" + "      <th colspan=\"{{::columns - 2}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" + "    </tr>\n" + "  </thead>\n" + "  <tbody>\n" + "    <tr class=\"uib-years\" ng-repeat=\"row in rows track by $index\">\n" + "      <td ng-repeat=\"dt in row\" class=\"uib-year text-center\" role=\"gridcell\"\n" + "        id=\"{{::dt.uid}}\"\n" + "        ng-class=\"::dt.customClass\">\n" + "        <button type=\"button\" class=\"btn btn-default\"\n" + "          uib-is-class=\"\n" + "            'btn-info' for selectedDt,\n" + "            'active' for activeDt\n" + "            on dt\"\n" + "          ng-click=\"select(dt.date)\"\n" + "          ng-disabled=\"::dt.disabled\"\n" + "          tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" + "      </td>\n" + "    </tr>\n" + "  </tbody>\n" + "</table>\n" + "");
    }]);
    angular.module("uib/template/datepickerPopup/popup.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/datepickerPopup/popup.html", "<ul class=\"uib-datepicker-popup dropdown-menu uib-position-measure\" dropdown-nested ng-if=\"isOpen\" ng-keydown=\"keydown($event)\" ng-click=\"$event.stopPropagation()\">\n" + "  <li ng-transclude></li>\n" + "  <li ng-if=\"showButtonBar\" class=\"uib-button-bar\">\n" + "    <span class=\"btn-group pull-left\">\n" + "      <button type=\"button\" class=\"btn btn-sm btn-info uib-datepicker-current\" ng-click=\"select('today', $event)\" ng-disabled=\"isDisabled('today')\">{{ getText('current') }}</button>\n" + "      <button type=\"button\" class=\"btn btn-sm btn-danger uib-clear\" ng-click=\"select(null, $event)\">{{ getText('clear') }}</button>\n" + "    </span>\n" + "    <button type=\"button\" class=\"btn btn-sm btn-success pull-right uib-close\" ng-click=\"close($event)\">{{ getText('close') }}</button>\n" + "  </li>\n" + "</ul>\n" + "");
    }]);
    angular.module("uib/template/modal/window.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/modal/window.html", "<div class=\"modal-dialog {{size ? 'modal-' + size : ''}}\"><div class=\"modal-content\" uib-modal-transclude></div></div>\n" + "");
    }]);
    angular.module("uib/template/pager/pager.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/pager/pager.html", "<li ng-class=\"{disabled: noPrevious()||ngDisabled, previous: align}\"><a href ng-click=\"selectPage(page - 1, $event)\" ng-disabled=\"noPrevious()||ngDisabled\" uib-tabindex-toggle>{{::getText('previous')}}</a></li>\n" + "<li ng-class=\"{disabled: noNext()||ngDisabled, next: align}\"><a href ng-click=\"selectPage(page + 1, $event)\" ng-disabled=\"noNext()||ngDisabled\" uib-tabindex-toggle>{{::getText('next')}}</a></li>\n" + "");
    }]);
    angular.module("uib/template/pagination/pagination.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/pagination/pagination.html", "<li ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-first\"><a href ng-click=\"selectPage(1, $event)\" ng-disabled=\"noPrevious()||ngDisabled\" uib-tabindex-toggle>{{::getText('first')}}</a></li>\n" + "<li ng-if=\"::directionLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-prev\"><a href ng-click=\"selectPage(page - 1, $event)\" ng-disabled=\"noPrevious()||ngDisabled\" uib-tabindex-toggle>{{::getText('previous')}}</a></li>\n" + "<li ng-repeat=\"page in pages track by $index\" ng-class=\"{active: page.active,disabled: ngDisabled&&!page.active}\" class=\"pagination-page\"><a href ng-click=\"selectPage(page.number, $event)\" ng-disabled=\"ngDisabled&&!page.active\" uib-tabindex-toggle>{{page.text}}</a></li>\n" + "<li ng-if=\"::directionLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-next\"><a href ng-click=\"selectPage(page + 1, $event)\" ng-disabled=\"noNext()||ngDisabled\" uib-tabindex-toggle>{{::getText('next')}}</a></li>\n" + "<li ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-last\"><a href ng-click=\"selectPage(totalPages, $event)\" ng-disabled=\"noNext()||ngDisabled\" uib-tabindex-toggle>{{::getText('last')}}</a></li>\n" + "");
    }]);
    angular.module("uib/template/tooltip/tooltip-html-popup.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/tooltip/tooltip-html-popup.html", "<div class=\"tooltip-arrow\"></div>\n" + "<div class=\"tooltip-inner\" ng-bind-html=\"contentExp()\"></div>\n" + "");
    }]);
    angular.module("uib/template/tooltip/tooltip-popup.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/tooltip/tooltip-popup.html", "<div class=\"tooltip-arrow\"></div>\n" + "<div class=\"tooltip-inner\" ng-bind=\"content\"></div>\n" + "");
    }]);
    angular.module("uib/template/tooltip/tooltip-template-popup.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/tooltip/tooltip-template-popup.html", "<div class=\"tooltip-arrow\"></div>\n" + "<div class=\"tooltip-inner\"\n" + "  uib-tooltip-template-transclude=\"contentExp()\"\n" + "  tooltip-template-transclude-scope=\"originScope()\"></div>\n" + "");
    }]);
    angular.module("uib/template/popover/popover-html.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/popover/popover-html.html", "<div class=\"arrow\"></div>\n" + "\n" + "<div class=\"popover-inner\">\n" + "    <h3 class=\"popover-title\" ng-bind=\"uibTitle\" ng-if=\"uibTitle\"></h3>\n" + "    <div class=\"popover-content\" ng-bind-html=\"contentExp()\"></div>\n" + "</div>\n" + "");
    }]);
    angular.module("uib/template/popover/popover-template.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/popover/popover-template.html", "<div class=\"arrow\"></div>\n" + "\n" + "<div class=\"popover-inner\">\n" + "    <h3 class=\"popover-title\" ng-bind=\"uibTitle\" ng-if=\"uibTitle\"></h3>\n" + "    <div class=\"popover-content\"\n" + "      uib-tooltip-template-transclude=\"contentExp()\"\n" + "      tooltip-template-transclude-scope=\"originScope()\"></div>\n" + "</div>\n" + "");
    }]);
    angular.module("uib/template/popover/popover.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/popover/popover.html", "<div class=\"arrow\"></div>\n" + "\n" + "<div class=\"popover-inner\">\n" + "    <h3 class=\"popover-title\" ng-bind=\"uibTitle\" ng-if=\"uibTitle\"></h3>\n" + "    <div class=\"popover-content\" ng-bind=\"content\"></div>\n" + "</div>\n" + "");
    }]);
    angular.module("uib/template/progressbar/bar.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/progressbar/bar.html", "<div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" aria-labelledby=\"{{::title}}\" ng-transclude></div>\n" + "");
    }]);
    angular.module("uib/template/progressbar/progress.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/progressbar/progress.html", "<div class=\"progress\" ng-transclude aria-labelledby=\"{{::title}}\"></div>");
    }]);
    angular.module("uib/template/progressbar/progressbar.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/progressbar/progressbar.html", "<div class=\"progress\">\n" + "  <div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" aria-labelledby=\"{{::title}}\" ng-transclude></div>\n" + "</div>\n" + "");
    }]);
    angular.module("uib/template/rating/rating.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/rating/rating.html", "<span ng-mouseleave=\"reset()\" ng-keydown=\"onKeydown($event)\" tabindex=\"0\" role=\"slider\" aria-valuemin=\"0\" aria-valuemax=\"{{range.length}}\" aria-valuenow=\"{{value}}\" aria-valuetext=\"{{title}}\">\n" + "    <span ng-repeat-start=\"r in range track by $index\" class=\"sr-only\">({{ $index < value ? '*' : ' ' }})</span>\n" + "    <i ng-repeat-end ng-mouseenter=\"enter($index + 1)\" ng-click=\"rate($index + 1)\" class=\"glyphicon\" ng-class=\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\" ng-attr-title=\"{{r.title}}\"></i>\n" + "</span>\n" + "");
    }]);
    angular.module("uib/template/tabs/tab.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/tabs/tab.html", "<li ng-class=\"[{active: active, disabled: disabled}, classes]\" class=\"uib-tab nav-item\">\n" + "  <a href ng-click=\"select($event)\" class=\"nav-link\" uib-tab-heading-transclude>{{heading}}</a>\n" + "</li>\n" + "");
    }]);
    angular.module("uib/template/tabs/tabset.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/tabs/tabset.html", "<div>\n" + "  <ul class=\"nav nav-{{tabset.type || 'tabs'}}\" ng-class=\"{'nav-stacked': vertical, 'nav-justified': justified}\" ng-transclude></ul>\n" + "  <div class=\"tab-content\">\n" + "    <div class=\"tab-pane\"\n" + "         ng-repeat=\"tab in tabset.tabs\"\n" + "         ng-class=\"{active: tabset.active === tab.index}\"\n" + "         uib-tab-content-transclude=\"tab\">\n" + "    </div>\n" + "  </div>\n" + "</div>\n" + "");
    }]);
    angular.module("uib/template/timepicker/timepicker.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/timepicker/timepicker.html", "<table class=\"uib-timepicker\">\n" + "  <tbody>\n" + "    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" + "      <td class=\"uib-increment hours\"><a ng-click=\"incrementHours()\" ng-class=\"{disabled: noIncrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementHours()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" + "      <td>&nbsp;</td>\n" + "      <td class=\"uib-increment minutes\"><a ng-click=\"incrementMinutes()\" ng-class=\"{disabled: noIncrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementMinutes()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" + "      <td ng-show=\"showSeconds\">&nbsp;</td>\n" + "      <td ng-show=\"showSeconds\" class=\"uib-increment seconds\"><a ng-click=\"incrementSeconds()\" ng-class=\"{disabled: noIncrementSeconds()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementSeconds()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" + "      <td ng-show=\"showMeridian\"></td>\n" + "    </tr>\n" + "    <tr>\n" + "      <td class=\"form-group uib-time hours\" ng-class=\"{'has-error': invalidHours}\">\n" + "        <input type=\"text\" placeholder=\"HH\" ng-model=\"hours\" ng-change=\"updateHours()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementHours()\" ng-blur=\"blur()\">\n" + "      </td>\n" + "      <td class=\"uib-separator\">:</td>\n" + "      <td class=\"form-group uib-time minutes\" ng-class=\"{'has-error': invalidMinutes}\">\n" + "        <input type=\"text\" placeholder=\"MM\" ng-model=\"minutes\" ng-change=\"updateMinutes()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementMinutes()\" ng-blur=\"blur()\">\n" + "      </td>\n" + "      <td ng-show=\"showSeconds\" class=\"uib-separator\">:</td>\n" + "      <td class=\"form-group uib-time seconds\" ng-class=\"{'has-error': invalidSeconds}\" ng-show=\"showSeconds\">\n" + "        <input type=\"text\" placeholder=\"SS\" ng-model=\"seconds\" ng-change=\"updateSeconds()\" class=\"form-control text-center\" ng-readonly=\"readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementSeconds()\" ng-blur=\"blur()\">\n" + "      </td>\n" + "      <td ng-show=\"showMeridian\" class=\"uib-time am-pm\"><button type=\"button\" ng-class=\"{disabled: noToggleMeridian()}\" class=\"btn btn-default text-center\" ng-click=\"toggleMeridian()\" ng-disabled=\"noToggleMeridian()\" tabindex=\"{{::tabindex}}\">{{meridian}}</button></td>\n" + "    </tr>\n" + "    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" + "      <td class=\"uib-decrement hours\"><a ng-click=\"decrementHours()\" ng-class=\"{disabled: noDecrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementHours()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" + "      <td>&nbsp;</td>\n" + "      <td class=\"uib-decrement minutes\"><a ng-click=\"decrementMinutes()\" ng-class=\"{disabled: noDecrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementMinutes()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" + "      <td ng-show=\"showSeconds\">&nbsp;</td>\n" + "      <td ng-show=\"showSeconds\" class=\"uib-decrement seconds\"><a ng-click=\"decrementSeconds()\" ng-class=\"{disabled: noDecrementSeconds()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementSeconds()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" + "      <td ng-show=\"showMeridian\"></td>\n" + "    </tr>\n" + "  </tbody>\n" + "</table>\n" + "");
    }]);
    angular.module("uib/template/typeahead/typeahead-match.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/typeahead/typeahead-match.html", "<a href\n" + "   tabindex=\"-1\"\n" + "   ng-bind-html=\"match.label | uibTypeaheadHighlight:query\"\n" + "   ng-attr-title=\"{{match.label}}\"></a>\n" + "");
    }]);
    angular.module("uib/template/typeahead/typeahead-popup.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/typeahead/typeahead-popup.html", "<ul class=\"dropdown-menu\" ng-show=\"isOpen() && !moveInProgress\" ng-style=\"{top: position().top+'px', left: position().left+'px'}\" role=\"listbox\" aria-hidden=\"{{!isOpen()}}\">\n" + "    <li class=\"uib-typeahead-match\" ng-repeat=\"match in matches track by $index\" ng-class=\"{active: isActive($index) }\" ng-mouseenter=\"selectActive($index)\" ng-click=\"selectMatch($index, $event)\" role=\"option\" id=\"{{::match.id}}\">\n" + "        <div uib-typeahead-match index=\"$index\" match=\"match\" query=\"query\" template-url=\"templateUrl\"></div>\n" + "    </li>\n" + "</ul>\n" + "");
    }]);
    angular.module('ui.bootstrap.carousel').run(function() {
      !angular.$$csp().noInlineStyle && !angular.$$uibCarouselCss && angular.element(document).find('head').prepend('<style type="text/css">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>');
      angular.$$uibCarouselCss = true;
    });
    angular.module('ui.bootstrap.datepicker').run(function() {
      !angular.$$csp().noInlineStyle && !angular.$$uibDatepickerCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-datepicker .uib-title{width:100%;}.uib-day button,.uib-month button,.uib-year button{min-width:100%;}.uib-left,.uib-right{width:100%}</style>');
      angular.$$uibDatepickerCss = true;
    });
    angular.module('ui.bootstrap.position').run(function() {
      !angular.$$csp().noInlineStyle && !angular.$$uibPositionCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-position-measure{display:block !important;visibility:hidden !important;position:absolute !important;top:-9999px !important;left:-9999px !important;}.uib-position-scrollbar-measure{position:absolute !important;top:-9999px !important;width:50px !important;height:50px !important;overflow:scroll !important;}.uib-position-body-scrollbar-measure{overflow:scroll !important;}</style>');
      angular.$$uibPositionCss = true;
    });
    angular.module('ui.bootstrap.datepickerPopup').run(function() {
      !angular.$$csp().noInlineStyle && !angular.$$uibDatepickerpopupCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-datepicker-popup.dropdown-menu{display:block;float:none;margin:0;}.uib-button-bar{padding:10px 9px 2px;}</style>');
      angular.$$uibDatepickerpopupCss = true;
    });
    angular.module('ui.bootstrap.tooltip').run(function() {
      !angular.$$csp().noInlineStyle && !angular.$$uibTooltipCss && angular.element(document).find('head').prepend('<style type="text/css">[uib-tooltip-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-bottom > .tooltip-arrow,[uib-popover-popup].popover.top-left > .arrow,[uib-popover-popup].popover.top-right > .arrow,[uib-popover-popup].popover.bottom-left > .arrow,[uib-popover-popup].popover.bottom-right > .arrow,[uib-popover-popup].popover.left-top > .arrow,[uib-popover-popup].popover.left-bottom > .arrow,[uib-popover-popup].popover.right-top > .arrow,[uib-popover-popup].popover.right-bottom > .arrow,[uib-popover-html-popup].popover.top-left > .arrow,[uib-popover-html-popup].popover.top-right > .arrow,[uib-popover-html-popup].popover.bottom-left > .arrow,[uib-popover-html-popup].popover.bottom-right > .arrow,[uib-popover-html-popup].popover.left-top > .arrow,[uib-popover-html-popup].popover.left-bottom > .arrow,[uib-popover-html-popup].popover.right-top > .arrow,[uib-popover-html-popup].popover.right-bottom > .arrow,[uib-popover-template-popup].popover.top-left > .arrow,[uib-popover-template-popup].popover.top-right > .arrow,[uib-popover-template-popup].popover.bottom-left > .arrow,[uib-popover-template-popup].popover.bottom-right > .arrow,[uib-popover-template-popup].popover.left-top > .arrow,[uib-popover-template-popup].popover.left-bottom > .arrow,[uib-popover-template-popup].popover.right-top > .arrow,[uib-popover-template-popup].popover.right-bottom > .arrow{top:auto;bottom:auto;left:auto;right:auto;margin:0;}[uib-popover-popup].popover,[uib-popover-html-popup].popover,[uib-popover-template-popup].popover{display:block !important;}</style>');
      angular.$$uibTooltipCss = true;
    });
    angular.module('ui.bootstrap.timepicker').run(function() {
      !angular.$$csp().noInlineStyle && !angular.$$uibTimepickerCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-time input{width:50px;}</style>');
      angular.$$uibTimepickerCss = true;
    });
    angular.module('ui.bootstrap.typeahead').run(function() {
      !angular.$$csp().noInlineStyle && !angular.$$uibTypeaheadCss && angular.element(document).find('head').prepend('<style type="text/css">[uib-typeahead-popup].dropdown-menu{display:block;}</style>');
      angular.$$uibTypeaheadCss = true;
    });
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("1c", ["1b"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('1b');
  module.exports = 'ui.bootstrap';
  return module.exports;
});

$__System.registerDynamic("1d", ["1c"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('1c');
  return module.exports;
});

$__System.registerDynamic("1e", [], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    (function() {
      'use strict';
      angular.module('angular-loading-bar', ['cfp.loadingBarInterceptor']);
      angular.module('chieffancypants.loadingBar', ['cfp.loadingBarInterceptor']);
      angular.module('cfp.loadingBarInterceptor', ['cfp.loadingBar']).config(['$httpProvider', function($httpProvider) {
        var interceptor = ['$q', '$cacheFactory', '$timeout', '$rootScope', '$log', 'cfpLoadingBar', function($q, $cacheFactory, $timeout, $rootScope, $log, cfpLoadingBar) {
          var reqsTotal = 0;
          var reqsCompleted = 0;
          var latencyThreshold = cfpLoadingBar.latencyThreshold;
          var startTimeout;
          function setComplete() {
            $timeout.cancel(startTimeout);
            cfpLoadingBar.complete();
            reqsCompleted = 0;
            reqsTotal = 0;
          }
          function isCached(config) {
            var cache;
            var defaultCache = $cacheFactory.get('$http');
            var defaults = $httpProvider.defaults;
            if ((config.cache || defaults.cache) && config.cache !== false && (config.method === 'GET' || config.method === 'JSONP')) {
              cache = angular.isObject(config.cache) ? config.cache : angular.isObject(defaults.cache) ? defaults.cache : defaultCache;
            }
            var cached = cache !== undefined ? cache.get(config.url) !== undefined : false;
            if (config.cached !== undefined && cached !== config.cached) {
              return config.cached;
            }
            config.cached = cached;
            return cached;
          }
          return {
            'request': function(config) {
              if (!config.ignoreLoadingBar && !isCached(config)) {
                $rootScope.$broadcast('cfpLoadingBar:loading', {url: config.url});
                if (reqsTotal === 0) {
                  startTimeout = $timeout(function() {
                    cfpLoadingBar.start();
                  }, latencyThreshold);
                }
                reqsTotal++;
                cfpLoadingBar.set(reqsCompleted / reqsTotal);
              }
              return config;
            },
            'response': function(response) {
              if (!response || !response.config) {
                $log.error('Broken interceptor detected: Config object not supplied in response:\n https://github.com/chieffancypants/angular-loading-bar/pull/50');
                return response;
              }
              if (!response.config.ignoreLoadingBar && !isCached(response.config)) {
                reqsCompleted++;
                $rootScope.$broadcast('cfpLoadingBar:loaded', {
                  url: response.config.url,
                  result: response
                });
                if (reqsCompleted >= reqsTotal) {
                  setComplete();
                } else {
                  cfpLoadingBar.set(reqsCompleted / reqsTotal);
                }
              }
              return response;
            },
            'responseError': function(rejection) {
              if (!rejection || !rejection.config) {
                $log.error('Broken interceptor detected: Config object not supplied in rejection:\n https://github.com/chieffancypants/angular-loading-bar/pull/50');
                return $q.reject(rejection);
              }
              if (!rejection.config.ignoreLoadingBar && !isCached(rejection.config)) {
                reqsCompleted++;
                $rootScope.$broadcast('cfpLoadingBar:loaded', {
                  url: rejection.config.url,
                  result: rejection
                });
                if (reqsCompleted >= reqsTotal) {
                  setComplete();
                } else {
                  cfpLoadingBar.set(reqsCompleted / reqsTotal);
                }
              }
              return $q.reject(rejection);
            }
          };
        }];
        $httpProvider.interceptors.push(interceptor);
      }]);
      angular.module('cfp.loadingBar', []).provider('cfpLoadingBar', function() {
        this.autoIncrement = true;
        this.includeSpinner = true;
        this.includeBar = true;
        this.latencyThreshold = 100;
        this.startSize = 0.02;
        this.parentSelector = 'body';
        this.spinnerTemplate = '<div id="loading-bar-spinner"><div class="spinner-icon"></div></div>';
        this.loadingBarTemplate = '<div id="loading-bar"><div class="bar"><div class="peg"></div></div></div>';
        this.$get = ['$injector', '$document', '$timeout', '$rootScope', function($injector, $document, $timeout, $rootScope) {
          var $animate;
          var $parentSelector = this.parentSelector,
              loadingBarContainer = angular.element(this.loadingBarTemplate),
              loadingBar = loadingBarContainer.find('div').eq(0),
              spinner = angular.element(this.spinnerTemplate);
          var incTimeout,
              completeTimeout,
              started = false,
              status = 0;
          var autoIncrement = this.autoIncrement;
          var includeSpinner = this.includeSpinner;
          var includeBar = this.includeBar;
          var startSize = this.startSize;
          function _start() {
            if (!$animate) {
              $animate = $injector.get('$animate');
            }
            $timeout.cancel(completeTimeout);
            if (started) {
              return;
            }
            var document = $document[0];
            var parent = document.querySelector ? document.querySelector($parentSelector) : $document.find($parentSelector)[0];
            ;
            if (!parent) {
              parent = document.getElementsByTagName('body')[0];
            }
            var $parent = angular.element(parent);
            var $after = parent.lastChild && angular.element(parent.lastChild);
            $rootScope.$broadcast('cfpLoadingBar:started');
            started = true;
            if (includeBar) {
              $animate.enter(loadingBarContainer, $parent, $after);
            }
            if (includeSpinner) {
              $animate.enter(spinner, $parent, loadingBarContainer);
            }
            _set(startSize);
          }
          function _set(n) {
            if (!started) {
              return;
            }
            var pct = (n * 100) + '%';
            loadingBar.css('width', pct);
            status = n;
            if (autoIncrement) {
              $timeout.cancel(incTimeout);
              incTimeout = $timeout(function() {
                _inc();
              }, 250);
            }
          }
          function _inc() {
            if (_status() >= 1) {
              return;
            }
            var rnd = 0;
            var stat = _status();
            if (stat >= 0 && stat < 0.25) {
              rnd = (Math.random() * (5 - 3 + 1) + 3) / 100;
            } else if (stat >= 0.25 && stat < 0.65) {
              rnd = (Math.random() * 3) / 100;
            } else if (stat >= 0.65 && stat < 0.9) {
              rnd = (Math.random() * 2) / 100;
            } else if (stat >= 0.9 && stat < 0.99) {
              rnd = 0.005;
            } else {
              rnd = 0;
            }
            var pct = _status() + rnd;
            _set(pct);
          }
          function _status() {
            return status;
          }
          function _completeAnimation() {
            status = 0;
            started = false;
          }
          function _complete() {
            if (!$animate) {
              $animate = $injector.get('$animate');
            }
            $rootScope.$broadcast('cfpLoadingBar:completed');
            _set(1);
            $timeout.cancel(completeTimeout);
            completeTimeout = $timeout(function() {
              var promise = $animate.leave(loadingBarContainer, _completeAnimation);
              if (promise && promise.then) {
                promise.then(_completeAnimation);
              }
              $animate.leave(spinner);
            }, 500);
          }
          return {
            start: _start,
            set: _set,
            status: _status,
            inc: _inc,
            complete: _complete,
            autoIncrement: this.autoIncrement,
            includeSpinner: this.includeSpinner,
            latencyThreshold: this.latencyThreshold,
            parentSelector: this.parentSelector,
            startSize: this.startSize
          };
        }];
      });
    })();
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("1f", ["1e"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('1e');
  module.exports = 'angular-loading-bar';
  return module.exports;
});

$__System.registerDynamic("20", ["1f"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('1f');
  return module.exports;
});

$__System.register('21', ['5', '6', '7', '9', '12', '20', '22', '23', 'a', 'd', 'f', '1a', '1d'], function (_export) {
	var AbstractBootstrap, _classCallCheck, _get, _inherits, _createClass, Theme;

	return {
		setters: [function (_5) {}, function (_4) {
			AbstractBootstrap = _4.AbstractBootstrap;
		}, function (_3) {
			_classCallCheck = _3['default'];
		}, function (_6) {}, function (_7) {}, function (_8) {}, function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_a) {
			_createClass = _a['default'];
		}, function (_d) {}, function (_f) {}, function (_a2) {}, function (_d2) {}],
		execute: function () {
			'use strict';

			Theme = (function (_AbstractBootstrap) {
				_inherits(Theme, _AbstractBootstrap);

				function Theme() {
					_classCallCheck(this, Theme);

					_get(Object.getPrototypeOf(Theme.prototype), 'constructor', this).apply(this, arguments);
				}

				_createClass(Theme, [{
					key: 'initialize',
					value: function initialize() {
						this.addRequires(['ui.bootstrap', 'angular-loading-bar', 'ionic']);
						this.getApp().config(function (cfpLoadingBarProvider) {
							cfpLoadingBarProvider.includeBar = true;
							cfpLoadingBarProvider.parentSelector = '#loading-bar-container';
							cfpLoadingBarProvider.includeSpinner = false;
						});
						this.getApp().config(function ($locationProvider) {
							$locationProvider.html5Mode(false); // disable html5 mode on mobile devices.
							// other pieces of code.
						});
						this.getApp().config(function ($ionicConfigProvider) {
							$ionicConfigProvider.tabs.position("bottom");
						});
						this.getApp().run(function ($ionicPlatform) {
							$ionicPlatform.ready(function () {
								// Hide the accessory bar by default (remove this to show the accessory bar above the keyboard
								// for form inputs)
								if (window.cordova && window.cordova.plugins && window.cordova.plugins.Keyboard) {
									cordova.plugins.Keyboard.hideKeyboardAccessoryBar(true);
									cordova.plugins.Keyboard.disableScroll(true);
								}
								if (window.StatusBar) {
									// org.apache.cordova.statusbar required
									StatusBar.styleDefault();
								}
							});
						});

						this.getApp().run(function ($timeout, $state) {
							$timeout(function () {
								$state.go('app.index');
							}, 5000);
						});
						// this.getApp().config( ($ionicConfigProvider)=>{
						// 	$ionicConfigProvider.views.maxCache(0);
						// });
						//
						this.addRequires([]);

						/*
      this.getApp().config( ()=>{
      		});
      		this.getApp().run( ()=>{
      		});
      */
					}
				}]);

				return Theme;
			})(AbstractBootstrap);

			_export('default', Theme);
		}
	};
});
$__System.registerDynamic("24", [], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    'use strict';
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("25", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = "<div class=\"component component-header-menu-bar\">\r\n    <md-menu-bar id=\"header-links\">\r\n        <!-- Get Started -->\r\n        <md-menu ng-repeat=\"route in vm.routes\" ng-if=\"route.isDisplayable\">\r\n            <button ng-click=\"$mdOpenMenu()\" aria-label=\"{{route.displayText}}\" ng-class=\"{'visiting': vm.parentActive == route.id }\">\r\n                {{route.displayText}}\r\n            </button>\r\n            <md-menu-content>\r\n                <md-menu-item class=\"header-menu-bar-menu\" ng-class=\"{'visiting': vm.childActive == 'index' && vm.parentActive == route.id }\">\r\n                    <md-button ui-sref=\"{{route.sref}}\">{{route.displayText}}</md-button>\r\n                </md-menu-item>\r\n                <md-menu-item class=\"header-menu-bar-menu\" ng-repeat=\"child in route.routes\"  ng-if=\"child.isDisplayable\" ng-class=\"{'visiting': vm.childActive == child.id }\">\r\n                    <md-button ui-sref=\"{{child.sref}}\">{{child.displayText}}</md-button>\r\n                </md-menu-item>\r\n            </md-menu-content>\r\n        </md-menu>\r\n    </md-menu-bar>\r\n\r\n</div>";
  return module.exports;
});

$__System.register('26', ['6', '7', '10', '25', 'a'], function (_export) {
	var RouteConfig, Component, View, _classCallCheck, _, template, _createClass, HeaderMenuBar;

	return {
		setters: [function (_3) {
			RouteConfig = _3.RouteConfig;
			Component = _3.Component;
			View = _3.View;
		}, function (_2) {
			_classCallCheck = _2['default'];
		}, function (_4) {
			_ = _4['default'];
		}, function (_5) {
			template = _5['default'];
		}, function (_a) {
			_createClass = _a['default'];
		}],
		execute: function () {

			//start-non-standard
			// jshint unused: false
			'use strict';

			//end-non-standard

			HeaderMenuBar = (function () {
				function HeaderMenuBar($rootScope, $state) {
					_classCallCheck(this, _HeaderMenuBar);

					// var routes = null;
					// if(_.isObject(routes) && _.has(routes, "app")) {
					// 	this.routes = routes.app;
					// } else {
					// 	return false;
					// 	//throw new Error("Can't load route map for header-menu-bar");
					// }

					this.setActiveState($state.current.name);

					var that = this;
					$rootScope.$on('$stateChangeSuccess', function (event, toState, toParams, fromState, fromParams, options) {
						that.setActiveState(toState.name);
					});
				}

				_createClass(HeaderMenuBar, [{
					key: 'setActiveState',
					value: function setActiveState(route) {
						var splits = route.split(".");
						splits.shift(); // Get rid of app. from the splits;

						this.parentActive = null;
						this.childActive = null;

						if (splits.length >= 1) {
							this.parentActive = splits[0];
						}
						if (splits.length >= 2) {
							this.childActive = splits[1];
						}
					}
				}]);

				var _HeaderMenuBar = HeaderMenuBar;
				HeaderMenuBar = View({
					template: template,
					scope: {}

				})(HeaderMenuBar) || HeaderMenuBar;
				HeaderMenuBar = Component({
					selector: 'header-menu-bar'
				})(HeaderMenuBar) || HeaderMenuBar;
				return HeaderMenuBar;
			})();

			_export('default', HeaderMenuBar);
		}
	};
});
$__System.registerDynamic("27", ["28"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  "format cjs";
  (function(process) {
    ;
    (function() {
      var undefined;
      var VERSION = '3.10.1';
      var BIND_FLAG = 1,
          BIND_KEY_FLAG = 2,
          CURRY_BOUND_FLAG = 4,
          CURRY_FLAG = 8,
          CURRY_RIGHT_FLAG = 16,
          PARTIAL_FLAG = 32,
          PARTIAL_RIGHT_FLAG = 64,
          ARY_FLAG = 128,
          REARG_FLAG = 256;
      var DEFAULT_TRUNC_LENGTH = 30,
          DEFAULT_TRUNC_OMISSION = '...';
      var HOT_COUNT = 150,
          HOT_SPAN = 16;
      var LARGE_ARRAY_SIZE = 200;
      var LAZY_FILTER_FLAG = 1,
          LAZY_MAP_FLAG = 2;
      var FUNC_ERROR_TEXT = 'Expected a function';
      var PLACEHOLDER = '__lodash_placeholder__';
      var argsTag = '[object Arguments]',
          arrayTag = '[object Array]',
          boolTag = '[object Boolean]',
          dateTag = '[object Date]',
          errorTag = '[object Error]',
          funcTag = '[object Function]',
          mapTag = '[object Map]',
          numberTag = '[object Number]',
          objectTag = '[object Object]',
          regexpTag = '[object RegExp]',
          setTag = '[object Set]',
          stringTag = '[object String]',
          weakMapTag = '[object WeakMap]';
      var arrayBufferTag = '[object ArrayBuffer]',
          float32Tag = '[object Float32Array]',
          float64Tag = '[object Float64Array]',
          int8Tag = '[object Int8Array]',
          int16Tag = '[object Int16Array]',
          int32Tag = '[object Int32Array]',
          uint8Tag = '[object Uint8Array]',
          uint8ClampedTag = '[object Uint8ClampedArray]',
          uint16Tag = '[object Uint16Array]',
          uint32Tag = '[object Uint32Array]';
      var reEmptyStringLeading = /\b__p \+= '';/g,
          reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
          reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
          reUnescapedHtml = /[&<>"'`]/g,
          reHasEscapedHtml = RegExp(reEscapedHtml.source),
          reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g,
          reEvaluate = /<%([\s\S]+?)%>/g,
          reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
          reIsPlainProp = /^\w*$/,
          rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;
      var reRegExpChars = /^[:!,]|[\\^$.*+?()[\]{}|\/]|(^[0-9a-fA-Fnrtuvx])|([\n\r\u2028\u2029])/g,
          reHasRegExpChars = RegExp(reRegExpChars.source);
      var reComboMark = /[\u0300-\u036f\ufe20-\ufe23]/g;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reHasHexPrefix = /^0[xX]/;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsUint = /^\d+$/;
      var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var reWords = (function() {
        var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
            lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';
        return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
      }());
      var contextProps = ['Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array', 'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number', 'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'isFinite', 'parseFloat', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array', 'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap'];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[stringTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[mapTag] = cloneableTags[setTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        '\xc0': 'A',
        '\xc1': 'A',
        '\xc2': 'A',
        '\xc3': 'A',
        '\xc4': 'A',
        '\xc5': 'A',
        '\xe0': 'a',
        '\xe1': 'a',
        '\xe2': 'a',
        '\xe3': 'a',
        '\xe4': 'a',
        '\xe5': 'a',
        '\xc7': 'C',
        '\xe7': 'c',
        '\xd0': 'D',
        '\xf0': 'd',
        '\xc8': 'E',
        '\xc9': 'E',
        '\xca': 'E',
        '\xcb': 'E',
        '\xe8': 'e',
        '\xe9': 'e',
        '\xea': 'e',
        '\xeb': 'e',
        '\xcC': 'I',
        '\xcd': 'I',
        '\xce': 'I',
        '\xcf': 'I',
        '\xeC': 'i',
        '\xed': 'i',
        '\xee': 'i',
        '\xef': 'i',
        '\xd1': 'N',
        '\xf1': 'n',
        '\xd2': 'O',
        '\xd3': 'O',
        '\xd4': 'O',
        '\xd5': 'O',
        '\xd6': 'O',
        '\xd8': 'O',
        '\xf2': 'o',
        '\xf3': 'o',
        '\xf4': 'o',
        '\xf5': 'o',
        '\xf6': 'o',
        '\xf8': 'o',
        '\xd9': 'U',
        '\xda': 'U',
        '\xdb': 'U',
        '\xdc': 'U',
        '\xf9': 'u',
        '\xfa': 'u',
        '\xfb': 'u',
        '\xfc': 'u',
        '\xdd': 'Y',
        '\xfd': 'y',
        '\xff': 'y',
        '\xc6': 'Ae',
        '\xe6': 'ae',
        '\xde': 'Th',
        '\xfe': 'th',
        '\xdf': 'ss'
      };
      var htmlEscapes = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;',
        '`': '&#96;'
      };
      var htmlUnescapes = {
        '&amp;': '&',
        '&lt;': '<',
        '&gt;': '>',
        '&quot;': '"',
        '&#39;': "'",
        '&#96;': '`'
      };
      var objectTypes = {
        'function': true,
        'object': true
      };
      var regexpEscapes = {
        '0': 'x30',
        '1': 'x31',
        '2': 'x32',
        '3': 'x33',
        '4': 'x34',
        '5': 'x35',
        '6': 'x36',
        '7': 'x37',
        '8': 'x38',
        '9': 'x39',
        'A': 'x41',
        'B': 'x42',
        'C': 'x43',
        'D': 'x44',
        'E': 'x45',
        'F': 'x46',
        'a': 'x61',
        'b': 'x62',
        'c': 'x63',
        'd': 'x64',
        'e': 'x65',
        'f': 'x66',
        'n': 'x6e',
        'r': 'x72',
        't': 'x74',
        'u': 'x75',
        'v': 'x76',
        'x': 'x78'
      };
      var stringEscapes = {
        '\\': '\\',
        "'": "'",
        '\n': 'n',
        '\r': 'r',
        '\u2028': 'u2028',
        '\u2029': 'u2029'
      };
      var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
      var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
      var freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;
      var freeSelf = objectTypes[typeof self] && self && self.Object && self;
      var freeWindow = objectTypes[typeof window] && window && window.Object && window;
      var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
      var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;
      function baseCompareAscending(value, other) {
        if (value !== other) {
          var valIsNull = value === null,
              valIsUndef = value === undefined,
              valIsReflexive = value === value;
          var othIsNull = other === null,
              othIsUndef = other === undefined,
              othIsReflexive = other === other;
          if ((value > other && !othIsNull) || !valIsReflexive || (valIsNull && !othIsUndef && othIsReflexive) || (valIsUndef && othIsReflexive)) {
            return 1;
          }
          if ((value < other && !valIsNull) || !othIsReflexive || (othIsNull && !valIsUndef && valIsReflexive) || (othIsUndef && valIsReflexive)) {
            return -1;
          }
        }
        return 0;
      }
      function baseFindIndex(array, predicate, fromRight) {
        var length = array.length,
            index = fromRight ? length : -1;
        while ((fromRight ? index-- : ++index < length)) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        if (value !== value) {
          return indexOfNaN(array, fromIndex);
        }
        var index = fromIndex - 1,
            length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function baseIsFunction(value) {
        return typeof value == 'function' || false;
      }
      function baseToString(value) {
        return value == null ? '' : (value + '');
      }
      function charsLeftIndex(string, chars) {
        var index = -1,
            length = string.length;
        while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
        return index;
      }
      function charsRightIndex(string, chars) {
        var index = string.length;
        while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
        return index;
      }
      function compareAscending(object, other) {
        return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
      }
      function compareMultiple(object, other, orders) {
        var index = -1,
            objCriteria = object.criteria,
            othCriteria = other.criteria,
            length = objCriteria.length,
            ordersLength = orders.length;
        while (++index < length) {
          var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
          if (result) {
            if (index >= ordersLength) {
              return result;
            }
            var order = orders[index];
            return result * ((order === 'asc' || order === true) ? 1 : -1);
          }
        }
        return object.index - other.index;
      }
      function deburrLetter(letter) {
        return deburredLetters[letter];
      }
      function escapeHtmlChar(chr) {
        return htmlEscapes[chr];
      }
      function escapeRegExpChar(chr, leadingChar, whitespaceChar) {
        if (leadingChar) {
          chr = regexpEscapes[chr];
        } else if (whitespaceChar) {
          chr = stringEscapes[chr];
        }
        return '\\' + chr;
      }
      function escapeStringChar(chr) {
        return '\\' + stringEscapes[chr];
      }
      function indexOfNaN(array, fromIndex, fromRight) {
        var length = array.length,
            index = fromIndex + (fromRight ? 0 : -1);
        while ((fromRight ? index-- : ++index < length)) {
          var other = array[index];
          if (other !== other) {
            return index;
          }
        }
        return -1;
      }
      function isObjectLike(value) {
        return !!value && typeof value == 'object';
      }
      function isSpace(charCode) {
        return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 || (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
      }
      function replaceHolders(array, placeholder) {
        var index = -1,
            length = array.length,
            resIndex = -1,
            result = [];
        while (++index < length) {
          if (array[index] === placeholder) {
            array[index] = PLACEHOLDER;
            result[++resIndex] = index;
          }
        }
        return result;
      }
      function sortedUniq(array, iteratee) {
        var seen,
            index = -1,
            length = array.length,
            resIndex = -1,
            result = [];
        while (++index < length) {
          var value = array[index],
              computed = iteratee ? iteratee(value, index, array) : value;
          if (!index || seen !== computed) {
            seen = computed;
            result[++resIndex] = value;
          }
        }
        return result;
      }
      function trimmedLeftIndex(string) {
        var index = -1,
            length = string.length;
        while (++index < length && isSpace(string.charCodeAt(index))) {}
        return index;
      }
      function trimmedRightIndex(string) {
        var index = string.length;
        while (index-- && isSpace(string.charCodeAt(index))) {}
        return index;
      }
      function unescapeHtmlChar(chr) {
        return htmlUnescapes[chr];
      }
      function runInContext(context) {
        context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
        var Array = context.Array,
            Date = context.Date,
            Error = context.Error,
            Function = context.Function,
            Math = context.Math,
            Number = context.Number,
            Object = context.Object,
            RegExp = context.RegExp,
            String = context.String,
            TypeError = context.TypeError;
        var arrayProto = Array.prototype,
            objectProto = Object.prototype,
            stringProto = String.prototype;
        var fnToString = Function.prototype.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var objToString = objectProto.toString;
        var oldDash = root._;
        var reIsNative = RegExp('^' + fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
        var ArrayBuffer = context.ArrayBuffer,
            clearTimeout = context.clearTimeout,
            parseFloat = context.parseFloat,
            pow = Math.pow,
            propertyIsEnumerable = objectProto.propertyIsEnumerable,
            Set = getNative(context, 'Set'),
            setTimeout = context.setTimeout,
            splice = arrayProto.splice,
            Uint8Array = context.Uint8Array,
            WeakMap = getNative(context, 'WeakMap');
        var nativeCeil = Math.ceil,
            nativeCreate = getNative(Object, 'create'),
            nativeFloor = Math.floor,
            nativeIsArray = getNative(Array, 'isArray'),
            nativeIsFinite = context.isFinite,
            nativeKeys = getNative(Object, 'keys'),
            nativeMax = Math.max,
            nativeMin = Math.min,
            nativeNow = getNative(Date, 'now'),
            nativeParseInt = context.parseInt,
            nativeRandom = Math.random;
        var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
            POSITIVE_INFINITY = Number.POSITIVE_INFINITY;
        var MAX_ARRAY_LENGTH = 4294967295,
            MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
            HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        var MAX_SAFE_INTEGER = 9007199254740991;
        var metaMap = WeakMap && new WeakMap;
        var realNames = {};
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        function baseLodash() {}
        function LodashWrapper(value, chainAll, actions) {
          this.__wrapped__ = value;
          this.__actions__ = actions || [];
          this.__chain__ = !!chainAll;
        }
        var support = lodash.support = {};
        lodash.templateSettings = {
          'escape': reEscape,
          'evaluate': reEvaluate,
          'interpolate': reInterpolate,
          'variable': '',
          'imports': {'_': lodash}
        };
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = POSITIVE_INFINITY;
          this.__views__ = [];
        }
        function lazyClone() {
          var result = new LazyWrapper(this.__wrapped__);
          result.__actions__ = arrayCopy(this.__actions__);
          result.__dir__ = this.__dir__;
          result.__filtered__ = this.__filtered__;
          result.__iteratees__ = arrayCopy(this.__iteratees__);
          result.__takeCount__ = this.__takeCount__;
          result.__views__ = arrayCopy(this.__views__);
          return result;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result = new LazyWrapper(this);
            result.__dir__ = -1;
            result.__filtered__ = true;
          } else {
            result = this.clone();
            result.__dir__ *= -1;
          }
          return result;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(),
              dir = this.__dir__,
              isArr = isArray(array),
              isRight = dir < 0,
              arrLength = isArr ? array.length : 0,
              view = getView(0, arrLength, this.__views__),
              start = view.start,
              end = view.end,
              length = end - start,
              index = isRight ? end : (start - 1),
              iteratees = this.__iteratees__,
              iterLength = iteratees.length,
              resIndex = 0,
              takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || arrLength < LARGE_ARRAY_SIZE || (arrLength == length && takeCount == length)) {
            return baseWrapperValue((isRight && isArr) ? array.reverse() : array, this.__actions__);
          }
          var result = [];
          outer: while (length-- && resIndex < takeCount) {
            index += dir;
            var iterIndex = -1,
                value = array[index];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex],
                  iteratee = data.iteratee,
                  type = data.type,
                  computed = iteratee(value);
              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result[resIndex++] = value;
          }
          return result;
        }
        function MapCache() {
          this.__data__ = {};
        }
        function mapDelete(key) {
          return this.has(key) && delete this.__data__[key];
        }
        function mapGet(key) {
          return key == '__proto__' ? undefined : this.__data__[key];
        }
        function mapHas(key) {
          return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
        }
        function mapSet(key, value) {
          if (key != '__proto__') {
            this.__data__[key] = value;
          }
          return this;
        }
        function SetCache(values) {
          var length = values ? values.length : 0;
          this.data = {
            'hash': nativeCreate(null),
            'set': new Set
          };
          while (length--) {
            this.push(values[length]);
          }
        }
        function cacheIndexOf(cache, value) {
          var data = cache.data,
              result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];
          return result ? 0 : -1;
        }
        function cachePush(value) {
          var data = this.data;
          if (typeof value == 'string' || isObject(value)) {
            data.set.add(value);
          } else {
            data.hash[value] = true;
          }
        }
        function arrayConcat(array, other) {
          var index = -1,
              length = array.length,
              othIndex = -1,
              othLength = other.length,
              result = Array(length + othLength);
          while (++index < length) {
            result[index] = array[index];
          }
          while (++othIndex < othLength) {
            result[index++] = other[othIndex];
          }
          return result;
        }
        function arrayCopy(source, array) {
          var index = -1,
              length = source.length;
          array || (array = Array(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function arrayEach(array, iteratee) {
          var index = -1,
              length = array.length;
          while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEachRight(array, iteratee) {
          var length = array.length;
          while (length--) {
            if (iteratee(array[length], length, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEvery(array, predicate) {
          var index = -1,
              length = array.length;
          while (++index < length) {
            if (!predicate(array[index], index, array)) {
              return false;
            }
          }
          return true;
        }
        function arrayExtremum(array, iteratee, comparator, exValue) {
          var index = -1,
              length = array.length,
              computed = exValue,
              result = computed;
          while (++index < length) {
            var value = array[index],
                current = +iteratee(value);
            if (comparator(current, computed)) {
              computed = current;
              result = value;
            }
          }
          return result;
        }
        function arrayFilter(array, predicate) {
          var index = -1,
              length = array.length,
              resIndex = -1,
              result = [];
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result[++resIndex] = value;
            }
          }
          return result;
        }
        function arrayMap(array, iteratee) {
          var index = -1,
              length = array.length,
              result = Array(length);
          while (++index < length) {
            result[index] = iteratee(array[index], index, array);
          }
          return result;
        }
        function arrayPush(array, values) {
          var index = -1,
              length = values.length,
              offset = array.length;
          while (++index < length) {
            array[offset + index] = values[index];
          }
          return array;
        }
        function arrayReduce(array, iteratee, accumulator, initFromArray) {
          var index = -1,
              length = array.length;
          if (initFromArray && length) {
            accumulator = array[++index];
          }
          while (++index < length) {
            accumulator = iteratee(accumulator, array[index], index, array);
          }
          return accumulator;
        }
        function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
          var length = array.length;
          if (initFromArray && length) {
            accumulator = array[--length];
          }
          while (length--) {
            accumulator = iteratee(accumulator, array[length], length, array);
          }
          return accumulator;
        }
        function arraySome(array, predicate) {
          var index = -1,
              length = array.length;
          while (++index < length) {
            if (predicate(array[index], index, array)) {
              return true;
            }
          }
          return false;
        }
        function arraySum(array, iteratee) {
          var length = array.length,
              result = 0;
          while (length--) {
            result += +iteratee(array[length]) || 0;
          }
          return result;
        }
        function assignDefaults(objectValue, sourceValue) {
          return objectValue === undefined ? sourceValue : objectValue;
        }
        function assignOwnDefaults(objectValue, sourceValue, key, object) {
          return (objectValue === undefined || !hasOwnProperty.call(object, key)) ? sourceValue : objectValue;
        }
        function assignWith(object, source, customizer) {
          var index = -1,
              props = keys(source),
              length = props.length;
          while (++index < length) {
            var key = props[index],
                value = object[key],
                result = customizer(value, source[key], key, object, source);
            if ((result === result ? (result !== value) : (value === value)) || (value === undefined && !(key in object))) {
              object[key] = result;
            }
          }
          return object;
        }
        function baseAssign(object, source) {
          return source == null ? object : baseCopy(source, keys(source), object);
        }
        function baseAt(collection, props) {
          var index = -1,
              isNil = collection == null,
              isArr = !isNil && isArrayLike(collection),
              length = isArr ? collection.length : 0,
              propsLength = props.length,
              result = Array(propsLength);
          while (++index < propsLength) {
            var key = props[index];
            if (isArr) {
              result[index] = isIndex(key, length) ? collection[key] : undefined;
            } else {
              result[index] = isNil ? undefined : collection[key];
            }
          }
          return result;
        }
        function baseCopy(source, props, object) {
          object || (object = {});
          var index = -1,
              length = props.length;
          while (++index < length) {
            var key = props[index];
            object[key] = source[key];
          }
          return object;
        }
        function baseCallback(func, thisArg, argCount) {
          var type = typeof func;
          if (type == 'function') {
            return thisArg === undefined ? func : bindCallback(func, thisArg, argCount);
          }
          if (func == null) {
            return identity;
          }
          if (type == 'object') {
            return baseMatches(func);
          }
          return thisArg === undefined ? property(func) : baseMatchesProperty(func, thisArg);
        }
        function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
          var result;
          if (customizer) {
            result = object ? customizer(value, key, object) : customizer(value);
          }
          if (result !== undefined) {
            return result;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result = initCloneArray(value);
            if (!isDeep) {
              return arrayCopy(value, result);
            }
          } else {
            var tag = objToString.call(value),
                isFunc = tag == funcTag;
            if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
              result = initCloneObject(isFunc ? {} : value);
              if (!isDeep) {
                return baseAssign(result, value);
              }
            } else {
              return cloneableTags[tag] ? initCloneByTag(value, tag, isDeep) : (object ? value : {});
            }
          }
          stackA || (stackA = []);
          stackB || (stackB = []);
          var length = stackA.length;
          while (length--) {
            if (stackA[length] == value) {
              return stackB[length];
            }
          }
          stackA.push(value);
          stackB.push(result);
          (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
            result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
          });
          return result;
        }
        var baseCreate = (function() {
          function object() {}
          return function(prototype) {
            if (isObject(prototype)) {
              object.prototype = prototype;
              var result = new object;
              object.prototype = undefined;
            }
            return result || {};
          };
        }());
        function baseDelay(func, wait, args) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return setTimeout(function() {
            func.apply(undefined, args);
          }, wait);
        }
        function baseDifference(array, values) {
          var length = array ? array.length : 0,
              result = [];
          if (!length) {
            return result;
          }
          var index = -1,
              indexOf = getIndexOf(),
              isCommon = indexOf == baseIndexOf,
              cache = (isCommon && values.length >= LARGE_ARRAY_SIZE) ? createCache(values) : null,
              valuesLength = values.length;
          if (cache) {
            indexOf = cacheIndexOf;
            isCommon = false;
            values = cache;
          }
          outer: while (++index < length) {
            var value = array[index];
            if (isCommon && value === value) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values[valuesIndex] === value) {
                  continue outer;
                }
              }
              result.push(value);
            } else if (indexOf(values, value, 0) < 0) {
              result.push(value);
            }
          }
          return result;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result = true;
          baseEach(collection, function(value, index, collection) {
            result = !!predicate(value, index, collection);
            return result;
          });
          return result;
        }
        function baseExtremum(collection, iteratee, comparator, exValue) {
          var computed = exValue,
              result = computed;
          baseEach(collection, function(value, index, collection) {
            var current = +iteratee(value, index, collection);
            if (comparator(current, computed) || (current === exValue && current === result)) {
              computed = current;
              result = value;
            }
          });
          return result;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = start == null ? 0 : (+start || 0);
          if (start < 0) {
            start = -start > length ? 0 : (length + start);
          }
          end = (end === undefined || end > length) ? length : (+end || 0);
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : (end >>> 0);
          start >>>= 0;
          while (start < length) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result = [];
          baseEach(collection, function(value, index, collection) {
            if (predicate(value, index, collection)) {
              result.push(value);
            }
          });
          return result;
        }
        function baseFind(collection, predicate, eachFunc, retKey) {
          var result;
          eachFunc(collection, function(value, key, collection) {
            if (predicate(value, key, collection)) {
              result = retKey ? key : value;
              return false;
            }
          });
          return result;
        }
        function baseFlatten(array, isDeep, isStrict, result) {
          result || (result = []);
          var index = -1,
              length = array.length;
          while (++index < length) {
            var value = array[index];
            if (isObjectLike(value) && isArrayLike(value) && (isStrict || isArray(value) || isArguments(value))) {
              if (isDeep) {
                baseFlatten(value, isDeep, isStrict, result);
              } else {
                arrayPush(result, value);
              }
            } else if (!isStrict) {
              result[result.length] = value;
            }
          }
          return result;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForIn(object, iteratee) {
          return baseFor(object, iteratee, keysIn);
        }
        function baseForOwn(object, iteratee) {
          return baseFor(object, iteratee, keys);
        }
        function baseForOwnRight(object, iteratee) {
          return baseForRight(object, iteratee, keys);
        }
        function baseFunctions(object, props) {
          var index = -1,
              length = props.length,
              resIndex = -1,
              result = [];
          while (++index < length) {
            var key = props[index];
            if (isFunction(object[key])) {
              result[++resIndex] = key;
            }
          }
          return result;
        }
        function baseGet(object, path, pathKey) {
          if (object == null) {
            return;
          }
          if (pathKey !== undefined && pathKey in toObject(object)) {
            path = [pathKey];
          }
          var index = 0,
              length = path.length;
          while (object != null && index < length) {
            object = object[path[index++]];
          }
          return (index && index == length) ? object : undefined;
        }
        function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
        }
        function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
          var objIsArr = isArray(object),
              othIsArr = isArray(other),
              objTag = arrayTag,
              othTag = arrayTag;
          if (!objIsArr) {
            objTag = objToString.call(object);
            if (objTag == argsTag) {
              objTag = objectTag;
            } else if (objTag != objectTag) {
              objIsArr = isTypedArray(object);
            }
          }
          if (!othIsArr) {
            othTag = objToString.call(other);
            if (othTag == argsTag) {
              othTag = objectTag;
            } else if (othTag != objectTag) {
              othIsArr = isTypedArray(other);
            }
          }
          var objIsObj = objTag == objectTag,
              othIsObj = othTag == objectTag,
              isSameTag = objTag == othTag;
          if (isSameTag && !(objIsArr || objIsObj)) {
            return equalByTag(object, other, objTag);
          }
          if (!isLoose) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
            if (objIsWrapped || othIsWrapped) {
              return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stackA || (stackA = []);
          stackB || (stackB = []);
          var length = stackA.length;
          while (length--) {
            if (stackA[length] == object) {
              return stackB[length] == other;
            }
          }
          stackA.push(object);
          stackB.push(other);
          var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);
          stackA.pop();
          stackB.pop();
          return result;
        }
        function baseIsMatch(object, matchData, customizer) {
          var index = matchData.length,
              length = index,
              noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = toObject(object);
          while (index--) {
            var data = matchData[index];
            if ((noCustomizer && data[2]) ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0],
                objValue = object[key],
                srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined && !(key in object)) {
                return false;
              }
            } else {
              var result = customizer ? customizer(objValue, srcValue, key) : undefined;
              if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseMap(collection, iteratee) {
          var index = -1,
              result = isArrayLike(collection) ? Array(collection.length) : [];
          baseEach(collection, function(value, key, collection) {
            result[++index] = iteratee(value, key, collection);
          });
          return result;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            var key = matchData[0][0],
                value = matchData[0][1];
            return function(object) {
              if (object == null) {
                return false;
              }
              return object[key] === value && (value !== undefined || (key in toObject(object)));
            };
          }
          return function(object) {
            return baseIsMatch(object, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          var isArr = isArray(path),
              isCommon = isKey(path) && isStrictComparable(srcValue),
              pathKey = (path + '');
          path = toPath(path);
          return function(object) {
            if (object == null) {
              return false;
            }
            var key = pathKey;
            object = toObject(object);
            if ((isArr || !isCommon) && !(key in object)) {
              object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
              if (object == null) {
                return false;
              }
              key = last(path);
              object = toObject(object);
            }
            return object[key] === srcValue ? (srcValue !== undefined || (key in object)) : baseIsEqual(srcValue, object[key], undefined, true);
          };
        }
        function baseMerge(object, source, customizer, stackA, stackB) {
          if (!isObject(object)) {
            return object;
          }
          var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),
              props = isSrcArr ? undefined : keys(source);
          arrayEach(props || source, function(srcValue, key) {
            if (props) {
              key = srcValue;
              srcValue = source[key];
            }
            if (isObjectLike(srcValue)) {
              stackA || (stackA = []);
              stackB || (stackB = []);
              baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
            } else {
              var value = object[key],
                  result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
                  isCommon = result === undefined;
              if (isCommon) {
                result = srcValue;
              }
              if ((result !== undefined || (isSrcArr && !(key in object))) && (isCommon || (result === result ? (result !== value) : (value === value)))) {
                object[key] = result;
              }
            }
          });
          return object;
        }
        function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
          var length = stackA.length,
              srcValue = source[key];
          while (length--) {
            if (stackA[length] == srcValue) {
              object[key] = stackB[length];
              return;
            }
          }
          var value = object[key],
              result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
              isCommon = result === undefined;
          if (isCommon) {
            result = srcValue;
            if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {
              result = isArray(value) ? value : (isArrayLike(value) ? arrayCopy(value) : []);
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              result = isArguments(value) ? toPlainObject(value) : (isPlainObject(value) ? value : {});
            } else {
              isCommon = false;
            }
          }
          stackA.push(srcValue);
          stackB.push(result);
          if (isCommon) {
            object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
          } else if (result === result ? (result !== value) : (value === value)) {
            object[key] = result;
          }
        }
        function baseProperty(key) {
          return function(object) {
            return object == null ? undefined : object[key];
          };
        }
        function basePropertyDeep(path) {
          var pathKey = (path + '');
          path = toPath(path);
          return function(object) {
            return baseGet(object, path, pathKey);
          };
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0;
          while (length--) {
            var index = indexes[length];
            if (index != previous && isIndex(index)) {
              var previous = index;
              splice.call(array, index, 1);
            }
          }
          return array;
        }
        function baseRandom(min, max) {
          return min + nativeFloor(nativeRandom() * (max - min + 1));
        }
        function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
          eachFunc(collection, function(value, index, collection) {
            accumulator = initFromCollection ? (initFromCollection = false, value) : iteratee(accumulator, value, index, collection);
          });
          return accumulator;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        function baseSlice(array, start, end) {
          var index = -1,
              length = array.length;
          start = start == null ? 0 : (+start || 0);
          if (start < 0) {
            start = -start > length ? 0 : (length + start);
          }
          end = (end === undefined || end > length) ? length : (+end || 0);
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : ((end - start) >>> 0);
          start >>>= 0;
          var result = Array(length);
          while (++index < length) {
            result[index] = array[index + start];
          }
          return result;
        }
        function baseSome(collection, predicate) {
          var result;
          baseEach(collection, function(value, index, collection) {
            result = predicate(value, index, collection);
            return !result;
          });
          return !!result;
        }
        function baseSortBy(array, comparer) {
          var length = array.length;
          array.sort(comparer);
          while (length--) {
            array[length] = array[length].value;
          }
          return array;
        }
        function baseSortByOrder(collection, iteratees, orders) {
          var callback = getCallback(),
              index = -1;
          iteratees = arrayMap(iteratees, function(iteratee) {
            return callback(iteratee);
          });
          var result = baseMap(collection, function(value) {
            var criteria = arrayMap(iteratees, function(iteratee) {
              return iteratee(value);
            });
            return {
              'criteria': criteria,
              'index': ++index,
              'value': value
            };
          });
          return baseSortBy(result, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function baseSum(collection, iteratee) {
          var result = 0;
          baseEach(collection, function(value, index, collection) {
            result += +iteratee(value, index, collection) || 0;
          });
          return result;
        }
        function baseUniq(array, iteratee) {
          var index = -1,
              indexOf = getIndexOf(),
              length = array.length,
              isCommon = indexOf == baseIndexOf,
              isLarge = isCommon && length >= LARGE_ARRAY_SIZE,
              seen = isLarge ? createCache() : null,
              result = [];
          if (seen) {
            indexOf = cacheIndexOf;
            isCommon = false;
          } else {
            isLarge = false;
            seen = iteratee ? [] : result;
          }
          outer: while (++index < length) {
            var value = array[index],
                computed = iteratee ? iteratee(value, index, array) : value;
            if (isCommon && value === value) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee) {
                seen.push(computed);
              }
              result.push(value);
            } else if (indexOf(seen, computed, 0) < 0) {
              if (iteratee || isLarge) {
                seen.push(computed);
              }
              result.push(value);
            }
          }
          return result;
        }
        function baseValues(object, props) {
          var index = -1,
              length = props.length,
              result = Array(length);
          while (++index < length) {
            result[index] = object[props[index]];
          }
          return result;
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length,
              index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}
          return isDrop ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length)) : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
        }
        function baseWrapperValue(value, actions) {
          var result = value;
          if (result instanceof LazyWrapper) {
            result = result.value();
          }
          var index = -1,
              length = actions.length;
          while (++index < length) {
            var action = actions[index];
            result = action.func.apply(action.thisArg, arrayPush([result], action.args));
          }
          return result;
        }
        function binaryIndex(array, value, retHighest) {
          var low = 0,
              high = array ? array.length : low;
          if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = (low + high) >>> 1,
                  computed = array[mid];
              if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return binaryIndexBy(array, value, identity, retHighest);
        }
        function binaryIndexBy(array, value, iteratee, retHighest) {
          value = iteratee(value);
          var low = 0,
              high = array ? array.length : 0,
              valIsNaN = value !== value,
              valIsNull = value === null,
              valIsUndef = value === undefined;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2),
                computed = iteratee(array[mid]),
                isDef = computed !== undefined,
                isReflexive = computed === computed;
            if (valIsNaN) {
              var setLow = isReflexive || retHighest;
            } else if (valIsNull) {
              setLow = isReflexive && isDef && (retHighest || computed != null);
            } else if (valIsUndef) {
              setLow = isReflexive && (retHighest || isDef);
            } else if (computed == null) {
              setLow = false;
            } else {
              setLow = retHighest ? (computed <= value) : (computed < value);
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function bindCallback(func, thisArg, argCount) {
          if (typeof func != 'function') {
            return identity;
          }
          if (thisArg === undefined) {
            return func;
          }
          switch (argCount) {
            case 1:
              return function(value) {
                return func.call(thisArg, value);
              };
            case 3:
              return function(value, index, collection) {
                return func.call(thisArg, value, index, collection);
              };
            case 4:
              return function(accumulator, value, index, collection) {
                return func.call(thisArg, accumulator, value, index, collection);
              };
            case 5:
              return function(value, other, key, object, source) {
                return func.call(thisArg, value, other, key, object, source);
              };
          }
          return function() {
            return func.apply(thisArg, arguments);
          };
        }
        function bufferClone(buffer) {
          var result = new ArrayBuffer(buffer.byteLength),
              view = new Uint8Array(result);
          view.set(new Uint8Array(buffer));
          return result;
        }
        function composeArgs(args, partials, holders) {
          var holdersLength = holders.length,
              argsIndex = -1,
              argsLength = nativeMax(args.length - holdersLength, 0),
              leftIndex = -1,
              leftLength = partials.length,
              result = Array(leftLength + argsLength);
          while (++leftIndex < leftLength) {
            result[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            result[holders[argsIndex]] = args[argsIndex];
          }
          while (argsLength--) {
            result[leftIndex++] = args[argsIndex++];
          }
          return result;
        }
        function composeArgsRight(args, partials, holders) {
          var holdersIndex = -1,
              holdersLength = holders.length,
              argsIndex = -1,
              argsLength = nativeMax(args.length - holdersLength, 0),
              rightIndex = -1,
              rightLength = partials.length,
              result = Array(argsLength + rightLength);
          while (++argsIndex < argsLength) {
            result[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            result[offset + holders[holdersIndex]] = args[argsIndex++];
          }
          return result;
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee, thisArg) {
            var result = initializer ? initializer() : {};
            iteratee = getCallback(iteratee, thisArg, 3);
            if (isArray(collection)) {
              var index = -1,
                  length = collection.length;
              while (++index < length) {
                var value = collection[index];
                setter(result, value, iteratee(value, index, collection), collection);
              }
            } else {
              baseEach(collection, function(value, key, collection) {
                setter(result, value, iteratee(value, key, collection), collection);
              });
            }
            return result;
          };
        }
        function createAssigner(assigner) {
          return restParam(function(object, sources) {
            var index = -1,
                length = object == null ? 0 : sources.length,
                customizer = length > 2 ? sources[length - 2] : undefined,
                guard = length > 2 ? sources[2] : undefined,
                thisArg = length > 1 ? sources[length - 1] : undefined;
            if (typeof customizer == 'function') {
              customizer = bindCallback(customizer, thisArg, 5);
              length -= 2;
            } else {
              customizer = typeof thisArg == 'function' ? thisArg : undefined;
              length -= (customizer ? 1 : 0);
            }
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined : customizer;
              length = 1;
            }
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee) {
            var length = collection ? getLength(collection) : 0;
            if (!isLength(length)) {
              return eachFunc(collection, iteratee);
            }
            var index = fromRight ? length : -1,
                iterable = toObject(collection);
            while ((fromRight ? index-- : ++index < length)) {
              if (iteratee(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee, keysFunc) {
            var iterable = toObject(object),
                props = keysFunc(object),
                length = props.length,
                index = fromRight ? length : -1;
            while ((fromRight ? index-- : ++index < length)) {
              var key = props[index];
              if (iteratee(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBindWrapper(func, thisArg) {
          var Ctor = createCtorWrapper(func);
          function wrapper() {
            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
            return fn.apply(thisArg, arguments);
          }
          return wrapper;
        }
        function createCache(values) {
          return (nativeCreate && Set) ? new SetCache(values) : null;
        }
        function createCompounder(callback) {
          return function(string) {
            var index = -1,
                array = words(deburr(string)),
                length = array.length,
                result = '';
            while (++index < length) {
              result = callback(result, array[index], index);
            }
            return result;
          };
        }
        function createCtorWrapper(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor;
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype),
                result = Ctor.apply(thisBinding, args);
            return isObject(result) ? result : thisBinding;
          };
        }
        function createCurry(flag) {
          function curryFunc(func, arity, guard) {
            if (guard && isIterateeCall(func, arity, guard)) {
              arity = undefined;
            }
            var result = createWrapper(func, flag, undefined, undefined, undefined, undefined, undefined, arity);
            result.placeholder = curryFunc.placeholder;
            return result;
          }
          return curryFunc;
        }
        function createDefaults(assigner, customizer) {
          return restParam(function(args) {
            var object = args[0];
            if (object == null) {
              return object;
            }
            args.push(customizer);
            return assigner.apply(undefined, args);
          });
        }
        function createExtremum(comparator, exValue) {
          return function(collection, iteratee, thisArg) {
            if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
              iteratee = undefined;
            }
            iteratee = getCallback(iteratee, thisArg, 3);
            if (iteratee.length == 1) {
              collection = isArray(collection) ? collection : toIterable(collection);
              var result = arrayExtremum(collection, iteratee, comparator, exValue);
              if (!(collection.length && result === exValue)) {
                return result;
              }
            }
            return baseExtremum(collection, iteratee, comparator, exValue);
          };
        }
        function createFind(eachFunc, fromRight) {
          return function(collection, predicate, thisArg) {
            predicate = getCallback(predicate, thisArg, 3);
            if (isArray(collection)) {
              var index = baseFindIndex(collection, predicate, fromRight);
              return index > -1 ? collection[index] : undefined;
            }
            return baseFind(collection, predicate, eachFunc);
          };
        }
        function createFindIndex(fromRight) {
          return function(array, predicate, thisArg) {
            if (!(array && array.length)) {
              return -1;
            }
            predicate = getCallback(predicate, thisArg, 3);
            return baseFindIndex(array, predicate, fromRight);
          };
        }
        function createFindKey(objectFunc) {
          return function(object, predicate, thisArg) {
            predicate = getCallback(predicate, thisArg, 3);
            return baseFind(object, predicate, objectFunc, true);
          };
        }
        function createFlow(fromRight) {
          return function() {
            var wrapper,
                length = arguments.length,
                index = fromRight ? length : -1,
                leftIndex = 0,
                funcs = Array(length);
            while ((fromRight ? index-- : ++index < length)) {
              var func = funcs[leftIndex++] = arguments[index];
              if (typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
              }
              if (!wrapper && LodashWrapper.prototype.thru && getFuncName(func) == 'wrapper') {
                wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? -1 : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func),
                  data = funcName == 'wrapper' ? getData(func) : undefined;
              if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments,
                  value = args[0];
              if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
                return wrapper.plant(value).value();
              }
              var index = 0,
                  result = length ? funcs[index].apply(this, args) : value;
              while (++index < length) {
                result = funcs[index].call(this, result);
              }
              return result;
            };
          };
        }
        function createForEach(arrayFunc, eachFunc) {
          return function(collection, iteratee, thisArg) {
            return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection)) ? arrayFunc(collection, iteratee) : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
          };
        }
        function createForIn(objectFunc) {
          return function(object, iteratee, thisArg) {
            if (typeof iteratee != 'function' || thisArg !== undefined) {
              iteratee = bindCallback(iteratee, thisArg, 3);
            }
            return objectFunc(object, iteratee, keysIn);
          };
        }
        function createForOwn(objectFunc) {
          return function(object, iteratee, thisArg) {
            if (typeof iteratee != 'function' || thisArg !== undefined) {
              iteratee = bindCallback(iteratee, thisArg, 3);
            }
            return objectFunc(object, iteratee);
          };
        }
        function createObjectMapper(isMapKeys) {
          return function(object, iteratee, thisArg) {
            var result = {};
            iteratee = getCallback(iteratee, thisArg, 3);
            baseForOwn(object, function(value, key, object) {
              var mapped = iteratee(value, key, object);
              key = isMapKeys ? mapped : key;
              value = isMapKeys ? value : mapped;
              result[key] = value;
            });
            return result;
          };
        }
        function createPadDir(fromRight) {
          return function(string, length, chars) {
            string = baseToString(string);
            return (fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string);
          };
        }
        function createPartial(flag) {
          var partialFunc = restParam(function(func, partials) {
            var holders = replaceHolders(partials, partialFunc.placeholder);
            return createWrapper(func, flag, undefined, partials, holders);
          });
          return partialFunc;
        }
        function createReduce(arrayFunc, eachFunc) {
          return function(collection, iteratee, accumulator, thisArg) {
            var initFromArray = arguments.length < 3;
            return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection)) ? arrayFunc(collection, iteratee, accumulator, initFromArray) : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
          };
        }
        function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
          var isAry = bitmask & ARY_FLAG,
              isBind = bitmask & BIND_FLAG,
              isBindKey = bitmask & BIND_KEY_FLAG,
              isCurry = bitmask & CURRY_FLAG,
              isCurryBound = bitmask & CURRY_BOUND_FLAG,
              isCurryRight = bitmask & CURRY_RIGHT_FLAG,
              Ctor = isBindKey ? undefined : createCtorWrapper(func);
          function wrapper() {
            var length = arguments.length,
                index = length,
                args = Array(length);
            while (index--) {
              args[index] = arguments[index];
            }
            if (partials) {
              args = composeArgs(args, partials, holders);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight);
            }
            if (isCurry || isCurryRight) {
              var placeholder = wrapper.placeholder,
                  argsHolders = replaceHolders(args, placeholder);
              length -= argsHolders.length;
              if (length < arity) {
                var newArgPos = argPos ? arrayCopy(argPos) : undefined,
                    newArity = nativeMax(arity - length, 0),
                    newsHolders = isCurry ? argsHolders : undefined,
                    newHoldersRight = isCurry ? undefined : argsHolders,
                    newPartials = isCurry ? args : undefined,
                    newPartialsRight = isCurry ? undefined : args;
                bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
                bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);
                if (!isCurryBound) {
                  bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
                }
                var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],
                    result = createHybridWrapper.apply(undefined, newData);
                if (isLaziable(func)) {
                  setData(result, newData);
                }
                result.placeholder = placeholder;
                return result;
              }
            }
            var thisBinding = isBind ? thisArg : this,
                fn = isBindKey ? thisBinding[func] : func;
            if (argPos) {
              args = reorder(args, argPos);
            }
            if (isAry && ary < args.length) {
              args.length = ary;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtorWrapper(func);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createPadding(string, length, chars) {
          var strLength = string.length;
          length = +length;
          if (strLength >= length || !nativeIsFinite(length)) {
            return '';
          }
          var padLength = length - strLength;
          chars = chars == null ? ' ' : (chars + '');
          return repeat(chars, nativeCeil(padLength / chars.length)).slice(0, padLength);
        }
        function createPartialWrapper(func, bitmask, thisArg, partials) {
          var isBind = bitmask & BIND_FLAG,
              Ctor = createCtorWrapper(func);
          function wrapper() {
            var argsIndex = -1,
                argsLength = arguments.length,
                leftIndex = -1,
                leftLength = partials.length,
                args = Array(leftLength + argsLength);
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRound(methodName) {
          var func = Math[methodName];
          return function(number, precision) {
            precision = precision === undefined ? 0 : (+precision || 0);
            if (precision) {
              precision = pow(10, precision);
              return func(number * precision) / precision;
            }
            return func(number);
          };
        }
        function createSortedIndex(retHighest) {
          return function(array, value, iteratee, thisArg) {
            var callback = getCallback(iteratee);
            return (iteratee == null && callback === baseCallback) ? binaryIndex(array, value, retHighest) : binaryIndexBy(array, value, callback(iteratee, thisArg, 1), retHighest);
          };
        }
        function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
          var isBindKey = bitmask & BIND_KEY_FLAG;
          if (!isBindKey && typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
            partials = holders = undefined;
          }
          length -= (holders ? holders.length : 0);
          if (bitmask & PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials,
                holdersRight = holders;
            partials = holders = undefined;
          }
          var data = isBindKey ? undefined : getData(func),
              newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];
          if (data) {
            mergeData(newData, data);
            bitmask = newData[1];
            arity = newData[9];
          }
          newData[9] = arity == null ? (isBindKey ? 0 : func.length) : (nativeMax(arity - length, 0) || 0);
          if (bitmask == BIND_FLAG) {
            var result = createBindWrapper(newData[0], newData[2]);
          } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
            result = createPartialWrapper.apply(undefined, newData);
          } else {
            result = createHybridWrapper.apply(undefined, newData);
          }
          var setter = data ? baseSetData : setData;
          return setter(result, newData);
        }
        function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
          var index = -1,
              arrLength = array.length,
              othLength = other.length;
          if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
            return false;
          }
          while (++index < arrLength) {
            var arrValue = array[index],
                othValue = other[index],
                result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;
            if (result !== undefined) {
              if (result) {
                continue;
              }
              return false;
            }
            if (isLoose) {
              if (!arraySome(other, function(othValue) {
                return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
              })) {
                return false;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
              return false;
            }
          }
          return true;
        }
        function equalByTag(object, other, tag) {
          switch (tag) {
            case boolTag:
            case dateTag:
              return +object == +other;
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case numberTag:
              return (object != +object) ? other != +other : object == +other;
            case regexpTag:
            case stringTag:
              return object == (other + '');
          }
          return false;
        }
        function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
          var objProps = keys(object),
              objLength = objProps.length,
              othProps = keys(other),
              othLength = othProps.length;
          if (objLength != othLength && !isLoose) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var skipCtor = isLoose;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key],
                othValue = other[key],
                result = customizer ? customizer(isLoose ? othValue : objValue, isLoose ? objValue : othValue, key) : undefined;
            if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
              return false;
            }
            skipCtor || (skipCtor = key == 'constructor');
          }
          if (!skipCtor) {
            var objCtor = object.constructor,
                othCtor = other.constructor;
            if (objCtor != othCtor && ('constructor' in object && 'constructor' in other) && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
              return false;
            }
          }
          return true;
        }
        function getCallback(func, thisArg, argCount) {
          var result = lodash.callback || callback;
          result = result === callback ? baseCallback : result;
          return argCount ? result(func, thisArg, argCount) : result;
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result = func.name,
              array = realNames[result],
              length = array ? array.length : 0;
          while (length--) {
            var data = array[length],
                otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result;
        }
        function getIndexOf(collection, target, fromIndex) {
          var result = lodash.indexOf || indexOf;
          result = result === indexOf ? baseIndexOf : result;
          return collection ? result(collection, target, fromIndex) : result;
        }
        var getLength = baseProperty('length');
        function getMatchData(object) {
          var result = pairs(object),
              length = result.length;
          while (length--) {
            result[length][2] = isStrictComparable(result[length][1]);
          }
          return result;
        }
        function getNative(object, key) {
          var value = object == null ? undefined : object[key];
          return isNative(value) ? value : undefined;
        }
        function getView(start, end, transforms) {
          var index = -1,
              length = transforms.length;
          while (++index < length) {
            var data = transforms[index],
                size = data.size;
            switch (data.type) {
              case 'drop':
                start += size;
                break;
              case 'dropRight':
                end -= size;
                break;
              case 'take':
                end = nativeMin(end, start + size);
                break;
              case 'takeRight':
                start = nativeMax(start, end - size);
                break;
            }
          }
          return {
            'start': start,
            'end': end
          };
        }
        function initCloneArray(array) {
          var length = array.length,
              result = new array.constructor(length);
          if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
            result.index = array.index;
            result.input = array.input;
          }
          return result;
        }
        function initCloneObject(object) {
          var Ctor = object.constructor;
          if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
            Ctor = Object;
          }
          return new Ctor;
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return bufferClone(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              var buffer = object.buffer;
              return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              var result = new Ctor(object.source, reFlags.exec(object));
              result.lastIndex = object.lastIndex;
          }
          return result;
        }
        function invokePath(object, path, args) {
          if (object != null && !isKey(path, object)) {
            path = toPath(path);
            object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
            path = last(path);
          }
          var func = object == null ? object : object[path];
          return func == null ? undefined : func.apply(object, args);
        }
        function isArrayLike(value) {
          return value != null && isLength(getLength(value));
        }
        function isIndex(value, length) {
          value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return value > -1 && value % 1 == 0 && value < length;
        }
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == 'number' ? (isArrayLike(object) && isIndex(index, object.length)) : (type == 'string' && index in object)) {
            var other = object[index];
            return value === value ? (value === other) : (other !== other);
          }
          return false;
        }
        function isKey(value, object) {
          var type = typeof value;
          if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
            return true;
          }
          if (isArray(value)) {
            return false;
          }
          var result = !reIsDeepProp.test(value);
          return result || (object != null && value in toObject(object));
        }
        function isLaziable(func) {
          var funcName = getFuncName(func);
          if (!(funcName in LazyWrapper.prototype)) {
            return false;
          }
          var other = lodash[funcName];
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isLength(value) {
          return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        function mergeData(data, source) {
          var bitmask = data[1],
              srcBitmask = source[1],
              newBitmask = bitmask | srcBitmask,
              isCommon = newBitmask < ARY_FLAG;
          var isCombo = (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) || (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) || (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
          }
          value = source[7];
          if (value) {
            data[7] = arrayCopy(value);
          }
          if (srcBitmask & ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function mergeDefaults(objectValue, sourceValue) {
          return objectValue === undefined ? sourceValue : merge(objectValue, sourceValue, mergeDefaults);
        }
        function pickByArray(object, props) {
          object = toObject(object);
          var index = -1,
              length = props.length,
              result = {};
          while (++index < length) {
            var key = props[index];
            if (key in object) {
              result[key] = object[key];
            }
          }
          return result;
        }
        function pickByCallback(object, predicate) {
          var result = {};
          baseForIn(object, function(value, key, object) {
            if (predicate(value, key, object)) {
              result[key] = value;
            }
          });
          return result;
        }
        function reorder(array, indexes) {
          var arrLength = array.length,
              length = nativeMin(indexes.length, arrLength),
              oldArray = arrayCopy(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
          }
          return array;
        }
        var setData = (function() {
          var count = 0,
              lastCalled = 0;
          return function(key, value) {
            var stamp = now(),
                remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return key;
              }
            } else {
              count = 0;
            }
            return baseSetData(key, value);
          };
        }());
        function shimKeys(object) {
          var props = keysIn(object),
              propsLength = props.length,
              length = propsLength && object.length;
          var allowIndexes = !!length && isLength(length) && (isArray(object) || isArguments(object));
          var index = -1,
              result = [];
          while (++index < propsLength) {
            var key = props[index];
            if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
              result.push(key);
            }
          }
          return result;
        }
        function toIterable(value) {
          if (value == null) {
            return [];
          }
          if (!isArrayLike(value)) {
            return values(value);
          }
          return isObject(value) ? value : Object(value);
        }
        function toObject(value) {
          return isObject(value) ? value : Object(value);
        }
        function toPath(value) {
          if (isArray(value)) {
            return value;
          }
          var result = [];
          baseToString(value).replace(rePropName, function(match, number, quote, string) {
            result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
          });
          return result;
        }
        function wrapperClone(wrapper) {
          return wrapper instanceof LazyWrapper ? wrapper.clone() : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
        }
        function chunk(array, size, guard) {
          if (guard ? isIterateeCall(array, size, guard) : size == null) {
            size = 1;
          } else {
            size = nativeMax(nativeFloor(size) || 1, 1);
          }
          var index = 0,
              length = array ? array.length : 0,
              resIndex = -1,
              result = Array(nativeCeil(length / size));
          while (index < length) {
            result[++resIndex] = baseSlice(array, index, (index += size));
          }
          return result;
        }
        function compact(array) {
          var index = -1,
              length = array ? array.length : 0,
              resIndex = -1,
              result = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result[++resIndex] = value;
            }
          }
          return result;
        }
        var difference = restParam(function(array, values) {
          return (isObjectLike(array) && isArrayLike(array)) ? baseDifference(array, baseFlatten(values, false, true)) : [];
        });
        function drop(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          return baseSlice(array, n < 0 ? 0 : n);
        }
        function dropRight(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          n = length - (+n || 0);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate, thisArg) {
          return (array && array.length) ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true) : [];
        }
        function dropWhile(array, predicate, thisArg) {
          return (array && array.length) ? baseWhile(array, getCallback(predicate, thisArg, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        var findIndex = createFindIndex();
        var findLastIndex = createFindIndex(true);
        function first(array) {
          return array ? array[0] : undefined;
        }
        function flatten(array, isDeep, guard) {
          var length = array ? array.length : 0;
          if (guard && isIterateeCall(array, isDeep, guard)) {
            isDeep = false;
          }
          return length ? baseFlatten(array, isDeep) : [];
        }
        function flattenDeep(array) {
          var length = array ? array.length : 0;
          return length ? baseFlatten(array, true) : [];
        }
        function indexOf(array, value, fromIndex) {
          var length = array ? array.length : 0;
          if (!length) {
            return -1;
          }
          if (typeof fromIndex == 'number') {
            fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
          } else if (fromIndex) {
            var index = binaryIndex(array, value);
            if (index < length && (value === value ? (value === array[index]) : (array[index] !== array[index]))) {
              return index;
            }
            return -1;
          }
          return baseIndexOf(array, value, fromIndex || 0);
        }
        function initial(array) {
          return dropRight(array, 1);
        }
        var intersection = restParam(function(arrays) {
          var othLength = arrays.length,
              othIndex = othLength,
              caches = Array(length),
              indexOf = getIndexOf(),
              isCommon = indexOf == baseIndexOf,
              result = [];
          while (othIndex--) {
            var value = arrays[othIndex] = isArrayLike(value = arrays[othIndex]) ? value : [];
            caches[othIndex] = (isCommon && value.length >= 120) ? createCache(othIndex && value) : null;
          }
          var array = arrays[0],
              index = -1,
              length = array ? array.length : 0,
              seen = caches[0];
          outer: while (++index < length) {
            value = array[index];
            if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
              var othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(value);
              }
              result.push(value);
            }
          }
          return result;
        });
        function last(array) {
          var length = array ? array.length : 0;
          return length ? array[length - 1] : undefined;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array ? array.length : 0;
          if (!length) {
            return -1;
          }
          var index = length;
          if (typeof fromIndex == 'number') {
            index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
          } else if (fromIndex) {
            index = binaryIndex(array, value, true) - 1;
            var other = array[index];
            if (value === value ? (value === other) : (other !== other)) {
              return index;
            }
            return -1;
          }
          if (value !== value) {
            return indexOfNaN(array, index, true);
          }
          while (index--) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }
        function pull() {
          var args = arguments,
              array = args[0];
          if (!(array && array.length)) {
            return array;
          }
          var index = 0,
              indexOf = getIndexOf(),
              length = args.length;
          while (++index < length) {
            var fromIndex = 0,
                value = args[index];
            while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        var pullAt = restParam(function(array, indexes) {
          indexes = baseFlatten(indexes);
          var result = baseAt(array, indexes);
          basePullAt(array, indexes.sort(baseCompareAscending));
          return result;
        });
        function remove(array, predicate, thisArg) {
          var result = [];
          if (!(array && array.length)) {
            return result;
          }
          var index = -1,
              indexes = [],
              length = array.length;
          predicate = getCallback(predicate, thisArg, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result;
        }
        function rest(array) {
          return drop(array, 1);
        }
        function slice(array, start, end) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          }
          return baseSlice(array, start, end);
        }
        var sortedIndex = createSortedIndex();
        var sortedLastIndex = createSortedIndex(true);
        function take(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          n = length - (+n || 0);
          return baseSlice(array, n < 0 ? 0 : n);
        }
        function takeRightWhile(array, predicate, thisArg) {
          return (array && array.length) ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true) : [];
        }
        function takeWhile(array, predicate, thisArg) {
          return (array && array.length) ? baseWhile(array, getCallback(predicate, thisArg, 3)) : [];
        }
        var union = restParam(function(arrays) {
          return baseUniq(baseFlatten(arrays, false, true));
        });
        function uniq(array, isSorted, iteratee, thisArg) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (isSorted != null && typeof isSorted != 'boolean') {
            thisArg = iteratee;
            iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;
            isSorted = false;
          }
          var callback = getCallback();
          if (!(iteratee == null && callback === baseCallback)) {
            iteratee = callback(iteratee, thisArg, 3);
          }
          return (isSorted && getIndexOf() == baseIndexOf) ? sortedUniq(array, iteratee) : baseUniq(array, iteratee);
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var index = -1,
              length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLike(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          var result = Array(length);
          while (++index < length) {
            result[index] = arrayMap(array, baseProperty(index));
          }
          return result;
        }
        function unzipWith(array, iteratee, thisArg) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          var result = unzip(array);
          if (iteratee == null) {
            return result;
          }
          iteratee = bindCallback(iteratee, thisArg, 4);
          return arrayMap(result, function(group) {
            return arrayReduce(group, iteratee, undefined, true);
          });
        }
        var without = restParam(function(array, values) {
          return isArrayLike(array) ? baseDifference(array, values) : [];
        });
        function xor() {
          var index = -1,
              length = arguments.length;
          while (++index < length) {
            var array = arguments[index];
            if (isArrayLike(array)) {
              var result = result ? arrayPush(baseDifference(result, array), baseDifference(array, result)) : array;
            }
          }
          return result ? baseUniq(result) : [];
        }
        var zip = restParam(unzip);
        function zipObject(props, values) {
          var index = -1,
              length = props ? props.length : 0,
              result = {};
          if (length && !values && !isArray(props[0])) {
            values = [];
          }
          while (++index < length) {
            var key = props[index];
            if (values) {
              result[key] = values[index];
            } else if (key) {
              result[key[0]] = key[1];
            }
          }
          return result;
        }
        var zipWith = restParam(function(arrays) {
          var length = arrays.length,
              iteratee = length > 2 ? arrays[length - 2] : undefined,
              thisArg = length > 1 ? arrays[length - 1] : undefined;
          if (length > 2 && typeof iteratee == 'function') {
            length -= 2;
          } else {
            iteratee = (length > 1 && typeof thisArg == 'function') ? (--length, thisArg) : undefined;
            thisArg = undefined;
          }
          arrays.length = length;
          return unzipWith(arrays, iteratee, thisArg);
        });
        function chain(value) {
          var result = lodash(value);
          result.__chain__ = true;
          return result;
        }
        function tap(value, interceptor, thisArg) {
          interceptor.call(thisArg, value);
          return value;
        }
        function thru(value, interceptor, thisArg) {
          return interceptor.call(thisArg, value);
        }
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        var wrapperConcat = restParam(function(values) {
          values = baseFlatten(values);
          return this.thru(function(array) {
            return arrayConcat(isArray(array) ? array : [toObject(array)], values);
          });
        });
        function wrapperPlant(value) {
          var result,
              parent = this;
          while (parent instanceof baseLodash) {
            var clone = wrapperClone(parent);
            if (result) {
              previous.__wrapped__ = clone;
            } else {
              result = clone;
            }
            var previous = clone;
            parent = parent.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          var interceptor = function(value) {
            return (wrapped && wrapped.__dir__ < 0) ? value : value.reverse();
          };
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              'func': thru,
              'args': [interceptor],
              'thisArg': undefined
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(interceptor);
        }
        function wrapperToString() {
          return (this.value() + '');
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var at = restParam(function(collection, props) {
          return baseAt(collection, baseFlatten(props));
        });
        var countBy = createAggregator(function(result, value, key) {
          hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
        });
        function every(collection, predicate, thisArg) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
            predicate = undefined;
          }
          if (typeof predicate != 'function' || thisArg !== undefined) {
            predicate = getCallback(predicate, thisArg, 3);
          }
          return func(collection, predicate);
        }
        function filter(collection, predicate, thisArg) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          predicate = getCallback(predicate, thisArg, 3);
          return func(collection, predicate);
        }
        var find = createFind(baseEach);
        var findLast = createFind(baseEachRight, true);
        function findWhere(collection, source) {
          return find(collection, baseMatches(source));
        }
        var forEach = createForEach(arrayEach, baseEach);
        var forEachRight = createForEach(arrayEachRight, baseEachRight);
        var groupBy = createAggregator(function(result, value, key) {
          if (hasOwnProperty.call(result, key)) {
            result[key].push(value);
          } else {
            result[key] = [value];
          }
        });
        function includes(collection, target, fromIndex, guard) {
          var length = collection ? getLength(collection) : 0;
          if (!isLength(length)) {
            collection = values(collection);
            length = collection.length;
          }
          if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {
            fromIndex = 0;
          } else {
            fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
          }
          return (typeof collection == 'string' || !isArray(collection) && isString(collection)) ? (fromIndex <= length && collection.indexOf(target, fromIndex) > -1) : (!!length && getIndexOf(collection, target, fromIndex) > -1);
        }
        var indexBy = createAggregator(function(result, value, key) {
          result[key] = value;
        });
        var invoke = restParam(function(collection, path, args) {
          var index = -1,
              isFunc = typeof path == 'function',
              isProp = isKey(path),
              result = isArrayLike(collection) ? Array(collection.length) : [];
          baseEach(collection, function(value) {
            var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);
            result[++index] = func ? func.apply(value, args) : invokePath(value, path, args);
          });
          return result;
        });
        function map(collection, iteratee, thisArg) {
          var func = isArray(collection) ? arrayMap : baseMap;
          iteratee = getCallback(iteratee, thisArg, 3);
          return func(collection, iteratee);
        }
        var partition = createAggregator(function(result, value, key) {
          result[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function pluck(collection, path) {
          return map(collection, property(path));
        }
        var reduce = createReduce(arrayReduce, baseEach);
        var reduceRight = createReduce(arrayReduceRight, baseEachRight);
        function reject(collection, predicate, thisArg) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          predicate = getCallback(predicate, thisArg, 3);
          return func(collection, function(value, index, collection) {
            return !predicate(value, index, collection);
          });
        }
        function sample(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n == null) {
            collection = toIterable(collection);
            var length = collection.length;
            return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
          }
          var index = -1,
              result = toArray(collection),
              length = result.length,
              lastIndex = length - 1;
          n = nativeMin(n < 0 ? 0 : (+n || 0), length);
          while (++index < n) {
            var rand = baseRandom(index, lastIndex),
                value = result[rand];
            result[rand] = result[index];
            result[index] = value;
          }
          result.length = n;
          return result;
        }
        function shuffle(collection) {
          return sample(collection, POSITIVE_INFINITY);
        }
        function size(collection) {
          var length = collection ? getLength(collection) : 0;
          return isLength(length) ? length : keys(collection).length;
        }
        function some(collection, predicate, thisArg) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
            predicate = undefined;
          }
          if (typeof predicate != 'function' || thisArg !== undefined) {
            predicate = getCallback(predicate, thisArg, 3);
          }
          return func(collection, predicate);
        }
        function sortBy(collection, iteratee, thisArg) {
          if (collection == null) {
            return [];
          }
          if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
            iteratee = undefined;
          }
          var index = -1;
          iteratee = getCallback(iteratee, thisArg, 3);
          var result = baseMap(collection, function(value, key, collection) {
            return {
              'criteria': iteratee(value, key, collection),
              'index': ++index,
              'value': value
            };
          });
          return baseSortBy(result, compareAscending);
        }
        var sortByAll = restParam(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var guard = iteratees[2];
          if (guard && isIterateeCall(iteratees[0], iteratees[1], guard)) {
            iteratees.length = 1;
          }
          return baseSortByOrder(collection, baseFlatten(iteratees), []);
        });
        function sortByOrder(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (guard && isIterateeCall(iteratees, orders, guard)) {
            orders = undefined;
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseSortByOrder(collection, iteratees, orders);
        }
        function where(collection, source) {
          return filter(collection, baseMatches(source));
        }
        var now = nativeNow || function() {
          return new Date().getTime();
        };
        function after(n, func) {
          if (typeof func != 'function') {
            if (typeof n == 'function') {
              var temp = n;
              n = func;
              func = temp;
            } else {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
          }
          n = nativeIsFinite(n = +n) ? n : 0;
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          if (guard && isIterateeCall(func, n, guard)) {
            n = undefined;
          }
          n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
          return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
        }
        function before(n, func) {
          var result;
          if (typeof func != 'function') {
            if (typeof n == 'function') {
              var temp = n;
              n = func;
              func = temp;
            } else {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
          }
          return function() {
            if (--n > 0) {
              result = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined;
            }
            return result;
          };
        }
        var bind = restParam(function(func, thisArg, partials) {
          var bitmask = BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, bind.placeholder);
            bitmask |= PARTIAL_FLAG;
          }
          return createWrapper(func, bitmask, thisArg, partials, holders);
        });
        var bindAll = restParam(function(object, methodNames) {
          methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);
          var index = -1,
              length = methodNames.length;
          while (++index < length) {
            var key = methodNames[index];
            object[key] = createWrapper(object[key], BIND_FLAG, object);
          }
          return object;
        });
        var bindKey = restParam(function(object, key, partials) {
          var bitmask = BIND_FLAG | BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, bindKey.placeholder);
            bitmask |= PARTIAL_FLAG;
          }
          return createWrapper(key, bitmask, object, partials, holders);
        });
        var curry = createCurry(CURRY_FLAG);
        var curryRight = createCurry(CURRY_RIGHT_FLAG);
        function debounce(func, wait, options) {
          var args,
              maxTimeoutId,
              result,
              stamp,
              thisArg,
              timeoutId,
              trailingCall,
              lastCalled = 0,
              maxWait = false,
              trailing = true;
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          wait = wait < 0 ? 0 : (+wait || 0);
          if (options === true) {
            var leading = true;
            trailing = false;
          } else if (isObject(options)) {
            leading = !!options.leading;
            maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }
          function cancel() {
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            if (maxTimeoutId) {
              clearTimeout(maxTimeoutId);
            }
            lastCalled = 0;
            maxTimeoutId = timeoutId = trailingCall = undefined;
          }
          function complete(isCalled, id) {
            if (id) {
              clearTimeout(id);
            }
            maxTimeoutId = timeoutId = trailingCall = undefined;
            if (isCalled) {
              lastCalled = now();
              result = func.apply(thisArg, args);
              if (!timeoutId && !maxTimeoutId) {
                args = thisArg = undefined;
              }
            }
          }
          function delayed() {
            var remaining = wait - (now() - stamp);
            if (remaining <= 0 || remaining > wait) {
              complete(trailingCall, maxTimeoutId);
            } else {
              timeoutId = setTimeout(delayed, remaining);
            }
          }
          function maxDelayed() {
            complete(trailing, timeoutId);
          }
          function debounced() {
            args = arguments;
            stamp = now();
            thisArg = this;
            trailingCall = trailing && (timeoutId || !leading);
            if (maxWait === false) {
              var leadingCall = leading && !timeoutId;
            } else {
              if (!maxTimeoutId && !leading) {
                lastCalled = stamp;
              }
              var remaining = maxWait - (stamp - lastCalled),
                  isCalled = remaining <= 0 || remaining > maxWait;
              if (isCalled) {
                if (maxTimeoutId) {
                  maxTimeoutId = clearTimeout(maxTimeoutId);
                }
                lastCalled = stamp;
                result = func.apply(thisArg, args);
              } else if (!maxTimeoutId) {
                maxTimeoutId = setTimeout(maxDelayed, remaining);
              }
            }
            if (isCalled && timeoutId) {
              timeoutId = clearTimeout(timeoutId);
            } else if (!timeoutId && wait !== maxWait) {
              timeoutId = setTimeout(delayed, wait);
            }
            if (leadingCall) {
              isCalled = true;
              result = func.apply(thisArg, args);
            }
            if (isCalled && !timeoutId && !maxTimeoutId) {
              args = thisArg = undefined;
            }
            return result;
          }
          debounced.cancel = cancel;
          return debounced;
        }
        var defer = restParam(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = restParam(function(func, wait, args) {
          return baseDelay(func, wait, args);
        });
        var flow = createFlow();
        var flowRight = createFlow(true);
        function memoize(func, resolver) {
          if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments,
                key = resolver ? resolver.apply(this, args) : args[0],
                cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result = func.apply(this, args);
            memoized.cache = cache.set(key, result);
            return result;
          };
          memoized.cache = new memoize.Cache;
          return memoized;
        }
        var modArgs = restParam(function(func, transforms) {
          transforms = baseFlatten(transforms);
          if (typeof func != 'function' || !arrayEvery(transforms, baseIsFunction)) {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var length = transforms.length;
          return restParam(function(args) {
            var index = nativeMin(args.length, length);
            while (index--) {
              args[index] = transforms[index](args[index]);
            }
            return func.apply(this, args);
          });
        });
        function negate(predicate) {
          if (typeof predicate != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return function() {
            return !predicate.apply(this, arguments);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var partial = createPartial(PARTIAL_FLAG);
        var partialRight = createPartial(PARTIAL_RIGHT_FLAG);
        var rearg = restParam(function(func, indexes) {
          return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes));
        });
        function restParam(func, start) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
          return function() {
            var args = arguments,
                index = -1,
                length = nativeMax(args.length - start, 0),
                rest = Array(length);
            while (++index < length) {
              rest[index] = args[start + index];
            }
            switch (start) {
              case 0:
                return func.call(this, rest);
              case 1:
                return func.call(this, args[0], rest);
              case 2:
                return func.call(this, args[0], args[1], rest);
            }
            var otherArgs = Array(start + 1);
            index = -1;
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = rest;
            return func.apply(this, otherArgs);
          };
        }
        function spread(func) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return function(array) {
            return func.apply(this, array);
          };
        }
        function throttle(func, wait, options) {
          var leading = true,
              trailing = true;
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (options === false) {
            leading = false;
          } else if (isObject(options)) {
            leading = 'leading' in options ? !!options.leading : leading;
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            'leading': leading,
            'maxWait': +wait,
            'trailing': trailing
          });
        }
        function wrap(value, wrapper) {
          wrapper = wrapper == null ? identity : wrapper;
          return createWrapper(wrapper, PARTIAL_FLAG, undefined, [value], []);
        }
        function clone(value, isDeep, customizer, thisArg) {
          if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
            isDeep = false;
          } else if (typeof isDeep == 'function') {
            thisArg = customizer;
            customizer = isDeep;
            isDeep = false;
          }
          return typeof customizer == 'function' ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 1)) : baseClone(value, isDeep);
        }
        function cloneDeep(value, customizer, thisArg) {
          return typeof customizer == 'function' ? baseClone(value, true, bindCallback(customizer, thisArg, 1)) : baseClone(value, true);
        }
        function gt(value, other) {
          return value > other;
        }
        function gte(value, other) {
          return value >= other;
        }
        function isArguments(value) {
          return isObjectLike(value) && isArrayLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
        }
        var isArray = nativeIsArray || function(value) {
          return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
        };
        function isBoolean(value) {
          return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);
        }
        function isDate(value) {
          return isObjectLike(value) && objToString.call(value) == dateTag;
        }
        function isElement(value) {
          return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) || (isObjectLike(value) && isFunction(value.splice)))) {
            return !value.length;
          }
          return !keys(value).length;
        }
        function isEqual(value, other, customizer, thisArg) {
          customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
          var result = customizer ? customizer(value, other) : undefined;
          return result === undefined ? baseIsEqual(value, other, customizer) : !!result;
        }
        function isError(value) {
          return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;
        }
        function isFinite(value) {
          return typeof value == 'number' && nativeIsFinite(value);
        }
        function isFunction(value) {
          return isObject(value) && objToString.call(value) == funcTag;
        }
        function isObject(value) {
          var type = typeof value;
          return !!value && (type == 'object' || type == 'function');
        }
        function isMatch(object, source, customizer, thisArg) {
          customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
          return baseIsMatch(object, getMatchData(source), customizer);
        }
        function isNaN(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (value == null) {
            return false;
          }
          if (isFunction(value)) {
            return reIsNative.test(fnToString.call(value));
          }
          return isObjectLike(value) && reIsHostCtor.test(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNumber(value) {
          return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);
        }
        function isPlainObject(value) {
          var Ctor;
          if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isArguments(value)) || (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
            return false;
          }
          var result;
          baseForIn(value, function(subValue, key) {
            result = key;
          });
          return result === undefined || hasOwnProperty.call(value, result);
        }
        function isRegExp(value) {
          return isObject(value) && objToString.call(value) == regexpTag;
        }
        function isString(value) {
          return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
        }
        function isTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
        }
        function isUndefined(value) {
          return value === undefined;
        }
        function lt(value, other) {
          return value < other;
        }
        function lte(value, other) {
          return value <= other;
        }
        function toArray(value) {
          var length = value ? getLength(value) : 0;
          if (!isLength(length)) {
            return values(value);
          }
          if (!length) {
            return [];
          }
          return arrayCopy(value);
        }
        function toPlainObject(value) {
          return baseCopy(value, keysIn(value));
        }
        var merge = createAssigner(baseMerge);
        var assign = createAssigner(function(object, source, customizer) {
          return customizer ? assignWith(object, source, customizer) : baseAssign(object, source);
        });
        function create(prototype, properties, guard) {
          var result = baseCreate(prototype);
          if (guard && isIterateeCall(prototype, properties, guard)) {
            properties = undefined;
          }
          return properties ? baseAssign(result, properties) : result;
        }
        var defaults = createDefaults(assign, assignDefaults);
        var defaultsDeep = createDefaults(merge, mergeDefaults);
        var findKey = createFindKey(baseForOwn);
        var findLastKey = createFindKey(baseForOwnRight);
        var forIn = createForIn(baseFor);
        var forInRight = createForIn(baseForRight);
        var forOwn = createForOwn(baseForOwn);
        var forOwnRight = createForOwn(baseForOwnRight);
        function functions(object) {
          return baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result = object == null ? undefined : baseGet(object, toPath(path), path + '');
          return result === undefined ? defaultValue : result;
        }
        function has(object, path) {
          if (object == null) {
            return false;
          }
          var result = hasOwnProperty.call(object, path);
          if (!result && !isKey(path)) {
            path = toPath(path);
            object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
            if (object == null) {
              return false;
            }
            path = last(path);
            result = hasOwnProperty.call(object, path);
          }
          return result || (isLength(object.length) && isIndex(path, object.length) && (isArray(object) || isArguments(object)));
        }
        function invert(object, multiValue, guard) {
          if (guard && isIterateeCall(object, multiValue, guard)) {
            multiValue = undefined;
          }
          var index = -1,
              props = keys(object),
              length = props.length,
              result = {};
          while (++index < length) {
            var key = props[index],
                value = object[key];
            if (multiValue) {
              if (hasOwnProperty.call(result, value)) {
                result[value].push(key);
              } else {
                result[value] = [key];
              }
            } else {
              result[value] = key;
            }
          }
          return result;
        }
        var keys = !nativeKeys ? shimKeys : function(object) {
          var Ctor = object == null ? undefined : object.constructor;
          if ((typeof Ctor == 'function' && Ctor.prototype === object) || (typeof object != 'function' && isArrayLike(object))) {
            return shimKeys(object);
          }
          return isObject(object) ? nativeKeys(object) : [];
        };
        function keysIn(object) {
          if (object == null) {
            return [];
          }
          if (!isObject(object)) {
            object = Object(object);
          }
          var length = object.length;
          length = (length && isLength(length) && (isArray(object) || isArguments(object)) && length) || 0;
          var Ctor = object.constructor,
              index = -1,
              isProto = typeof Ctor == 'function' && Ctor.prototype === object,
              result = Array(length),
              skipIndexes = length > 0;
          while (++index < length) {
            result[index] = (index + '');
          }
          for (var key in object) {
            if (!(skipIndexes && isIndex(key, length)) && !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
              result.push(key);
            }
          }
          return result;
        }
        var mapKeys = createObjectMapper(true);
        var mapValues = createObjectMapper();
        var omit = restParam(function(object, props) {
          if (object == null) {
            return {};
          }
          if (typeof props[0] != 'function') {
            var props = arrayMap(baseFlatten(props), String);
            return pickByArray(object, baseDifference(keysIn(object), props));
          }
          var predicate = bindCallback(props[0], props[1], 3);
          return pickByCallback(object, function(value, key, object) {
            return !predicate(value, key, object);
          });
        });
        function pairs(object) {
          object = toObject(object);
          var index = -1,
              props = keys(object),
              length = props.length,
              result = Array(length);
          while (++index < length) {
            var key = props[index];
            result[index] = [key, object[key]];
          }
          return result;
        }
        var pick = restParam(function(object, props) {
          if (object == null) {
            return {};
          }
          return typeof props[0] == 'function' ? pickByCallback(object, bindCallback(props[0], props[1], 3)) : pickByArray(object, baseFlatten(props));
        });
        function result(object, path, defaultValue) {
          var result = object == null ? undefined : object[path];
          if (result === undefined) {
            if (object != null && !isKey(path, object)) {
              path = toPath(path);
              object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
              result = object == null ? undefined : object[last(path)];
            }
            result = result === undefined ? defaultValue : result;
          }
          return isFunction(result) ? result.call(object) : result;
        }
        function set(object, path, value) {
          if (object == null) {
            return object;
          }
          var pathKey = (path + '');
          path = (object[pathKey] != null || isKey(path, object)) ? [pathKey] : toPath(path);
          var index = -1,
              length = path.length,
              lastIndex = length - 1,
              nested = object;
          while (nested != null && ++index < length) {
            var key = path[index];
            if (isObject(nested)) {
              if (index == lastIndex) {
                nested[key] = value;
              } else if (nested[key] == null) {
                nested[key] = isIndex(path[index + 1]) ? [] : {};
              }
            }
            nested = nested[key];
          }
          return object;
        }
        function transform(object, iteratee, accumulator, thisArg) {
          var isArr = isArray(object) || isTypedArray(object);
          iteratee = getCallback(iteratee, thisArg, 4);
          if (accumulator == null) {
            if (isArr || isObject(object)) {
              var Ctor = object.constructor;
              if (isArr) {
                accumulator = isArray(object) ? new Ctor : [];
              } else {
                accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);
              }
            } else {
              accumulator = {};
            }
          }
          (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
            return iteratee(accumulator, value, index, object);
          });
          return accumulator;
        }
        function values(object) {
          return baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return baseValues(object, keysIn(object));
        }
        function inRange(value, start, end) {
          start = +start || 0;
          if (end === undefined) {
            end = start;
            start = 0;
          } else {
            end = +end || 0;
          }
          return value >= nativeMin(start, end) && value < nativeMax(start, end);
        }
        function random(min, max, floating) {
          if (floating && isIterateeCall(min, max, floating)) {
            max = floating = undefined;
          }
          var noMin = min == null,
              noMax = max == null;
          if (floating == null) {
            if (noMax && typeof min == 'boolean') {
              floating = min;
              min = 1;
            } else if (typeof max == 'boolean') {
              floating = max;
              noMax = true;
            }
          }
          if (noMin && noMax) {
            max = 1;
            noMax = false;
          }
          min = +min || 0;
          if (noMax) {
            max = min;
            min = 0;
          } else {
            max = +max || 0;
          }
          if (floating || min % 1 || max % 1) {
            var rand = nativeRandom();
            return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
          }
          return baseRandom(min, max);
        }
        var camelCase = createCompounder(function(result, word, index) {
          word = word.toLowerCase();
          return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
        });
        function capitalize(string) {
          string = baseToString(string);
          return string && (string.charAt(0).toUpperCase() + string.slice(1));
        }
        function deburr(string) {
          string = baseToString(string);
          return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
        }
        function endsWith(string, target, position) {
          string = baseToString(string);
          target = (target + '');
          var length = string.length;
          position = position === undefined ? length : nativeMin(position < 0 ? 0 : (+position || 0), length);
          position -= target.length;
          return position >= 0 && string.indexOf(target, position) == position;
        }
        function escape(string) {
          string = baseToString(string);
          return (string && reHasUnescapedHtml.test(string)) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = baseToString(string);
          return (string && reHasRegExpChars.test(string)) ? string.replace(reRegExpChars, escapeRegExpChar) : (string || '(?:)');
        }
        var kebabCase = createCompounder(function(result, word, index) {
          return result + (index ? '-' : '') + word.toLowerCase();
        });
        function pad(string, length, chars) {
          string = baseToString(string);
          length = +length;
          var strLength = string.length;
          if (strLength >= length || !nativeIsFinite(length)) {
            return string;
          }
          var mid = (length - strLength) / 2,
              leftLength = nativeFloor(mid),
              rightLength = nativeCeil(mid);
          chars = createPadding('', rightLength, chars);
          return chars.slice(0, leftLength) + string + chars;
        }
        var padLeft = createPadDir();
        var padRight = createPadDir(true);
        function parseInt(string, radix, guard) {
          if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          string = trim(string);
          return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
        }
        function repeat(string, n) {
          var result = '';
          string = baseToString(string);
          n = +n;
          if (n < 1 || !string || !nativeIsFinite(n)) {
            return result;
          }
          do {
            if (n % 2) {
              result += string;
            }
            n = nativeFloor(n / 2);
            string += string;
          } while (n);
          return result;
        }
        var snakeCase = createCompounder(function(result, word, index) {
          return result + (index ? '_' : '') + word.toLowerCase();
        });
        var startCase = createCompounder(function(result, word, index) {
          return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
        });
        function startsWith(string, target, position) {
          string = baseToString(string);
          position = position == null ? 0 : nativeMin(position < 0 ? 0 : (+position || 0), string.length);
          return string.lastIndexOf(target, position) == position;
        }
        function template(string, options, otherOptions) {
          var settings = lodash.templateSettings;
          if (otherOptions && isIterateeCall(string, options, otherOptions)) {
            options = otherOptions = undefined;
          }
          string = baseToString(string);
          options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);
          var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
              importsKeys = keys(imports),
              importsValues = baseValues(imports, importsKeys);
          var isEscaping,
              isEvaluating,
              index = 0,
              interpolate = options.interpolate || reNoMatch,
              source = "__p += '";
          var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g');
          var sourceURL = '//# sourceURL=' + ('sourceURL' in options ? options.sourceURL : ('lodash.templateSources[' + (++templateCounter) + ']')) + '\n';
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = options.variable;
          if (!variable) {
            source = 'with (obj) {\n' + source + '\n}\n';
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;');
          source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';
          var result = attempt(function() {
            return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
          });
          result.source = source;
          if (isError(result)) {
            throw result;
          }
          return result;
        }
        function trim(string, chars, guard) {
          var value = string;
          string = baseToString(string);
          if (!string) {
            return string;
          }
          if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
            return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
          }
          chars = (chars + '');
          return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
        }
        function trimLeft(string, chars, guard) {
          var value = string;
          string = baseToString(string);
          if (!string) {
            return string;
          }
          if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
            return string.slice(trimmedLeftIndex(string));
          }
          return string.slice(charsLeftIndex(string, (chars + '')));
        }
        function trimRight(string, chars, guard) {
          var value = string;
          string = baseToString(string);
          if (!string) {
            return string;
          }
          if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
            return string.slice(0, trimmedRightIndex(string) + 1);
          }
          return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
        }
        function trunc(string, options, guard) {
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined;
          }
          var length = DEFAULT_TRUNC_LENGTH,
              omission = DEFAULT_TRUNC_OMISSION;
          if (options != null) {
            if (isObject(options)) {
              var separator = 'separator' in options ? options.separator : separator;
              length = 'length' in options ? (+options.length || 0) : length;
              omission = 'omission' in options ? baseToString(options.omission) : omission;
            } else {
              length = +options || 0;
            }
          }
          string = baseToString(string);
          if (length >= string.length) {
            return string;
          }
          var end = length - omission.length;
          if (end < 1) {
            return omission;
          }
          var result = string.slice(0, end);
          if (separator == null) {
            return result + omission;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match,
                  newEnd,
                  substring = string.slice(0, end);
              if (!separator.global) {
                separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
              }
              separator.lastIndex = 0;
              while ((match = separator.exec(substring))) {
                newEnd = match.index;
              }
              result = result.slice(0, newEnd == null ? end : newEnd);
            }
          } else if (string.indexOf(separator, end) != end) {
            var index = result.lastIndexOf(separator);
            if (index > -1) {
              result = result.slice(0, index);
            }
          }
          return result + omission;
        }
        function unescape(string) {
          string = baseToString(string);
          return (string && reHasEscapedHtml.test(string)) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        function words(string, pattern, guard) {
          if (guard && isIterateeCall(string, pattern, guard)) {
            pattern = undefined;
          }
          string = baseToString(string);
          return string.match(pattern || reWords) || [];
        }
        var attempt = restParam(function(func, args) {
          try {
            return func.apply(undefined, args);
          } catch (e) {
            return isError(e) ? e : new Error(e);
          }
        });
        function callback(func, thisArg, guard) {
          if (guard && isIterateeCall(func, thisArg, guard)) {
            thisArg = undefined;
          }
          return isObjectLike(func) ? matches(func) : baseCallback(func, thisArg);
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function identity(value) {
          return value;
        }
        function matches(source) {
          return baseMatches(baseClone(source, true));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, true));
        }
        var method = restParam(function(path, args) {
          return function(object) {
            return invokePath(object, path, args);
          };
        });
        var methodOf = restParam(function(object, args) {
          return function(path) {
            return invokePath(object, path, args);
          };
        });
        function mixin(object, source, options) {
          if (options == null) {
            var isObj = isObject(source),
                props = isObj ? keys(source) : undefined,
                methodNames = (props && props.length) ? baseFunctions(source, props) : undefined;
            if (!(methodNames ? methodNames.length : isObj)) {
              methodNames = false;
              options = source;
              source = object;
              object = this;
            }
          }
          if (!methodNames) {
            methodNames = baseFunctions(source, keys(source));
          }
          var chain = true,
              index = -1,
              isFunc = isFunction(object),
              length = methodNames.length;
          if (options === false) {
            chain = false;
          } else if (isObject(options) && 'chain' in options) {
            chain = options.chain;
          }
          while (++index < length) {
            var methodName = methodNames[index],
                func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = (function(func) {
                return function() {
                  var chainAll = this.__chain__;
                  if (chain || chainAll) {
                    var result = object(this.__wrapped__),
                        actions = result.__actions__ = arrayCopy(this.__actions__);
                    actions.push({
                      'func': func,
                      'args': arguments,
                      'thisArg': object
                    });
                    result.__chain__ = chainAll;
                    return result;
                  }
                  return func.apply(object, arrayPush([this.value()], arguments));
                };
              }(func));
            }
          }
          return object;
        }
        function noConflict() {
          root._ = oldDash;
          return this;
        }
        function noop() {}
        function property(path) {
          return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return baseGet(object, toPath(path), path + '');
          };
        }
        function range(start, end, step) {
          if (step && isIterateeCall(start, end, step)) {
            end = step = undefined;
          }
          start = +start || 0;
          step = step == null ? 1 : (+step || 0);
          if (end == null) {
            end = start;
            start = 0;
          } else {
            end = +end || 0;
          }
          var index = -1,
              length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
              result = Array(length);
          while (++index < length) {
            result[index] = start;
            start += step;
          }
          return result;
        }
        function times(n, iteratee, thisArg) {
          n = nativeFloor(n);
          if (n < 1 || !nativeIsFinite(n)) {
            return [];
          }
          var index = -1,
              result = Array(nativeMin(n, MAX_ARRAY_LENGTH));
          iteratee = bindCallback(iteratee, thisArg, 1);
          while (++index < n) {
            if (index < MAX_ARRAY_LENGTH) {
              result[index] = iteratee(index);
            } else {
              iteratee(index);
            }
          }
          return result;
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return baseToString(prefix) + id;
        }
        function add(augend, addend) {
          return (+augend || 0) + (+addend || 0);
        }
        var ceil = createRound('ceil');
        var floor = createRound('floor');
        var max = createExtremum(gt, NEGATIVE_INFINITY);
        var min = createExtremum(lt, POSITIVE_INFINITY);
        var round = createRound('round');
        function sum(collection, iteratee, thisArg) {
          if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
            iteratee = undefined;
          }
          iteratee = getCallback(iteratee, thisArg, 3);
          return iteratee.length == 1 ? arraySum(isArray(collection) ? collection : toIterable(collection), iteratee) : baseSum(collection, iteratee);
        }
        lodash.prototype = baseLodash.prototype;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        MapCache.prototype['delete'] = mapDelete;
        MapCache.prototype.get = mapGet;
        MapCache.prototype.has = mapHas;
        MapCache.prototype.set = mapSet;
        SetCache.prototype.push = cachePush;
        memoize.Cache = MapCache;
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.callback = callback;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.functions = functions;
        lodash.groupBy = groupBy;
        lodash.indexBy = indexBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.invert = invert;
        lodash.invoke = invoke;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.modArgs = modArgs;
        lodash.negate = negate;
        lodash.omit = omit;
        lodash.once = once;
        lodash.pairs = pairs;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pluck = pluck;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.restParam = restParam;
        lodash.set = set;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortByAll = sortByAll;
        lodash.sortByOrder = sortByOrder;
        lodash.spread = spread;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.times = times;
        lodash.toArray = toArray;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.union = union;
        lodash.uniq = uniq;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.where = where;
        lodash.without = without;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipWith = zipWith;
        lodash.backflow = flowRight;
        lodash.collect = map;
        lodash.compose = flowRight;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.extend = assign;
        lodash.iteratee = callback;
        lodash.methods = functions;
        lodash.object = zipObject;
        lodash.select = filter;
        lodash.tail = rest;
        lodash.unique = uniq;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.deburr = deburr;
        lodash.endsWith = endsWith;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.findWhere = findWhere;
        lodash.first = first;
        lodash.floor = floor;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isBoolean = isBoolean;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isError = isError;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isMatch = isMatch;
        lodash.isNaN = isNaN;
        lodash.isNative = isNative;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isString = isString;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.min = min;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padLeft = padLeft;
        lodash.padRight = padRight;
        lodash.parseInt = parseInt;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.sum = sum;
        lodash.template = template;
        lodash.trim = trim;
        lodash.trimLeft = trimLeft;
        lodash.trimRight = trimRight;
        lodash.trunc = trunc;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.words = words;
        lodash.all = every;
        lodash.any = some;
        lodash.contains = includes;
        lodash.eq = isEqual;
        lodash.detect = find;
        lodash.foldl = reduce;
        lodash.foldr = reduceRight;
        lodash.head = first;
        lodash.include = includes;
        lodash.inject = reduce;
        mixin(lodash, (function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!lodash.prototype[methodName]) {
              source[methodName] = func;
            }
          });
          return source;
        }()), false);
        lodash.sample = sample;
        lodash.prototype.sample = function(n) {
          if (!this.__chain__ && n == null) {
            return sample(this.value());
          }
          return this.thru(function(value) {
            return sample(value, n);
          });
        };
        lodash.VERSION = VERSION;
        arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(['drop', 'take'], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            var filtered = this.__filtered__;
            if (filtered && !index) {
              return new LazyWrapper(this);
            }
            n = n == null ? 1 : nativeMax(nativeFloor(n) || 0, 0);
            var result = this.clone();
            if (filtered) {
              result.__takeCount__ = nativeMin(result.__takeCount__, n);
            } else {
              result.__views__.push({
                'size': n,
                'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
              });
            }
            return result;
          };
          LazyWrapper.prototype[methodName + 'Right'] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
          var type = index + 1,
              isFilter = type != LAZY_MAP_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
            var result = this.clone();
            result.__iteratees__.push({
              'iteratee': getCallback(iteratee, thisArg, 1),
              'type': type
            });
            result.__filtered__ = result.__filtered__ || isFilter;
            return result;
          };
        });
        arrayEach(['first', 'last'], function(methodName, index) {
          var takeName = 'take' + (index ? 'Right' : '');
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(['initial', 'rest'], function(methodName, index) {
          var dropName = 'drop' + (index ? '' : 'Right');
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        arrayEach(['pluck', 'where'], function(methodName, index) {
          var operationName = index ? 'filter' : 'map',
              createCallback = index ? baseMatches : property;
          LazyWrapper.prototype[methodName] = function(value) {
            return this[operationName](createCallback(value));
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.reject = function(predicate, thisArg) {
          predicate = getCallback(predicate, thisArg, 1);
          return this.filter(function(value) {
            return !predicate(value);
          });
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = start == null ? 0 : (+start || 0);
          var result = this;
          if (result.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result);
          }
          if (start < 0) {
            result = result.takeRight(-start);
          } else if (start) {
            result = result.drop(start);
          }
          if (end !== undefined) {
            end = (+end || 0);
            result = end < 0 ? result.dropRight(-end) : result.take(end - start);
          }
          return result;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate, thisArg) {
          return this.reverse().takeWhile(predicate, thisArg).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(POSITIVE_INFINITY);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName),
              retUnwrapped = /^(?:first|last)$/.test(methodName),
              lodashFunc = lodash[retUnwrapped ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName];
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var args = retUnwrapped ? [1] : arguments,
                chainAll = this.__chain__,
                value = this.__wrapped__,
                isHybrid = !!this.__actions__.length,
                isLazy = value instanceof LazyWrapper,
                iteratee = args[0],
                useLazy = isLazy || isArray(value);
            if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
              isLazy = useLazy = false;
            }
            var interceptor = function(value) {
              return (retUnwrapped && chainAll) ? lodashFunc(value, 1)[0] : lodashFunc.apply(undefined, arrayPush([value], args));
            };
            var action = {
              'func': thru,
              'args': [interceptor],
              'thisArg': undefined
            },
                onlyLazy = isLazy && !isHybrid;
            if (retUnwrapped && !chainAll) {
              if (onlyLazy) {
                value = value.clone();
                value.__actions__.push(action);
                return func.call(value);
              }
              return lodashFunc.call(undefined, this.value())[0];
            }
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result = func.apply(value, args);
              result.__actions__.push(action);
              return new LodashWrapper(result, chainAll);
            }
            return this.thru(interceptor);
          };
        });
        arrayEach(['join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'], function(methodName) {
          var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName],
              chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
              retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              return func.apply(this.value(), args);
            }
            return this[chainName](function(value) {
              return func.apply(value, args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name,
                names = realNames[key] || (realNames[key] = []);
            names.push({
              'name': methodName,
              'func': lodashFunc
            });
          }
        });
        realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{
          'name': 'wrapper',
          'func': undefined
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.concat = wrapperConcat;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toString = wrapperToString;
        lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.collect = lodash.prototype.map;
        lodash.prototype.head = lodash.prototype.first;
        lodash.prototype.select = lodash.prototype.filter;
        lodash.prototype.tail = lodash.prototype.rest;
        return lodash;
      }
      var _ = runInContext();
      if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        root._ = _;
        define(function() {
          return _;
        });
      } else if (freeExports && freeModule) {
        if (moduleExports) {
          (freeModule.exports = _)._ = _;
        } else {
          freeExports._ = _;
        }
      } else {
        root._ = _;
      }
    }.call(this));
  })($__require('28'));
  return module.exports;
});

$__System.registerDynamic("10", ["27"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('27');
  return module.exports;
});

$__System.registerDynamic("29", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = "<div class=\"component component-routes-side-nav\">\r\n    <ul class=\"link-list\" ng-if=\"vm.isDisplayable\">\r\n        <li ng-repeat=\"route in vm.routes\" ng-if=\"route.isDisplayable\">\r\n            <div class=\"route-link\"><i class=\"fa\" ng-class=\"{'fa-caret-right': route.sref == vm.selectedRoute}\"></i><a ui-sref=\"{{route.sref}}\">{{route.displayText}}</a></div>\r\n            <div class=\"route-children\">\r\n                <ul class=\"link-list\">\r\n                    <li ng-repeat=\"child in route.routes\" ng-if=\"child.isDisplayable\">\r\n                        <div class=\"route-link\"><i class=\"fa\" ng-class=\"{'fa-caret-right': child.sref == vm.selectedRoute}\"></i><a ui-sref=\"{{child.sref}}\">{{child.displayText}}</a></div>\r\n                    </li>\r\n                </ul>\r\n            </div>\r\n        </li>\r\n    </ul>\r\n</div>";
  return module.exports;
});

$__System.register('2a', ['6', '7', '10', '29', 'a'], function (_export) {
	var RouteConfig, Component, View, _classCallCheck, _, template, _createClass, RoutesSideNav;

	return {
		setters: [function (_3) {
			RouteConfig = _3.RouteConfig;
			Component = _3.Component;
			View = _3.View;
		}, function (_2) {
			_classCallCheck = _2['default'];
		}, function (_4) {
			_ = _4['default'];
		}, function (_5) {
			template = _5['default'];
		}, function (_a) {
			_createClass = _a['default'];
		}],
		execute: function () {

			//start-non-standard
			// jshint unused: false
			'use strict';

			//end-non-standard

			RoutesSideNav = (function () {
				function RoutesSideNav($rootScope, $state) {
					_classCallCheck(this, _RoutesSideNav);

					// var routes = $rootScope.getRouteMap();
					// if(_.isObject(routes) && _.has(routes, "app")) {
					// 	this.routes = routes.app;
					// } else {
					// 	return false;
					// 	//throw new Error("Can't load route map for routes-side-nav");
					// }

					return false;
					this.setActiveState($state.current.name, $state.params);

					var that = this;
					$rootScope.$on('$stateChangeSuccess', function (event, toState, toParams, fromState, fromParams, options) {
						that.setActiveState(toState.name, toParams);
					});
				}

				_createClass(RoutesSideNav, [{
					key: 'setActiveState',
					value: function setActiveState(route, params) {
						this.setDisplayable(route);

						var splits = route.split(".");
						splits.shift(); // Get rid of app. from the splits;

						this.parentActive = null;
						this.childActive = null;
						this.selectedRoute = route;

						if (_.endsWith(this.selectedRoute, ".index")) {
							this.selectedRoute = this.selectedRoute.substr(0, this.selectedRoute.indexOf(".index"));
						}

						if (splits.length >= 1) {
							this.parentActive = splits[0];
						}
						if (splits.length >= 2) {
							this.childActive = splits[1];
						}
					}
				}, {
					key: 'setDisplayable',
					value: function setDisplayable(fullRoute) {

						this.isDisplayable = false;
						var split = fullRoute.split(".");
						split.shift(); // Take off app from the root

						// Strip .index if there is one
						if (split[split.length - 1] == "index") {
							split.pop();
						}

						var isNestedRoute = false;
						var foundObj = this.routes;

						_.each(split, function (name, index) {
							if (!_.isObject(foundObj)) {
								return;
							}

							if (index > 0) {
								isNestedRoute = true;
							}

							if (_.has(foundObj, "routes")) {
								foundObj = foundObj.routes;
							}

							foundObj = _.find(foundObj, function (item) {
								return item.id == name;
							});
						}, this);

						if (_.isObject(foundObj)) {
							/*
       	If it's the head item and it has children, otherwise no point showing the side nav
        */
							if (!isNestedRoute && _.has(foundObj, "routes") && foundObj.routes.length > 0) {
								this.isDisplayable = true;
							}

							/*
       	If it's a nested route, then obviously we want to show the side nav
        */
							if (isNestedRoute) {
								this.isDisplayable = true;
							}
						}
					}
				}]);

				var _RoutesSideNav = RoutesSideNav;
				RoutesSideNav = View({
					template: template,
					scope: {}

				})(RoutesSideNav) || RoutesSideNav;
				RoutesSideNav = Component({
					selector: 'routes-side-nav'
				})(RoutesSideNav) || RoutesSideNav;
				return RoutesSideNav;
			})();

			_export('default', RoutesSideNav);
		}
	};
});
$__System.register('2b', ['26', '2a'], function (_export) {
  'use strict';
  return {
    setters: [function (_) {}, function (_a) {}],
    execute: function () {}
  };
});
$__System.register('2c', ['6', '7'], function (_export) {
	var RouteConfig, _classCallCheck, ROUTE, PARAMS, Account;

	return {
		setters: [function (_2) {
			RouteConfig = _2.RouteConfig;
		}, function (_) {
			_classCallCheck = _['default'];
		}],
		execute: function () {
			// jshint unused: false

			// export-params-start
			'use strict';

			ROUTE = 'app.account';
			PARAMS = {
				url: '/account',
				template: "<ion-nav-view></ion-nav-view>",
				redirectTo: "app.account.index",
				ncyBreadcrumb: {
					label: "Account"
				}
			};

			// export-params-end

			//start-non-standard

			//end-non-standard

			Account = (function () {
				function Account() {
					_classCallCheck(this, _Account);
				}

				var _Account = Account;
				Account = RouteConfig(ROUTE, PARAMS)(Account) || Account;
				return Account;
			})();

			_export('default', Account);

			_export('ROUTE', ROUTE);

			_export('PARAMS', PARAMS);
		}
	};
});
$__System.registerDynamic("2d", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = "<!--<div class=\"route route-account.index\">-->\r\n    <!--<section>-->\r\n        <!--<h1>Index Page</h1>-->\r\n    <!--</section>-->\r\n<!--</div>-->\r\n\r\n<ion-view view-title=\"Account\">\r\n    <ion-content class=\"padding\">\r\n        <h2>Product Owners</h2>\r\n        <ion-list>\r\n            <ion-item ng-repeat=\"item in vm.products\">\r\n                {{item.name}} - {{item.age}}\r\n            </ion-item>\r\n        </ion-list>\r\n    </ion-content>\r\n</ion-view>\r\n";
  return module.exports;
});

$__System.register('2e', ['6', '7', '22', '23', '2d'], function (_export) {
	var RouteConfig, AbstractPage, _classCallCheck, _get, _inherits, template, ROUTE, PARAMS, AccountIndex;

	return {
		setters: [function (_4) {
			RouteConfig = _4.RouteConfig;
			AbstractPage = _4.AbstractPage;
		}, function (_3) {
			_classCallCheck = _3['default'];
		}, function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_d) {
			template = _d['default'];
		}],
		execute: function () {

			// export-params-start
			'use strict';

			// jshint unused: false
			ROUTE = 'app.account.index';
			PARAMS = {
				url: '/',
				template: template,
				resolve: {},
				ncyBreadcrumb: {
					skip: true
				}
			};

			// export-params-end

			//start-non-standard

			//end-non-standard

			AccountIndex = (function (_AbstractPage) {
				_inherits(AccountIndex, _AbstractPage);

				function AccountIndex($state, $scope, ProductsService) {
					var _this = this;

					_classCallCheck(this, _AccountIndex);

					_get(Object.getPrototypeOf(_AccountIndex.prototype), 'constructor', this).call(this, $scope);

					this.$state = $state;
					this.$scope = $scope;

					ProductsService.list().then(function (data) {
						_this.products = data;
					});
				}

				var _AccountIndex = AccountIndex;
				AccountIndex = RouteConfig(ROUTE, PARAMS)(AccountIndex) || AccountIndex;
				return AccountIndex;
			})(AbstractPage);

			_export('default', AccountIndex);

			_export('ROUTE', ROUTE);

			_export('PARAMS', PARAMS);
		}
	};
});
$__System.registerDynamic("2f", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = "<ion-view view-title=\"Dashboard\">\r\n    <ion-content class=\"padding\">\r\n        <h2>Welcome to Ionic</h2>\r\n        <p>\r\n            This is the Ionic starter for tabs-based apps. For other starters and ready-made templates, check out the <a href=\"http://market.ionic.io/starters\" target=\"_blank\">Ionic Market</a>.\r\n        </p>\r\n        <p>\r\n            To edit the content of each tab, edit the corresponding template file in <code>www/templates/</code>. This template is <code>www/templates/tab-dash.html</code>\r\n        </p>\r\n        <p>\r\n            If you need help with your app, join the Ionic Community on the <a href=\"http://forum.ionicframework.com\" target=\"_blank\">Ionic Forum</a>. Make sure to <a href=\"http://twitter.com/ionicframework\" target=\"_blank\">follow us</a> on Twitter to get important updates and announcements for Ionic developers.\r\n        </p>\r\n        <p>\r\n            For help sending push notifications, join the <a href=\"https://apps.ionic.io/signup\" target=\"_blank\">Ionic Platform</a> and check out <a href=\"http://docs.ionic.io/docs/push-overview\" target=\"_blank\">Ionic Push</a>. We also have other services available.\r\n        </p>\r\n    </ion-content>\r\n</ion-view>\r\n";
  return module.exports;
});

$__System.register('30', ['6', '7', '22', '23', '2f'], function (_export) {
	var RouteConfig, AbstractPage, _classCallCheck, _get, _inherits, template, ROUTE, PARAMS, Index;

	return {
		setters: [function (_4) {
			RouteConfig = _4.RouteConfig;
			AbstractPage = _4.AbstractPage;
		}, function (_3) {
			_classCallCheck = _3['default'];
		}, function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_f) {
			template = _f['default'];
		}],
		execute: function () {

			// export-params-start
			'use strict';

			// jshint unused: false
			ROUTE = 'app.index';
			PARAMS = {
				url: '/',
				template: template,
				resolve: {},
				ncyBreadcrumb: {
					skip: true
				}
			};

			// export-params-end

			//start-non-standard

			//end-non-standard

			Index = (function (_AbstractPage) {
				_inherits(Index, _AbstractPage);

				function Index($state, $scope) {
					_classCallCheck(this, _Index);

					_get(Object.getPrototypeOf(_Index.prototype), 'constructor', this).call(this, $scope);

					this.$state = $state;
					this.$scope = $scope;
				}

				var _Index = Index;
				Index = RouteConfig(ROUTE, PARAMS)(Index) || Index;
				return Index;
			})(AbstractPage);

			_export('default', Index);

			_export('ROUTE', ROUTE);

			_export('PARAMS', PARAMS);
		}
	};
});
$__System.register('31', ['30', '2c', '2e'], function (_export) {
  'use strict';
  return {
    setters: [function (_) {}, function (_c) {}, function (_e) {}],
    execute: function () {}
  };
});
$__System.registerDynamic("32", ["33"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var _Object$defineProperty = $__require('33')["default"];
  exports["default"] = (function() {
    function defineProperties(target, descriptors, initializers) {
      for (var i = 0; i < descriptors.length; i++) {
        var descriptor = descriptors[i];
        var decorators = descriptor.decorators;
        var key = descriptor.key;
        delete descriptor.key;
        delete descriptor.decorators;
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor || descriptor.initializer)
          descriptor.writable = true;
        if (decorators) {
          for (var f = 0; f < decorators.length; f++) {
            var decorator = decorators[f];
            if (typeof decorator === "function") {
              descriptor = decorator(target, key, descriptor) || descriptor;
            } else {
              throw new TypeError("The decorator for method " + descriptor.key + " is of the invalid type " + typeof decorator);
            }
          }
          if (descriptor.initializer !== undefined) {
            initializers[key] = descriptor;
            continue;
          }
        }
        _Object$defineProperty(target, key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps, protoInitializers, staticInitializers) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps, protoInitializers);
      if (staticProps)
        defineProperties(Constructor, staticProps, staticInitializers);
      return Constructor;
    };
  })();
  exports.__esModule = true;
  return module.exports;
});

$__System.register("34", [], function (_export) {
	"use strict";

	return {
		setters: [],
		execute: function () {
			_export("default", {
				"COLLECTION": []
				/*
    	{
    		id: 1,
    		Name: "JJ",
    		Age: 23
    	}
     */

				/*
    To declare a custom return route, the property name is what the route you call.
    The property value is the structure that gets returned.
    
    "getUserPreferences": [
    	{ID: 23, prefName: "save", value: 0}
    ]
     */
			});
		}
	};
});
$__System.register('35', ['6', '7', '22', '23', '32', '34'], function (_export) {
	var MockHttp, Run, _classCallCheck, _get, _inherits, _createDecoratedClass, fixture, ProductsServiceMock;

	return {
		setters: [function (_6) {
			MockHttp = _6.MockHttp;
			Run = _6.Run;
		}, function (_4) {
			_classCallCheck = _4['default'];
		}, function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_3) {
			_createDecoratedClass = _3['default'];
		}, function (_5) {
			fixture = _5['default'];
		}],
		execute: function () {
			'use strict';

			ProductsServiceMock = (function (_MockHttp) {
				_inherits(ProductsServiceMock, _MockHttp);

				function ProductsServiceMock() {
					_classCallCheck(this, ProductsServiceMock);

					_get(Object.getPrototypeOf(ProductsServiceMock.prototype), 'constructor', this).apply(this, arguments);
				}

				_createDecoratedClass(ProductsServiceMock, [{
					key: 'runFactory',
					decorators: [Run()],

					//end-non-standard
					value: function runFactory($httpBackend, ProductsService) {
						var route = ProductsService.getApiRouteName();

						_get(Object.getPrototypeOf(ProductsServiceMock.prototype), 'init', this).call(this, $httpBackend, route, fixture);
					}
				}]);

				return ProductsServiceMock;
			})(MockHttp);

			_export('default', ProductsServiceMock);
		}
	};
});

//start-non-standard
$__System.register('36', ['35'], function (_export) {
  'use strict';
  return {
    setters: [function (_) {}],
    execute: function () {}
  };
});
$__System.registerDynamic("22", ["37"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var _Object$getOwnPropertyDescriptor = $__require('37')["default"];
  exports["default"] = function get(_x, _x2, _x3) {
    var _again = true;
    _function: while (_again) {
      var object = _x,
          property = _x2,
          receiver = _x3;
      _again = false;
      if (object === null)
        object = Function.prototype;
      var desc = _Object$getOwnPropertyDescriptor(object, property);
      if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);
        if (parent === null) {
          return undefined;
        } else {
          _x = parent;
          _x2 = property;
          _x3 = receiver;
          _again = true;
          desc = parent = undefined;
          continue _function;
        }
      } else if ("value" in desc) {
        return desc.value;
      } else {
        var getter = desc.get;
        if (getter === undefined) {
          return undefined;
        }
        return getter.call(receiver);
      }
    }
  };
  exports.__esModule = true;
  return module.exports;
});

$__System.registerDynamic("a", ["33"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var _Object$defineProperty = $__require('33')["default"];
  exports["default"] = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        _Object$defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  exports.__esModule = true;
  return module.exports;
});

$__System.registerDynamic("7", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  exports["default"] = function(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  exports.__esModule = true;
  return module.exports;
});

$__System.registerDynamic("38", ["14"], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    "format global";
    "deps angular";
    (function(window, angular) {
      'use strict';
      var ngAriaModule = angular.module('ngAria', ['ng']).provider('$aria', $AriaProvider);
      var nodeBlackList = ['BUTTON', 'A', 'INPUT', 'TEXTAREA', 'SELECT', 'DETAILS', 'SUMMARY'];
      var isNodeOneOf = function(elem, nodeTypeArray) {
        if (nodeTypeArray.indexOf(elem[0].nodeName) !== -1) {
          return true;
        }
      };
      function $AriaProvider() {
        var config = {
          ariaHidden: true,
          ariaChecked: true,
          ariaReadonly: true,
          ariaDisabled: true,
          ariaRequired: true,
          ariaInvalid: true,
          ariaValue: true,
          tabindex: true,
          bindKeypress: true,
          bindRoleForClick: true
        };
        this.config = function(newConfig) {
          config = angular.extend(config, newConfig);
        };
        function watchExpr(attrName, ariaAttr, nodeBlackList, negate) {
          return function(scope, elem, attr) {
            var ariaCamelName = attr.$normalize(ariaAttr);
            if (config[ariaCamelName] && !isNodeOneOf(elem, nodeBlackList) && !attr[ariaCamelName]) {
              scope.$watch(attr[attrName], function(boolVal) {
                boolVal = negate ? !boolVal : !!boolVal;
                elem.attr(ariaAttr, boolVal);
              });
            }
          };
        }
        this.$get = function() {
          return {
            config: function(key) {
              return config[key];
            },
            $$watchExpr: watchExpr
          };
        };
      }
      ngAriaModule.directive('ngShow', ['$aria', function($aria) {
        return $aria.$$watchExpr('ngShow', 'aria-hidden', [], true);
      }]).directive('ngHide', ['$aria', function($aria) {
        return $aria.$$watchExpr('ngHide', 'aria-hidden', [], false);
      }]).directive('ngValue', ['$aria', function($aria) {
        return $aria.$$watchExpr('ngValue', 'aria-checked', nodeBlackList, false);
      }]).directive('ngChecked', ['$aria', function($aria) {
        return $aria.$$watchExpr('ngChecked', 'aria-checked', nodeBlackList, false);
      }]).directive('ngReadonly', ['$aria', function($aria) {
        return $aria.$$watchExpr('ngReadonly', 'aria-readonly', nodeBlackList, false);
      }]).directive('ngRequired', ['$aria', function($aria) {
        return $aria.$$watchExpr('ngRequired', 'aria-required', nodeBlackList, false);
      }]).directive('ngModel', ['$aria', function($aria) {
        function shouldAttachAttr(attr, normalizedAttr, elem, allowBlacklistEls) {
          return $aria.config(normalizedAttr) && !elem.attr(attr) && (allowBlacklistEls || !isNodeOneOf(elem, nodeBlackList));
        }
        function shouldAttachRole(role, elem) {
          return !elem.attr('role') && (elem.attr('type') === role) && (elem[0].nodeName !== 'INPUT');
        }
        function getShape(attr, elem) {
          var type = attr.type,
              role = attr.role;
          return ((type || role) === 'checkbox' || role === 'menuitemcheckbox') ? 'checkbox' : ((type || role) === 'radio' || role === 'menuitemradio') ? 'radio' : (type === 'range' || role === 'progressbar' || role === 'slider') ? 'range' : '';
        }
        return {
          restrict: 'A',
          require: 'ngModel',
          priority: 200,
          compile: function(elem, attr) {
            var shape = getShape(attr, elem);
            return {
              pre: function(scope, elem, attr, ngModel) {
                if (shape === 'checkbox') {
                  ngModel.$isEmpty = function(value) {
                    return value === false;
                  };
                }
              },
              post: function(scope, elem, attr, ngModel) {
                var needsTabIndex = shouldAttachAttr('tabindex', 'tabindex', elem, false);
                function ngAriaWatchModelValue() {
                  return ngModel.$modelValue;
                }
                function getRadioReaction(newVal) {
                  var boolVal = (attr.value == ngModel.$viewValue);
                  elem.attr('aria-checked', boolVal);
                }
                function getCheckboxReaction() {
                  elem.attr('aria-checked', !ngModel.$isEmpty(ngModel.$viewValue));
                }
                switch (shape) {
                  case 'radio':
                  case 'checkbox':
                    if (shouldAttachRole(shape, elem)) {
                      elem.attr('role', shape);
                    }
                    if (shouldAttachAttr('aria-checked', 'ariaChecked', elem, false)) {
                      scope.$watch(ngAriaWatchModelValue, shape === 'radio' ? getRadioReaction : getCheckboxReaction);
                    }
                    if (needsTabIndex) {
                      elem.attr('tabindex', 0);
                    }
                    break;
                  case 'range':
                    if (shouldAttachRole(shape, elem)) {
                      elem.attr('role', 'slider');
                    }
                    if ($aria.config('ariaValue')) {
                      var needsAriaValuemin = !elem.attr('aria-valuemin') && (attr.hasOwnProperty('min') || attr.hasOwnProperty('ngMin'));
                      var needsAriaValuemax = !elem.attr('aria-valuemax') && (attr.hasOwnProperty('max') || attr.hasOwnProperty('ngMax'));
                      var needsAriaValuenow = !elem.attr('aria-valuenow');
                      if (needsAriaValuemin) {
                        attr.$observe('min', function ngAriaValueMinReaction(newVal) {
                          elem.attr('aria-valuemin', newVal);
                        });
                      }
                      if (needsAriaValuemax) {
                        attr.$observe('max', function ngAriaValueMinReaction(newVal) {
                          elem.attr('aria-valuemax', newVal);
                        });
                      }
                      if (needsAriaValuenow) {
                        scope.$watch(ngAriaWatchModelValue, function ngAriaValueNowReaction(newVal) {
                          elem.attr('aria-valuenow', newVal);
                        });
                      }
                    }
                    if (needsTabIndex) {
                      elem.attr('tabindex', 0);
                    }
                    break;
                }
                if (!attr.hasOwnProperty('ngRequired') && ngModel.$validators.required && shouldAttachAttr('aria-required', 'ariaRequired', elem, false)) {
                  attr.$observe('required', function() {
                    elem.attr('aria-required', !!attr['required']);
                  });
                }
                if (shouldAttachAttr('aria-invalid', 'ariaInvalid', elem, true)) {
                  scope.$watch(function ngAriaInvalidWatch() {
                    return ngModel.$invalid;
                  }, function ngAriaInvalidReaction(newVal) {
                    elem.attr('aria-invalid', !!newVal);
                  });
                }
              }
            };
          }
        };
      }]).directive('ngDisabled', ['$aria', function($aria) {
        return $aria.$$watchExpr('ngDisabled', 'aria-disabled', nodeBlackList, false);
      }]).directive('ngMessages', function() {
        return {
          restrict: 'A',
          require: '?ngMessages',
          link: function(scope, elem, attr, ngMessages) {
            if (!elem.attr('aria-live')) {
              elem.attr('aria-live', 'assertive');
            }
          }
        };
      }).directive('ngClick', ['$aria', '$parse', function($aria, $parse) {
        return {
          restrict: 'A',
          compile: function(elem, attr) {
            var fn = $parse(attr.ngClick, null, true);
            return function(scope, elem, attr) {
              if (!isNodeOneOf(elem, nodeBlackList)) {
                if ($aria.config('bindRoleForClick') && !elem.attr('role')) {
                  elem.attr('role', 'button');
                }
                if ($aria.config('tabindex') && !elem.attr('tabindex')) {
                  elem.attr('tabindex', 0);
                }
                if ($aria.config('bindKeypress') && !attr.ngKeypress) {
                  elem.on('keypress', function(event) {
                    var keyCode = event.which || event.keyCode;
                    if (keyCode === 32 || keyCode === 13) {
                      scope.$apply(callback);
                    }
                    function callback() {
                      fn(scope, {$event: event});
                    }
                  });
                }
              }
            };
          }
        };
      }]).directive('ngDblclick', ['$aria', function($aria) {
        return function(scope, elem, attr) {
          if ($aria.config('tabindex') && !elem.attr('tabindex') && !isNodeOneOf(elem, nodeBlackList)) {
            elem.attr('tabindex', 0);
          }
        };
      }]);
    })(window, window.angular);
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("39", ["38"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('38');
  module.exports = 'ngAria';
  return module.exports;
});

$__System.registerDynamic("3a", ["39"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('39');
  return module.exports;
});

$__System.registerDynamic("3b", ["14"], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    "format global";
    "deps angular";
    (function(window, angular) {
      'use strict';
      var noop = angular.noop;
      var copy = angular.copy;
      var extend = angular.extend;
      var jqLite = angular.element;
      var forEach = angular.forEach;
      var isArray = angular.isArray;
      var isString = angular.isString;
      var isObject = angular.isObject;
      var isUndefined = angular.isUndefined;
      var isDefined = angular.isDefined;
      var isFunction = angular.isFunction;
      var isElement = angular.isElement;
      var ELEMENT_NODE = 1;
      var COMMENT_NODE = 8;
      var ADD_CLASS_SUFFIX = '-add';
      var REMOVE_CLASS_SUFFIX = '-remove';
      var EVENT_CLASS_PREFIX = 'ng-';
      var ACTIVE_CLASS_SUFFIX = '-active';
      var PREPARE_CLASS_SUFFIX = '-prepare';
      var NG_ANIMATE_CLASSNAME = 'ng-animate';
      var NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';
      var CSS_PREFIX = '',
          TRANSITION_PROP,
          TRANSITIONEND_EVENT,
          ANIMATION_PROP,
          ANIMATIONEND_EVENT;
      if (isUndefined(window.ontransitionend) && isDefined(window.onwebkittransitionend)) {
        CSS_PREFIX = '-webkit-';
        TRANSITION_PROP = 'WebkitTransition';
        TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';
      } else {
        TRANSITION_PROP = 'transition';
        TRANSITIONEND_EVENT = 'transitionend';
      }
      if (isUndefined(window.onanimationend) && isDefined(window.onwebkitanimationend)) {
        CSS_PREFIX = '-webkit-';
        ANIMATION_PROP = 'WebkitAnimation';
        ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';
      } else {
        ANIMATION_PROP = 'animation';
        ANIMATIONEND_EVENT = 'animationend';
      }
      var DURATION_KEY = 'Duration';
      var PROPERTY_KEY = 'Property';
      var DELAY_KEY = 'Delay';
      var TIMING_KEY = 'TimingFunction';
      var ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';
      var ANIMATION_PLAYSTATE_KEY = 'PlayState';
      var SAFE_FAST_FORWARD_DURATION_VALUE = 9999;
      var ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;
      var ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;
      var TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;
      var TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;
      var isPromiseLike = function(p) {
        return p && p.then ? true : false;
      };
      var ngMinErr = angular.$$minErr('ng');
      function assertArg(arg, name, reason) {
        if (!arg) {
          throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
        }
        return arg;
      }
      function mergeClasses(a, b) {
        if (!a && !b)
          return '';
        if (!a)
          return b;
        if (!b)
          return a;
        if (isArray(a))
          a = a.join(' ');
        if (isArray(b))
          b = b.join(' ');
        return a + ' ' + b;
      }
      function packageStyles(options) {
        var styles = {};
        if (options && (options.to || options.from)) {
          styles.to = options.to;
          styles.from = options.from;
        }
        return styles;
      }
      function pendClasses(classes, fix, isPrefix) {
        var className = '';
        classes = isArray(classes) ? classes : classes && isString(classes) && classes.length ? classes.split(/\s+/) : [];
        forEach(classes, function(klass, i) {
          if (klass && klass.length > 0) {
            className += (i > 0) ? ' ' : '';
            className += isPrefix ? fix + klass : klass + fix;
          }
        });
        return className;
      }
      function removeFromArray(arr, val) {
        var index = arr.indexOf(val);
        if (val >= 0) {
          arr.splice(index, 1);
        }
      }
      function stripCommentsFromElement(element) {
        if (element instanceof jqLite) {
          switch (element.length) {
            case 0:
              return element;
              break;
            case 1:
              if (element[0].nodeType === ELEMENT_NODE) {
                return element;
              }
              break;
            default:
              return jqLite(extractElementNode(element));
              break;
          }
        }
        if (element.nodeType === ELEMENT_NODE) {
          return jqLite(element);
        }
      }
      function extractElementNode(element) {
        if (!element[0])
          return element;
        for (var i = 0; i < element.length; i++) {
          var elm = element[i];
          if (elm.nodeType == ELEMENT_NODE) {
            return elm;
          }
        }
      }
      function $$addClass($$jqLite, element, className) {
        forEach(element, function(elm) {
          $$jqLite.addClass(elm, className);
        });
      }
      function $$removeClass($$jqLite, element, className) {
        forEach(element, function(elm) {
          $$jqLite.removeClass(elm, className);
        });
      }
      function applyAnimationClassesFactory($$jqLite) {
        return function(element, options) {
          if (options.addClass) {
            $$addClass($$jqLite, element, options.addClass);
            options.addClass = null;
          }
          if (options.removeClass) {
            $$removeClass($$jqLite, element, options.removeClass);
            options.removeClass = null;
          }
        };
      }
      function prepareAnimationOptions(options) {
        options = options || {};
        if (!options.$$prepared) {
          var domOperation = options.domOperation || noop;
          options.domOperation = function() {
            options.$$domOperationFired = true;
            domOperation();
            domOperation = noop;
          };
          options.$$prepared = true;
        }
        return options;
      }
      function applyAnimationStyles(element, options) {
        applyAnimationFromStyles(element, options);
        applyAnimationToStyles(element, options);
      }
      function applyAnimationFromStyles(element, options) {
        if (options.from) {
          element.css(options.from);
          options.from = null;
        }
      }
      function applyAnimationToStyles(element, options) {
        if (options.to) {
          element.css(options.to);
          options.to = null;
        }
      }
      function mergeAnimationDetails(element, oldAnimation, newAnimation) {
        var target = oldAnimation.options || {};
        var newOptions = newAnimation.options || {};
        var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');
        var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');
        var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);
        if (newOptions.preparationClasses) {
          target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);
          delete newOptions.preparationClasses;
        }
        var realDomOperation = target.domOperation !== noop ? target.domOperation : null;
        extend(target, newOptions);
        if (realDomOperation) {
          target.domOperation = realDomOperation;
        }
        if (classes.addClass) {
          target.addClass = classes.addClass;
        } else {
          target.addClass = null;
        }
        if (classes.removeClass) {
          target.removeClass = classes.removeClass;
        } else {
          target.removeClass = null;
        }
        oldAnimation.addClass = target.addClass;
        oldAnimation.removeClass = target.removeClass;
        return target;
      }
      function resolveElementClasses(existing, toAdd, toRemove) {
        var ADD_CLASS = 1;
        var REMOVE_CLASS = -1;
        var flags = {};
        existing = splitClassesToLookup(existing);
        toAdd = splitClassesToLookup(toAdd);
        forEach(toAdd, function(value, key) {
          flags[key] = ADD_CLASS;
        });
        toRemove = splitClassesToLookup(toRemove);
        forEach(toRemove, function(value, key) {
          flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;
        });
        var classes = {
          addClass: '',
          removeClass: ''
        };
        forEach(flags, function(val, klass) {
          var prop,
              allow;
          if (val === ADD_CLASS) {
            prop = 'addClass';
            allow = !existing[klass];
          } else if (val === REMOVE_CLASS) {
            prop = 'removeClass';
            allow = existing[klass];
          }
          if (allow) {
            if (classes[prop].length) {
              classes[prop] += ' ';
            }
            classes[prop] += klass;
          }
        });
        function splitClassesToLookup(classes) {
          if (isString(classes)) {
            classes = classes.split(' ');
          }
          var obj = {};
          forEach(classes, function(klass) {
            if (klass.length) {
              obj[klass] = true;
            }
          });
          return obj;
        }
        return classes;
      }
      function getDomNode(element) {
        return (element instanceof angular.element) ? element[0] : element;
      }
      function applyGeneratedPreparationClasses(element, event, options) {
        var classes = '';
        if (event) {
          classes = pendClasses(event, EVENT_CLASS_PREFIX, true);
        }
        if (options.addClass) {
          classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));
        }
        if (options.removeClass) {
          classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));
        }
        if (classes.length) {
          options.preparationClasses = classes;
          element.addClass(classes);
        }
      }
      function clearGeneratedClasses(element, options) {
        if (options.preparationClasses) {
          element.removeClass(options.preparationClasses);
          options.preparationClasses = null;
        }
        if (options.activeClasses) {
          element.removeClass(options.activeClasses);
          options.activeClasses = null;
        }
      }
      function blockTransitions(node, duration) {
        var value = duration ? '-' + duration + 's' : '';
        applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);
        return [TRANSITION_DELAY_PROP, value];
      }
      function blockKeyframeAnimations(node, applyBlock) {
        var value = applyBlock ? 'paused' : '';
        var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;
        applyInlineStyle(node, [key, value]);
        return [key, value];
      }
      function applyInlineStyle(node, styleTuple) {
        var prop = styleTuple[0];
        var value = styleTuple[1];
        node.style[prop] = value;
      }
      function concatWithSpace(a, b) {
        if (!a)
          return b;
        if (!b)
          return a;
        return a + ' ' + b;
      }
      var $$rAFSchedulerFactory = ['$$rAF', function($$rAF) {
        var queue,
            cancelFn;
        function scheduler(tasks) {
          queue = queue.concat(tasks);
          nextTick();
        }
        queue = scheduler.queue = [];
        scheduler.waitUntilQuiet = function(fn) {
          if (cancelFn)
            cancelFn();
          cancelFn = $$rAF(function() {
            cancelFn = null;
            fn();
            nextTick();
          });
        };
        return scheduler;
        function nextTick() {
          if (!queue.length)
            return;
          var items = queue.shift();
          for (var i = 0; i < items.length; i++) {
            items[i]();
          }
          if (!cancelFn) {
            $$rAF(function() {
              if (!cancelFn)
                nextTick();
            });
          }
        }
      }];
      var $$AnimateChildrenDirective = ['$interpolate', function($interpolate) {
        return {link: function(scope, element, attrs) {
            var val = attrs.ngAnimateChildren;
            if (angular.isString(val) && val.length === 0) {
              element.data(NG_ANIMATE_CHILDREN_DATA, true);
            } else {
              setData($interpolate(val)(scope));
              attrs.$observe('ngAnimateChildren', setData);
            }
            function setData(value) {
              value = value === 'on' || value === 'true';
              element.data(NG_ANIMATE_CHILDREN_DATA, value);
            }
          }};
      }];
      var ANIMATE_TIMER_KEY = '$$animateCss';
      var ONE_SECOND = 1000;
      var BASE_TEN = 10;
      var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;
      var CLOSING_TIME_BUFFER = 1.5;
      var DETECT_CSS_PROPERTIES = {
        transitionDuration: TRANSITION_DURATION_PROP,
        transitionDelay: TRANSITION_DELAY_PROP,
        transitionProperty: TRANSITION_PROP + PROPERTY_KEY,
        animationDuration: ANIMATION_DURATION_PROP,
        animationDelay: ANIMATION_DELAY_PROP,
        animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY
      };
      var DETECT_STAGGER_CSS_PROPERTIES = {
        transitionDuration: TRANSITION_DURATION_PROP,
        transitionDelay: TRANSITION_DELAY_PROP,
        animationDuration: ANIMATION_DURATION_PROP,
        animationDelay: ANIMATION_DELAY_PROP
      };
      function getCssKeyframeDurationStyle(duration) {
        return [ANIMATION_DURATION_PROP, duration + 's'];
      }
      function getCssDelayStyle(delay, isKeyframeAnimation) {
        var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;
        return [prop, delay + 's'];
      }
      function computeCssStyles($window, element, properties) {
        var styles = Object.create(null);
        var detectedStyles = $window.getComputedStyle(element) || {};
        forEach(properties, function(formalStyleName, actualStyleName) {
          var val = detectedStyles[formalStyleName];
          if (val) {
            var c = val.charAt(0);
            if (c === '-' || c === '+' || c >= 0) {
              val = parseMaxTime(val);
            }
            if (val === 0) {
              val = null;
            }
            styles[actualStyleName] = val;
          }
        });
        return styles;
      }
      function parseMaxTime(str) {
        var maxValue = 0;
        var values = str.split(/\s*,\s*/);
        forEach(values, function(value) {
          if (value.charAt(value.length - 1) == 's') {
            value = value.substring(0, value.length - 1);
          }
          value = parseFloat(value) || 0;
          maxValue = maxValue ? Math.max(value, maxValue) : value;
        });
        return maxValue;
      }
      function truthyTimingValue(val) {
        return val === 0 || val != null;
      }
      function getCssTransitionDurationStyle(duration, applyOnlyDuration) {
        var style = TRANSITION_PROP;
        var value = duration + 's';
        if (applyOnlyDuration) {
          style += DURATION_KEY;
        } else {
          value += ' linear all';
        }
        return [style, value];
      }
      function createLocalCacheLookup() {
        var cache = Object.create(null);
        return {
          flush: function() {
            cache = Object.create(null);
          },
          count: function(key) {
            var entry = cache[key];
            return entry ? entry.total : 0;
          },
          get: function(key) {
            var entry = cache[key];
            return entry && entry.value;
          },
          put: function(key, value) {
            if (!cache[key]) {
              cache[key] = {
                total: 1,
                value: value
              };
            } else {
              cache[key].total++;
            }
          }
        };
      }
      function registerRestorableStyles(backup, node, properties) {
        forEach(properties, function(prop) {
          backup[prop] = isDefined(backup[prop]) ? backup[prop] : node.style.getPropertyValue(prop);
        });
      }
      var $AnimateCssProvider = ['$animateProvider', function($animateProvider) {
        var gcsLookup = createLocalCacheLookup();
        var gcsStaggerLookup = createLocalCacheLookup();
        this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout', '$$forceReflow', '$sniffer', '$$rAFScheduler', '$$animateQueue', function($window, $$jqLite, $$AnimateRunner, $timeout, $$forceReflow, $sniffer, $$rAFScheduler, $$animateQueue) {
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          var parentCounter = 0;
          function gcsHashFn(node, extraClasses) {
            var KEY = "$$ngAnimateParentKey";
            var parentNode = node.parentNode;
            var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);
            return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;
          }
          function computeCachedCssStyles(node, className, cacheKey, properties) {
            var timings = gcsLookup.get(cacheKey);
            if (!timings) {
              timings = computeCssStyles($window, node, properties);
              if (timings.animationIterationCount === 'infinite') {
                timings.animationIterationCount = 1;
              }
            }
            gcsLookup.put(cacheKey, timings);
            return timings;
          }
          function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {
            var stagger;
            if (gcsLookup.count(cacheKey) > 0) {
              stagger = gcsStaggerLookup.get(cacheKey);
              if (!stagger) {
                var staggerClassName = pendClasses(className, '-stagger');
                $$jqLite.addClass(node, staggerClassName);
                stagger = computeCssStyles($window, node, properties);
                stagger.animationDuration = Math.max(stagger.animationDuration, 0);
                stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);
                $$jqLite.removeClass(node, staggerClassName);
                gcsStaggerLookup.put(cacheKey, stagger);
              }
            }
            return stagger || {};
          }
          var cancelLastRAFRequest;
          var rafWaitQueue = [];
          function waitUntilQuiet(callback) {
            rafWaitQueue.push(callback);
            $$rAFScheduler.waitUntilQuiet(function() {
              gcsLookup.flush();
              gcsStaggerLookup.flush();
              var pageWidth = $$forceReflow();
              for (var i = 0; i < rafWaitQueue.length; i++) {
                rafWaitQueue[i](pageWidth);
              }
              rafWaitQueue.length = 0;
            });
          }
          function computeTimings(node, className, cacheKey) {
            var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);
            var aD = timings.animationDelay;
            var tD = timings.transitionDelay;
            timings.maxDelay = aD && tD ? Math.max(aD, tD) : (aD || tD);
            timings.maxDuration = Math.max(timings.animationDuration * timings.animationIterationCount, timings.transitionDuration);
            return timings;
          }
          return function init(element, initialOptions) {
            var options = initialOptions || {};
            if (!options.$$prepared) {
              options = prepareAnimationOptions(copy(options));
            }
            var restoreStyles = {};
            var node = getDomNode(element);
            if (!node || !node.parentNode || !$$animateQueue.enabled()) {
              return closeAndReturnNoopAnimator();
            }
            var temporaryStyles = [];
            var classes = element.attr('class');
            var styles = packageStyles(options);
            var animationClosed;
            var animationPaused;
            var animationCompleted;
            var runner;
            var runnerHost;
            var maxDelay;
            var maxDelayTime;
            var maxDuration;
            var maxDurationTime;
            var startTime;
            var events = [];
            if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {
              return closeAndReturnNoopAnimator();
            }
            var method = options.event && isArray(options.event) ? options.event.join(' ') : options.event;
            var isStructural = method && options.structural;
            var structuralClassName = '';
            var addRemoveClassName = '';
            if (isStructural) {
              structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);
            } else if (method) {
              structuralClassName = method;
            }
            if (options.addClass) {
              addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);
            }
            if (options.removeClass) {
              if (addRemoveClassName.length) {
                addRemoveClassName += ' ';
              }
              addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);
            }
            if (options.applyClassesEarly && addRemoveClassName.length) {
              applyAnimationClasses(element, options);
            }
            var preparationClasses = [structuralClassName, addRemoveClassName].join(' ').trim();
            var fullClassName = classes + ' ' + preparationClasses;
            var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);
            var hasToStyles = styles.to && Object.keys(styles.to).length > 0;
            var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0;
            if (!containsKeyframeAnimation && !hasToStyles && !preparationClasses) {
              return closeAndReturnNoopAnimator();
            }
            var cacheKey,
                stagger;
            if (options.stagger > 0) {
              var staggerVal = parseFloat(options.stagger);
              stagger = {
                transitionDelay: staggerVal,
                animationDelay: staggerVal,
                transitionDuration: 0,
                animationDuration: 0
              };
            } else {
              cacheKey = gcsHashFn(node, fullClassName);
              stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);
            }
            if (!options.$$skipPreparationClasses) {
              $$jqLite.addClass(element, preparationClasses);
            }
            var applyOnlyDuration;
            if (options.transitionStyle) {
              var transitionStyle = [TRANSITION_PROP, options.transitionStyle];
              applyInlineStyle(node, transitionStyle);
              temporaryStyles.push(transitionStyle);
            }
            if (options.duration >= 0) {
              applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;
              var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);
              applyInlineStyle(node, durationStyle);
              temporaryStyles.push(durationStyle);
            }
            if (options.keyframeStyle) {
              var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];
              applyInlineStyle(node, keyframeStyle);
              temporaryStyles.push(keyframeStyle);
            }
            var itemIndex = stagger ? options.staggerIndex >= 0 ? options.staggerIndex : gcsLookup.count(cacheKey) : 0;
            var isFirst = itemIndex === 0;
            if (isFirst && !options.skipBlocking) {
              blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);
            }
            var timings = computeTimings(node, fullClassName, cacheKey);
            var relativeDelay = timings.maxDelay;
            maxDelay = Math.max(relativeDelay, 0);
            maxDuration = timings.maxDuration;
            var flags = {};
            flags.hasTransitions = timings.transitionDuration > 0;
            flags.hasAnimations = timings.animationDuration > 0;
            flags.hasTransitionAll = flags.hasTransitions && timings.transitionProperty == 'all';
            flags.applyTransitionDuration = hasToStyles && ((flags.hasTransitions && !flags.hasTransitionAll) || (flags.hasAnimations && !flags.hasTransitions));
            flags.applyAnimationDuration = options.duration && flags.hasAnimations;
            flags.applyTransitionDelay = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);
            flags.applyAnimationDelay = truthyTimingValue(options.delay) && flags.hasAnimations;
            flags.recalculateTimingStyles = addRemoveClassName.length > 0;
            if (flags.applyTransitionDuration || flags.applyAnimationDuration) {
              maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;
              if (flags.applyTransitionDuration) {
                flags.hasTransitions = true;
                timings.transitionDuration = maxDuration;
                applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;
                temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));
              }
              if (flags.applyAnimationDuration) {
                flags.hasAnimations = true;
                timings.animationDuration = maxDuration;
                temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));
              }
            }
            if (maxDuration === 0 && !flags.recalculateTimingStyles) {
              return closeAndReturnNoopAnimator();
            }
            if (options.delay != null) {
              var delayStyle;
              if (typeof options.delay !== "boolean") {
                delayStyle = parseFloat(options.delay);
                maxDelay = Math.max(delayStyle, 0);
              }
              if (flags.applyTransitionDelay) {
                temporaryStyles.push(getCssDelayStyle(delayStyle));
              }
              if (flags.applyAnimationDelay) {
                temporaryStyles.push(getCssDelayStyle(delayStyle, true));
              }
            }
            if (options.duration == null && timings.transitionDuration > 0) {
              flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;
            }
            maxDelayTime = maxDelay * ONE_SECOND;
            maxDurationTime = maxDuration * ONE_SECOND;
            if (!options.skipBlocking) {
              flags.blockTransition = timings.transitionDuration > 0;
              flags.blockKeyframeAnimation = timings.animationDuration > 0 && stagger.animationDelay > 0 && stagger.animationDuration === 0;
            }
            if (options.from) {
              if (options.cleanupStyles) {
                registerRestorableStyles(restoreStyles, node, Object.keys(options.from));
              }
              applyAnimationFromStyles(element, options);
            }
            if (flags.blockTransition || flags.blockKeyframeAnimation) {
              applyBlocking(maxDuration);
            } else if (!options.skipBlocking) {
              blockTransitions(node, false);
            }
            return {
              $$willAnimate: true,
              end: endFn,
              start: function() {
                if (animationClosed)
                  return;
                runnerHost = {
                  end: endFn,
                  cancel: cancelFn,
                  resume: null,
                  pause: null
                };
                runner = new $$AnimateRunner(runnerHost);
                waitUntilQuiet(start);
                return runner;
              }
            };
            function endFn() {
              close();
            }
            function cancelFn() {
              close(true);
            }
            function close(rejected) {
              if (animationClosed || (animationCompleted && animationPaused))
                return;
              animationClosed = true;
              animationPaused = false;
              if (!options.$$skipPreparationClasses) {
                $$jqLite.removeClass(element, preparationClasses);
              }
              $$jqLite.removeClass(element, activeClasses);
              blockKeyframeAnimations(node, false);
              blockTransitions(node, false);
              forEach(temporaryStyles, function(entry) {
                node.style[entry[0]] = '';
              });
              applyAnimationClasses(element, options);
              applyAnimationStyles(element, options);
              if (Object.keys(restoreStyles).length) {
                forEach(restoreStyles, function(value, prop) {
                  value ? node.style.setProperty(prop, value) : node.style.removeProperty(prop);
                });
              }
              if (options.onDone) {
                options.onDone();
              }
              if (events && events.length) {
                element.off(events.join(' '), onAnimationProgress);
              }
              var animationTimerData = element.data(ANIMATE_TIMER_KEY);
              if (animationTimerData) {
                $timeout.cancel(animationTimerData[0].timer);
                element.removeData(ANIMATE_TIMER_KEY);
              }
              if (runner) {
                runner.complete(!rejected);
              }
            }
            function applyBlocking(duration) {
              if (flags.blockTransition) {
                blockTransitions(node, duration);
              }
              if (flags.blockKeyframeAnimation) {
                blockKeyframeAnimations(node, !!duration);
              }
            }
            function closeAndReturnNoopAnimator() {
              runner = new $$AnimateRunner({
                end: endFn,
                cancel: cancelFn
              });
              waitUntilQuiet(noop);
              close();
              return {
                $$willAnimate: false,
                start: function() {
                  return runner;
                },
                end: endFn
              };
            }
            function onAnimationProgress(event) {
              event.stopPropagation();
              var ev = event.originalEvent || event;
              var timeStamp = ev.$manualTimeStamp || Date.now();
              var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));
              if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {
                animationCompleted = true;
                close();
              }
            }
            function start() {
              if (animationClosed)
                return;
              if (!node.parentNode) {
                close();
                return;
              }
              var playPause = function(playAnimation) {
                if (!animationCompleted) {
                  animationPaused = !playAnimation;
                  if (timings.animationDuration) {
                    var value = blockKeyframeAnimations(node, animationPaused);
                    animationPaused ? temporaryStyles.push(value) : removeFromArray(temporaryStyles, value);
                  }
                } else if (animationPaused && playAnimation) {
                  animationPaused = false;
                  close();
                }
              };
              var maxStagger = itemIndex > 0 && ((timings.transitionDuration && stagger.transitionDuration === 0) || (timings.animationDuration && stagger.animationDuration === 0)) && Math.max(stagger.animationDelay, stagger.transitionDelay);
              if (maxStagger) {
                $timeout(triggerAnimationStart, Math.floor(maxStagger * itemIndex * ONE_SECOND), false);
              } else {
                triggerAnimationStart();
              }
              runnerHost.resume = function() {
                playPause(true);
              };
              runnerHost.pause = function() {
                playPause(false);
              };
              function triggerAnimationStart() {
                if (animationClosed)
                  return;
                applyBlocking(false);
                forEach(temporaryStyles, function(entry) {
                  var key = entry[0];
                  var value = entry[1];
                  node.style[key] = value;
                });
                applyAnimationClasses(element, options);
                $$jqLite.addClass(element, activeClasses);
                if (flags.recalculateTimingStyles) {
                  fullClassName = node.className + ' ' + preparationClasses;
                  cacheKey = gcsHashFn(node, fullClassName);
                  timings = computeTimings(node, fullClassName, cacheKey);
                  relativeDelay = timings.maxDelay;
                  maxDelay = Math.max(relativeDelay, 0);
                  maxDuration = timings.maxDuration;
                  if (maxDuration === 0) {
                    close();
                    return;
                  }
                  flags.hasTransitions = timings.transitionDuration > 0;
                  flags.hasAnimations = timings.animationDuration > 0;
                }
                if (flags.applyAnimationDelay) {
                  relativeDelay = typeof options.delay !== "boolean" && truthyTimingValue(options.delay) ? parseFloat(options.delay) : relativeDelay;
                  maxDelay = Math.max(relativeDelay, 0);
                  timings.animationDelay = relativeDelay;
                  delayStyle = getCssDelayStyle(relativeDelay, true);
                  temporaryStyles.push(delayStyle);
                  node.style[delayStyle[0]] = delayStyle[1];
                }
                maxDelayTime = maxDelay * ONE_SECOND;
                maxDurationTime = maxDuration * ONE_SECOND;
                if (options.easing) {
                  var easeProp,
                      easeVal = options.easing;
                  if (flags.hasTransitions) {
                    easeProp = TRANSITION_PROP + TIMING_KEY;
                    temporaryStyles.push([easeProp, easeVal]);
                    node.style[easeProp] = easeVal;
                  }
                  if (flags.hasAnimations) {
                    easeProp = ANIMATION_PROP + TIMING_KEY;
                    temporaryStyles.push([easeProp, easeVal]);
                    node.style[easeProp] = easeVal;
                  }
                }
                if (timings.transitionDuration) {
                  events.push(TRANSITIONEND_EVENT);
                }
                if (timings.animationDuration) {
                  events.push(ANIMATIONEND_EVENT);
                }
                startTime = Date.now();
                var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;
                var endTime = startTime + timerTime;
                var animationsData = element.data(ANIMATE_TIMER_KEY) || [];
                var setupFallbackTimer = true;
                if (animationsData.length) {
                  var currentTimerData = animationsData[0];
                  setupFallbackTimer = endTime > currentTimerData.expectedEndTime;
                  if (setupFallbackTimer) {
                    $timeout.cancel(currentTimerData.timer);
                  } else {
                    animationsData.push(close);
                  }
                }
                if (setupFallbackTimer) {
                  var timer = $timeout(onAnimationExpired, timerTime, false);
                  animationsData[0] = {
                    timer: timer,
                    expectedEndTime: endTime
                  };
                  animationsData.push(close);
                  element.data(ANIMATE_TIMER_KEY, animationsData);
                }
                if (events.length) {
                  element.on(events.join(' '), onAnimationProgress);
                }
                if (options.to) {
                  if (options.cleanupStyles) {
                    registerRestorableStyles(restoreStyles, node, Object.keys(options.to));
                  }
                  applyAnimationToStyles(element, options);
                }
              }
              function onAnimationExpired() {
                var animationsData = element.data(ANIMATE_TIMER_KEY);
                if (animationsData) {
                  for (var i = 1; i < animationsData.length; i++) {
                    animationsData[i]();
                  }
                  element.removeData(ANIMATE_TIMER_KEY);
                }
              }
            }
          };
        }];
      }];
      var $$AnimateCssDriverProvider = ['$$animationProvider', function($$animationProvider) {
        $$animationProvider.drivers.push('$$animateCssDriver');
        var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';
        var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';
        var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';
        var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';
        function isDocumentFragment(node) {
          return node.parentNode && node.parentNode.nodeType === 11;
        }
        this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$sniffer', '$$jqLite', '$document', function($animateCss, $rootScope, $$AnimateRunner, $rootElement, $sniffer, $$jqLite, $document) {
          if (!$sniffer.animations && !$sniffer.transitions)
            return noop;
          var bodyNode = $document[0].body;
          var rootNode = getDomNode($rootElement);
          var rootBodyElement = jqLite(isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode);
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          return function initDriverFn(animationDetails) {
            return animationDetails.from && animationDetails.to ? prepareFromToAnchorAnimation(animationDetails.from, animationDetails.to, animationDetails.classes, animationDetails.anchors) : prepareRegularAnimation(animationDetails);
          };
          function filterCssClasses(classes) {
            return classes.replace(/\bng-\S+\b/g, '');
          }
          function getUniqueValues(a, b) {
            if (isString(a))
              a = a.split(' ');
            if (isString(b))
              b = b.split(' ');
            return a.filter(function(val) {
              return b.indexOf(val) === -1;
            }).join(' ');
          }
          function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {
            var clone = jqLite(getDomNode(outAnchor).cloneNode(true));
            var startingClasses = filterCssClasses(getClassVal(clone));
            outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
            inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
            clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);
            rootBodyElement.append(clone);
            var animatorIn,
                animatorOut = prepareOutAnimation();
            if (!animatorOut) {
              animatorIn = prepareInAnimation();
              if (!animatorIn) {
                return end();
              }
            }
            var startingAnimator = animatorOut || animatorIn;
            return {start: function() {
                var runner;
                var currentAnimation = startingAnimator.start();
                currentAnimation.done(function() {
                  currentAnimation = null;
                  if (!animatorIn) {
                    animatorIn = prepareInAnimation();
                    if (animatorIn) {
                      currentAnimation = animatorIn.start();
                      currentAnimation.done(function() {
                        currentAnimation = null;
                        end();
                        runner.complete();
                      });
                      return currentAnimation;
                    }
                  }
                  end();
                  runner.complete();
                });
                runner = new $$AnimateRunner({
                  end: endFn,
                  cancel: endFn
                });
                return runner;
                function endFn() {
                  if (currentAnimation) {
                    currentAnimation.end();
                  }
                }
              }};
            function calculateAnchorStyles(anchor) {
              var styles = {};
              var coords = getDomNode(anchor).getBoundingClientRect();
              forEach(['width', 'height', 'top', 'left'], function(key) {
                var value = coords[key];
                switch (key) {
                  case 'top':
                    value += bodyNode.scrollTop;
                    break;
                  case 'left':
                    value += bodyNode.scrollLeft;
                    break;
                }
                styles[key] = Math.floor(value) + 'px';
              });
              return styles;
            }
            function prepareOutAnimation() {
              var animator = $animateCss(clone, {
                addClass: NG_OUT_ANCHOR_CLASS_NAME,
                delay: true,
                from: calculateAnchorStyles(outAnchor)
              });
              return animator.$$willAnimate ? animator : null;
            }
            function getClassVal(element) {
              return element.attr('class') || '';
            }
            function prepareInAnimation() {
              var endingClasses = filterCssClasses(getClassVal(inAnchor));
              var toAdd = getUniqueValues(endingClasses, startingClasses);
              var toRemove = getUniqueValues(startingClasses, endingClasses);
              var animator = $animateCss(clone, {
                to: calculateAnchorStyles(inAnchor),
                addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,
                removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,
                delay: true
              });
              return animator.$$willAnimate ? animator : null;
            }
            function end() {
              clone.remove();
              outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
              inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
            }
          }
          function prepareFromToAnchorAnimation(from, to, classes, anchors) {
            var fromAnimation = prepareRegularAnimation(from, noop);
            var toAnimation = prepareRegularAnimation(to, noop);
            var anchorAnimations = [];
            forEach(anchors, function(anchor) {
              var outElement = anchor['out'];
              var inElement = anchor['in'];
              var animator = prepareAnchoredAnimation(classes, outElement, inElement);
              if (animator) {
                anchorAnimations.push(animator);
              }
            });
            if (!fromAnimation && !toAnimation && anchorAnimations.length === 0)
              return;
            return {start: function() {
                var animationRunners = [];
                if (fromAnimation) {
                  animationRunners.push(fromAnimation.start());
                }
                if (toAnimation) {
                  animationRunners.push(toAnimation.start());
                }
                forEach(anchorAnimations, function(animation) {
                  animationRunners.push(animation.start());
                });
                var runner = new $$AnimateRunner({
                  end: endFn,
                  cancel: endFn
                });
                $$AnimateRunner.all(animationRunners, function(status) {
                  runner.complete(status);
                });
                return runner;
                function endFn() {
                  forEach(animationRunners, function(runner) {
                    runner.end();
                  });
                }
              }};
          }
          function prepareRegularAnimation(animationDetails) {
            var element = animationDetails.element;
            var options = animationDetails.options || {};
            if (animationDetails.structural) {
              options.event = animationDetails.event;
              options.structural = true;
              options.applyClassesEarly = true;
              if (animationDetails.event === 'leave') {
                options.onDone = options.domOperation;
              }
            }
            if (options.preparationClasses) {
              options.event = concatWithSpace(options.event, options.preparationClasses);
            }
            var animator = $animateCss(element, options);
            return animator.$$willAnimate ? animator : null;
          }
        }];
      }];
      var $$AnimateJsProvider = ['$animateProvider', function($animateProvider) {
        this.$get = ['$injector', '$$AnimateRunner', '$$jqLite', function($injector, $$AnimateRunner, $$jqLite) {
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          return function(element, event, classes, options) {
            var animationClosed = false;
            if (arguments.length === 3 && isObject(classes)) {
              options = classes;
              classes = null;
            }
            options = prepareAnimationOptions(options);
            if (!classes) {
              classes = element.attr('class') || '';
              if (options.addClass) {
                classes += ' ' + options.addClass;
              }
              if (options.removeClass) {
                classes += ' ' + options.removeClass;
              }
            }
            var classesToAdd = options.addClass;
            var classesToRemove = options.removeClass;
            var animations = lookupAnimations(classes);
            var before,
                after;
            if (animations.length) {
              var afterFn,
                  beforeFn;
              if (event == 'leave') {
                beforeFn = 'leave';
                afterFn = 'afterLeave';
              } else {
                beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);
                afterFn = event;
              }
              if (event !== 'enter' && event !== 'move') {
                before = packageAnimations(element, event, options, animations, beforeFn);
              }
              after = packageAnimations(element, event, options, animations, afterFn);
            }
            if (!before && !after)
              return;
            function applyOptions() {
              options.domOperation();
              applyAnimationClasses(element, options);
            }
            function close() {
              animationClosed = true;
              applyOptions();
              applyAnimationStyles(element, options);
            }
            var runner;
            return {
              $$willAnimate: true,
              end: function() {
                if (runner) {
                  runner.end();
                } else {
                  close();
                  runner = new $$AnimateRunner();
                  runner.complete(true);
                }
                return runner;
              },
              start: function() {
                if (runner) {
                  return runner;
                }
                runner = new $$AnimateRunner();
                var closeActiveAnimations;
                var chain = [];
                if (before) {
                  chain.push(function(fn) {
                    closeActiveAnimations = before(fn);
                  });
                }
                if (chain.length) {
                  chain.push(function(fn) {
                    applyOptions();
                    fn(true);
                  });
                } else {
                  applyOptions();
                }
                if (after) {
                  chain.push(function(fn) {
                    closeActiveAnimations = after(fn);
                  });
                }
                runner.setHost({
                  end: function() {
                    endAnimations();
                  },
                  cancel: function() {
                    endAnimations(true);
                  }
                });
                $$AnimateRunner.chain(chain, onComplete);
                return runner;
                function onComplete(success) {
                  close(success);
                  runner.complete(success);
                }
                function endAnimations(cancelled) {
                  if (!animationClosed) {
                    (closeActiveAnimations || noop)(cancelled);
                    onComplete(cancelled);
                  }
                }
              }
            };
            function executeAnimationFn(fn, element, event, options, onDone) {
              var args;
              switch (event) {
                case 'animate':
                  args = [element, options.from, options.to, onDone];
                  break;
                case 'setClass':
                  args = [element, classesToAdd, classesToRemove, onDone];
                  break;
                case 'addClass':
                  args = [element, classesToAdd, onDone];
                  break;
                case 'removeClass':
                  args = [element, classesToRemove, onDone];
                  break;
                default:
                  args = [element, onDone];
                  break;
              }
              args.push(options);
              var value = fn.apply(fn, args);
              if (value) {
                if (isFunction(value.start)) {
                  value = value.start();
                }
                if (value instanceof $$AnimateRunner) {
                  value.done(onDone);
                } else if (isFunction(value)) {
                  return value;
                }
              }
              return noop;
            }
            function groupEventedAnimations(element, event, options, animations, fnName) {
              var operations = [];
              forEach(animations, function(ani) {
                var animation = ani[fnName];
                if (!animation)
                  return;
                operations.push(function() {
                  var runner;
                  var endProgressCb;
                  var resolved = false;
                  var onAnimationComplete = function(rejected) {
                    if (!resolved) {
                      resolved = true;
                      (endProgressCb || noop)(rejected);
                      runner.complete(!rejected);
                    }
                  };
                  runner = new $$AnimateRunner({
                    end: function() {
                      onAnimationComplete();
                    },
                    cancel: function() {
                      onAnimationComplete(true);
                    }
                  });
                  endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {
                    var cancelled = result === false;
                    onAnimationComplete(cancelled);
                  });
                  return runner;
                });
              });
              return operations;
            }
            function packageAnimations(element, event, options, animations, fnName) {
              var operations = groupEventedAnimations(element, event, options, animations, fnName);
              if (operations.length === 0) {
                var a,
                    b;
                if (fnName === 'beforeSetClass') {
                  a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');
                  b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');
                } else if (fnName === 'setClass') {
                  a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');
                  b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');
                }
                if (a) {
                  operations = operations.concat(a);
                }
                if (b) {
                  operations = operations.concat(b);
                }
              }
              if (operations.length === 0)
                return;
              return function startAnimation(callback) {
                var runners = [];
                if (operations.length) {
                  forEach(operations, function(animateFn) {
                    runners.push(animateFn());
                  });
                }
                runners.length ? $$AnimateRunner.all(runners, callback) : callback();
                return function endFn(reject) {
                  forEach(runners, function(runner) {
                    reject ? runner.cancel() : runner.end();
                  });
                };
              };
            }
          };
          function lookupAnimations(classes) {
            classes = isArray(classes) ? classes : classes.split(' ');
            var matches = [],
                flagMap = {};
            for (var i = 0; i < classes.length; i++) {
              var klass = classes[i],
                  animationFactory = $animateProvider.$$registeredAnimations[klass];
              if (animationFactory && !flagMap[klass]) {
                matches.push($injector.get(animationFactory));
                flagMap[klass] = true;
              }
            }
            return matches;
          }
        }];
      }];
      var $$AnimateJsDriverProvider = ['$$animationProvider', function($$animationProvider) {
        $$animationProvider.drivers.push('$$animateJsDriver');
        this.$get = ['$$animateJs', '$$AnimateRunner', function($$animateJs, $$AnimateRunner) {
          return function initDriverFn(animationDetails) {
            if (animationDetails.from && animationDetails.to) {
              var fromAnimation = prepareAnimation(animationDetails.from);
              var toAnimation = prepareAnimation(animationDetails.to);
              if (!fromAnimation && !toAnimation)
                return;
              return {start: function() {
                  var animationRunners = [];
                  if (fromAnimation) {
                    animationRunners.push(fromAnimation.start());
                  }
                  if (toAnimation) {
                    animationRunners.push(toAnimation.start());
                  }
                  $$AnimateRunner.all(animationRunners, done);
                  var runner = new $$AnimateRunner({
                    end: endFnFactory(),
                    cancel: endFnFactory()
                  });
                  return runner;
                  function endFnFactory() {
                    return function() {
                      forEach(animationRunners, function(runner) {
                        runner.end();
                      });
                    };
                  }
                  function done(status) {
                    runner.complete(status);
                  }
                }};
            } else {
              return prepareAnimation(animationDetails);
            }
          };
          function prepareAnimation(animationDetails) {
            var element = animationDetails.element;
            var event = animationDetails.event;
            var options = animationDetails.options;
            var classes = animationDetails.classes;
            return $$animateJs(element, event, classes, options);
          }
        }];
      }];
      var NG_ANIMATE_ATTR_NAME = 'data-ng-animate';
      var NG_ANIMATE_PIN_DATA = '$ngAnimatePin';
      var $$AnimateQueueProvider = ['$animateProvider', function($animateProvider) {
        var PRE_DIGEST_STATE = 1;
        var RUNNING_STATE = 2;
        var ONE_SPACE = ' ';
        var rules = this.rules = {
          skip: [],
          cancel: [],
          join: []
        };
        function makeTruthyCssClassMap(classString) {
          if (!classString) {
            return null;
          }
          var keys = classString.split(ONE_SPACE);
          var map = Object.create(null);
          forEach(keys, function(key) {
            map[key] = true;
          });
          return map;
        }
        function hasMatchingClasses(newClassString, currentClassString) {
          if (newClassString && currentClassString) {
            var currentClassMap = makeTruthyCssClassMap(currentClassString);
            return newClassString.split(ONE_SPACE).some(function(className) {
              return currentClassMap[className];
            });
          }
        }
        function isAllowed(ruleType, element, currentAnimation, previousAnimation) {
          return rules[ruleType].some(function(fn) {
            return fn(element, currentAnimation, previousAnimation);
          });
        }
        function hasAnimationClasses(animation, and) {
          var a = (animation.addClass || '').length > 0;
          var b = (animation.removeClass || '').length > 0;
          return and ? a && b : a || b;
        }
        rules.join.push(function(element, newAnimation, currentAnimation) {
          return !newAnimation.structural && hasAnimationClasses(newAnimation);
        });
        rules.skip.push(function(element, newAnimation, currentAnimation) {
          return !newAnimation.structural && !hasAnimationClasses(newAnimation);
        });
        rules.skip.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.event == 'leave' && newAnimation.structural;
        });
        rules.skip.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;
        });
        rules.cancel.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.structural && newAnimation.structural;
        });
        rules.cancel.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.state === RUNNING_STATE && newAnimation.structural;
        });
        rules.cancel.push(function(element, newAnimation, currentAnimation) {
          if (currentAnimation.structural)
            return false;
          var nA = newAnimation.addClass;
          var nR = newAnimation.removeClass;
          var cA = currentAnimation.addClass;
          var cR = currentAnimation.removeClass;
          if ((isUndefined(nA) && isUndefined(nR)) || (isUndefined(cA) && isUndefined(cR))) {
            return false;
          }
          return hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA);
        });
        this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$HashMap', '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', '$$forceReflow', function($$rAF, $rootScope, $rootElement, $document, $$HashMap, $$animation, $$AnimateRunner, $templateRequest, $$jqLite, $$forceReflow) {
          var activeAnimationsLookup = new $$HashMap();
          var disabledElementsLookup = new $$HashMap();
          var animationsEnabled = null;
          function postDigestTaskFactory() {
            var postDigestCalled = false;
            return function(fn) {
              if (postDigestCalled) {
                fn();
              } else {
                $rootScope.$$postDigest(function() {
                  postDigestCalled = true;
                  fn();
                });
              }
            };
          }
          var deregisterWatch = $rootScope.$watch(function() {
            return $templateRequest.totalPendingRequests === 0;
          }, function(isEmpty) {
            if (!isEmpty)
              return;
            deregisterWatch();
            $rootScope.$$postDigest(function() {
              $rootScope.$$postDigest(function() {
                if (animationsEnabled === null) {
                  animationsEnabled = true;
                }
              });
            });
          });
          var callbackRegistry = {};
          var classNameFilter = $animateProvider.classNameFilter();
          var isAnimatableClassName = !classNameFilter ? function() {
            return true;
          } : function(className) {
            return classNameFilter.test(className);
          };
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          function normalizeAnimationDetails(element, animation) {
            return mergeAnimationDetails(element, animation, {});
          }
          var contains = window.Node.prototype.contains || function(arg) {
            return this === arg || !!(this.compareDocumentPosition(arg) & 16);
          };
          function findCallbacks(parent, element, event) {
            var targetNode = getDomNode(element);
            var targetParentNode = getDomNode(parent);
            var matches = [];
            var entries = callbackRegistry[event];
            if (entries) {
              forEach(entries, function(entry) {
                if (contains.call(entry.node, targetNode)) {
                  matches.push(entry.callback);
                } else if (event === 'leave' && contains.call(entry.node, targetParentNode)) {
                  matches.push(entry.callback);
                }
              });
            }
            return matches;
          }
          function filterFromRegistry(list, matchContainer, matchCallback) {
            var containerNode = extractElementNode(matchContainer);
            return list.filter(function(entry) {
              var isMatch = entry.node === containerNode && (!matchCallback || entry.callback === matchCallback);
              return !isMatch;
            });
          }
          function cleanupEventListeners(phase, element) {
            if (phase === 'close' && !element[0].parentNode) {
              $animate.off(element);
            }
          }
          var $animate = {
            on: function(event, container, callback) {
              var node = extractElementNode(container);
              callbackRegistry[event] = callbackRegistry[event] || [];
              callbackRegistry[event].push({
                node: node,
                callback: callback
              });
              jqLite(container).on('$destroy', function() {
                var animationDetails = activeAnimationsLookup.get(node);
                if (!animationDetails) {
                  $animate.off(event, container, callback);
                }
              });
            },
            off: function(event, container, callback) {
              if (arguments.length === 1 && !angular.isString(arguments[0])) {
                container = arguments[0];
                for (var eventType in callbackRegistry) {
                  callbackRegistry[eventType] = filterFromRegistry(callbackRegistry[eventType], container);
                }
                return;
              }
              var entries = callbackRegistry[event];
              if (!entries)
                return;
              callbackRegistry[event] = arguments.length === 1 ? null : filterFromRegistry(entries, container, callback);
            },
            pin: function(element, parentElement) {
              assertArg(isElement(element), 'element', 'not an element');
              assertArg(isElement(parentElement), 'parentElement', 'not an element');
              element.data(NG_ANIMATE_PIN_DATA, parentElement);
            },
            push: function(element, event, options, domOperation) {
              options = options || {};
              options.domOperation = domOperation;
              return queueAnimation(element, event, options);
            },
            enabled: function(element, bool) {
              var argCount = arguments.length;
              if (argCount === 0) {
                bool = !!animationsEnabled;
              } else {
                var hasElement = isElement(element);
                if (!hasElement) {
                  bool = animationsEnabled = !!element;
                } else {
                  var node = getDomNode(element);
                  var recordExists = disabledElementsLookup.get(node);
                  if (argCount === 1) {
                    bool = !recordExists;
                  } else {
                    disabledElementsLookup.put(node, !bool);
                  }
                }
              }
              return bool;
            }
          };
          return $animate;
          function queueAnimation(element, event, initialOptions) {
            var options = copy(initialOptions);
            var node,
                parent;
            element = stripCommentsFromElement(element);
            if (element) {
              node = getDomNode(element);
              parent = element.parent();
            }
            options = prepareAnimationOptions(options);
            var runner = new $$AnimateRunner();
            var runInNextPostDigestOrNow = postDigestTaskFactory();
            if (isArray(options.addClass)) {
              options.addClass = options.addClass.join(' ');
            }
            if (options.addClass && !isString(options.addClass)) {
              options.addClass = null;
            }
            if (isArray(options.removeClass)) {
              options.removeClass = options.removeClass.join(' ');
            }
            if (options.removeClass && !isString(options.removeClass)) {
              options.removeClass = null;
            }
            if (options.from && !isObject(options.from)) {
              options.from = null;
            }
            if (options.to && !isObject(options.to)) {
              options.to = null;
            }
            if (!node) {
              close();
              return runner;
            }
            var className = [node.className, options.addClass, options.removeClass].join(' ');
            if (!isAnimatableClassName(className)) {
              close();
              return runner;
            }
            var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;
            var documentHidden = $document[0].hidden;
            var skipAnimations = !animationsEnabled || documentHidden || disabledElementsLookup.get(node);
            var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};
            var hasExistingAnimation = !!existingAnimation.state;
            if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state != PRE_DIGEST_STATE)) {
              skipAnimations = !areAnimationsAllowed(element, parent, event);
            }
            if (skipAnimations) {
              if (documentHidden)
                notifyProgress(runner, event, 'start');
              close();
              if (documentHidden)
                notifyProgress(runner, event, 'close');
              return runner;
            }
            if (isStructural) {
              closeChildAnimations(element);
            }
            var newAnimation = {
              structural: isStructural,
              element: element,
              event: event,
              addClass: options.addClass,
              removeClass: options.removeClass,
              close: close,
              options: options,
              runner: runner
            };
            if (hasExistingAnimation) {
              var skipAnimationFlag = isAllowed('skip', element, newAnimation, existingAnimation);
              if (skipAnimationFlag) {
                if (existingAnimation.state === RUNNING_STATE) {
                  close();
                  return runner;
                } else {
                  mergeAnimationDetails(element, existingAnimation, newAnimation);
                  return existingAnimation.runner;
                }
              }
              var cancelAnimationFlag = isAllowed('cancel', element, newAnimation, existingAnimation);
              if (cancelAnimationFlag) {
                if (existingAnimation.state === RUNNING_STATE) {
                  existingAnimation.runner.end();
                } else if (existingAnimation.structural) {
                  existingAnimation.close();
                } else {
                  mergeAnimationDetails(element, existingAnimation, newAnimation);
                  return existingAnimation.runner;
                }
              } else {
                var joinAnimationFlag = isAllowed('join', element, newAnimation, existingAnimation);
                if (joinAnimationFlag) {
                  if (existingAnimation.state === RUNNING_STATE) {
                    normalizeAnimationDetails(element, newAnimation);
                  } else {
                    applyGeneratedPreparationClasses(element, isStructural ? event : null, options);
                    event = newAnimation.event = existingAnimation.event;
                    options = mergeAnimationDetails(element, existingAnimation, newAnimation);
                    return existingAnimation.runner;
                  }
                }
              }
            } else {
              normalizeAnimationDetails(element, newAnimation);
            }
            var isValidAnimation = newAnimation.structural;
            if (!isValidAnimation) {
              isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0) || hasAnimationClasses(newAnimation);
            }
            if (!isValidAnimation) {
              close();
              clearElementAnimationState(element);
              return runner;
            }
            var counter = (existingAnimation.counter || 0) + 1;
            newAnimation.counter = counter;
            markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);
            $rootScope.$$postDigest(function() {
              var animationDetails = activeAnimationsLookup.get(node);
              var animationCancelled = !animationDetails;
              animationDetails = animationDetails || {};
              var parentElement = element.parent() || [];
              var isValidAnimation = parentElement.length > 0 && (animationDetails.event === 'animate' || animationDetails.structural || hasAnimationClasses(animationDetails));
              if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {
                if (animationCancelled) {
                  applyAnimationClasses(element, options);
                  applyAnimationStyles(element, options);
                }
                if (animationCancelled || (isStructural && animationDetails.event !== event)) {
                  options.domOperation();
                  runner.end();
                }
                if (!isValidAnimation) {
                  clearElementAnimationState(element);
                }
                return;
              }
              event = !animationDetails.structural && hasAnimationClasses(animationDetails, true) ? 'setClass' : animationDetails.event;
              markElementAnimationState(element, RUNNING_STATE);
              var realRunner = $$animation(element, event, animationDetails.options);
              runner.setHost(realRunner);
              notifyProgress(runner, event, 'start', {});
              realRunner.done(function(status) {
                close(!status);
                var animationDetails = activeAnimationsLookup.get(node);
                if (animationDetails && animationDetails.counter === counter) {
                  clearElementAnimationState(getDomNode(element));
                }
                notifyProgress(runner, event, 'close', {});
              });
            });
            return runner;
            function notifyProgress(runner, event, phase, data) {
              runInNextPostDigestOrNow(function() {
                var callbacks = findCallbacks(parent, element, event);
                if (callbacks.length) {
                  $$rAF(function() {
                    forEach(callbacks, function(callback) {
                      callback(element, phase, data);
                    });
                    cleanupEventListeners(phase, element);
                  });
                } else {
                  cleanupEventListeners(phase, element);
                }
              });
              runner.progress(event, phase, data);
            }
            function close(reject) {
              clearGeneratedClasses(element, options);
              applyAnimationClasses(element, options);
              applyAnimationStyles(element, options);
              options.domOperation();
              runner.complete(!reject);
            }
          }
          function closeChildAnimations(element) {
            var node = getDomNode(element);
            var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');
            forEach(children, function(child) {
              var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME));
              var animationDetails = activeAnimationsLookup.get(child);
              if (animationDetails) {
                switch (state) {
                  case RUNNING_STATE:
                    animationDetails.runner.end();
                  case PRE_DIGEST_STATE:
                    activeAnimationsLookup.remove(child);
                    break;
                }
              }
            });
          }
          function clearElementAnimationState(element) {
            var node = getDomNode(element);
            node.removeAttribute(NG_ANIMATE_ATTR_NAME);
            activeAnimationsLookup.remove(node);
          }
          function isMatchingElement(nodeOrElmA, nodeOrElmB) {
            return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);
          }
          function areAnimationsAllowed(element, parentElement, event) {
            var bodyElement = jqLite($document[0].body);
            var bodyElementDetected = isMatchingElement(element, bodyElement) || element[0].nodeName === 'HTML';
            var rootElementDetected = isMatchingElement(element, $rootElement);
            var parentAnimationDetected = false;
            var animateChildren;
            var elementDisabled = disabledElementsLookup.get(getDomNode(element));
            var parentHost = jqLite.data(element[0], NG_ANIMATE_PIN_DATA);
            if (parentHost) {
              parentElement = parentHost;
            }
            parentElement = getDomNode(parentElement);
            while (parentElement) {
              if (!rootElementDetected) {
                rootElementDetected = isMatchingElement(parentElement, $rootElement);
              }
              if (parentElement.nodeType !== ELEMENT_NODE) {
                break;
              }
              var details = activeAnimationsLookup.get(parentElement) || {};
              if (!parentAnimationDetected) {
                var parentElementDisabled = disabledElementsLookup.get(parentElement);
                if (parentElementDisabled === true && elementDisabled !== false) {
                  elementDisabled = true;
                  break;
                } else if (parentElementDisabled === false) {
                  elementDisabled = false;
                }
                parentAnimationDetected = details.structural;
              }
              if (isUndefined(animateChildren) || animateChildren === true) {
                var value = jqLite.data(parentElement, NG_ANIMATE_CHILDREN_DATA);
                if (isDefined(value)) {
                  animateChildren = value;
                }
              }
              if (parentAnimationDetected && animateChildren === false)
                break;
              if (!bodyElementDetected) {
                bodyElementDetected = isMatchingElement(parentElement, bodyElement);
              }
              if (bodyElementDetected && rootElementDetected) {
                break;
              }
              if (!rootElementDetected) {
                parentHost = jqLite.data(parentElement, NG_ANIMATE_PIN_DATA);
                if (parentHost) {
                  parentElement = getDomNode(parentHost);
                  continue;
                }
              }
              parentElement = parentElement.parentNode;
            }
            var allowAnimation = (!parentAnimationDetected || animateChildren) && elementDisabled !== true;
            return allowAnimation && rootElementDetected && bodyElementDetected;
          }
          function markElementAnimationState(element, state, details) {
            details = details || {};
            details.state = state;
            var node = getDomNode(element);
            node.setAttribute(NG_ANIMATE_ATTR_NAME, state);
            var oldValue = activeAnimationsLookup.get(node);
            var newValue = oldValue ? extend(oldValue, details) : details;
            activeAnimationsLookup.put(node, newValue);
          }
        }];
      }];
      var $$AnimationProvider = ['$animateProvider', function($animateProvider) {
        var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';
        var drivers = this.drivers = [];
        var RUNNER_STORAGE_KEY = '$$animationRunner';
        function setRunner(element, runner) {
          element.data(RUNNER_STORAGE_KEY, runner);
        }
        function removeRunner(element) {
          element.removeData(RUNNER_STORAGE_KEY);
        }
        function getRunner(element) {
          return element.data(RUNNER_STORAGE_KEY);
        }
        this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$HashMap', '$$rAFScheduler', function($$jqLite, $rootScope, $injector, $$AnimateRunner, $$HashMap, $$rAFScheduler) {
          var animationQueue = [];
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          function sortAnimations(animations) {
            var tree = {children: []};
            var i,
                lookup = new $$HashMap();
            for (i = 0; i < animations.length; i++) {
              var animation = animations[i];
              lookup.put(animation.domNode, animations[i] = {
                domNode: animation.domNode,
                fn: animation.fn,
                children: []
              });
            }
            for (i = 0; i < animations.length; i++) {
              processNode(animations[i]);
            }
            return flatten(tree);
            function processNode(entry) {
              if (entry.processed)
                return entry;
              entry.processed = true;
              var elementNode = entry.domNode;
              var parentNode = elementNode.parentNode;
              lookup.put(elementNode, entry);
              var parentEntry;
              while (parentNode) {
                parentEntry = lookup.get(parentNode);
                if (parentEntry) {
                  if (!parentEntry.processed) {
                    parentEntry = processNode(parentEntry);
                  }
                  break;
                }
                parentNode = parentNode.parentNode;
              }
              (parentEntry || tree).children.push(entry);
              return entry;
            }
            function flatten(tree) {
              var result = [];
              var queue = [];
              var i;
              for (i = 0; i < tree.children.length; i++) {
                queue.push(tree.children[i]);
              }
              var remainingLevelEntries = queue.length;
              var nextLevelEntries = 0;
              var row = [];
              for (i = 0; i < queue.length; i++) {
                var entry = queue[i];
                if (remainingLevelEntries <= 0) {
                  remainingLevelEntries = nextLevelEntries;
                  nextLevelEntries = 0;
                  result.push(row);
                  row = [];
                }
                row.push(entry.fn);
                entry.children.forEach(function(childEntry) {
                  nextLevelEntries++;
                  queue.push(childEntry);
                });
                remainingLevelEntries--;
              }
              if (row.length) {
                result.push(row);
              }
              return result;
            }
          }
          return function(element, event, options) {
            options = prepareAnimationOptions(options);
            var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;
            var runner = new $$AnimateRunner({
              end: function() {
                close();
              },
              cancel: function() {
                close(true);
              }
            });
            if (!drivers.length) {
              close();
              return runner;
            }
            setRunner(element, runner);
            var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));
            var tempClasses = options.tempClasses;
            if (tempClasses) {
              classes += ' ' + tempClasses;
              options.tempClasses = null;
            }
            var prepareClassName;
            if (isStructural) {
              prepareClassName = 'ng-' + event + PREPARE_CLASS_SUFFIX;
              $$jqLite.addClass(element, prepareClassName);
            }
            animationQueue.push({
              element: element,
              classes: classes,
              event: event,
              structural: isStructural,
              options: options,
              beforeStart: beforeStart,
              close: close
            });
            element.on('$destroy', handleDestroyedElement);
            if (animationQueue.length > 1)
              return runner;
            $rootScope.$$postDigest(function() {
              var animations = [];
              forEach(animationQueue, function(entry) {
                if (getRunner(entry.element)) {
                  animations.push(entry);
                } else {
                  entry.close();
                }
              });
              animationQueue.length = 0;
              var groupedAnimations = groupAnimations(animations);
              var toBeSortedAnimations = [];
              forEach(groupedAnimations, function(animationEntry) {
                toBeSortedAnimations.push({
                  domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),
                  fn: function triggerAnimationStart() {
                    animationEntry.beforeStart();
                    var startAnimationFn,
                        closeFn = animationEntry.close;
                    var targetElement = animationEntry.anchors ? (animationEntry.from.element || animationEntry.to.element) : animationEntry.element;
                    if (getRunner(targetElement)) {
                      var operation = invokeFirstDriver(animationEntry);
                      if (operation) {
                        startAnimationFn = operation.start;
                      }
                    }
                    if (!startAnimationFn) {
                      closeFn();
                    } else {
                      var animationRunner = startAnimationFn();
                      animationRunner.done(function(status) {
                        closeFn(!status);
                      });
                      updateAnimationRunners(animationEntry, animationRunner);
                    }
                  }
                });
              });
              $$rAFScheduler(sortAnimations(toBeSortedAnimations));
            });
            return runner;
            function getAnchorNodes(node) {
              var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';
              var items = node.hasAttribute(NG_ANIMATE_REF_ATTR) ? [node] : node.querySelectorAll(SELECTOR);
              var anchors = [];
              forEach(items, function(node) {
                var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);
                if (attr && attr.length) {
                  anchors.push(node);
                }
              });
              return anchors;
            }
            function groupAnimations(animations) {
              var preparedAnimations = [];
              var refLookup = {};
              forEach(animations, function(animation, index) {
                var element = animation.element;
                var node = getDomNode(element);
                var event = animation.event;
                var enterOrMove = ['enter', 'move'].indexOf(event) >= 0;
                var anchorNodes = animation.structural ? getAnchorNodes(node) : [];
                if (anchorNodes.length) {
                  var direction = enterOrMove ? 'to' : 'from';
                  forEach(anchorNodes, function(anchor) {
                    var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);
                    refLookup[key] = refLookup[key] || {};
                    refLookup[key][direction] = {
                      animationID: index,
                      element: jqLite(anchor)
                    };
                  });
                } else {
                  preparedAnimations.push(animation);
                }
              });
              var usedIndicesLookup = {};
              var anchorGroups = {};
              forEach(refLookup, function(operations, key) {
                var from = operations.from;
                var to = operations.to;
                if (!from || !to) {
                  var index = from ? from.animationID : to.animationID;
                  var indexKey = index.toString();
                  if (!usedIndicesLookup[indexKey]) {
                    usedIndicesLookup[indexKey] = true;
                    preparedAnimations.push(animations[index]);
                  }
                  return;
                }
                var fromAnimation = animations[from.animationID];
                var toAnimation = animations[to.animationID];
                var lookupKey = from.animationID.toString();
                if (!anchorGroups[lookupKey]) {
                  var group = anchorGroups[lookupKey] = {
                    structural: true,
                    beforeStart: function() {
                      fromAnimation.beforeStart();
                      toAnimation.beforeStart();
                    },
                    close: function() {
                      fromAnimation.close();
                      toAnimation.close();
                    },
                    classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),
                    from: fromAnimation,
                    to: toAnimation,
                    anchors: []
                  };
                  if (group.classes.length) {
                    preparedAnimations.push(group);
                  } else {
                    preparedAnimations.push(fromAnimation);
                    preparedAnimations.push(toAnimation);
                  }
                }
                anchorGroups[lookupKey].anchors.push({
                  'out': from.element,
                  'in': to.element
                });
              });
              return preparedAnimations;
            }
            function cssClassesIntersection(a, b) {
              a = a.split(' ');
              b = b.split(' ');
              var matches = [];
              for (var i = 0; i < a.length; i++) {
                var aa = a[i];
                if (aa.substring(0, 3) === 'ng-')
                  continue;
                for (var j = 0; j < b.length; j++) {
                  if (aa === b[j]) {
                    matches.push(aa);
                    break;
                  }
                }
              }
              return matches.join(' ');
            }
            function invokeFirstDriver(animationDetails) {
              for (var i = drivers.length - 1; i >= 0; i--) {
                var driverName = drivers[i];
                var factory = $injector.get(driverName);
                var driver = factory(animationDetails);
                if (driver) {
                  return driver;
                }
              }
            }
            function beforeStart() {
              element.addClass(NG_ANIMATE_CLASSNAME);
              if (tempClasses) {
                $$jqLite.addClass(element, tempClasses);
              }
              if (prepareClassName) {
                $$jqLite.removeClass(element, prepareClassName);
                prepareClassName = null;
              }
            }
            function updateAnimationRunners(animation, newRunner) {
              if (animation.from && animation.to) {
                update(animation.from.element);
                update(animation.to.element);
              } else {
                update(animation.element);
              }
              function update(element) {
                var runner = getRunner(element);
                if (runner)
                  runner.setHost(newRunner);
              }
            }
            function handleDestroyedElement() {
              var runner = getRunner(element);
              if (runner && (event !== 'leave' || !options.$$domOperationFired)) {
                runner.end();
              }
            }
            function close(rejected) {
              element.off('$destroy', handleDestroyedElement);
              removeRunner(element);
              applyAnimationClasses(element, options);
              applyAnimationStyles(element, options);
              options.domOperation();
              if (tempClasses) {
                $$jqLite.removeClass(element, tempClasses);
              }
              element.removeClass(NG_ANIMATE_CLASSNAME);
              runner.complete(!rejected);
            }
          };
        }];
      }];
      var ngAnimateSwapDirective = ['$animate', '$rootScope', function($animate, $rootScope) {
        return {
          restrict: 'A',
          transclude: 'element',
          terminal: true,
          priority: 600,
          link: function(scope, $element, attrs, ctrl, $transclude) {
            var previousElement,
                previousScope;
            scope.$watchCollection(attrs.ngAnimateSwap || attrs['for'], function(value) {
              if (previousElement) {
                $animate.leave(previousElement);
              }
              if (previousScope) {
                previousScope.$destroy();
                previousScope = null;
              }
              if (value || value === 0) {
                previousScope = scope.$new();
                $transclude(previousScope, function(element) {
                  previousElement = element;
                  $animate.enter(element, null, $element);
                });
              }
            });
          }
        };
      }];
      angular.module('ngAnimate', []).directive('ngAnimateSwap', ngAnimateSwapDirective).directive('ngAnimateChildren', $$AnimateChildrenDirective).factory('$$rAFScheduler', $$rAFSchedulerFactory).provider('$$animateQueue', $$AnimateQueueProvider).provider('$$animation', $$AnimationProvider).provider('$animateCss', $AnimateCssProvider).provider('$$animateCssDriver', $$AnimateCssDriverProvider).provider('$$animateJs', $$AnimateJsProvider).provider('$$animateJsDriver', $$AnimateJsDriverProvider);
    })(window, window.angular);
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("3c", ["3b"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('3b');
  module.exports = 'ngAnimate';
  return module.exports;
});

$__System.registerDynamic("3d", ["3c"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('3c');
  return module.exports;
});

$__System.registerDynamic("3e", ["14"], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    "format global";
    "deps angular";
    (function(window, angular) {
      'use strict';
      var $sanitizeMinErr = angular.$$minErr('$sanitize');
      function $SanitizeProvider() {
        var svgEnabled = false;
        this.$get = ['$$sanitizeUri', function($$sanitizeUri) {
          if (svgEnabled) {
            angular.extend(validElements, svgElements);
          }
          return function(html) {
            var buf = [];
            htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {
              return !/^unsafe:/.test($$sanitizeUri(uri, isImage));
            }));
            return buf.join('');
          };
        }];
        this.enableSvg = function(enableSvg) {
          if (angular.isDefined(enableSvg)) {
            svgEnabled = enableSvg;
            return this;
          } else {
            return svgEnabled;
          }
        };
      }
      function sanitizeText(chars) {
        var buf = [];
        var writer = htmlSanitizeWriter(buf, angular.noop);
        writer.chars(chars);
        return buf.join('');
      }
      var SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
          NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
      var voidElements = toMap("area,br,col,hr,img,wbr");
      var optionalEndTagBlockElements = toMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
          optionalEndTagInlineElements = toMap("rp,rt"),
          optionalEndTagElements = angular.extend({}, optionalEndTagInlineElements, optionalEndTagBlockElements);
      var blockElements = angular.extend({}, optionalEndTagBlockElements, toMap("address,article," + "aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5," + "h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,section,table,ul"));
      var inlineElements = angular.extend({}, optionalEndTagInlineElements, toMap("a,abbr,acronym,b," + "bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s," + "samp,small,span,strike,strong,sub,sup,time,tt,u,var"));
      var svgElements = toMap("circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph," + "hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline," + "radialGradient,rect,stop,svg,switch,text,title,tspan");
      var blockedElements = toMap("script,style");
      var validElements = angular.extend({}, voidElements, blockElements, inlineElements, optionalEndTagElements);
      var uriAttrs = toMap("background,cite,href,longdesc,src,xlink:href");
      var htmlAttrs = toMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' + 'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' + 'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' + 'scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,' + 'valign,value,vspace,width');
      var svgAttrs = toMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' + 'baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,' + 'cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,' + 'font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,' + 'height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,' + 'marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,' + 'max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,' + 'path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,' + 'requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,' + 'stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,' + 'stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,' + 'stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,' + 'underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,' + 'width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,' + 'xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan', true);
      var validAttrs = angular.extend({}, uriAttrs, svgAttrs, htmlAttrs);
      function toMap(str, lowercaseKeys) {
        var obj = {},
            items = str.split(','),
            i;
        for (i = 0; i < items.length; i++) {
          obj[lowercaseKeys ? angular.lowercase(items[i]) : items[i]] = true;
        }
        return obj;
      }
      var inertBodyElement;
      (function(window) {
        var doc;
        if (window.document && window.document.implementation) {
          doc = window.document.implementation.createHTMLDocument("inert");
        } else {
          throw $sanitizeMinErr('noinert', "Can't create an inert html document");
        }
        var docElement = doc.documentElement || doc.getDocumentElement();
        var bodyElements = docElement.getElementsByTagName('body');
        if (bodyElements.length === 1) {
          inertBodyElement = bodyElements[0];
        } else {
          var html = doc.createElement('html');
          inertBodyElement = doc.createElement('body');
          html.appendChild(inertBodyElement);
          doc.appendChild(html);
        }
      })(window);
      function htmlParser(html, handler) {
        if (html === null || html === undefined) {
          html = '';
        } else if (typeof html !== 'string') {
          html = '' + html;
        }
        inertBodyElement.innerHTML = html;
        var mXSSAttempts = 5;
        do {
          if (mXSSAttempts === 0) {
            throw $sanitizeMinErr('uinput', "Failed to sanitize html because the input is unstable");
          }
          mXSSAttempts--;
          if (window.document.documentMode) {
            stripCustomNsAttrs(inertBodyElement);
          }
          html = inertBodyElement.innerHTML;
          inertBodyElement.innerHTML = html;
        } while (html !== inertBodyElement.innerHTML);
        var node = inertBodyElement.firstChild;
        while (node) {
          switch (node.nodeType) {
            case 1:
              handler.start(node.nodeName.toLowerCase(), attrToMap(node.attributes));
              break;
            case 3:
              handler.chars(node.textContent);
              break;
          }
          var nextNode;
          if (!(nextNode = node.firstChild)) {
            if (node.nodeType == 1) {
              handler.end(node.nodeName.toLowerCase());
            }
            nextNode = node.nextSibling;
            if (!nextNode) {
              while (nextNode == null) {
                node = node.parentNode;
                if (node === inertBodyElement)
                  break;
                nextNode = node.nextSibling;
                if (node.nodeType == 1) {
                  handler.end(node.nodeName.toLowerCase());
                }
              }
            }
          }
          node = nextNode;
        }
        while (node = inertBodyElement.firstChild) {
          inertBodyElement.removeChild(node);
        }
      }
      function attrToMap(attrs) {
        var map = {};
        for (var i = 0,
            ii = attrs.length; i < ii; i++) {
          var attr = attrs[i];
          map[attr.name] = attr.value;
        }
        return map;
      }
      function encodeEntities(value) {
        return value.replace(/&/g, '&amp;').replace(SURROGATE_PAIR_REGEXP, function(value) {
          var hi = value.charCodeAt(0);
          var low = value.charCodeAt(1);
          return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';
        }).replace(NON_ALPHANUMERIC_REGEXP, function(value) {
          return '&#' + value.charCodeAt(0) + ';';
        }).replace(/</g, '&lt;').replace(/>/g, '&gt;');
      }
      function htmlSanitizeWriter(buf, uriValidator) {
        var ignoreCurrentElement = false;
        var out = angular.bind(buf, buf.push);
        return {
          start: function(tag, attrs) {
            tag = angular.lowercase(tag);
            if (!ignoreCurrentElement && blockedElements[tag]) {
              ignoreCurrentElement = tag;
            }
            if (!ignoreCurrentElement && validElements[tag] === true) {
              out('<');
              out(tag);
              angular.forEach(attrs, function(value, key) {
                var lkey = angular.lowercase(key);
                var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');
                if (validAttrs[lkey] === true && (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {
                  out(' ');
                  out(key);
                  out('="');
                  out(encodeEntities(value));
                  out('"');
                }
              });
              out('>');
            }
          },
          end: function(tag) {
            tag = angular.lowercase(tag);
            if (!ignoreCurrentElement && validElements[tag] === true && voidElements[tag] !== true) {
              out('</');
              out(tag);
              out('>');
            }
            if (tag == ignoreCurrentElement) {
              ignoreCurrentElement = false;
            }
          },
          chars: function(chars) {
            if (!ignoreCurrentElement) {
              out(encodeEntities(chars));
            }
          }
        };
      }
      function stripCustomNsAttrs(node) {
        if (node.nodeType === window.Node.ELEMENT_NODE) {
          var attrs = node.attributes;
          for (var i = 0,
              l = attrs.length; i < l; i++) {
            var attrNode = attrs[i];
            var attrName = attrNode.name.toLowerCase();
            if (attrName === 'xmlns:ns1' || attrName.lastIndexOf('ns1:', 0) === 0) {
              node.removeAttributeNode(attrNode);
              i--;
              l--;
            }
          }
        }
        var nextNode = node.firstChild;
        if (nextNode) {
          stripCustomNsAttrs(nextNode);
        }
        nextNode = node.nextSibling;
        if (nextNode) {
          stripCustomNsAttrs(nextNode);
        }
      }
      angular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);
      angular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {
        var LINKY_URL_REGEXP = /((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"\u201d\u2019]/i,
            MAILTO_REGEXP = /^mailto:/i;
        var linkyMinErr = angular.$$minErr('linky');
        var isString = angular.isString;
        return function(text, target, attributes) {
          if (text == null || text === '')
            return text;
          if (!isString(text))
            throw linkyMinErr('notstring', 'Expected string but received: {0}', text);
          var attributesFn = angular.isFunction(attributes) ? attributes : angular.isObject(attributes) ? function getAttributesObject() {
            return attributes;
          } : function getEmptyAttributesObject() {
            return {};
          };
          var match;
          var raw = text;
          var html = [];
          var url;
          var i;
          while ((match = raw.match(LINKY_URL_REGEXP))) {
            url = match[0];
            if (!match[2] && !match[4]) {
              url = (match[3] ? 'http://' : 'mailto:') + url;
            }
            i = match.index;
            addText(raw.substr(0, i));
            addLink(url, match[0].replace(MAILTO_REGEXP, ''));
            raw = raw.substring(i + match[0].length);
          }
          addText(raw);
          return $sanitize(html.join(''));
          function addText(text) {
            if (!text) {
              return;
            }
            html.push(sanitizeText(text));
          }
          function addLink(url, text) {
            var key,
                linkAttributes = attributesFn(url);
            html.push('<a ');
            for (key in linkAttributes) {
              html.push(key + '="' + linkAttributes[key] + '" ');
            }
            if (angular.isDefined(target) && !('target' in linkAttributes)) {
              html.push('target="', target, '" ');
            }
            html.push('href="', url.replace(/"/g, '&quot;'), '">');
            addText(text);
            html.push('</a>');
          }
        };
      }]);
    })(window, window.angular);
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("3f", ["3e"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('3e');
  module.exports = 'ngSanitize';
  return module.exports;
});

$__System.registerDynamic("40", ["3f"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('3f');
  return module.exports;
});

$__System.registerDynamic("41", ["14"], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    "format global";
    "deps angular";
    (function(window, angular) {
      'use strict';
      var isArray = angular.isArray;
      var forEach = angular.forEach;
      var isString = angular.isString;
      var jqLite = angular.element;
      angular.module('ngMessages', []).directive('ngMessages', ['$animate', function($animate) {
        var ACTIVE_CLASS = 'ng-active';
        var INACTIVE_CLASS = 'ng-inactive';
        return {
          require: 'ngMessages',
          restrict: 'AE',
          controller: ['$element', '$scope', '$attrs', function($element, $scope, $attrs) {
            var ctrl = this;
            var latestKey = 0;
            var nextAttachId = 0;
            this.getAttachId = function getAttachId() {
              return nextAttachId++;
            };
            var messages = this.messages = {};
            var renderLater,
                cachedCollection;
            this.render = function(collection) {
              collection = collection || {};
              renderLater = false;
              cachedCollection = collection;
              var multiple = isAttrTruthy($scope, $attrs.ngMessagesMultiple) || isAttrTruthy($scope, $attrs.multiple);
              var unmatchedMessages = [];
              var matchedKeys = {};
              var messageItem = ctrl.head;
              var messageFound = false;
              var totalMessages = 0;
              while (messageItem != null) {
                totalMessages++;
                var messageCtrl = messageItem.message;
                var messageUsed = false;
                if (!messageFound) {
                  forEach(collection, function(value, key) {
                    if (!messageUsed && truthy(value) && messageCtrl.test(key)) {
                      if (matchedKeys[key])
                        return;
                      matchedKeys[key] = true;
                      messageUsed = true;
                      messageCtrl.attach();
                    }
                  });
                }
                if (messageUsed) {
                  messageFound = !multiple;
                } else {
                  unmatchedMessages.push(messageCtrl);
                }
                messageItem = messageItem.next;
              }
              forEach(unmatchedMessages, function(messageCtrl) {
                messageCtrl.detach();
              });
              unmatchedMessages.length !== totalMessages ? $animate.setClass($element, ACTIVE_CLASS, INACTIVE_CLASS) : $animate.setClass($element, INACTIVE_CLASS, ACTIVE_CLASS);
            };
            $scope.$watchCollection($attrs.ngMessages || $attrs['for'], ctrl.render);
            $element.on('$destroy', function() {
              forEach(messages, function(item) {
                item.message.detach();
              });
            });
            this.reRender = function() {
              if (!renderLater) {
                renderLater = true;
                $scope.$evalAsync(function() {
                  if (renderLater) {
                    cachedCollection && ctrl.render(cachedCollection);
                  }
                });
              }
            };
            this.register = function(comment, messageCtrl) {
              var nextKey = latestKey.toString();
              messages[nextKey] = {message: messageCtrl};
              insertMessageNode($element[0], comment, nextKey);
              comment.$$ngMessageNode = nextKey;
              latestKey++;
              ctrl.reRender();
            };
            this.deregister = function(comment) {
              var key = comment.$$ngMessageNode;
              delete comment.$$ngMessageNode;
              removeMessageNode($element[0], comment, key);
              delete messages[key];
              ctrl.reRender();
            };
            function findPreviousMessage(parent, comment) {
              var prevNode = comment;
              var parentLookup = [];
              while (prevNode && prevNode !== parent) {
                var prevKey = prevNode.$$ngMessageNode;
                if (prevKey && prevKey.length) {
                  return messages[prevKey];
                }
                if (prevNode.childNodes.length && parentLookup.indexOf(prevNode) === -1) {
                  parentLookup.push(prevNode);
                  prevNode = prevNode.childNodes[prevNode.childNodes.length - 1];
                } else if (prevNode.previousSibling) {
                  prevNode = prevNode.previousSibling;
                } else {
                  prevNode = prevNode.parentNode;
                  parentLookup.push(prevNode);
                }
              }
            }
            function insertMessageNode(parent, comment, key) {
              var messageNode = messages[key];
              if (!ctrl.head) {
                ctrl.head = messageNode;
              } else {
                var match = findPreviousMessage(parent, comment);
                if (match) {
                  messageNode.next = match.next;
                  match.next = messageNode;
                } else {
                  messageNode.next = ctrl.head;
                  ctrl.head = messageNode;
                }
              }
            }
            function removeMessageNode(parent, comment, key) {
              var messageNode = messages[key];
              var match = findPreviousMessage(parent, comment);
              if (match) {
                match.next = messageNode.next;
              } else {
                ctrl.head = messageNode.next;
              }
            }
          }]
        };
        function isAttrTruthy(scope, attr) {
          return (isString(attr) && attr.length === 0) || truthy(scope.$eval(attr));
        }
        function truthy(val) {
          return isString(val) ? val.length : !!val;
        }
      }]).directive('ngMessagesInclude', ['$templateRequest', '$document', '$compile', function($templateRequest, $document, $compile) {
        return {
          restrict: 'AE',
          require: '^^ngMessages',
          link: function($scope, element, attrs) {
            var src = attrs.ngMessagesInclude || attrs.src;
            $templateRequest(src).then(function(html) {
              if ($scope.$$destroyed)
                return;
              if (isString(html) && !html.trim()) {
                replaceElementWithMarker(element, src);
              } else {
                $compile(html)($scope, function(contents) {
                  element.after(contents);
                  replaceElementWithMarker(element, src);
                });
              }
            });
          }
        };
        function replaceElementWithMarker(element, src) {
          var comment = $compile.$$createComment ? $compile.$$createComment('ngMessagesInclude', src) : $document[0].createComment(' ngMessagesInclude: ' + src + ' ');
          var marker = jqLite(comment);
          element.after(marker);
          element.remove();
        }
      }]).directive('ngMessage', ngMessageDirectiveFactory()).directive('ngMessageExp', ngMessageDirectiveFactory());
      function ngMessageDirectiveFactory() {
        return ['$animate', function($animate) {
          return {
            restrict: 'AE',
            transclude: 'element',
            priority: 1,
            terminal: true,
            require: '^^ngMessages',
            link: function(scope, element, attrs, ngMessagesCtrl, $transclude) {
              var commentNode = element[0];
              var records;
              var staticExp = attrs.ngMessage || attrs.when;
              var dynamicExp = attrs.ngMessageExp || attrs.whenExp;
              var assignRecords = function(items) {
                records = items ? (isArray(items) ? items : items.split(/[\s,]+/)) : null;
                ngMessagesCtrl.reRender();
              };
              if (dynamicExp) {
                assignRecords(scope.$eval(dynamicExp));
                scope.$watchCollection(dynamicExp, assignRecords);
              } else {
                assignRecords(staticExp);
              }
              var currentElement,
                  messageCtrl;
              ngMessagesCtrl.register(commentNode, messageCtrl = {
                test: function(name) {
                  return contains(records, name);
                },
                attach: function() {
                  if (!currentElement) {
                    $transclude(function(elm, newScope) {
                      $animate.enter(elm, null, element);
                      currentElement = elm;
                      var $$attachId = currentElement.$$attachId = ngMessagesCtrl.getAttachId();
                      currentElement.on('$destroy', function() {
                        if (currentElement && currentElement.$$attachId === $$attachId) {
                          ngMessagesCtrl.deregister(commentNode);
                          messageCtrl.detach();
                        }
                        newScope.$destroy();
                      });
                    });
                  }
                },
                detach: function() {
                  if (currentElement) {
                    var elm = currentElement;
                    currentElement = null;
                    $animate.leave(elm);
                  }
                }
              });
            }
          };
        }];
        function contains(collection, key) {
          if (collection) {
            return isArray(collection) ? collection.indexOf(key) >= 0 : collection.hasOwnProperty(key);
          }
        }
      }
    })(window, window.angular);
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("42", ["41"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('41');
  module.exports = 'ngMessages';
  return module.exports;
});

$__System.registerDynamic("43", ["42"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('42');
  return module.exports;
});

$__System.registerDynamic("44", ["28"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  (function(process) {
    if (typeof module !== "undefined" && typeof exports !== "undefined" && module.exports === exports) {
      module.exports = 'ui.router';
    }
    (function(window, angular, undefined) {
      'use strict';
      var isDefined = angular.isDefined,
          isFunction = angular.isFunction,
          isString = angular.isString,
          isObject = angular.isObject,
          isArray = angular.isArray,
          forEach = angular.forEach,
          extend = angular.extend,
          copy = angular.copy,
          toJson = angular.toJson;
      function inherit(parent, extra) {
        return extend(new (extend(function() {}, {prototype: parent}))(), extra);
      }
      function merge(dst) {
        forEach(arguments, function(obj) {
          if (obj !== dst) {
            forEach(obj, function(value, key) {
              if (!dst.hasOwnProperty(key))
                dst[key] = value;
            });
          }
        });
        return dst;
      }
      function ancestors(first, second) {
        var path = [];
        for (var n in first.path) {
          if (first.path[n] !== second.path[n])
            break;
          path.push(first.path[n]);
        }
        return path;
      }
      function objectKeys(object) {
        if (Object.keys) {
          return Object.keys(object);
        }
        var result = [];
        forEach(object, function(val, key) {
          result.push(key);
        });
        return result;
      }
      function indexOf(array, value) {
        if (Array.prototype.indexOf) {
          return array.indexOf(value, Number(arguments[2]) || 0);
        }
        var len = array.length >>> 0,
            from = Number(arguments[2]) || 0;
        from = (from < 0) ? Math.ceil(from) : Math.floor(from);
        if (from < 0)
          from += len;
        for (; from < len; from++) {
          if (from in array && array[from] === value)
            return from;
        }
        return -1;
      }
      function inheritParams(currentParams, newParams, $current, $to) {
        var parents = ancestors($current, $to),
            parentParams,
            inherited = {},
            inheritList = [];
        for (var i in parents) {
          if (!parents[i] || !parents[i].params)
            continue;
          parentParams = objectKeys(parents[i].params);
          if (!parentParams.length)
            continue;
          for (var j in parentParams) {
            if (indexOf(inheritList, parentParams[j]) >= 0)
              continue;
            inheritList.push(parentParams[j]);
            inherited[parentParams[j]] = currentParams[parentParams[j]];
          }
        }
        return extend({}, inherited, newParams);
      }
      function equalForKeys(a, b, keys) {
        if (!keys) {
          keys = [];
          for (var n in a)
            keys.push(n);
        }
        for (var i = 0; i < keys.length; i++) {
          var k = keys[i];
          if (a[k] != b[k])
            return false;
        }
        return true;
      }
      function filterByKeys(keys, values) {
        var filtered = {};
        forEach(keys, function(name) {
          filtered[name] = values[name];
        });
        return filtered;
      }
      function indexBy(array, propName) {
        var result = {};
        forEach(array, function(item) {
          result[item[propName]] = item;
        });
        return result;
      }
      function pick(obj) {
        var copy = {};
        var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        forEach(keys, function(key) {
          if (key in obj)
            copy[key] = obj[key];
        });
        return copy;
      }
      function omit(obj) {
        var copy = {};
        var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        for (var key in obj) {
          if (indexOf(keys, key) == -1)
            copy[key] = obj[key];
        }
        return copy;
      }
      function pluck(collection, key) {
        var result = isArray(collection) ? [] : {};
        forEach(collection, function(val, i) {
          result[i] = isFunction(key) ? key(val) : val[key];
        });
        return result;
      }
      function filter(collection, callback) {
        var array = isArray(collection);
        var result = array ? [] : {};
        forEach(collection, function(val, i) {
          if (callback(val, i)) {
            result[array ? result.length : i] = val;
          }
        });
        return result;
      }
      function map(collection, callback) {
        var result = isArray(collection) ? [] : {};
        forEach(collection, function(val, i) {
          result[i] = callback(val, i);
        });
        return result;
      }
      angular.module('ui.router.util', ['ng']);
      angular.module('ui.router.router', ['ui.router.util']);
      angular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);
      angular.module('ui.router', ['ui.router.state']);
      angular.module('ui.router.compat', ['ui.router']);
      $Resolve.$inject = ['$q', '$injector'];
      function $Resolve($q, $injector) {
        var VISIT_IN_PROGRESS = 1,
            VISIT_DONE = 2,
            NOTHING = {},
            NO_DEPENDENCIES = [],
            NO_LOCALS = NOTHING,
            NO_PARENT = extend($q.when(NOTHING), {
              $$promises: NOTHING,
              $$values: NOTHING
            });
        this.study = function(invocables) {
          if (!isObject(invocables))
            throw new Error("'invocables' must be an object");
          var invocableKeys = objectKeys(invocables || {});
          var plan = [],
              cycle = [],
              visited = {};
          function visit(value, key) {
            if (visited[key] === VISIT_DONE)
              return;
            cycle.push(key);
            if (visited[key] === VISIT_IN_PROGRESS) {
              cycle.splice(0, indexOf(cycle, key));
              throw new Error("Cyclic dependency: " + cycle.join(" -> "));
            }
            visited[key] = VISIT_IN_PROGRESS;
            if (isString(value)) {
              plan.push(key, [function() {
                return $injector.get(value);
              }], NO_DEPENDENCIES);
            } else {
              var params = $injector.annotate(value);
              forEach(params, function(param) {
                if (param !== key && invocables.hasOwnProperty(param))
                  visit(invocables[param], param);
              });
              plan.push(key, value, params);
            }
            cycle.pop();
            visited[key] = VISIT_DONE;
          }
          forEach(invocables, visit);
          invocables = cycle = visited = null;
          function isResolve(value) {
            return isObject(value) && value.then && value.$$promises;
          }
          return function(locals, parent, self) {
            if (isResolve(locals) && self === undefined) {
              self = parent;
              parent = locals;
              locals = null;
            }
            if (!locals)
              locals = NO_LOCALS;
            else if (!isObject(locals)) {
              throw new Error("'locals' must be an object");
            }
            if (!parent)
              parent = NO_PARENT;
            else if (!isResolve(parent)) {
              throw new Error("'parent' must be a promise returned by $resolve.resolve()");
            }
            var resolution = $q.defer(),
                result = resolution.promise,
                promises = result.$$promises = {},
                values = extend({}, locals),
                wait = 1 + plan.length / 3,
                merged = false;
            function done() {
              if (!--wait) {
                if (!merged)
                  merge(values, parent.$$values);
                result.$$values = values;
                result.$$promises = result.$$promises || true;
                delete result.$$inheritedValues;
                resolution.resolve(values);
              }
            }
            function fail(reason) {
              result.$$failure = reason;
              resolution.reject(reason);
            }
            if (isDefined(parent.$$failure)) {
              fail(parent.$$failure);
              return result;
            }
            if (parent.$$inheritedValues) {
              merge(values, omit(parent.$$inheritedValues, invocableKeys));
            }
            extend(promises, parent.$$promises);
            if (parent.$$values) {
              merged = merge(values, omit(parent.$$values, invocableKeys));
              result.$$inheritedValues = omit(parent.$$values, invocableKeys);
              done();
            } else {
              if (parent.$$inheritedValues) {
                result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);
              }
              parent.then(done, fail);
            }
            for (var i = 0,
                ii = plan.length; i < ii; i += 3) {
              if (locals.hasOwnProperty(plan[i]))
                done();
              else
                invoke(plan[i], plan[i + 1], plan[i + 2]);
            }
            function invoke(key, invocable, params) {
              var invocation = $q.defer(),
                  waitParams = 0;
              function onfailure(reason) {
                invocation.reject(reason);
                fail(reason);
              }
              forEach(params, function(dep) {
                if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {
                  waitParams++;
                  promises[dep].then(function(result) {
                    values[dep] = result;
                    if (!(--waitParams))
                      proceed();
                  }, onfailure);
                }
              });
              if (!waitParams)
                proceed();
              function proceed() {
                if (isDefined(result.$$failure))
                  return;
                try {
                  invocation.resolve($injector.invoke(invocable, self, values));
                  invocation.promise.then(function(result) {
                    values[key] = result;
                    done();
                  }, onfailure);
                } catch (e) {
                  onfailure(e);
                }
              }
              promises[key] = invocation.promise;
            }
            return result;
          };
        };
        this.resolve = function(invocables, locals, parent, self) {
          return this.study(invocables)(locals, parent, self);
        };
      }
      angular.module('ui.router.util').service('$resolve', $Resolve);
      $TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];
      function $TemplateFactory($http, $templateCache, $injector) {
        this.fromConfig = function(config, params, locals) {
          return (isDefined(config.template) ? this.fromString(config.template, params) : isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) : isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) : null);
        };
        this.fromString = function(template, params) {
          return isFunction(template) ? template(params) : template;
        };
        this.fromUrl = function(url, params) {
          if (isFunction(url))
            url = url(params);
          if (url == null)
            return null;
          else
            return $http.get(url, {
              cache: $templateCache,
              headers: {Accept: 'text/html'}
            }).then(function(response) {
              return response.data;
            });
        };
        this.fromProvider = function(provider, params, locals) {
          return $injector.invoke(provider, null, locals || {params: params});
        };
      }
      angular.module('ui.router.util').service('$templateFactory', $TemplateFactory);
      var $$UMFP;
      function UrlMatcher(pattern, config, parentMatcher) {
        config = extend({params: {}}, isObject(config) ? config : {});
        var placeholder = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
            searchPlaceholder = /([:]?)([\w\[\].-]+)|\{([\w\[\].-]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
            compiled = '^',
            last = 0,
            m,
            segments = this.segments = [],
            parentParams = parentMatcher ? parentMatcher.params : {},
            params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),
            paramNames = [];
        function addParameter(id, type, config, location) {
          paramNames.push(id);
          if (parentParams[id])
            return parentParams[id];
          if (!/^\w+([-.]+\w+)*(?:\[\])?$/.test(id))
            throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
          if (params[id])
            throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
          params[id] = new $$UMFP.Param(id, type, config, location);
          return params[id];
        }
        function quoteRegExp(string, pattern, squash, optional) {
          var surroundPattern = ['', ''],
              result = string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
          if (!pattern)
            return result;
          switch (squash) {
            case false:
              surroundPattern = ['(', ')' + (optional ? "?" : "")];
              break;
            case true:
              result = result.replace(/\/$/, '');
              surroundPattern = ['(?:\/(', ')|\/)?'];
              break;
            default:
              surroundPattern = ['(' + squash + "|", ')?'];
              break;
          }
          return result + surroundPattern[0] + pattern + surroundPattern[1];
        }
        this.source = pattern;
        function matchDetails(m, isSearch) {
          var id,
              regexp,
              segment,
              type,
              cfg,
              arrayMode;
          id = m[2] || m[3];
          cfg = config.params[id];
          segment = pattern.substring(last, m.index);
          regexp = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);
          if (regexp) {
            type = $$UMFP.type(regexp) || inherit($$UMFP.type("string"), {pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined)});
          }
          return {
            id: id,
            regexp: regexp,
            segment: segment,
            type: type,
            cfg: cfg
          };
        }
        var p,
            param,
            segment;
        while ((m = placeholder.exec(pattern))) {
          p = matchDetails(m, false);
          if (p.segment.indexOf('?') >= 0)
            break;
          param = addParameter(p.id, p.type, p.cfg, "path");
          compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);
          segments.push(p.segment);
          last = placeholder.lastIndex;
        }
        segment = pattern.substring(last);
        var i = segment.indexOf('?');
        if (i >= 0) {
          var search = this.sourceSearch = segment.substring(i);
          segment = segment.substring(0, i);
          this.sourcePath = pattern.substring(0, last + i);
          if (search.length > 0) {
            last = 0;
            while ((m = searchPlaceholder.exec(search))) {
              p = matchDetails(m, true);
              param = addParameter(p.id, p.type, p.cfg, "search");
              last = placeholder.lastIndex;
            }
          }
        } else {
          this.sourcePath = pattern;
          this.sourceSearch = '';
        }
        compiled += quoteRegExp(segment) + (config.strict === false ? '\/?' : '') + '$';
        segments.push(segment);
        this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);
        this.prefix = segments[0];
        this.$$paramNames = paramNames;
      }
      UrlMatcher.prototype.concat = function(pattern, config) {
        var defaultConfig = {
          caseInsensitive: $$UMFP.caseInsensitive(),
          strict: $$UMFP.strictMode(),
          squash: $$UMFP.defaultSquashPolicy()
        };
        return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);
      };
      UrlMatcher.prototype.toString = function() {
        return this.source;
      };
      UrlMatcher.prototype.exec = function(path, searchParams) {
        var m = this.regexp.exec(path);
        if (!m)
          return null;
        searchParams = searchParams || {};
        var paramNames = this.parameters(),
            nTotal = paramNames.length,
            nPath = this.segments.length - 1,
            values = {},
            i,
            j,
            cfg,
            paramName;
        if (nPath !== m.length - 1)
          throw new Error("Unbalanced capture group in route '" + this.source + "'");
        function decodePathArray(string) {
          function reverseString(str) {
            return str.split("").reverse().join("");
          }
          function unquoteDashes(str) {
            return str.replace(/\\-/g, "-");
          }
          var split = reverseString(string).split(/-(?!\\)/);
          var allReversed = map(split, reverseString);
          return map(allReversed, unquoteDashes).reverse();
        }
        var param,
            paramVal;
        for (i = 0; i < nPath; i++) {
          paramName = paramNames[i];
          param = this.params[paramName];
          paramVal = m[i + 1];
          for (j = 0; j < param.replace.length; j++) {
            if (param.replace[j].from === paramVal)
              paramVal = param.replace[j].to;
          }
          if (paramVal && param.array === true)
            paramVal = decodePathArray(paramVal);
          if (isDefined(paramVal))
            paramVal = param.type.decode(paramVal);
          values[paramName] = param.value(paramVal);
        }
        for (; i < nTotal; i++) {
          paramName = paramNames[i];
          values[paramName] = this.params[paramName].value(searchParams[paramName]);
          param = this.params[paramName];
          paramVal = searchParams[paramName];
          for (j = 0; j < param.replace.length; j++) {
            if (param.replace[j].from === paramVal)
              paramVal = param.replace[j].to;
          }
          if (isDefined(paramVal))
            paramVal = param.type.decode(paramVal);
          values[paramName] = param.value(paramVal);
        }
        return values;
      };
      UrlMatcher.prototype.parameters = function(param) {
        if (!isDefined(param))
          return this.$$paramNames;
        return this.params[param] || null;
      };
      UrlMatcher.prototype.validates = function(params) {
        return this.params.$$validates(params);
      };
      UrlMatcher.prototype.format = function(values) {
        values = values || {};
        var segments = this.segments,
            params = this.parameters(),
            paramset = this.params;
        if (!this.validates(values))
          return null;
        var i,
            search = false,
            nPath = segments.length - 1,
            nTotal = params.length,
            result = segments[0];
        function encodeDashes(str) {
          return encodeURIComponent(str).replace(/-/g, function(c) {
            return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase();
          });
        }
        for (i = 0; i < nTotal; i++) {
          var isPathParam = i < nPath;
          var name = params[i],
              param = paramset[name],
              value = param.value(values[name]);
          var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);
          var squash = isDefaultValue ? param.squash : false;
          var encoded = param.type.encode(value);
          if (isPathParam) {
            var nextSegment = segments[i + 1];
            var isFinalPathParam = i + 1 === nPath;
            if (squash === false) {
              if (encoded != null) {
                if (isArray(encoded)) {
                  result += map(encoded, encodeDashes).join("-");
                } else {
                  result += encodeURIComponent(encoded);
                }
              }
              result += nextSegment;
            } else if (squash === true) {
              var capture = result.match(/\/$/) ? /\/?(.*)/ : /(.*)/;
              result += nextSegment.match(capture)[1];
            } else if (isString(squash)) {
              result += squash + nextSegment;
            }
            if (isFinalPathParam && param.squash === true && result.slice(-1) === '/')
              result = result.slice(0, -1);
          } else {
            if (encoded == null || (isDefaultValue && squash !== false))
              continue;
            if (!isArray(encoded))
              encoded = [encoded];
            if (encoded.length === 0)
              continue;
            encoded = map(encoded, encodeURIComponent).join('&' + name + '=');
            result += (search ? '&' : '?') + (name + '=' + encoded);
            search = true;
          }
        }
        return result;
      };
      function Type(config) {
        extend(this, config);
      }
      Type.prototype.is = function(val, key) {
        return true;
      };
      Type.prototype.encode = function(val, key) {
        return val;
      };
      Type.prototype.decode = function(val, key) {
        return val;
      };
      Type.prototype.equals = function(a, b) {
        return a == b;
      };
      Type.prototype.$subPattern = function() {
        var sub = this.pattern.toString();
        return sub.substr(1, sub.length - 2);
      };
      Type.prototype.pattern = /.*/;
      Type.prototype.toString = function() {
        return "{Type:" + this.name + "}";
      };
      Type.prototype.$normalize = function(val) {
        return this.is(val) ? val : this.decode(val);
      };
      Type.prototype.$asArray = function(mode, isSearch) {
        if (!mode)
          return this;
        if (mode === "auto" && !isSearch)
          throw new Error("'auto' array mode is for query parameters only");
        function ArrayType(type, mode) {
          function bindTo(type, callbackName) {
            return function() {
              return type[callbackName].apply(type, arguments);
            };
          }
          function arrayWrap(val) {
            return isArray(val) ? val : (isDefined(val) ? [val] : []);
          }
          function arrayUnwrap(val) {
            switch (val.length) {
              case 0:
                return undefined;
              case 1:
                return mode === "auto" ? val[0] : val;
              default:
                return val;
            }
          }
          function falsey(val) {
            return !val;
          }
          function arrayHandler(callback, allTruthyMode) {
            return function handleArray(val) {
              if (isArray(val) && val.length === 0)
                return val;
              val = arrayWrap(val);
              var result = map(val, callback);
              if (allTruthyMode === true)
                return filter(result, falsey).length === 0;
              return arrayUnwrap(result);
            };
          }
          function arrayEqualsHandler(callback) {
            return function handleArray(val1, val2) {
              var left = arrayWrap(val1),
                  right = arrayWrap(val2);
              if (left.length !== right.length)
                return false;
              for (var i = 0; i < left.length; i++) {
                if (!callback(left[i], right[i]))
                  return false;
              }
              return true;
            };
          }
          this.encode = arrayHandler(bindTo(type, 'encode'));
          this.decode = arrayHandler(bindTo(type, 'decode'));
          this.is = arrayHandler(bindTo(type, 'is'), true);
          this.equals = arrayEqualsHandler(bindTo(type, 'equals'));
          this.pattern = type.pattern;
          this.$normalize = arrayHandler(bindTo(type, '$normalize'));
          this.name = type.name;
          this.$arrayMode = mode;
        }
        return new ArrayType(this, mode);
      };
      function $UrlMatcherFactory() {
        $$UMFP = this;
        var isCaseInsensitive = false,
            isStrictMode = true,
            defaultSquashPolicy = false;
        function valToString(val) {
          return val != null ? val.toString().replace(/~/g, "~~").replace(/\//g, "~2F") : val;
        }
        function valFromString(val) {
          return val != null ? val.toString().replace(/~2F/g, "/").replace(/~~/g, "~") : val;
        }
        var $types = {},
            enqueue = true,
            typeQueue = [],
            injector,
            defaultTypes = {
              "string": {
                encode: valToString,
                decode: valFromString,
                is: function(val) {
                  return val == null || !isDefined(val) || typeof val === "string";
                },
                pattern: /[^/]*/
              },
              "int": {
                encode: valToString,
                decode: function(val) {
                  return parseInt(val, 10);
                },
                is: function(val) {
                  return isDefined(val) && this.decode(val.toString()) === val;
                },
                pattern: /\d+/
              },
              "bool": {
                encode: function(val) {
                  return val ? 1 : 0;
                },
                decode: function(val) {
                  return parseInt(val, 10) !== 0;
                },
                is: function(val) {
                  return val === true || val === false;
                },
                pattern: /0|1/
              },
              "date": {
                encode: function(val) {
                  if (!this.is(val))
                    return undefined;
                  return [val.getFullYear(), ('0' + (val.getMonth() + 1)).slice(-2), ('0' + val.getDate()).slice(-2)].join("-");
                },
                decode: function(val) {
                  if (this.is(val))
                    return val;
                  var match = this.capture.exec(val);
                  return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
                },
                is: function(val) {
                  return val instanceof Date && !isNaN(val.valueOf());
                },
                equals: function(a, b) {
                  return this.is(a) && this.is(b) && a.toISOString() === b.toISOString();
                },
                pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
                capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
              },
              "json": {
                encode: angular.toJson,
                decode: angular.fromJson,
                is: angular.isObject,
                equals: angular.equals,
                pattern: /[^/]*/
              },
              "any": {
                encode: angular.identity,
                decode: angular.identity,
                equals: angular.equals,
                pattern: /.*/
              }
            };
        function getDefaultConfig() {
          return {
            strict: isStrictMode,
            caseInsensitive: isCaseInsensitive
          };
        }
        function isInjectable(value) {
          return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));
        }
        $UrlMatcherFactory.$$getDefaultValue = function(config) {
          if (!isInjectable(config.value))
            return config.value;
          if (!injector)
            throw new Error("Injectable functions cannot be called at configuration time");
          return injector.invoke(config.value);
        };
        this.caseInsensitive = function(value) {
          if (isDefined(value))
            isCaseInsensitive = value;
          return isCaseInsensitive;
        };
        this.strictMode = function(value) {
          if (isDefined(value))
            isStrictMode = value;
          return isStrictMode;
        };
        this.defaultSquashPolicy = function(value) {
          if (!isDefined(value))
            return defaultSquashPolicy;
          if (value !== true && value !== false && !isString(value))
            throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");
          defaultSquashPolicy = value;
          return value;
        };
        this.compile = function(pattern, config) {
          return new UrlMatcher(pattern, extend(getDefaultConfig(), config));
        };
        this.isMatcher = function(o) {
          if (!isObject(o))
            return false;
          var result = true;
          forEach(UrlMatcher.prototype, function(val, name) {
            if (isFunction(val)) {
              result = result && (isDefined(o[name]) && isFunction(o[name]));
            }
          });
          return result;
        };
        this.type = function(name, definition, definitionFn) {
          if (!isDefined(definition))
            return $types[name];
          if ($types.hasOwnProperty(name))
            throw new Error("A type named '" + name + "' has already been defined.");
          $types[name] = new Type(extend({name: name}, definition));
          if (definitionFn) {
            typeQueue.push({
              name: name,
              def: definitionFn
            });
            if (!enqueue)
              flushTypeQueue();
          }
          return this;
        };
        function flushTypeQueue() {
          while (typeQueue.length) {
            var type = typeQueue.shift();
            if (type.pattern)
              throw new Error("You cannot override a type's .pattern at runtime.");
            angular.extend($types[type.name], injector.invoke(type.def));
          }
        }
        forEach(defaultTypes, function(type, name) {
          $types[name] = new Type(extend({name: name}, type));
        });
        $types = inherit($types, {});
        this.$get = ['$injector', function($injector) {
          injector = $injector;
          enqueue = false;
          flushTypeQueue();
          forEach(defaultTypes, function(type, name) {
            if (!$types[name])
              $types[name] = new Type(type);
          });
          return this;
        }];
        this.Param = function Param(id, type, config, location) {
          var self = this;
          config = unwrapShorthand(config);
          type = getType(config, type, location);
          var arrayMode = getArrayMode();
          type = arrayMode ? type.$asArray(arrayMode, location === "search") : type;
          if (type.name === "string" && !arrayMode && location === "path" && config.value === undefined)
            config.value = "";
          var isOptional = config.value !== undefined;
          var squash = getSquashPolicy(config, isOptional);
          var replace = getReplace(config, arrayMode, isOptional, squash);
          function unwrapShorthand(config) {
            var keys = isObject(config) ? objectKeys(config) : [];
            var isShorthand = indexOf(keys, "value") === -1 && indexOf(keys, "type") === -1 && indexOf(keys, "squash") === -1 && indexOf(keys, "array") === -1;
            if (isShorthand)
              config = {value: config};
            config.$$fn = isInjectable(config.value) ? config.value : function() {
              return config.value;
            };
            return config;
          }
          function getType(config, urlType, location) {
            if (config.type && urlType)
              throw new Error("Param '" + id + "' has two type configurations.");
            if (urlType)
              return urlType;
            if (!config.type)
              return (location === "config" ? $types.any : $types.string);
            if (angular.isString(config.type))
              return $types[config.type];
            if (config.type instanceof Type)
              return config.type;
            return new Type(config.type);
          }
          function getArrayMode() {
            var arrayDefaults = {array: (location === "search" ? "auto" : false)};
            var arrayParamNomenclature = id.match(/\[\]$/) ? {array: true} : {};
            return extend(arrayDefaults, arrayParamNomenclature, config).array;
          }
          function getSquashPolicy(config, isOptional) {
            var squash = config.squash;
            if (!isOptional || squash === false)
              return false;
            if (!isDefined(squash) || squash == null)
              return defaultSquashPolicy;
            if (squash === true || isString(squash))
              return squash;
            throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string");
          }
          function getReplace(config, arrayMode, isOptional, squash) {
            var replace,
                configuredKeys,
                defaultPolicy = [{
                  from: "",
                  to: (isOptional || arrayMode ? undefined : "")
                }, {
                  from: null,
                  to: (isOptional || arrayMode ? undefined : "")
                }];
            replace = isArray(config.replace) ? config.replace : [];
            if (isString(squash))
              replace.push({
                from: squash,
                to: undefined
              });
            configuredKeys = map(replace, function(item) {
              return item.from;
            });
            return filter(defaultPolicy, function(item) {
              return indexOf(configuredKeys, item.from) === -1;
            }).concat(replace);
          }
          function $$getDefaultValue() {
            if (!injector)
              throw new Error("Injectable functions cannot be called at configuration time");
            var defaultValue = injector.invoke(config.$$fn);
            if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))
              throw new Error("Default value (" + defaultValue + ") for parameter '" + self.id + "' is not an instance of Type (" + self.type.name + ")");
            return defaultValue;
          }
          function $value(value) {
            function hasReplaceVal(val) {
              return function(obj) {
                return obj.from === val;
              };
            }
            function $replace(value) {
              var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) {
                return obj.to;
              });
              return replacement.length ? replacement[0] : value;
            }
            value = $replace(value);
            return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);
          }
          function toString() {
            return "{Param:" + id + " " + type + " squash: '" + squash + "' optional: " + isOptional + "}";
          }
          extend(this, {
            id: id,
            type: type,
            location: location,
            array: arrayMode,
            squash: squash,
            replace: replace,
            isOptional: isOptional,
            value: $value,
            dynamic: undefined,
            config: config,
            toString: toString
          });
        };
        function ParamSet(params) {
          extend(this, params || {});
        }
        ParamSet.prototype = {
          $$new: function() {
            return inherit(this, extend(new ParamSet(), {$$parent: this}));
          },
          $$keys: function() {
            var keys = [],
                chain = [],
                parent = this,
                ignore = objectKeys(ParamSet.prototype);
            while (parent) {
              chain.push(parent);
              parent = parent.$$parent;
            }
            chain.reverse();
            forEach(chain, function(paramset) {
              forEach(objectKeys(paramset), function(key) {
                if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1)
                  keys.push(key);
              });
            });
            return keys;
          },
          $$values: function(paramValues) {
            var values = {},
                self = this;
            forEach(self.$$keys(), function(key) {
              values[key] = self[key].value(paramValues && paramValues[key]);
            });
            return values;
          },
          $$equals: function(paramValues1, paramValues2) {
            var equal = true,
                self = this;
            forEach(self.$$keys(), function(key) {
              var left = paramValues1 && paramValues1[key],
                  right = paramValues2 && paramValues2[key];
              if (!self[key].type.equals(left, right))
                equal = false;
            });
            return equal;
          },
          $$validates: function $$validate(paramValues) {
            var keys = this.$$keys(),
                i,
                param,
                rawVal,
                normalized,
                encoded;
            for (i = 0; i < keys.length; i++) {
              param = this[keys[i]];
              rawVal = paramValues[keys[i]];
              if ((rawVal === undefined || rawVal === null) && param.isOptional)
                break;
              normalized = param.type.$normalize(rawVal);
              if (!param.type.is(normalized))
                return false;
              encoded = param.type.encode(normalized);
              if (angular.isString(encoded) && !param.type.pattern.exec(encoded))
                return false;
            }
            return true;
          },
          $$parent: undefined
        };
        this.ParamSet = ParamSet;
      }
      angular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);
      angular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) {}]);
      $UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];
      function $UrlRouterProvider($locationProvider, $urlMatcherFactory) {
        var rules = [],
            otherwise = null,
            interceptDeferred = false,
            listener;
        function regExpPrefix(re) {
          var prefix = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(re.source);
          return (prefix != null) ? prefix[1].replace(/\\(.)/g, "$1") : '';
        }
        function interpolate(pattern, match) {
          return pattern.replace(/\$(\$|\d{1,2})/, function(m, what) {
            return match[what === '$' ? 0 : Number(what)];
          });
        }
        this.rule = function(rule) {
          if (!isFunction(rule))
            throw new Error("'rule' must be a function");
          rules.push(rule);
          return this;
        };
        this.otherwise = function(rule) {
          if (isString(rule)) {
            var redirect = rule;
            rule = function() {
              return redirect;
            };
          } else if (!isFunction(rule))
            throw new Error("'rule' must be a function");
          otherwise = rule;
          return this;
        };
        function handleIfMatch($injector, handler, match) {
          if (!match)
            return false;
          var result = $injector.invoke(handler, handler, {$match: match});
          return isDefined(result) ? result : true;
        }
        this.when = function(what, handler) {
          var redirect,
              handlerIsString = isString(handler);
          if (isString(what))
            what = $urlMatcherFactory.compile(what);
          if (!handlerIsString && !isFunction(handler) && !isArray(handler))
            throw new Error("invalid 'handler' in when()");
          var strategies = {
            matcher: function(what, handler) {
              if (handlerIsString) {
                redirect = $urlMatcherFactory.compile(handler);
                handler = ['$match', function($match) {
                  return redirect.format($match);
                }];
              }
              return extend(function($injector, $location) {
                return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));
              }, {prefix: isString(what.prefix) ? what.prefix : ''});
            },
            regex: function(what, handler) {
              if (what.global || what.sticky)
                throw new Error("when() RegExp must not be global or sticky");
              if (handlerIsString) {
                redirect = handler;
                handler = ['$match', function($match) {
                  return interpolate(redirect, $match);
                }];
              }
              return extend(function($injector, $location) {
                return handleIfMatch($injector, handler, what.exec($location.path()));
              }, {prefix: regExpPrefix(what)});
            }
          };
          var check = {
            matcher: $urlMatcherFactory.isMatcher(what),
            regex: what instanceof RegExp
          };
          for (var n in check) {
            if (check[n])
              return this.rule(strategies[n](what, handler));
          }
          throw new Error("invalid 'what' in when()");
        };
        this.deferIntercept = function(defer) {
          if (defer === undefined)
            defer = true;
          interceptDeferred = defer;
        };
        this.$get = $get;
        $get.$inject = ['$location', '$rootScope', '$injector', '$browser', '$sniffer'];
        function $get($location, $rootScope, $injector, $browser, $sniffer) {
          var baseHref = $browser.baseHref(),
              location = $location.url(),
              lastPushedUrl;
          function appendBasePath(url, isHtml5, absolute) {
            if (baseHref === '/')
              return url;
            if (isHtml5)
              return baseHref.slice(0, -1) + url;
            if (absolute)
              return baseHref.slice(1) + url;
            return url;
          }
          function update(evt) {
            if (evt && evt.defaultPrevented)
              return;
            var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;
            lastPushedUrl = undefined;
            function check(rule) {
              var handled = rule($injector, $location);
              if (!handled)
                return false;
              if (isString(handled))
                $location.replace().url(handled);
              return true;
            }
            var n = rules.length,
                i;
            for (i = 0; i < n; i++) {
              if (check(rules[i]))
                return;
            }
            if (otherwise)
              check(otherwise);
          }
          function listen() {
            listener = listener || $rootScope.$on('$locationChangeSuccess', update);
            return listener;
          }
          if (!interceptDeferred)
            listen();
          return {
            sync: function() {
              update();
            },
            listen: function() {
              return listen();
            },
            update: function(read) {
              if (read) {
                location = $location.url();
                return;
              }
              if ($location.url() === location)
                return;
              $location.url(location);
              $location.replace();
            },
            push: function(urlMatcher, params, options) {
              var url = urlMatcher.format(params || {});
              if (url !== null && params && params['#']) {
                url += '#' + params['#'];
              }
              $location.url(url);
              lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;
              if (options && options.replace)
                $location.replace();
            },
            href: function(urlMatcher, params, options) {
              if (!urlMatcher.validates(params))
                return null;
              var isHtml5 = $locationProvider.html5Mode();
              if (angular.isObject(isHtml5)) {
                isHtml5 = isHtml5.enabled;
              }
              isHtml5 = isHtml5 && $sniffer.history;
              var url = urlMatcher.format(params);
              options = options || {};
              if (!isHtml5 && url !== null) {
                url = "#" + $locationProvider.hashPrefix() + url;
              }
              if (url !== null && params && params['#']) {
                url += '#' + params['#'];
              }
              url = appendBasePath(url, isHtml5, options.absolute);
              if (!options.absolute || !url) {
                return url;
              }
              var slash = (!isHtml5 && url ? '/' : ''),
                  port = $location.port();
              port = (port === 80 || port === 443 ? '' : ':' + port);
              return [$location.protocol(), '://', $location.host(), port, slash, url].join('');
            }
          };
        }
      }
      angular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);
      $StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];
      function $StateProvider($urlRouterProvider, $urlMatcherFactory) {
        var root,
            states = {},
            $state,
            queue = {},
            abstractKey = 'abstract';
        var stateBuilder = {
          parent: function(state) {
            if (isDefined(state.parent) && state.parent)
              return findState(state.parent);
            var compositeName = /^(.+)\.[^.]+$/.exec(state.name);
            return compositeName ? findState(compositeName[1]) : root;
          },
          data: function(state) {
            if (state.parent && state.parent.data) {
              state.data = state.self.data = inherit(state.parent.data, state.data);
            }
            return state.data;
          },
          url: function(state) {
            var url = state.url,
                config = {params: state.params || {}};
            if (isString(url)) {
              if (url.charAt(0) == '^')
                return $urlMatcherFactory.compile(url.substring(1), config);
              return (state.parent.navigable || root).url.concat(url, config);
            }
            if (!url || $urlMatcherFactory.isMatcher(url))
              return url;
            throw new Error("Invalid url '" + url + "' in state '" + state + "'");
          },
          navigable: function(state) {
            return state.url ? state : (state.parent ? state.parent.navigable : null);
          },
          ownParams: function(state) {
            var params = state.url && state.url.params || new $$UMFP.ParamSet();
            forEach(state.params || {}, function(config, id) {
              if (!params[id])
                params[id] = new $$UMFP.Param(id, null, config, "config");
            });
            return params;
          },
          params: function(state) {
            var ownParams = pick(state.ownParams, state.ownParams.$$keys());
            return state.parent && state.parent.params ? extend(state.parent.params.$$new(), ownParams) : new $$UMFP.ParamSet();
          },
          views: function(state) {
            var views = {};
            forEach(isDefined(state.views) ? state.views : {'': state}, function(view, name) {
              if (name.indexOf('@') < 0)
                name += '@' + state.parent.name;
              views[name] = view;
            });
            return views;
          },
          path: function(state) {
            return state.parent ? state.parent.path.concat(state) : [];
          },
          includes: function(state) {
            var includes = state.parent ? extend({}, state.parent.includes) : {};
            includes[state.name] = true;
            return includes;
          },
          $delegates: {}
        };
        function isRelative(stateName) {
          return stateName.indexOf(".") === 0 || stateName.indexOf("^") === 0;
        }
        function findState(stateOrName, base) {
          if (!stateOrName)
            return undefined;
          var isStr = isString(stateOrName),
              name = isStr ? stateOrName : stateOrName.name,
              path = isRelative(name);
          if (path) {
            if (!base)
              throw new Error("No reference point given for path '" + name + "'");
            base = findState(base);
            var rel = name.split("."),
                i = 0,
                pathLength = rel.length,
                current = base;
            for (; i < pathLength; i++) {
              if (rel[i] === "" && i === 0) {
                current = base;
                continue;
              }
              if (rel[i] === "^") {
                if (!current.parent)
                  throw new Error("Path '" + name + "' not valid for state '" + base.name + "'");
                current = current.parent;
                continue;
              }
              break;
            }
            rel = rel.slice(i).join(".");
            name = current.name + (current.name && rel ? "." : "") + rel;
          }
          var state = states[name];
          if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {
            return state;
          }
          return undefined;
        }
        function queueState(parentName, state) {
          if (!queue[parentName]) {
            queue[parentName] = [];
          }
          queue[parentName].push(state);
        }
        function flushQueuedChildren(parentName) {
          var queued = queue[parentName] || [];
          while (queued.length) {
            registerState(queued.shift());
          }
        }
        function registerState(state) {
          state = inherit(state, {
            self: state,
            resolve: state.resolve || {},
            toString: function() {
              return this.name;
            }
          });
          var name = state.name;
          if (!isString(name) || name.indexOf('@') >= 0)
            throw new Error("State must have a valid name");
          if (states.hasOwnProperty(name))
            throw new Error("State '" + name + "' is already defined");
          var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.')) : (isString(state.parent)) ? state.parent : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name : '';
          if (parentName && !states[parentName]) {
            return queueState(parentName, state.self);
          }
          for (var key in stateBuilder) {
            if (isFunction(stateBuilder[key]))
              state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);
          }
          states[name] = state;
          if (!state[abstractKey] && state.url) {
            $urlRouterProvider.when(state.url, ['$match', '$stateParams', function($match, $stateParams) {
              if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {
                $state.transitionTo(state, $match, {
                  inherit: true,
                  location: false
                });
              }
            }]);
          }
          flushQueuedChildren(name);
          return state;
        }
        function isGlob(text) {
          return text.indexOf('*') > -1;
        }
        function doesStateMatchGlob(glob) {
          var globSegments = glob.split('.'),
              segments = $state.$current.name.split('.');
          for (var i = 0,
              l = globSegments.length; i < l; i++) {
            if (globSegments[i] === '*') {
              segments[i] = '*';
            }
          }
          if (globSegments[0] === '**') {
            segments = segments.slice(indexOf(segments, globSegments[1]));
            segments.unshift('**');
          }
          if (globSegments[globSegments.length - 1] === '**') {
            segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);
            segments.push('**');
          }
          if (globSegments.length != segments.length) {
            return false;
          }
          return segments.join('') === globSegments.join('');
        }
        root = registerState({
          name: '',
          url: '^',
          views: null,
          'abstract': true
        });
        root.navigable = null;
        this.decorator = decorator;
        function decorator(name, func) {
          if (isString(name) && !isDefined(func)) {
            return stateBuilder[name];
          }
          if (!isFunction(func) || !isString(name)) {
            return this;
          }
          if (stateBuilder[name] && !stateBuilder.$delegates[name]) {
            stateBuilder.$delegates[name] = stateBuilder[name];
          }
          stateBuilder[name] = func;
          return this;
        }
        this.state = state;
        function state(name, definition) {
          if (isObject(name))
            definition = name;
          else
            definition.name = name;
          registerState(definition);
          return this;
        }
        this.$get = $get;
        $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];
        function $get($rootScope, $q, $view, $injector, $resolve, $stateParams, $urlRouter, $location, $urlMatcherFactory) {
          var TransitionSuperseded = $q.reject(new Error('transition superseded'));
          var TransitionPrevented = $q.reject(new Error('transition prevented'));
          var TransitionAborted = $q.reject(new Error('transition aborted'));
          var TransitionFailed = $q.reject(new Error('transition failed'));
          function handleRedirect(redirect, state, params, options) {
            var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);
            if (evt.defaultPrevented) {
              $urlRouter.update();
              return TransitionAborted;
            }
            if (!evt.retry) {
              return null;
            }
            if (options.$retry) {
              $urlRouter.update();
              return TransitionFailed;
            }
            var retryTransition = $state.transition = $q.when(evt.retry);
            retryTransition.then(function() {
              if (retryTransition !== $state.transition)
                return TransitionSuperseded;
              redirect.options.$retry = true;
              return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);
            }, function() {
              return TransitionAborted;
            });
            $urlRouter.update();
            return retryTransition;
          }
          root.locals = {
            resolve: null,
            globals: {$stateParams: {}}
          };
          $state = {
            params: {},
            current: root.self,
            $current: root,
            transition: null
          };
          $state.reload = function reload(state) {
            return $state.transitionTo($state.current, $stateParams, {
              reload: state || true,
              inherit: false,
              notify: true
            });
          };
          $state.go = function go(to, params, options) {
            return $state.transitionTo(to, params, extend({
              inherit: true,
              relative: $state.$current
            }, options));
          };
          $state.transitionTo = function transitionTo(to, toParams, options) {
            toParams = toParams || {};
            options = extend({
              location: true,
              inherit: false,
              relative: null,
              notify: true,
              reload: false,
              $retry: false
            }, options || {});
            var from = $state.$current,
                fromParams = $state.params,
                fromPath = from.path;
            var evt,
                toState = findState(to, options.relative);
            var hash = toParams['#'];
            if (!isDefined(toState)) {
              var redirect = {
                to: to,
                toParams: toParams,
                options: options
              };
              var redirectResult = handleRedirect(redirect, from.self, fromParams, options);
              if (redirectResult) {
                return redirectResult;
              }
              to = redirect.to;
              toParams = redirect.toParams;
              options = redirect.options;
              toState = findState(to, options.relative);
              if (!isDefined(toState)) {
                if (!options.relative)
                  throw new Error("No such state '" + to + "'");
                throw new Error("Could not resolve '" + to + "' from state '" + options.relative + "'");
              }
            }
            if (toState[abstractKey])
              throw new Error("Cannot transition to abstract state '" + to + "'");
            if (options.inherit)
              toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);
            if (!toState.params.$$validates(toParams))
              return TransitionFailed;
            toParams = toState.params.$$values(toParams);
            to = toState;
            var toPath = to.path;
            var keep = 0,
                state = toPath[keep],
                locals = root.locals,
                toLocals = [];
            if (!options.reload) {
              while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {
                locals = toLocals[keep] = state.locals;
                keep++;
                state = toPath[keep];
              }
            } else if (isString(options.reload) || isObject(options.reload)) {
              if (isObject(options.reload) && !options.reload.name) {
                throw new Error('Invalid reload state object');
              }
              var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);
              if (options.reload && !reloadState) {
                throw new Error("No such reload state '" + (isString(options.reload) ? options.reload : options.reload.name) + "'");
              }
              while (state && state === fromPath[keep] && state !== reloadState) {
                locals = toLocals[keep] = state.locals;
                keep++;
                state = toPath[keep];
              }
            }
            if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {
              if (hash)
                toParams['#'] = hash;
              $state.params = toParams;
              copy($state.params, $stateParams);
              copy(filterByKeys(to.params.$$keys(), $stateParams), to.locals.globals.$stateParams);
              if (options.location && to.navigable && to.navigable.url) {
                $urlRouter.push(to.navigable.url, toParams, {
                  $$avoidResync: true,
                  replace: options.location === 'replace'
                });
                $urlRouter.update(true);
              }
              $state.transition = null;
              return $q.when($state.current);
            }
            toParams = filterByKeys(to.params.$$keys(), toParams || {});
            if (hash)
              toParams['#'] = hash;
            if (options.notify) {
              if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams, options).defaultPrevented) {
                $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);
                if ($state.transition == null)
                  $urlRouter.update();
                return TransitionPrevented;
              }
            }
            var resolved = $q.when(locals);
            for (var l = keep; l < toPath.length; l++, state = toPath[l]) {
              locals = toLocals[l] = inherit(locals);
              resolved = resolveState(state, toParams, state === to, resolved, locals, options);
            }
            var transition = $state.transition = resolved.then(function() {
              var l,
                  entering,
                  exiting;
              if ($state.transition !== transition)
                return TransitionSuperseded;
              for (l = fromPath.length - 1; l >= keep; l--) {
                exiting = fromPath[l];
                if (exiting.self.onExit) {
                  $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);
                }
                exiting.locals = null;
              }
              for (l = keep; l < toPath.length; l++) {
                entering = toPath[l];
                entering.locals = toLocals[l];
                if (entering.self.onEnter) {
                  $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);
                }
              }
              if ($state.transition !== transition)
                return TransitionSuperseded;
              $state.$current = to;
              $state.current = to.self;
              $state.params = toParams;
              copy($state.params, $stateParams);
              $state.transition = null;
              if (options.location && to.navigable) {
                $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {
                  $$avoidResync: true,
                  replace: options.location === 'replace'
                });
              }
              if (options.notify) {
                $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);
              }
              $urlRouter.update(true);
              return $state.current;
            }, function(error) {
              if ($state.transition !== transition)
                return TransitionSuperseded;
              $state.transition = null;
              evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);
              if (!evt.defaultPrevented) {
                $urlRouter.update();
              }
              return $q.reject(error);
            });
            return transition;
          };
          $state.is = function is(stateOrName, params, options) {
            options = extend({relative: $state.$current}, options || {});
            var state = findState(stateOrName, options.relative);
            if (!isDefined(state)) {
              return undefined;
            }
            if ($state.$current !== state) {
              return false;
            }
            return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;
          };
          $state.includes = function includes(stateOrName, params, options) {
            options = extend({relative: $state.$current}, options || {});
            if (isString(stateOrName) && isGlob(stateOrName)) {
              if (!doesStateMatchGlob(stateOrName)) {
                return false;
              }
              stateOrName = $state.$current.name;
            }
            var state = findState(stateOrName, options.relative);
            if (!isDefined(state)) {
              return undefined;
            }
            if (!isDefined($state.$current.includes[state.name])) {
              return false;
            }
            return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;
          };
          $state.href = function href(stateOrName, params, options) {
            options = extend({
              lossy: true,
              inherit: true,
              absolute: false,
              relative: $state.$current
            }, options || {});
            var state = findState(stateOrName, options.relative);
            if (!isDefined(state))
              return null;
            if (options.inherit)
              params = inheritParams($stateParams, params || {}, $state.$current, state);
            var nav = (state && options.lossy) ? state.navigable : state;
            if (!nav || nav.url === undefined || nav.url === null) {
              return null;
            }
            return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {absolute: options.absolute});
          };
          $state.get = function(stateOrName, context) {
            if (arguments.length === 0)
              return map(objectKeys(states), function(name) {
                return states[name].self;
              });
            var state = findState(stateOrName, context || $state.$current);
            return (state && state.self) ? state.self : null;
          };
          function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {
            var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);
            var locals = {$stateParams: $stateParams};
            dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);
            var promises = [dst.resolve.then(function(globals) {
              dst.globals = globals;
            })];
            if (inherited)
              promises.push(inherited);
            function resolveViews() {
              var viewsPromises = [];
              forEach(state.views, function(view, name) {
                var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});
                injectables.$template = [function() {
                  return $view.load(name, {
                    view: view,
                    locals: dst.globals,
                    params: $stateParams,
                    notify: options.notify
                  }) || '';
                }];
                viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function(result) {
                  if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {
                    var injectLocals = angular.extend({}, injectables, dst.globals);
                    result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);
                  } else {
                    result.$$controller = view.controller;
                  }
                  result.$$state = state;
                  result.$$controllerAs = view.controllerAs;
                  dst[name] = result;
                }));
              });
              return $q.all(viewsPromises).then(function() {
                return dst.globals;
              });
            }
            return $q.all(promises).then(resolveViews).then(function(values) {
              return dst;
            });
          }
          return $state;
        }
        function shouldSkipReload(to, toParams, from, fromParams, locals, options) {
          function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {
            function notSearchParam(key) {
              return fromAndToState.params[key].location != "search";
            }
            var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);
            var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));
            var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);
            return nonQueryParamSet.$$equals(fromParams, toParams);
          }
          if (!options.reload && to === from && (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {
            return true;
          }
        }
      }
      angular.module('ui.router.state').factory('$stateParams', function() {
        return {};
      }).provider('$state', $StateProvider);
      $ViewProvider.$inject = [];
      function $ViewProvider() {
        this.$get = $get;
        $get.$inject = ['$rootScope', '$templateFactory'];
        function $get($rootScope, $templateFactory) {
          return {load: function load(name, options) {
              var result,
                  defaults = {
                    template: null,
                    controller: null,
                    view: null,
                    locals: null,
                    notify: true,
                    async: true,
                    params: {}
                  };
              options = extend(defaults, options);
              if (options.view) {
                result = $templateFactory.fromConfig(options.view, options.params, options.locals);
              }
              return result;
            }};
        }
      }
      angular.module('ui.router.state').provider('$view', $ViewProvider);
      function $ViewScrollProvider() {
        var useAnchorScroll = false;
        this.useAnchorScroll = function() {
          useAnchorScroll = true;
        };
        this.$get = ['$anchorScroll', '$timeout', function($anchorScroll, $timeout) {
          if (useAnchorScroll) {
            return $anchorScroll;
          }
          return function($element) {
            return $timeout(function() {
              $element[0].scrollIntoView();
            }, 0, false);
          };
        }];
      }
      angular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);
      var ngMajorVer = angular.version.major;
      var ngMinorVer = angular.version.minor;
      $ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate'];
      function $ViewDirective($state, $injector, $uiViewScroll, $interpolate) {
        function getService() {
          return ($injector.has) ? function(service) {
            return $injector.has(service) ? $injector.get(service) : null;
          } : function(service) {
            try {
              return $injector.get(service);
            } catch (e) {
              return null;
            }
          };
        }
        var service = getService(),
            $animator = service('$animator'),
            $animate = service('$animate');
        function getRenderer(attrs, scope) {
          var statics = {
            enter: function(element, target, cb) {
              target.after(element);
              cb();
            },
            leave: function(element, cb) {
              element.remove();
              cb();
            }
          };
          if (!!attrs.noanimation)
            return statics;
          function animEnabled(element) {
            if (ngMajorVer === 1 && ngMinorVer >= 4)
              return !!$animate.enabled(element);
            if (ngMajorVer === 1 && ngMinorVer >= 2)
              return !!$animate.enabled();
            return (!!$animator);
          }
          if ($animate) {
            return {
              enter: function(element, target, cb) {
                if (!animEnabled(element)) {
                  statics.enter(element, target, cb);
                } else if (angular.version.minor > 2) {
                  $animate.enter(element, null, target).then(cb);
                } else {
                  $animate.enter(element, null, target, cb);
                }
              },
              leave: function(element, cb) {
                if (!animEnabled(element)) {
                  statics.leave(element, cb);
                } else if (angular.version.minor > 2) {
                  $animate.leave(element).then(cb);
                } else {
                  $animate.leave(element, cb);
                }
              }
            };
          }
          if ($animator) {
            var animate = $animator && $animator(scope, attrs);
            return {
              enter: function(element, target, cb) {
                animate.enter(element, null, target);
                cb();
              },
              leave: function(element, cb) {
                animate.leave(element);
                cb();
              }
            };
          }
          return statics;
        }
        var directive = {
          restrict: 'ECA',
          terminal: true,
          priority: 400,
          transclude: 'element',
          compile: function(tElement, tAttrs, $transclude) {
            return function(scope, $element, attrs) {
              var previousEl,
                  currentEl,
                  currentScope,
                  latestLocals,
                  onloadExp = attrs.onload || '',
                  autoScrollExp = attrs.autoscroll,
                  renderer = getRenderer(attrs, scope);
              scope.$on('$stateChangeSuccess', function() {
                updateView(false);
              });
              updateView(true);
              function cleanupLastView() {
                var _previousEl = previousEl;
                var _currentScope = currentScope;
                if (_currentScope) {
                  _currentScope._willBeDestroyed = true;
                }
                function cleanOld() {
                  if (_previousEl) {
                    _previousEl.remove();
                  }
                  if (_currentScope) {
                    _currentScope.$destroy();
                  }
                }
                if (currentEl) {
                  renderer.leave(currentEl, function() {
                    cleanOld();
                    previousEl = null;
                  });
                  previousEl = currentEl;
                } else {
                  cleanOld();
                  previousEl = null;
                }
                currentEl = null;
                currentScope = null;
              }
              function updateView(firstTime) {
                var newScope,
                    name = getUiViewName(scope, attrs, $element, $interpolate),
                    previousLocals = name && $state.$current && $state.$current.locals[name];
                if (!firstTime && previousLocals === latestLocals || scope._willBeDestroyed)
                  return;
                newScope = scope.$new();
                latestLocals = $state.$current.locals[name];
                newScope.$emit('$viewContentLoading', name);
                var clone = $transclude(newScope, function(clone) {
                  renderer.enter(clone, $element, function onUiViewEnter() {
                    if (currentScope) {
                      currentScope.$emit('$viewContentAnimationEnded');
                    }
                    if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {
                      $uiViewScroll(clone);
                    }
                  });
                  cleanupLastView();
                });
                currentEl = clone;
                currentScope = newScope;
                currentScope.$emit('$viewContentLoaded', name);
                currentScope.$eval(onloadExp);
              }
            };
          }
        };
        return directive;
      }
      $ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];
      function $ViewDirectiveFill($compile, $controller, $state, $interpolate) {
        return {
          restrict: 'ECA',
          priority: -400,
          compile: function(tElement) {
            var initial = tElement.html();
            return function(scope, $element, attrs) {
              var current = $state.$current,
                  name = getUiViewName(scope, attrs, $element, $interpolate),
                  locals = current && current.locals[name];
              if (!locals) {
                return;
              }
              $element.data('$uiView', {
                name: name,
                state: locals.$$state
              });
              $element.html(locals.$template ? locals.$template : initial);
              var link = $compile($element.contents());
              if (locals.$$controller) {
                locals.$scope = scope;
                locals.$element = $element;
                var controller = $controller(locals.$$controller, locals);
                if (locals.$$controllerAs) {
                  scope[locals.$$controllerAs] = controller;
                }
                $element.data('$ngControllerController', controller);
                $element.children().data('$ngControllerController', controller);
              }
              link(scope);
            };
          }
        };
      }
      function getUiViewName(scope, attrs, element, $interpolate) {
        var name = $interpolate(attrs.uiView || attrs.name || '')(scope);
        var inherited = element.inheritedData('$uiView');
        return name.indexOf('@') >= 0 ? name : (name + '@' + (inherited ? inherited.state.name : ''));
      }
      angular.module('ui.router.state').directive('uiView', $ViewDirective);
      angular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);
      function parseStateRef(ref, current) {
        var preparsed = ref.match(/^\s*({[^}]*})\s*$/),
            parsed;
        if (preparsed)
          ref = current + '(' + preparsed[1] + ')';
        parsed = ref.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/);
        if (!parsed || parsed.length !== 4)
          throw new Error("Invalid state ref '" + ref + "'");
        return {
          state: parsed[1],
          paramExpr: parsed[3] || null
        };
      }
      function stateContext(el) {
        var stateData = el.parent().inheritedData('$uiView');
        if (stateData && stateData.state && stateData.state.name) {
          return stateData.state;
        }
      }
      function getTypeInfo(el) {
        var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';
        var isForm = el[0].nodeName === "FORM";
        return {
          attr: isForm ? "action" : (isSvg ? 'xlink:href' : 'href'),
          isAnchor: el.prop("tagName").toUpperCase() === "A",
          clickable: !isForm
        };
      }
      function clickHook(el, $state, $timeout, type, current) {
        return function(e) {
          var button = e.which || e.button,
              target = current();
          if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {
            var transition = $timeout(function() {
              $state.go(target.state, target.params, target.options);
            });
            e.preventDefault();
            var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1 : 0;
            e.preventDefault = function() {
              if (ignorePreventDefaultCount-- <= 0)
                $timeout.cancel(transition);
            };
          }
        };
      }
      function defaultOpts(el, $state) {
        return {
          relative: stateContext(el) || $state.$current,
          inherit: true
        };
      }
      $StateRefDirective.$inject = ['$state', '$timeout'];
      function $StateRefDirective($state, $timeout) {
        return {
          restrict: 'A',
          require: ['?^uiSrefActive', '?^uiSrefActiveEq'],
          link: function(scope, element, attrs, uiSrefActive) {
            var ref = parseStateRef(attrs.uiSref, $state.current.name);
            var def = {
              state: ref.state,
              href: null,
              params: null
            };
            var type = getTypeInfo(element);
            var active = uiSrefActive[1] || uiSrefActive[0];
            def.options = extend(defaultOpts(element, $state), attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {});
            var update = function(val) {
              if (val)
                def.params = angular.copy(val);
              def.href = $state.href(ref.state, def.params, def.options);
              if (active)
                active.$$addStateInfo(ref.state, def.params);
              if (def.href !== null)
                attrs.$set(type.attr, def.href);
            };
            if (ref.paramExpr) {
              scope.$watch(ref.paramExpr, function(val) {
                if (val !== def.params)
                  update(val);
              }, true);
              def.params = angular.copy(scope.$eval(ref.paramExpr));
            }
            update();
            if (!type.clickable)
              return;
            element.bind("click", clickHook(element, $state, $timeout, type, function() {
              return def;
            }));
          }
        };
      }
      $StateRefDynamicDirective.$inject = ['$state', '$timeout'];
      function $StateRefDynamicDirective($state, $timeout) {
        return {
          restrict: 'A',
          require: ['?^uiSrefActive', '?^uiSrefActiveEq'],
          link: function(scope, element, attrs, uiSrefActive) {
            var type = getTypeInfo(element);
            var active = uiSrefActive[1] || uiSrefActive[0];
            var group = [attrs.uiState, attrs.uiStateParams || null, attrs.uiStateOpts || null];
            var watch = '[' + group.map(function(val) {
              return val || 'null';
            }).join(', ') + ']';
            var def = {
              state: null,
              params: null,
              options: null,
              href: null
            };
            function runStateRefLink(group) {
              def.state = group[0];
              def.params = group[1];
              def.options = group[2];
              def.href = $state.href(def.state, def.params, def.options);
              if (active)
                active.$$addStateInfo(def.state, def.params);
              if (def.href)
                attrs.$set(type.attr, def.href);
            }
            scope.$watch(watch, runStateRefLink, true);
            runStateRefLink(scope.$eval(watch));
            if (!type.clickable)
              return;
            element.bind("click", clickHook(element, $state, $timeout, type, function() {
              return def;
            }));
          }
        };
      }
      $StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];
      function $StateRefActiveDirective($state, $stateParams, $interpolate) {
        return {
          restrict: "A",
          controller: ['$scope', '$element', '$attrs', '$timeout', function($scope, $element, $attrs, $timeout) {
            var states = [],
                activeClasses = {},
                activeEqClass,
                uiSrefActive;
            activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);
            try {
              uiSrefActive = $scope.$eval($attrs.uiSrefActive);
            } catch (e) {}
            uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);
            if (isObject(uiSrefActive)) {
              forEach(uiSrefActive, function(stateOrName, activeClass) {
                if (isString(stateOrName)) {
                  var ref = parseStateRef(stateOrName, $state.current.name);
                  addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);
                }
              });
            }
            this.$$addStateInfo = function(newState, newParams) {
              if (isObject(uiSrefActive) && states.length > 0) {
                return;
              }
              addState(newState, newParams, uiSrefActive);
              update();
            };
            $scope.$on('$stateChangeSuccess', update);
            function addState(stateName, stateParams, activeClass) {
              var state = $state.get(stateName, stateContext($element));
              var stateHash = createStateHash(stateName, stateParams);
              states.push({
                state: state || {name: stateName},
                params: stateParams,
                hash: stateHash
              });
              activeClasses[stateHash] = activeClass;
            }
            function createStateHash(state, params) {
              if (!isString(state)) {
                throw new Error('state should be a string');
              }
              if (isObject(params)) {
                return state + toJson(params);
              }
              params = $scope.$eval(params);
              if (isObject(params)) {
                return state + toJson(params);
              }
              return state;
            }
            function update() {
              for (var i = 0; i < states.length; i++) {
                if (anyMatch(states[i].state, states[i].params)) {
                  addClass($element, activeClasses[states[i].hash]);
                } else {
                  removeClass($element, activeClasses[states[i].hash]);
                }
                if (exactMatch(states[i].state, states[i].params)) {
                  addClass($element, activeEqClass);
                } else {
                  removeClass($element, activeEqClass);
                }
              }
            }
            function addClass(el, className) {
              $timeout(function() {
                el.addClass(className);
              });
            }
            function removeClass(el, className) {
              el.removeClass(className);
            }
            function anyMatch(state, params) {
              return $state.includes(state.name, params);
            }
            function exactMatch(state, params) {
              return $state.is(state.name, params);
            }
            update();
          }]
        };
      }
      angular.module('ui.router.state').directive('uiSref', $StateRefDirective).directive('uiSrefActive', $StateRefActiveDirective).directive('uiSrefActiveEq', $StateRefActiveDirective).directive('uiState', $StateRefDynamicDirective);
      $IsStateFilter.$inject = ['$state'];
      function $IsStateFilter($state) {
        var isFilter = function(state, params) {
          return $state.is(state, params);
        };
        isFilter.$stateful = true;
        return isFilter;
      }
      $IncludedByStateFilter.$inject = ['$state'];
      function $IncludedByStateFilter($state) {
        var includesFilter = function(state, params, options) {
          return $state.includes(state, params, options);
        };
        includesFilter.$stateful = true;
        return includesFilter;
      }
      angular.module('ui.router.state').filter('isState', $IsStateFilter).filter('includedByState', $IncludedByStateFilter);
    })(window, window.angular);
  })($__require('28'));
  return module.exports;
});

$__System.registerDynamic("45", ["44"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('44');
  return module.exports;
});

$__System.registerDynamic("46", ["48", "47"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _lodash = $__require('48');
  var _lodash2 = _interopRequireDefault(_lodash);
  var _parserHelper = $__require('47');
  var _parserHelper2 = _interopRequireDefault(_parserHelper);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var ValidationGeneratorHelper = {
    hasRestrictions: function hasRestrictions(attrs, messages) {
      var hasValidation = false;
      _lodash2.default.each(messages, function(msg, key) {
        if (_lodash2.default.has(attrs, key)) {
          hasValidation = true;
        }
      });
      return hasValidation;
    },
    getValidationMessage: function getValidationMessage(allowedRestrictions, attrs) {
      var setRestrictions = {};
      _lodash2.default.each(allowedRestrictions, function(msg, type) {
        if (_lodash2.default.has(attrs, type)) {
          var messageAttr = type + "Message";
          if (_lodash2.default.has(attrs, messageAttr)) {
            msg = attrs[messageAttr];
          } else if (msg == null) {
            throw new Error("You must provide an validation error message for: " + type);
          }
          var replace = '{' + type + '}';
          msg = msg.replace(replace, attrs[type]);
          if (type.indexOf("ng") === 0) {
            type = type.substr(2);
            type = type[0].toLowerCase() + type.substr(1);
          }
          setRestrictions[type] = msg;
        }
      });
      return setRestrictions;
    },
    generateMessageContainer: function generateMessageContainer(elem, name, attrs) {
      if (_lodash2.default.startsWith(attrs.name, "{{")) {
        return null;
      }
      var messageName = "_form." + name + ".$error";
      var div = angular.element('<div ng-messages="' + messageName + '" multiple md-auto-hide="false" role="alert"></div>');
      elem.after(div);
      return div;
    },
    generateMessageDiv: function generateMessageDiv(element, messageContainer, allowedRestrictions, attrs) {
      var scope = angular.element(element).scope();
      if (attrs.ngRequired && scope && scope.$parent.$eval(attrs.ngRequired) === true) {
        attrs.required = true;
      }
      if (attrs.required) {
        attrs.required = true;
      }
      if (ValidationGeneratorHelper.hasRestrictions(attrs, allowedRestrictions) && messageContainer) {
        var messages = this.getValidationMessage(allowedRestrictions, attrs);
        var html = "";
        var containerValue = messageContainer.attr("ng-messages");
        _lodash2.default.each(messages, function(msg, prop) {
          var elemName = containerValue.replace(".$error", "");
          var ngif = elemName + ".$touched||_form.$submitted";
          html += '<div ng-message="' + prop + '"><span ng-if="' + ngif + '">' + msg + '</span></div>';
        });
        messageContainer.html(html);
      }
      return true;
    }
  };
  exports.default = ValidationGeneratorHelper;
  return module.exports;
});

$__System.registerDynamic("49", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  Object.defineProperty(exports, "__esModule", {value: true});
  var LIVE_EDITS = false;
  exports.default = {isLiveEditEnabled: function isLiveEditEnabled() {
      return LIVE_EDITS;
    }};
  return module.exports;
});

$__System.registerDynamic("4a", ["4b", "4c", "4d", "4e", "48", "4f", "50", "47"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _typeof2 = $__require('4b');
  var _typeof3 = _interopRequireDefault(_typeof2);
  var _defineProperty2 = $__require('4c');
  var _defineProperty3 = _interopRequireDefault(_defineProperty2);
  var _classCallCheck2 = $__require('4d');
  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
  var _createClass2 = $__require('4e');
  var _createClass3 = _interopRequireDefault(_createClass2);
  var _lodash = $__require('48');
  var _lodash2 = _interopRequireDefault(_lodash);
  var _index = $__require('4f');
  var _index2 = _interopRequireDefault(_index);
  var _moment = $__require('50');
  var _moment2 = _interopRequireDefault(_moment);
  var _parserHelper = $__require('47');
  var _parserHelper2 = _interopRequireDefault(_parserHelper);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var ID_PROP;
  var HEADER_API_VERSION = 'application/json;version=1';
  var keptID = Math.floor(Date.now() / 1000);
  function parseURL(url) {
    if (url.indexOf("?") === -1)
      return {};
    var params = url.substr(url.indexOf("?") + 1).split("&");
    var results = [];
    _lodash2.default.each(params, function(part) {
      var item = part.split("=");
      try {
        var str = decodeURIComponent(item[1]).replace(/\+/g, " ");
        results[item[0]] = JSON.parse(str);
      } catch (e) {}
    });
    return results;
  }
  function _filter(url, obj) {
    var params = parseURL(url);
    obj = angular.copy(obj);
    if (params.sorting && _lodash2.default.isObject(params.sorting)) {
      var col = [],
          order = [];
      _lodash2.default.each(params.sorting, function(value, name) {
        col.push(name);
        order.push(value);
      });
      if (col.length) {
        obj = _lodash2.default.orderBy(obj, col, order);
      }
    }
    var setFilter = function setFilter(filters, name, value) {
      var reservedFilters = ['sorting', 'count', 'page'];
      if (reservedFilters.indexOf(name) === -1) {
        filters[name] = value;
        return true;
      }
      return false;
    };
    var shouldFilterRecord = function shouldFilterRecord(record, filters) {
      var foundRecord = true;
      _lodash2.default.each(filters, function(value, name) {
        if (!_lodash2.default.has(record, name)) {
          foundRecord = false;
          return;
        }
        if (!_lodash2.default.isArray(value)) {
          value = [value];
        }
        if (value.length == 0) {
          return;
        }
        var foundInFilter = false;
        _lodash2.default.each(value, function(itemValue) {
          switch (true) {
            case _lodash2.default.isNumber(itemValue):
              if (_parserHelper2.default.convertToNumber(record[name]) == itemValue) {
                foundInFilter = true;
              }
              break;
            case _lodash2.default.isString(itemValue):
              if (_lodash2.default.startsWith(record[name], itemValue)) {
                foundInFilter = true;
              }
              break;
            case _lodash2.default.isObject(itemValue):
              console.log("Object nested filtering on prototype mode is not yet supported. Obviously this needs to be eventually.");
              foundRecord = false;
              break;
            default:
              console.log("Not sure how to parse the following to filter it", name, itemValue);
              foundRecord = false;
          }
        });
        if (!foundInFilter) {
          foundRecord = false;
        }
      });
      return foundRecord;
    };
    if (params.filter && _lodash2.default.isObject(params.filter)) {
      var filters = {};
      _lodash2.default.each(params.filter, function(value, name) {
        if (value !== null) {
          filters[name] = value;
        }
      });
      obj = _lodash2.default.filter(obj, function(record) {
        return shouldFilterRecord(record, filters);
      });
      if (!_lodash2.default.isArray(obj)) {
        obj = [];
      }
    }
    var totalCount = obj.length;
    if (params.count && _lodash2.default.isNumber(params.count) && params.count != 1) {
      var start = 0;
      var end = params.count;
      if (params.page && _lodash2.default.isNumber(params.page)) {
        start = params.page * params.count - params.count;
        end = start + params.count;
      }
      obj = _lodash2.default.slice(obj, start, end);
    }
    return {
      inlineCount: totalCount,
      results: obj
    };
  }
  function addId(data) {
    if (_parserHelper2.default.isObject(data) && !_lodash2.default.has(data, ID_PROP)) {
      keptID++;
      data[ID_PROP] = keptID;
    }
    if (_parserHelper2.default.isContainer(data)) {
      _lodash2.default.each(data, function(value, key) {
        if (_parserHelper2.default.isContainer(value)) {
          data[key] = addId(value);
        }
      }, this);
    }
    return data;
  }
  var MockHttp = function() {
    function MockHttp() {
      (0, _classCallCheck3.default)(this, MockHttp);
    }
    (0, _createClass3.default)(MockHttp, [{
      key: 'init',
      value: function init($httpBackend, route, fixture, overrides) {
        if (!_index2.default.config.isPrototypeMode()) {
          return false;
        }
        ID_PROP = _index2.default.config.getIdPropertyName();
        overrides = overrides || {};
        var patternBase = new RegExp('/api/' + route),
            patternGet = new RegExp('/api/' + route + '/\\d+'),
            patternId = new RegExp('/api/' + route + '/(\\d+)');
        var ignoreParams = ["GET", "LIST"];
        function callSet(headers, statusCode, data) {
          headers['Content-Type'] = HEADER_API_VERSION;
          if (data) {
            return [statusCode, data];
          } else {
            return [statusCode];
          }
        }
        function callCustom(fn, method, url, data, headers) {
          var returnData = fn(method, url, data, headers);
          if (returnData.length == 1) {
            return callSet(headers, returnData[0]);
          } else if (returnData.length == 2) {
            return callSet(headers, returnData[0], returnData[1]);
          }
        }
        if (fixture.COLLECTION) {
          $httpBackend.whenGET(patternGet).respond(function(method, url, data, headers) {
            if (overrides.GET) {
              return callCustom(overrides.GET, method, url, data, headers);
            } else {
              var id = parseInt(url.match(patternId)[1], 10);
              var found = _lodash2.default.find(fixture.COLLECTION, function(item) {
                return _lodash2.default.has(item, ID_PROP) && item[ID_PROP] == id;
              });
              if (found) {
                return callSet(headers, 200, found);
              }
              return callSet(headers, 404);
            }
          });
          $httpBackend.whenGET(patternBase).respond(function(method, url, data, headers) {
            if (overrides.LIST) {
              return callCustom(overrides.LIST, method, url, data, headers);
            } else {
              var returnObj = _filter(url, fixture.COLLECTION);
              return callSet(headers, 200, returnObj);
            }
          });
        } else {
          fixture.COLLECTION = [];
        }
        _lodash2.default.each(fixture, function(value, param) {
          if (ignoreParams.indexOf(param) === -1) {
            var regBase = new RegExp('/api/' + param);
            $httpBackend.whenGET(regBase).respond(function(method, url, data, headers) {
              console.log('GET', url);
              headers['Content-Type'] = HEADER_API_VERSION;
              if (fixture[param]) {
                return [200, fixture[param]];
              }
              console.log("===== MOCK DATA FETCH FAILURE =======");
              console.log(param);
              console.log(fixture);
              return [404];
            });
          }
        });
        $httpBackend.whenPOST(patternBase).respond(function(method, url, data, headers) {
          try {
            data = addId(JSON.parse(data));
            data.CreatedOn = (0, _moment2.default)().format();
            data.ModifiedOn = (0, _moment2.default)().format();
          } catch (e) {}
          if (overrides.POST) {
            return callCustom(overrides.POST, method, url, data, headers);
          } else {
            console.log('POST', url);
            headers['Content-Type'] = HEADER_API_VERSION;
            fixture.COLLECTION.push(data);
            return [201, (0, _defineProperty3.default)({}, ID_PROP, data[ID_PROP])];
          }
        });
        $httpBackend.whenPUT(patternGet).respond(function(method, url, data, headers) {
          try {
            data = addId(JSON.parse(data));
            data.ModifiedOn = (0, _moment2.default)().format();
          } catch (e) {}
          if (overrides.PUT) {
            return callCustom(overrides.PUT, method, url, data, headers);
          } else {
            console.log('PUT', url);
            headers['Content-Type'] = HEADER_API_VERSION;
            if (!_lodash2.default.has(data, ID_PROP)) {
              console.log("==== NO " + ID_PROP + " IN THE PUT DATA. NEED THIS AS AN IDENTIFIER!====");
              return [500];
            }
            var id = data[ID_PROP];
            var foundItem = false;
            for (var i = 0; i < fixture.COLLECTION.length; i++) {
              if (_lodash2.default.has(fixture.COLLECTION[i], ID_PROP) && fixture.COLLECTION[i][ID_PROP] == id) {
                foundItem = true;
                fixture.COLLECTION[i] = data;
                break;
              }
            }
            if (!foundItem) {
              return [404];
            }
            return [200, data];
          }
        });
        $httpBackend.whenDELETE(patternGet).respond(function(method, url, data, headers) {
          if (overrides.DELETE) {
            return callCustom(overrides.DELETE, method, url, data, headers);
          } else {
            var originalLength;
            var _ret = function() {
              console.log('DELETE', url);
              headers['Content-Type'] = HEADER_API_VERSION;
              var id = url.match(patternId)[1];
              originalLength = fixture.COLLECTION.length;
              fixture.COLLECTION = _lodash2.default.filter(fixture.COLLECTION, function(item) {
                return item[ID_PROP] != id;
              });
              if (originalLength == fixture.COLLECTION.length && fixture.COLLECTION.length > 0) {
                console.log("DELETE couldn't find identifier: ", id);
                return {v: [404]};
              }
              return {v: [204]};
            }();
            if ((typeof _ret === 'undefined' ? 'undefined' : (0, _typeof3.default)(_ret)) === "object")
              return _ret.v;
          }
        });
        return this;
      }
    }, {
      key: 'filter',
      value: function filter(url, obj) {
        return _filter(url, obj);
      }
    }]);
    return MockHttp;
  }();
  exports.default = MockHttp;
  return module.exports;
});

$__System.registerDynamic("51", [], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    "format global";
    !function(e) {
      if ("object" == typeof exports && "undefined" != typeof module)
        module.exports = e();
      else if ("function" == typeof define && define.amd)
        define([], e);
      else {
        var f;
        "undefined" != typeof window ? f = window : "undefined" != typeof global ? f = global : "undefined" != typeof self && (f = self), f.Promise = e();
      }
    }(function() {
      var define,
          module,
          exports;
      return (function e(t, n, r) {
        function s(o, u) {
          if (!n[o]) {
            if (!t[o]) {
              var a = typeof _dereq_ == "function" && _dereq_;
              if (!u && a)
                return a(o, !0);
              if (i)
                return i(o, !0);
              var f = new Error("Cannot find module '" + o + "'");
              throw f.code = "MODULE_NOT_FOUND", f;
            }
            var l = n[o] = {exports: {}};
            t[o][0].call(l.exports, function(e) {
              var n = t[o][1][e];
              return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
          }
          return n[o].exports;
        }
        var i = typeof _dereq_ == "function" && _dereq_;
        for (var o = 0; o < r.length; o++)
          s(r[o]);
        return s;
      })({
        1: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise) {
            var SomePromiseArray = Promise._SomePromiseArray;
            function any(promises) {
              var ret = new SomePromiseArray(promises);
              var promise = ret.promise();
              ret.setHowMany(1);
              ret.setUnwrap();
              ret.init();
              return promise;
            }
            Promise.any = function(promises) {
              return any(promises);
            };
            Promise.prototype.any = function() {
              return any(this);
            };
          };
        }, {}],
        2: [function(_dereq_, module, exports) {
          "use strict";
          var firstLineError;
          try {
            throw new Error();
          } catch (e) {
            firstLineError = e;
          }
          var schedule = _dereq_("./schedule");
          var Queue = _dereq_("./queue");
          var util = _dereq_("./util");
          function Async() {
            this._customScheduler = false;
            this._isTickUsed = false;
            this._lateQueue = new Queue(16);
            this._normalQueue = new Queue(16);
            this._haveDrainedQueues = false;
            this._trampolineEnabled = true;
            var self = this;
            this.drainQueues = function() {
              self._drainQueues();
            };
            this._schedule = schedule;
          }
          Async.prototype.setScheduler = function(fn) {
            var prev = this._schedule;
            this._schedule = fn;
            this._customScheduler = true;
            return prev;
          };
          Async.prototype.hasCustomScheduler = function() {
            return this._customScheduler;
          };
          Async.prototype.enableTrampoline = function() {
            this._trampolineEnabled = true;
          };
          Async.prototype.disableTrampolineIfNecessary = function() {
            if (util.hasDevTools) {
              this._trampolineEnabled = false;
            }
          };
          Async.prototype.haveItemsQueued = function() {
            return this._isTickUsed || this._haveDrainedQueues;
          };
          Async.prototype.fatalError = function(e, isNode) {
            if (isNode) {
              process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) + "\n");
              process.exit(2);
            } else {
              this.throwLater(e);
            }
          };
          Async.prototype.throwLater = function(fn, arg) {
            if (arguments.length === 1) {
              arg = fn;
              fn = function() {
                throw arg;
              };
            }
            if (typeof setTimeout !== "undefined") {
              setTimeout(function() {
                fn(arg);
              }, 0);
            } else
              try {
                this._schedule(function() {
                  fn(arg);
                });
              } catch (e) {
                throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
              }
          };
          function AsyncInvokeLater(fn, receiver, arg) {
            this._lateQueue.push(fn, receiver, arg);
            this._queueTick();
          }
          function AsyncInvoke(fn, receiver, arg) {
            this._normalQueue.push(fn, receiver, arg);
            this._queueTick();
          }
          function AsyncSettlePromises(promise) {
            this._normalQueue._pushOne(promise);
            this._queueTick();
          }
          if (!util.hasDevTools) {
            Async.prototype.invokeLater = AsyncInvokeLater;
            Async.prototype.invoke = AsyncInvoke;
            Async.prototype.settlePromises = AsyncSettlePromises;
          } else {
            Async.prototype.invokeLater = function(fn, receiver, arg) {
              if (this._trampolineEnabled) {
                AsyncInvokeLater.call(this, fn, receiver, arg);
              } else {
                this._schedule(function() {
                  setTimeout(function() {
                    fn.call(receiver, arg);
                  }, 100);
                });
              }
            };
            Async.prototype.invoke = function(fn, receiver, arg) {
              if (this._trampolineEnabled) {
                AsyncInvoke.call(this, fn, receiver, arg);
              } else {
                this._schedule(function() {
                  fn.call(receiver, arg);
                });
              }
            };
            Async.prototype.settlePromises = function(promise) {
              if (this._trampolineEnabled) {
                AsyncSettlePromises.call(this, promise);
              } else {
                this._schedule(function() {
                  promise._settlePromises();
                });
              }
            };
          }
          Async.prototype.invokeFirst = function(fn, receiver, arg) {
            this._normalQueue.unshift(fn, receiver, arg);
            this._queueTick();
          };
          Async.prototype._drainQueue = function(queue) {
            while (queue.length() > 0) {
              var fn = queue.shift();
              if (typeof fn !== "function") {
                fn._settlePromises();
                continue;
              }
              var receiver = queue.shift();
              var arg = queue.shift();
              fn.call(receiver, arg);
            }
          };
          Async.prototype._drainQueues = function() {
            this._drainQueue(this._normalQueue);
            this._reset();
            this._haveDrainedQueues = true;
            this._drainQueue(this._lateQueue);
          };
          Async.prototype._queueTick = function() {
            if (!this._isTickUsed) {
              this._isTickUsed = true;
              this._schedule(this.drainQueues);
            }
          };
          Async.prototype._reset = function() {
            this._isTickUsed = false;
          };
          module.exports = Async;
          module.exports.firstLineError = firstLineError;
        }, {
          "./queue": 26,
          "./schedule": 29,
          "./util": 36
        }],
        3: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, INTERNAL, tryConvertToPromise, debug) {
            var calledBind = false;
            var rejectThis = function(_, e) {
              this._reject(e);
            };
            var targetRejected = function(e, context) {
              context.promiseRejectionQueued = true;
              context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
            };
            var bindingResolved = function(thisArg, context) {
              if (((this._bitField & 50397184) === 0)) {
                this._resolveCallback(context.target);
              }
            };
            var bindingRejected = function(e, context) {
              if (!context.promiseRejectionQueued)
                this._reject(e);
            };
            Promise.prototype.bind = function(thisArg) {
              if (!calledBind) {
                calledBind = true;
                Promise.prototype._propagateFrom = debug.propagateFromFunction();
                Promise.prototype._boundValue = debug.boundValueFunction();
              }
              var maybePromise = tryConvertToPromise(thisArg);
              var ret = new Promise(INTERNAL);
              ret._propagateFrom(this, 1);
              var target = this._target();
              ret._setBoundTo(maybePromise);
              if (maybePromise instanceof Promise) {
                var context = {
                  promiseRejectionQueued: false,
                  promise: ret,
                  target: target,
                  bindingPromise: maybePromise
                };
                target._then(INTERNAL, targetRejected, undefined, ret, context);
                maybePromise._then(bindingResolved, bindingRejected, undefined, ret, context);
                ret._setOnCancel(maybePromise);
              } else {
                ret._resolveCallback(target);
              }
              return ret;
            };
            Promise.prototype._setBoundTo = function(obj) {
              if (obj !== undefined) {
                this._bitField = this._bitField | 2097152;
                this._boundTo = obj;
              } else {
                this._bitField = this._bitField & (~2097152);
              }
            };
            Promise.prototype._isBound = function() {
              return (this._bitField & 2097152) === 2097152;
            };
            Promise.bind = function(thisArg, value) {
              return Promise.resolve(value).bind(thisArg);
            };
          };
        }, {}],
        4: [function(_dereq_, module, exports) {
          "use strict";
          var old;
          if (typeof Promise !== "undefined")
            old = Promise;
          function noConflict() {
            try {
              if (Promise === bluebird)
                Promise = old;
            } catch (e) {}
            return bluebird;
          }
          var bluebird = _dereq_("./promise")();
          bluebird.noConflict = noConflict;
          module.exports = bluebird;
        }, {"./promise": 22}],
        5: [function(_dereq_, module, exports) {
          "use strict";
          var cr = Object.create;
          if (cr) {
            var callerCache = cr(null);
            var getterCache = cr(null);
            callerCache[" size"] = getterCache[" size"] = 0;
          }
          module.exports = function(Promise) {
            var util = _dereq_("./util");
            var canEvaluate = util.canEvaluate;
            var isIdentifier = util.isIdentifier;
            var getMethodCaller;
            var getGetter;
            if (!true) {
              var makeMethodCaller = function(methodName) {
                return new Function("ensureMethod", "                                    \n\
        return function(obj) {                                               \n\
            'use strict'                                                     \n\
            var len = this.length;                                           \n\
            ensureMethod(obj, 'methodName');                                 \n\
            switch(len) {                                                    \n\
                case 1: return obj.methodName(this[0]);                      \n\
                case 2: return obj.methodName(this[0], this[1]);             \n\
                case 3: return obj.methodName(this[0], this[1], this[2]);    \n\
                case 0: return obj.methodName();                             \n\
                default:                                                     \n\
                    return obj.methodName.apply(obj, this);                  \n\
            }                                                                \n\
        };                                                                   \n\
        ".replace(/methodName/g, methodName))(ensureMethod);
              };
              var makeGetter = function(propertyName) {
                return new Function("obj", "                                             \n\
        'use strict';                                                        \n\
        return obj.propertyName;                                             \n\
        ".replace("propertyName", propertyName));
              };
              var getCompiled = function(name, compiler, cache) {
                var ret = cache[name];
                if (typeof ret !== "function") {
                  if (!isIdentifier(name)) {
                    return null;
                  }
                  ret = compiler(name);
                  cache[name] = ret;
                  cache[" size"]++;
                  if (cache[" size"] > 512) {
                    var keys = Object.keys(cache);
                    for (var i = 0; i < 256; ++i)
                      delete cache[keys[i]];
                    cache[" size"] = keys.length - 256;
                  }
                }
                return ret;
              };
              getMethodCaller = function(name) {
                return getCompiled(name, makeMethodCaller, callerCache);
              };
              getGetter = function(name) {
                return getCompiled(name, makeGetter, getterCache);
              };
            }
            function ensureMethod(obj, methodName) {
              var fn;
              if (obj != null)
                fn = obj[methodName];
              if (typeof fn !== "function") {
                var message = "Object " + util.classString(obj) + " has no method '" + util.toString(methodName) + "'";
                throw new Promise.TypeError(message);
              }
              return fn;
            }
            function caller(obj) {
              var methodName = this.pop();
              var fn = ensureMethod(obj, methodName);
              return fn.apply(obj, this);
            }
            Promise.prototype.call = function(methodName) {
              var args = [].slice.call(arguments, 1);
              ;
              if (!true) {
                if (canEvaluate) {
                  var maybeCaller = getMethodCaller(methodName);
                  if (maybeCaller !== null) {
                    return this._then(maybeCaller, undefined, undefined, args, undefined);
                  }
                }
              }
              args.push(methodName);
              return this._then(caller, undefined, undefined, args, undefined);
            };
            function namedGetter(obj) {
              return obj[this];
            }
            function indexedGetter(obj) {
              var index = +this;
              if (index < 0)
                index = Math.max(0, index + obj.length);
              return obj[index];
            }
            Promise.prototype.get = function(propertyName) {
              var isIndex = (typeof propertyName === "number");
              var getter;
              if (!isIndex) {
                if (canEvaluate) {
                  var maybeGetter = getGetter(propertyName);
                  getter = maybeGetter !== null ? maybeGetter : namedGetter;
                } else {
                  getter = namedGetter;
                }
              } else {
                getter = indexedGetter;
              }
              return this._then(getter, undefined, undefined, propertyName, undefined);
            };
          };
        }, {"./util": 36}],
        6: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, PromiseArray, apiRejection, debug) {
            var util = _dereq_("./util");
            var tryCatch = util.tryCatch;
            var errorObj = util.errorObj;
            var async = Promise._async;
            Promise.prototype["break"] = Promise.prototype.cancel = function() {
              if (!debug.cancellation())
                return this._warn("cancellation is disabled");
              var promise = this;
              var child = promise;
              while (promise.isCancellable()) {
                if (!promise._cancelBy(child)) {
                  if (child._isFollowing()) {
                    child._followee().cancel();
                  } else {
                    child._cancelBranched();
                  }
                  break;
                }
                var parent = promise._cancellationParent;
                if (parent == null || !parent.isCancellable()) {
                  if (promise._isFollowing()) {
                    promise._followee().cancel();
                  } else {
                    promise._cancelBranched();
                  }
                  break;
                } else {
                  if (promise._isFollowing())
                    promise._followee().cancel();
                  child = promise;
                  promise = parent;
                }
              }
            };
            Promise.prototype._branchHasCancelled = function() {
              this._branchesRemainingToCancel--;
            };
            Promise.prototype._enoughBranchesHaveCancelled = function() {
              return this._branchesRemainingToCancel === undefined || this._branchesRemainingToCancel <= 0;
            };
            Promise.prototype._cancelBy = function(canceller) {
              if (canceller === this) {
                this._branchesRemainingToCancel = 0;
                this._invokeOnCancel();
                return true;
              } else {
                this._branchHasCancelled();
                if (this._enoughBranchesHaveCancelled()) {
                  this._invokeOnCancel();
                  return true;
                }
              }
              return false;
            };
            Promise.prototype._cancelBranched = function() {
              if (this._enoughBranchesHaveCancelled()) {
                this._cancel();
              }
            };
            Promise.prototype._cancel = function() {
              if (!this.isCancellable())
                return;
              this._setCancelled();
              async.invoke(this._cancelPromises, this, undefined);
            };
            Promise.prototype._cancelPromises = function() {
              if (this._length() > 0)
                this._settlePromises();
            };
            Promise.prototype._unsetOnCancel = function() {
              this._onCancelField = undefined;
            };
            Promise.prototype.isCancellable = function() {
              return this.isPending() && !this.isCancelled();
            };
            Promise.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
              if (util.isArray(onCancelCallback)) {
                for (var i = 0; i < onCancelCallback.length; ++i) {
                  this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
                }
              } else if (onCancelCallback !== undefined) {
                if (typeof onCancelCallback === "function") {
                  if (!internalOnly) {
                    var e = tryCatch(onCancelCallback).call(this._boundValue());
                    if (e === errorObj) {
                      this._attachExtraTrace(e.e);
                      async.throwLater(e.e);
                    }
                  }
                } else {
                  onCancelCallback._resultCancelled(this);
                }
              }
            };
            Promise.prototype._invokeOnCancel = function() {
              var onCancelCallback = this._onCancel();
              this._unsetOnCancel();
              async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
            };
            Promise.prototype._invokeInternalOnCancel = function() {
              if (this.isCancellable()) {
                this._doInvokeOnCancel(this._onCancel(), true);
                this._unsetOnCancel();
              }
            };
            Promise.prototype._resultCancelled = function() {
              this.cancel();
            };
          };
        }, {"./util": 36}],
        7: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(NEXT_FILTER) {
            var util = _dereq_("./util");
            var getKeys = _dereq_("./es5").keys;
            var tryCatch = util.tryCatch;
            var errorObj = util.errorObj;
            function catchFilter(instances, cb, promise) {
              return function(e) {
                var boundTo = promise._boundValue();
                predicateLoop: for (var i = 0; i < instances.length; ++i) {
                  var item = instances[i];
                  if (item === Error || (item != null && item.prototype instanceof Error)) {
                    if (e instanceof item) {
                      return tryCatch(cb).call(boundTo, e);
                    }
                  } else if (typeof item === "function") {
                    var matchesPredicate = tryCatch(item).call(boundTo, e);
                    if (matchesPredicate === errorObj) {
                      return matchesPredicate;
                    } else if (matchesPredicate) {
                      return tryCatch(cb).call(boundTo, e);
                    }
                  } else if (util.isObject(e)) {
                    var keys = getKeys(item);
                    for (var j = 0; j < keys.length; ++j) {
                      var key = keys[j];
                      if (item[key] != e[key]) {
                        continue predicateLoop;
                      }
                    }
                    return tryCatch(cb).call(boundTo, e);
                  }
                }
                return NEXT_FILTER;
              };
            }
            return catchFilter;
          };
        }, {
          "./es5": 13,
          "./util": 36
        }],
        8: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise) {
            var longStackTraces = false;
            var contextStack = [];
            Promise.prototype._promiseCreated = function() {};
            Promise.prototype._pushContext = function() {};
            Promise.prototype._popContext = function() {
              return null;
            };
            Promise._peekContext = Promise.prototype._peekContext = function() {};
            function Context() {
              this._trace = new Context.CapturedTrace(peekContext());
            }
            Context.prototype._pushContext = function() {
              if (this._trace !== undefined) {
                this._trace._promiseCreated = null;
                contextStack.push(this._trace);
              }
            };
            Context.prototype._popContext = function() {
              if (this._trace !== undefined) {
                var trace = contextStack.pop();
                var ret = trace._promiseCreated;
                trace._promiseCreated = null;
                return ret;
              }
              return null;
            };
            function createContext() {
              if (longStackTraces)
                return new Context();
            }
            function peekContext() {
              var lastIndex = contextStack.length - 1;
              if (lastIndex >= 0) {
                return contextStack[lastIndex];
              }
              return undefined;
            }
            Context.CapturedTrace = null;
            Context.create = createContext;
            Context.deactivateLongStackTraces = function() {};
            Context.activateLongStackTraces = function() {
              var Promise_pushContext = Promise.prototype._pushContext;
              var Promise_popContext = Promise.prototype._popContext;
              var Promise_PeekContext = Promise._peekContext;
              var Promise_peekContext = Promise.prototype._peekContext;
              var Promise_promiseCreated = Promise.prototype._promiseCreated;
              Context.deactivateLongStackTraces = function() {
                Promise.prototype._pushContext = Promise_pushContext;
                Promise.prototype._popContext = Promise_popContext;
                Promise._peekContext = Promise_PeekContext;
                Promise.prototype._peekContext = Promise_peekContext;
                Promise.prototype._promiseCreated = Promise_promiseCreated;
                longStackTraces = false;
              };
              longStackTraces = true;
              Promise.prototype._pushContext = Context.prototype._pushContext;
              Promise.prototype._popContext = Context.prototype._popContext;
              Promise._peekContext = Promise.prototype._peekContext = peekContext;
              Promise.prototype._promiseCreated = function() {
                var ctx = this._peekContext();
                if (ctx && ctx._promiseCreated == null)
                  ctx._promiseCreated = this;
              };
            };
            return Context;
          };
        }, {}],
        9: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, Context) {
            var getDomain = Promise._getDomain;
            var async = Promise._async;
            var Warning = _dereq_("./errors").Warning;
            var util = _dereq_("./util");
            var canAttachTrace = util.canAttachTrace;
            var unhandledRejectionHandled;
            var possiblyUnhandledRejection;
            var bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
            var stackFramePattern = null;
            var formatStack = null;
            var indentStackFrames = false;
            var printWarning;
            var debugging = !!(util.env("BLUEBIRD_DEBUG") != 0 && (true || util.env("BLUEBIRD_DEBUG") || util.env("NODE_ENV") === "development"));
            var warnings = !!(util.env("BLUEBIRD_WARNINGS") != 0 && (debugging || util.env("BLUEBIRD_WARNINGS")));
            var longStackTraces = !!(util.env("BLUEBIRD_LONG_STACK_TRACES") != 0 && (debugging || util.env("BLUEBIRD_LONG_STACK_TRACES")));
            var wForgottenReturn = util.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 && (warnings || !!util.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
            Promise.prototype.suppressUnhandledRejections = function() {
              var target = this._target();
              target._bitField = ((target._bitField & (~1048576)) | 524288);
            };
            Promise.prototype._ensurePossibleRejectionHandled = function() {
              if ((this._bitField & 524288) !== 0)
                return;
              this._setRejectionIsUnhandled();
              async.invokeLater(this._notifyUnhandledRejection, this, undefined);
            };
            Promise.prototype._notifyUnhandledRejectionIsHandled = function() {
              fireRejectionEvent("rejectionHandled", unhandledRejectionHandled, undefined, this);
            };
            Promise.prototype._setReturnedNonUndefined = function() {
              this._bitField = this._bitField | 268435456;
            };
            Promise.prototype._returnedNonUndefined = function() {
              return (this._bitField & 268435456) !== 0;
            };
            Promise.prototype._notifyUnhandledRejection = function() {
              if (this._isRejectionUnhandled()) {
                var reason = this._settledValue();
                this._setUnhandledRejectionIsNotified();
                fireRejectionEvent("unhandledRejection", possiblyUnhandledRejection, reason, this);
              }
            };
            Promise.prototype._setUnhandledRejectionIsNotified = function() {
              this._bitField = this._bitField | 262144;
            };
            Promise.prototype._unsetUnhandledRejectionIsNotified = function() {
              this._bitField = this._bitField & (~262144);
            };
            Promise.prototype._isUnhandledRejectionNotified = function() {
              return (this._bitField & 262144) > 0;
            };
            Promise.prototype._setRejectionIsUnhandled = function() {
              this._bitField = this._bitField | 1048576;
            };
            Promise.prototype._unsetRejectionIsUnhandled = function() {
              this._bitField = this._bitField & (~1048576);
              if (this._isUnhandledRejectionNotified()) {
                this._unsetUnhandledRejectionIsNotified();
                this._notifyUnhandledRejectionIsHandled();
              }
            };
            Promise.prototype._isRejectionUnhandled = function() {
              return (this._bitField & 1048576) > 0;
            };
            Promise.prototype._warn = function(message, shouldUseOwnTrace, promise) {
              return warn(message, shouldUseOwnTrace, promise || this);
            };
            Promise.onPossiblyUnhandledRejection = function(fn) {
              var domain = getDomain();
              possiblyUnhandledRejection = typeof fn === "function" ? (domain === null ? fn : domain.bind(fn)) : undefined;
            };
            Promise.onUnhandledRejectionHandled = function(fn) {
              var domain = getDomain();
              unhandledRejectionHandled = typeof fn === "function" ? (domain === null ? fn : domain.bind(fn)) : undefined;
            };
            var disableLongStackTraces = function() {};
            Promise.longStackTraces = function() {
              if (async.haveItemsQueued() && !config.longStackTraces) {
                throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
              }
              if (!config.longStackTraces && longStackTracesIsSupported()) {
                var Promise_captureStackTrace = Promise.prototype._captureStackTrace;
                var Promise_attachExtraTrace = Promise.prototype._attachExtraTrace;
                config.longStackTraces = true;
                disableLongStackTraces = function() {
                  if (async.haveItemsQueued() && !config.longStackTraces) {
                    throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
                  }
                  Promise.prototype._captureStackTrace = Promise_captureStackTrace;
                  Promise.prototype._attachExtraTrace = Promise_attachExtraTrace;
                  Context.deactivateLongStackTraces();
                  async.enableTrampoline();
                  config.longStackTraces = false;
                };
                Promise.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
                Promise.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
                Context.activateLongStackTraces();
                async.disableTrampolineIfNecessary();
              }
            };
            Promise.hasLongStackTraces = function() {
              return config.longStackTraces && longStackTracesIsSupported();
            };
            var fireDomEvent = (function() {
              try {
                var event = document.createEvent("CustomEvent");
                event.initCustomEvent("testingtheevent", false, true, {});
                util.global.dispatchEvent(event);
                return function(name, event) {
                  var domEvent = document.createEvent("CustomEvent");
                  domEvent.initCustomEvent(name.toLowerCase(), false, true, event);
                  return !util.global.dispatchEvent(domEvent);
                };
              } catch (e) {}
              return function() {
                return false;
              };
            })();
            var fireGlobalEvent = (function() {
              if (util.isNode) {
                return function() {
                  return process.emit.apply(process, arguments);
                };
              } else {
                if (!util.global) {
                  return function() {
                    return false;
                  };
                }
                return function(name) {
                  var methodName = "on" + name.toLowerCase();
                  var method = util.global[methodName];
                  if (!method)
                    return false;
                  method.apply(util.global, [].slice.call(arguments, 1));
                  return true;
                };
              }
            })();
            function generatePromiseLifecycleEventObject(name, promise) {
              return {promise: promise};
            }
            var eventToObjectGenerator = {
              promiseCreated: generatePromiseLifecycleEventObject,
              promiseFulfilled: generatePromiseLifecycleEventObject,
              promiseRejected: generatePromiseLifecycleEventObject,
              promiseResolved: generatePromiseLifecycleEventObject,
              promiseCancelled: generatePromiseLifecycleEventObject,
              promiseChained: function(name, promise, child) {
                return {
                  promise: promise,
                  child: child
                };
              },
              warning: function(name, warning) {
                return {warning: warning};
              },
              unhandledRejection: function(name, reason, promise) {
                return {
                  reason: reason,
                  promise: promise
                };
              },
              rejectionHandled: generatePromiseLifecycleEventObject
            };
            var activeFireEvent = function(name) {
              var globalEventFired = false;
              try {
                globalEventFired = fireGlobalEvent.apply(null, arguments);
              } catch (e) {
                async.throwLater(e);
                globalEventFired = true;
              }
              var domEventFired = false;
              try {
                domEventFired = fireDomEvent(name, eventToObjectGenerator[name].apply(null, arguments));
              } catch (e) {
                async.throwLater(e);
                domEventFired = true;
              }
              return domEventFired || globalEventFired;
            };
            Promise.config = function(opts) {
              opts = Object(opts);
              if ("longStackTraces" in opts) {
                if (opts.longStackTraces) {
                  Promise.longStackTraces();
                } else if (!opts.longStackTraces && Promise.hasLongStackTraces()) {
                  disableLongStackTraces();
                }
              }
              if ("warnings" in opts) {
                var warningsOption = opts.warnings;
                config.warnings = !!warningsOption;
                wForgottenReturn = config.warnings;
                if (util.isObject(warningsOption)) {
                  if ("wForgottenReturn" in warningsOption) {
                    wForgottenReturn = !!warningsOption.wForgottenReturn;
                  }
                }
              }
              if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
                if (async.haveItemsQueued()) {
                  throw new Error("cannot enable cancellation after promises are in use");
                }
                Promise.prototype._clearCancellationData = cancellationClearCancellationData;
                Promise.prototype._propagateFrom = cancellationPropagateFrom;
                Promise.prototype._onCancel = cancellationOnCancel;
                Promise.prototype._setOnCancel = cancellationSetOnCancel;
                Promise.prototype._attachCancellationCallback = cancellationAttachCancellationCallback;
                Promise.prototype._execute = cancellationExecute;
                propagateFromFunction = cancellationPropagateFrom;
                config.cancellation = true;
              }
              if ("monitoring" in opts) {
                if (opts.monitoring && !config.monitoring) {
                  config.monitoring = true;
                  Promise.prototype._fireEvent = activeFireEvent;
                } else if (!opts.monitoring && config.monitoring) {
                  config.monitoring = false;
                  Promise.prototype._fireEvent = defaultFireEvent;
                }
              }
            };
            function defaultFireEvent() {
              return false;
            }
            Promise.prototype._fireEvent = defaultFireEvent;
            Promise.prototype._execute = function(executor, resolve, reject) {
              try {
                executor(resolve, reject);
              } catch (e) {
                return e;
              }
            };
            Promise.prototype._onCancel = function() {};
            Promise.prototype._setOnCancel = function(handler) {
              ;
            };
            Promise.prototype._attachCancellationCallback = function(onCancel) {
              ;
            };
            Promise.prototype._captureStackTrace = function() {};
            Promise.prototype._attachExtraTrace = function() {};
            Promise.prototype._clearCancellationData = function() {};
            Promise.prototype._propagateFrom = function(parent, flags) {
              ;
              ;
            };
            function cancellationExecute(executor, resolve, reject) {
              var promise = this;
              try {
                executor(resolve, reject, function(onCancel) {
                  if (typeof onCancel !== "function") {
                    throw new TypeError("onCancel must be a function, got: " + util.toString(onCancel));
                  }
                  promise._attachCancellationCallback(onCancel);
                });
              } catch (e) {
                return e;
              }
            }
            function cancellationAttachCancellationCallback(onCancel) {
              if (!this.isCancellable())
                return this;
              var previousOnCancel = this._onCancel();
              if (previousOnCancel !== undefined) {
                if (util.isArray(previousOnCancel)) {
                  previousOnCancel.push(onCancel);
                } else {
                  this._setOnCancel([previousOnCancel, onCancel]);
                }
              } else {
                this._setOnCancel(onCancel);
              }
            }
            function cancellationOnCancel() {
              return this._onCancelField;
            }
            function cancellationSetOnCancel(onCancel) {
              this._onCancelField = onCancel;
            }
            function cancellationClearCancellationData() {
              this._cancellationParent = undefined;
              this._onCancelField = undefined;
            }
            function cancellationPropagateFrom(parent, flags) {
              if ((flags & 1) !== 0) {
                this._cancellationParent = parent;
                var branchesRemainingToCancel = parent._branchesRemainingToCancel;
                if (branchesRemainingToCancel === undefined) {
                  branchesRemainingToCancel = 0;
                }
                parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
              }
              if ((flags & 2) !== 0 && parent._isBound()) {
                this._setBoundTo(parent._boundTo);
              }
            }
            function bindingPropagateFrom(parent, flags) {
              if ((flags & 2) !== 0 && parent._isBound()) {
                this._setBoundTo(parent._boundTo);
              }
            }
            var propagateFromFunction = bindingPropagateFrom;
            function boundValueFunction() {
              var ret = this._boundTo;
              if (ret !== undefined) {
                if (ret instanceof Promise) {
                  if (ret.isFulfilled()) {
                    return ret.value();
                  } else {
                    return undefined;
                  }
                }
              }
              return ret;
            }
            function longStackTracesCaptureStackTrace() {
              this._trace = new CapturedTrace(this._peekContext());
            }
            function longStackTracesAttachExtraTrace(error, ignoreSelf) {
              if (canAttachTrace(error)) {
                var trace = this._trace;
                if (trace !== undefined) {
                  if (ignoreSelf)
                    trace = trace._parent;
                }
                if (trace !== undefined) {
                  trace.attachExtraTrace(error);
                } else if (!error.__stackCleaned__) {
                  var parsed = parseStackAndMessage(error);
                  util.notEnumerableProp(error, "stack", parsed.message + "\n" + parsed.stack.join("\n"));
                  util.notEnumerableProp(error, "__stackCleaned__", true);
                }
              }
            }
            function checkForgottenReturns(returnValue, promiseCreated, name, promise, parent) {
              if (returnValue === undefined && promiseCreated !== null && wForgottenReturn) {
                if (parent !== undefined && parent._returnedNonUndefined())
                  return;
                if ((promise._bitField & 65535) === 0)
                  return;
                if (name)
                  name = name + " ";
                var msg = "a promise was created in a " + name + "handler but was not returned from it";
                promise._warn(msg, true, promiseCreated);
              }
            }
            function deprecated(name, replacement) {
              var message = name + " is deprecated and will be removed in a future version.";
              if (replacement)
                message += " Use " + replacement + " instead.";
              return warn(message);
            }
            function warn(message, shouldUseOwnTrace, promise) {
              if (!config.warnings)
                return;
              var warning = new Warning(message);
              var ctx;
              if (shouldUseOwnTrace) {
                promise._attachExtraTrace(warning);
              } else if (config.longStackTraces && (ctx = Promise._peekContext())) {
                ctx.attachExtraTrace(warning);
              } else {
                var parsed = parseStackAndMessage(warning);
                warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
              }
              if (!activeFireEvent("warning", warning)) {
                formatAndLogError(warning, "", true);
              }
            }
            function reconstructStack(message, stacks) {
              for (var i = 0; i < stacks.length - 1; ++i) {
                stacks[i].push("From previous event:");
                stacks[i] = stacks[i].join("\n");
              }
              if (i < stacks.length) {
                stacks[i] = stacks[i].join("\n");
              }
              return message + "\n" + stacks.join("\n");
            }
            function removeDuplicateOrEmptyJumps(stacks) {
              for (var i = 0; i < stacks.length; ++i) {
                if (stacks[i].length === 0 || ((i + 1 < stacks.length) && stacks[i][0] === stacks[i + 1][0])) {
                  stacks.splice(i, 1);
                  i--;
                }
              }
            }
            function removeCommonRoots(stacks) {
              var current = stacks[0];
              for (var i = 1; i < stacks.length; ++i) {
                var prev = stacks[i];
                var currentLastIndex = current.length - 1;
                var currentLastLine = current[currentLastIndex];
                var commonRootMeetPoint = -1;
                for (var j = prev.length - 1; j >= 0; --j) {
                  if (prev[j] === currentLastLine) {
                    commonRootMeetPoint = j;
                    break;
                  }
                }
                for (var j = commonRootMeetPoint; j >= 0; --j) {
                  var line = prev[j];
                  if (current[currentLastIndex] === line) {
                    current.pop();
                    currentLastIndex--;
                  } else {
                    break;
                  }
                }
                current = prev;
              }
            }
            function cleanStack(stack) {
              var ret = [];
              for (var i = 0; i < stack.length; ++i) {
                var line = stack[i];
                var isTraceLine = "    (No stack trace)" === line || stackFramePattern.test(line);
                var isInternalFrame = isTraceLine && shouldIgnore(line);
                if (isTraceLine && !isInternalFrame) {
                  if (indentStackFrames && line.charAt(0) !== " ") {
                    line = "    " + line;
                  }
                  ret.push(line);
                }
              }
              return ret;
            }
            function stackFramesAsArray(error) {
              var stack = error.stack.replace(/\s+$/g, "").split("\n");
              for (var i = 0; i < stack.length; ++i) {
                var line = stack[i];
                if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
                  break;
                }
              }
              if (i > 0) {
                stack = stack.slice(i);
              }
              return stack;
            }
            function parseStackAndMessage(error) {
              var stack = error.stack;
              var message = error.toString();
              stack = typeof stack === "string" && stack.length > 0 ? stackFramesAsArray(error) : ["    (No stack trace)"];
              return {
                message: message,
                stack: cleanStack(stack)
              };
            }
            function formatAndLogError(error, title, isSoft) {
              if (typeof console !== "undefined") {
                var message;
                if (util.isObject(error)) {
                  var stack = error.stack;
                  message = title + formatStack(stack, error);
                } else {
                  message = title + String(error);
                }
                if (typeof printWarning === "function") {
                  printWarning(message, isSoft);
                } else if (typeof console.log === "function" || typeof console.log === "object") {
                  console.log(message);
                }
              }
            }
            function fireRejectionEvent(name, localHandler, reason, promise) {
              var localEventFired = false;
              try {
                if (typeof localHandler === "function") {
                  localEventFired = true;
                  if (name === "rejectionHandled") {
                    localHandler(promise);
                  } else {
                    localHandler(reason, promise);
                  }
                }
              } catch (e) {
                async.throwLater(e);
              }
              if (name === "unhandledRejection") {
                if (!activeFireEvent(name, reason, promise) && !localEventFired) {
                  formatAndLogError(reason, "Unhandled rejection ");
                }
              } else {
                activeFireEvent(name, promise);
              }
            }
            function formatNonError(obj) {
              var str;
              if (typeof obj === "function") {
                str = "[function " + (obj.name || "anonymous") + "]";
              } else {
                str = obj && typeof obj.toString === "function" ? obj.toString() : util.toString(obj);
                var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
                if (ruselessToString.test(str)) {
                  try {
                    var newStr = JSON.stringify(obj);
                    str = newStr;
                  } catch (e) {}
                }
                if (str.length === 0) {
                  str = "(empty array)";
                }
              }
              return ("(<" + snip(str) + ">, no stack trace)");
            }
            function snip(str) {
              var maxChars = 41;
              if (str.length < maxChars) {
                return str;
              }
              return str.substr(0, maxChars - 3) + "...";
            }
            function longStackTracesIsSupported() {
              return typeof captureStackTrace === "function";
            }
            var shouldIgnore = function() {
              return false;
            };
            var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
            function parseLineInfo(line) {
              var matches = line.match(parseLineInfoRegex);
              if (matches) {
                return {
                  fileName: matches[1],
                  line: parseInt(matches[2], 10)
                };
              }
            }
            function setBounds(firstLineError, lastLineError) {
              if (!longStackTracesIsSupported())
                return;
              var firstStackLines = firstLineError.stack.split("\n");
              var lastStackLines = lastLineError.stack.split("\n");
              var firstIndex = -1;
              var lastIndex = -1;
              var firstFileName;
              var lastFileName;
              for (var i = 0; i < firstStackLines.length; ++i) {
                var result = parseLineInfo(firstStackLines[i]);
                if (result) {
                  firstFileName = result.fileName;
                  firstIndex = result.line;
                  break;
                }
              }
              for (var i = 0; i < lastStackLines.length; ++i) {
                var result = parseLineInfo(lastStackLines[i]);
                if (result) {
                  lastFileName = result.fileName;
                  lastIndex = result.line;
                  break;
                }
              }
              if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {
                return;
              }
              shouldIgnore = function(line) {
                if (bluebirdFramePattern.test(line))
                  return true;
                var info = parseLineInfo(line);
                if (info) {
                  if (info.fileName === firstFileName && (firstIndex <= info.line && info.line <= lastIndex)) {
                    return true;
                  }
                }
                return false;
              };
            }
            function CapturedTrace(parent) {
              this._parent = parent;
              this._promisesCreated = 0;
              var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
              captureStackTrace(this, CapturedTrace);
              if (length > 32)
                this.uncycle();
            }
            util.inherits(CapturedTrace, Error);
            Context.CapturedTrace = CapturedTrace;
            CapturedTrace.prototype.uncycle = function() {
              var length = this._length;
              if (length < 2)
                return;
              var nodes = [];
              var stackToIndex = {};
              for (var i = 0,
                  node = this; node !== undefined; ++i) {
                nodes.push(node);
                node = node._parent;
              }
              length = this._length = i;
              for (var i = length - 1; i >= 0; --i) {
                var stack = nodes[i].stack;
                if (stackToIndex[stack] === undefined) {
                  stackToIndex[stack] = i;
                }
              }
              for (var i = 0; i < length; ++i) {
                var currentStack = nodes[i].stack;
                var index = stackToIndex[currentStack];
                if (index !== undefined && index !== i) {
                  if (index > 0) {
                    nodes[index - 1]._parent = undefined;
                    nodes[index - 1]._length = 1;
                  }
                  nodes[i]._parent = undefined;
                  nodes[i]._length = 1;
                  var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
                  if (index < length - 1) {
                    cycleEdgeNode._parent = nodes[index + 1];
                    cycleEdgeNode._parent.uncycle();
                    cycleEdgeNode._length = cycleEdgeNode._parent._length + 1;
                  } else {
                    cycleEdgeNode._parent = undefined;
                    cycleEdgeNode._length = 1;
                  }
                  var currentChildLength = cycleEdgeNode._length + 1;
                  for (var j = i - 2; j >= 0; --j) {
                    nodes[j]._length = currentChildLength;
                    currentChildLength++;
                  }
                  return;
                }
              }
            };
            CapturedTrace.prototype.attachExtraTrace = function(error) {
              if (error.__stackCleaned__)
                return;
              this.uncycle();
              var parsed = parseStackAndMessage(error);
              var message = parsed.message;
              var stacks = [parsed.stack];
              var trace = this;
              while (trace !== undefined) {
                stacks.push(cleanStack(trace.stack.split("\n")));
                trace = trace._parent;
              }
              removeCommonRoots(stacks);
              removeDuplicateOrEmptyJumps(stacks);
              util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
              util.notEnumerableProp(error, "__stackCleaned__", true);
            };
            var captureStackTrace = (function stackDetection() {
              var v8stackFramePattern = /^\s*at\s*/;
              var v8stackFormatter = function(stack, error) {
                if (typeof stack === "string")
                  return stack;
                if (error.name !== undefined && error.message !== undefined) {
                  return error.toString();
                }
                return formatNonError(error);
              };
              if (typeof Error.stackTraceLimit === "number" && typeof Error.captureStackTrace === "function") {
                Error.stackTraceLimit += 6;
                stackFramePattern = v8stackFramePattern;
                formatStack = v8stackFormatter;
                var captureStackTrace = Error.captureStackTrace;
                shouldIgnore = function(line) {
                  return bluebirdFramePattern.test(line);
                };
                return function(receiver, ignoreUntil) {
                  Error.stackTraceLimit += 6;
                  captureStackTrace(receiver, ignoreUntil);
                  Error.stackTraceLimit -= 6;
                };
              }
              var err = new Error();
              if (typeof err.stack === "string" && err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
                stackFramePattern = /@/;
                formatStack = v8stackFormatter;
                indentStackFrames = true;
                return function captureStackTrace(o) {
                  o.stack = new Error().stack;
                };
              }
              var hasStackAfterThrow;
              try {
                throw new Error();
              } catch (e) {
                hasStackAfterThrow = ("stack" in e);
              }
              if (!("stack" in err) && hasStackAfterThrow && typeof Error.stackTraceLimit === "number") {
                stackFramePattern = v8stackFramePattern;
                formatStack = v8stackFormatter;
                return function captureStackTrace(o) {
                  Error.stackTraceLimit += 6;
                  try {
                    throw new Error();
                  } catch (e) {
                    o.stack = e.stack;
                  }
                  Error.stackTraceLimit -= 6;
                };
              }
              formatStack = function(stack, error) {
                if (typeof stack === "string")
                  return stack;
                if ((typeof error === "object" || typeof error === "function") && error.name !== undefined && error.message !== undefined) {
                  return error.toString();
                }
                return formatNonError(error);
              };
              return null;
            })([]);
            if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
              printWarning = function(message) {
                console.warn(message);
              };
              if (util.isNode && process.stderr.isTTY) {
                printWarning = function(message, isSoft) {
                  var color = isSoft ? "\u001b[33m" : "\u001b[31m";
                  console.warn(color + message + "\u001b[0m\n");
                };
              } else if (!util.isNode && typeof(new Error().stack) === "string") {
                printWarning = function(message, isSoft) {
                  console.warn("%c" + message, isSoft ? "color: darkorange" : "color: red");
                };
              }
            }
            var config = {
              warnings: warnings,
              longStackTraces: false,
              cancellation: false,
              monitoring: false
            };
            if (longStackTraces)
              Promise.longStackTraces();
            return {
              longStackTraces: function() {
                return config.longStackTraces;
              },
              warnings: function() {
                return config.warnings;
              },
              cancellation: function() {
                return config.cancellation;
              },
              monitoring: function() {
                return config.monitoring;
              },
              propagateFromFunction: function() {
                return propagateFromFunction;
              },
              boundValueFunction: function() {
                return boundValueFunction;
              },
              checkForgottenReturns: checkForgottenReturns,
              setBounds: setBounds,
              warn: warn,
              deprecated: deprecated,
              CapturedTrace: CapturedTrace,
              fireDomEvent: fireDomEvent,
              fireGlobalEvent: fireGlobalEvent
            };
          };
        }, {
          "./errors": 12,
          "./util": 36
        }],
        10: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise) {
            function returner() {
              return this.value;
            }
            function thrower() {
              throw this.reason;
            }
            Promise.prototype["return"] = Promise.prototype.thenReturn = function(value) {
              if (value instanceof Promise)
                value.suppressUnhandledRejections();
              return this._then(returner, undefined, undefined, {value: value}, undefined);
            };
            Promise.prototype["throw"] = Promise.prototype.thenThrow = function(reason) {
              return this._then(thrower, undefined, undefined, {reason: reason}, undefined);
            };
            Promise.prototype.catchThrow = function(reason) {
              if (arguments.length <= 1) {
                return this._then(undefined, thrower, undefined, {reason: reason}, undefined);
              } else {
                var _reason = arguments[1];
                var handler = function() {
                  throw _reason;
                };
                return this.caught(reason, handler);
              }
            };
            Promise.prototype.catchReturn = function(value) {
              if (arguments.length <= 1) {
                if (value instanceof Promise)
                  value.suppressUnhandledRejections();
                return this._then(undefined, returner, undefined, {value: value}, undefined);
              } else {
                var _value = arguments[1];
                if (_value instanceof Promise)
                  _value.suppressUnhandledRejections();
                var handler = function() {
                  return _value;
                };
                return this.caught(value, handler);
              }
            };
          };
        }, {}],
        11: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, INTERNAL) {
            var PromiseReduce = Promise.reduce;
            var PromiseAll = Promise.all;
            function promiseAllThis() {
              return PromiseAll(this);
            }
            function PromiseMapSeries(promises, fn) {
              return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
            }
            Promise.prototype.each = function(fn) {
              return this.mapSeries(fn)._then(promiseAllThis, undefined, undefined, this, undefined);
            };
            Promise.prototype.mapSeries = function(fn) {
              return PromiseReduce(this, fn, INTERNAL, INTERNAL);
            };
            Promise.each = function(promises, fn) {
              return PromiseMapSeries(promises, fn)._then(promiseAllThis, undefined, undefined, promises, undefined);
            };
            Promise.mapSeries = PromiseMapSeries;
          };
        }, {}],
        12: [function(_dereq_, module, exports) {
          "use strict";
          var es5 = _dereq_("./es5");
          var Objectfreeze = es5.freeze;
          var util = _dereq_("./util");
          var inherits = util.inherits;
          var notEnumerableProp = util.notEnumerableProp;
          function subError(nameProperty, defaultMessage) {
            function SubError(message) {
              if (!(this instanceof SubError))
                return new SubError(message);
              notEnumerableProp(this, "message", typeof message === "string" ? message : defaultMessage);
              notEnumerableProp(this, "name", nameProperty);
              if (Error.captureStackTrace) {
                Error.captureStackTrace(this, this.constructor);
              } else {
                Error.call(this);
              }
            }
            inherits(SubError, Error);
            return SubError;
          }
          var _TypeError,
              _RangeError;
          var Warning = subError("Warning", "warning");
          var CancellationError = subError("CancellationError", "cancellation error");
          var TimeoutError = subError("TimeoutError", "timeout error");
          var AggregateError = subError("AggregateError", "aggregate error");
          try {
            _TypeError = TypeError;
            _RangeError = RangeError;
          } catch (e) {
            _TypeError = subError("TypeError", "type error");
            _RangeError = subError("RangeError", "range error");
          }
          var methods = ("join pop push shift unshift slice filter forEach some " + "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");
          for (var i = 0; i < methods.length; ++i) {
            if (typeof Array.prototype[methods[i]] === "function") {
              AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
            }
          }
          es5.defineProperty(AggregateError.prototype, "length", {
            value: 0,
            configurable: false,
            writable: true,
            enumerable: true
          });
          AggregateError.prototype["isOperational"] = true;
          var level = 0;
          AggregateError.prototype.toString = function() {
            var indent = Array(level * 4 + 1).join(" ");
            var ret = "\n" + indent + "AggregateError of:" + "\n";
            level++;
            indent = Array(level * 4 + 1).join(" ");
            for (var i = 0; i < this.length; ++i) {
              var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
              var lines = str.split("\n");
              for (var j = 0; j < lines.length; ++j) {
                lines[j] = indent + lines[j];
              }
              str = lines.join("\n");
              ret += str + "\n";
            }
            level--;
            return ret;
          };
          function OperationalError(message) {
            if (!(this instanceof OperationalError))
              return new OperationalError(message);
            notEnumerableProp(this, "name", "OperationalError");
            notEnumerableProp(this, "message", message);
            this.cause = message;
            this["isOperational"] = true;
            if (message instanceof Error) {
              notEnumerableProp(this, "message", message.message);
              notEnumerableProp(this, "stack", message.stack);
            } else if (Error.captureStackTrace) {
              Error.captureStackTrace(this, this.constructor);
            }
          }
          inherits(OperationalError, Error);
          var errorTypes = Error["__BluebirdErrorTypes__"];
          if (!errorTypes) {
            errorTypes = Objectfreeze({
              CancellationError: CancellationError,
              TimeoutError: TimeoutError,
              OperationalError: OperationalError,
              RejectionError: OperationalError,
              AggregateError: AggregateError
            });
            es5.defineProperty(Error, "__BluebirdErrorTypes__", {
              value: errorTypes,
              writable: false,
              enumerable: false,
              configurable: false
            });
          }
          module.exports = {
            Error: Error,
            TypeError: _TypeError,
            RangeError: _RangeError,
            CancellationError: errorTypes.CancellationError,
            OperationalError: errorTypes.OperationalError,
            TimeoutError: errorTypes.TimeoutError,
            AggregateError: errorTypes.AggregateError,
            Warning: Warning
          };
        }, {
          "./es5": 13,
          "./util": 36
        }],
        13: [function(_dereq_, module, exports) {
          var isES5 = (function() {
            "use strict";
            return this === undefined;
          })();
          if (isES5) {
            module.exports = {
              freeze: Object.freeze,
              defineProperty: Object.defineProperty,
              getDescriptor: Object.getOwnPropertyDescriptor,
              keys: Object.keys,
              names: Object.getOwnPropertyNames,
              getPrototypeOf: Object.getPrototypeOf,
              isArray: Array.isArray,
              isES5: isES5,
              propertyIsWritable: function(obj, prop) {
                var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
                return !!(!descriptor || descriptor.writable || descriptor.set);
              }
            };
          } else {
            var has = {}.hasOwnProperty;
            var str = {}.toString;
            var proto = {}.constructor.prototype;
            var ObjectKeys = function(o) {
              var ret = [];
              for (var key in o) {
                if (has.call(o, key)) {
                  ret.push(key);
                }
              }
              return ret;
            };
            var ObjectGetDescriptor = function(o, key) {
              return {value: o[key]};
            };
            var ObjectDefineProperty = function(o, key, desc) {
              o[key] = desc.value;
              return o;
            };
            var ObjectFreeze = function(obj) {
              return obj;
            };
            var ObjectGetPrototypeOf = function(obj) {
              try {
                return Object(obj).constructor.prototype;
              } catch (e) {
                return proto;
              }
            };
            var ArrayIsArray = function(obj) {
              try {
                return str.call(obj) === "[object Array]";
              } catch (e) {
                return false;
              }
            };
            module.exports = {
              isArray: ArrayIsArray,
              keys: ObjectKeys,
              names: ObjectKeys,
              defineProperty: ObjectDefineProperty,
              getDescriptor: ObjectGetDescriptor,
              freeze: ObjectFreeze,
              getPrototypeOf: ObjectGetPrototypeOf,
              isES5: isES5,
              propertyIsWritable: function() {
                return true;
              }
            };
          }
        }, {}],
        14: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, INTERNAL) {
            var PromiseMap = Promise.map;
            Promise.prototype.filter = function(fn, options) {
              return PromiseMap(this, fn, options, INTERNAL);
            };
            Promise.filter = function(promises, fn, options) {
              return PromiseMap(promises, fn, options, INTERNAL);
            };
          };
        }, {}],
        15: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, tryConvertToPromise) {
            var util = _dereq_("./util");
            var CancellationError = Promise.CancellationError;
            var errorObj = util.errorObj;
            function PassThroughHandlerContext(promise, type, handler) {
              this.promise = promise;
              this.type = type;
              this.handler = handler;
              this.called = false;
              this.cancelPromise = null;
            }
            PassThroughHandlerContext.prototype.isFinallyHandler = function() {
              return this.type === 0;
            };
            function FinallyHandlerCancelReaction(finallyHandler) {
              this.finallyHandler = finallyHandler;
            }
            FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
              checkCancel(this.finallyHandler);
            };
            function checkCancel(ctx, reason) {
              if (ctx.cancelPromise != null) {
                if (arguments.length > 1) {
                  ctx.cancelPromise._reject(reason);
                } else {
                  ctx.cancelPromise._cancel();
                }
                ctx.cancelPromise = null;
                return true;
              }
              return false;
            }
            function succeed() {
              return finallyHandler.call(this, this.promise._target()._settledValue());
            }
            function fail(reason) {
              if (checkCancel(this, reason))
                return;
              errorObj.e = reason;
              return errorObj;
            }
            function finallyHandler(reasonOrValue) {
              var promise = this.promise;
              var handler = this.handler;
              if (!this.called) {
                this.called = true;
                var ret = this.isFinallyHandler() ? handler.call(promise._boundValue()) : handler.call(promise._boundValue(), reasonOrValue);
                if (ret !== undefined) {
                  promise._setReturnedNonUndefined();
                  var maybePromise = tryConvertToPromise(ret, promise);
                  if (maybePromise instanceof Promise) {
                    if (this.cancelPromise != null) {
                      if (maybePromise.isCancelled()) {
                        var reason = new CancellationError("late cancellation observer");
                        promise._attachExtraTrace(reason);
                        errorObj.e = reason;
                        return errorObj;
                      } else if (maybePromise.isPending()) {
                        maybePromise._attachCancellationCallback(new FinallyHandlerCancelReaction(this));
                      }
                    }
                    return maybePromise._then(succeed, fail, undefined, this, undefined);
                  }
                }
              }
              if (promise.isRejected()) {
                checkCancel(this);
                errorObj.e = reasonOrValue;
                return errorObj;
              } else {
                checkCancel(this);
                return reasonOrValue;
              }
            }
            Promise.prototype._passThrough = function(handler, type, success, fail) {
              if (typeof handler !== "function")
                return this.then();
              return this._then(success, fail, undefined, new PassThroughHandlerContext(this, type, handler), undefined);
            };
            Promise.prototype.lastly = Promise.prototype["finally"] = function(handler) {
              return this._passThrough(handler, 0, finallyHandler, finallyHandler);
            };
            Promise.prototype.tap = function(handler) {
              return this._passThrough(handler, 1, finallyHandler);
            };
            return PassThroughHandlerContext;
          };
        }, {"./util": 36}],
        16: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug) {
            var errors = _dereq_("./errors");
            var TypeError = errors.TypeError;
            var util = _dereq_("./util");
            var errorObj = util.errorObj;
            var tryCatch = util.tryCatch;
            var yieldHandlers = [];
            function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
              for (var i = 0; i < yieldHandlers.length; ++i) {
                traceParent._pushContext();
                var result = tryCatch(yieldHandlers[i])(value);
                traceParent._popContext();
                if (result === errorObj) {
                  traceParent._pushContext();
                  var ret = Promise.reject(errorObj.e);
                  traceParent._popContext();
                  return ret;
                }
                var maybePromise = tryConvertToPromise(result, traceParent);
                if (maybePromise instanceof Promise)
                  return maybePromise;
              }
              return null;
            }
            function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
              if (debug.cancellation()) {
                var internal = new Promise(INTERNAL);
                var _finallyPromise = this._finallyPromise = new Promise(INTERNAL);
                this._promise = internal.lastly(function() {
                  return _finallyPromise;
                });
                internal._captureStackTrace();
                internal._setOnCancel(this);
              } else {
                var promise = this._promise = new Promise(INTERNAL);
                promise._captureStackTrace();
              }
              this._stack = stack;
              this._generatorFunction = generatorFunction;
              this._receiver = receiver;
              this._generator = undefined;
              this._yieldHandlers = typeof yieldHandler === "function" ? [yieldHandler].concat(yieldHandlers) : yieldHandlers;
              this._yieldedPromise = null;
              this._cancellationPhase = false;
            }
            util.inherits(PromiseSpawn, Proxyable);
            PromiseSpawn.prototype._isResolved = function() {
              return this._promise === null;
            };
            PromiseSpawn.prototype._cleanup = function() {
              this._promise = this._generator = null;
              if (debug.cancellation() && this._finallyPromise !== null) {
                this._finallyPromise._fulfill();
                this._finallyPromise = null;
              }
            };
            PromiseSpawn.prototype._promiseCancelled = function() {
              if (this._isResolved())
                return;
              var implementsReturn = typeof this._generator["return"] !== "undefined";
              var result;
              if (!implementsReturn) {
                var reason = new Promise.CancellationError("generator .return() sentinel");
                Promise.coroutine.returnSentinel = reason;
                this._promise._attachExtraTrace(reason);
                this._promise._pushContext();
                result = tryCatch(this._generator["throw"]).call(this._generator, reason);
                this._promise._popContext();
              } else {
                this._promise._pushContext();
                result = tryCatch(this._generator["return"]).call(this._generator, undefined);
                this._promise._popContext();
              }
              this._cancellationPhase = true;
              this._yieldedPromise = null;
              this._continue(result);
            };
            PromiseSpawn.prototype._promiseFulfilled = function(value) {
              this._yieldedPromise = null;
              this._promise._pushContext();
              var result = tryCatch(this._generator.next).call(this._generator, value);
              this._promise._popContext();
              this._continue(result);
            };
            PromiseSpawn.prototype._promiseRejected = function(reason) {
              this._yieldedPromise = null;
              this._promise._attachExtraTrace(reason);
              this._promise._pushContext();
              var result = tryCatch(this._generator["throw"]).call(this._generator, reason);
              this._promise._popContext();
              this._continue(result);
            };
            PromiseSpawn.prototype._resultCancelled = function() {
              if (this._yieldedPromise instanceof Promise) {
                var promise = this._yieldedPromise;
                this._yieldedPromise = null;
                promise.cancel();
              }
            };
            PromiseSpawn.prototype.promise = function() {
              return this._promise;
            };
            PromiseSpawn.prototype._run = function() {
              this._generator = this._generatorFunction.call(this._receiver);
              this._receiver = this._generatorFunction = undefined;
              this._promiseFulfilled(undefined);
            };
            PromiseSpawn.prototype._continue = function(result) {
              var promise = this._promise;
              if (result === errorObj) {
                this._cleanup();
                if (this._cancellationPhase) {
                  return promise.cancel();
                } else {
                  return promise._rejectCallback(result.e, false);
                }
              }
              var value = result.value;
              if (result.done === true) {
                this._cleanup();
                if (this._cancellationPhase) {
                  return promise.cancel();
                } else {
                  return promise._resolveCallback(value);
                }
              } else {
                var maybePromise = tryConvertToPromise(value, this._promise);
                if (!(maybePromise instanceof Promise)) {
                  maybePromise = promiseFromYieldHandler(maybePromise, this._yieldHandlers, this._promise);
                  if (maybePromise === null) {
                    this._promiseRejected(new TypeError("A value %s was yielded that could not be treated as a promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a\u000a".replace("%s", value) + "From coroutine:\u000a" + this._stack.split("\n").slice(1, -7).join("\n")));
                    return;
                  }
                }
                maybePromise = maybePromise._target();
                var bitField = maybePromise._bitField;
                ;
                if (((bitField & 50397184) === 0)) {
                  this._yieldedPromise = maybePromise;
                  maybePromise._proxy(this, null);
                } else if (((bitField & 33554432) !== 0)) {
                  this._promiseFulfilled(maybePromise._value());
                } else if (((bitField & 16777216) !== 0)) {
                  this._promiseRejected(maybePromise._reason());
                } else {
                  this._promiseCancelled();
                }
              }
            };
            Promise.coroutine = function(generatorFunction, options) {
              if (typeof generatorFunction !== "function") {
                throw new TypeError("generatorFunction must be a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
              }
              var yieldHandler = Object(options).yieldHandler;
              var PromiseSpawn$ = PromiseSpawn;
              var stack = new Error().stack;
              return function() {
                var generator = generatorFunction.apply(this, arguments);
                var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler, stack);
                var ret = spawn.promise();
                spawn._generator = generator;
                spawn._promiseFulfilled(undefined);
                return ret;
              };
            };
            Promise.coroutine.addYieldHandler = function(fn) {
              if (typeof fn !== "function") {
                throw new TypeError("expecting a function but got " + util.classString(fn));
              }
              yieldHandlers.push(fn);
            };
            Promise.spawn = function(generatorFunction) {
              debug.deprecated("Promise.spawn()", "Promise.coroutine()");
              if (typeof generatorFunction !== "function") {
                return apiRejection("generatorFunction must be a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
              }
              var spawn = new PromiseSpawn(generatorFunction, this);
              var ret = spawn.promise();
              spawn._run(Promise.spawn);
              return ret;
            };
          };
        }, {
          "./errors": 12,
          "./util": 36
        }],
        17: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, PromiseArray, tryConvertToPromise, INTERNAL) {
            var util = _dereq_("./util");
            var canEvaluate = util.canEvaluate;
            var tryCatch = util.tryCatch;
            var errorObj = util.errorObj;
            var reject;
            if (!true) {
              if (canEvaluate) {
                var thenCallback = function(i) {
                  return new Function("value", "holder", "                             \n\
            'use strict';                                                    \n\
            holder.pIndex = value;                                           \n\
            holder.checkFulfillment(this);                                   \n\
            ".replace(/Index/g, i));
                };
                var promiseSetter = function(i) {
                  return new Function("promise", "holder", "                           \n\
            'use strict';                                                    \n\
            holder.pIndex = promise;                                         \n\
            ".replace(/Index/g, i));
                };
                var generateHolderClass = function(total) {
                  var props = new Array(total);
                  for (var i = 0; i < props.length; ++i) {
                    props[i] = "this.p" + (i + 1);
                  }
                  var assignment = props.join(" = ") + " = null;";
                  var cancellationCode = "var promise;\n" + props.map(function(prop) {
                    return "                                                         \n\
                promise = " + prop + ";                                      \n\
                if (promise instanceof Promise) {                            \n\
                    promise.cancel();                                        \n\
                }                                                            \n\
            ";
                  }).join("\n");
                  var passedArguments = props.join(", ");
                  var name = "Holder$" + total;
                  var code = "return function(tryCatch, errorObj, Promise) {           \n\
            'use strict';                                                    \n\
            function [TheName](fn) {                                         \n\
                [TheProperties]                                              \n\
                this.fn = fn;                                                \n\
                this.now = 0;                                                \n\
            }                                                                \n\
            [TheName].prototype.checkFulfillment = function(promise) {       \n\
                var now = ++this.now;                                        \n\
                if (now === [TheTotal]) {                                    \n\
                    promise._pushContext();                                  \n\
                    var callback = this.fn;                                  \n\
                    var ret = tryCatch(callback)([ThePassedArguments]);      \n\
                    promise._popContext();                                   \n\
                    if (ret === errorObj) {                                  \n\
                        promise._rejectCallback(ret.e, false);               \n\
                    } else {                                                 \n\
                        promise._resolveCallback(ret);                       \n\
                    }                                                        \n\
                }                                                            \n\
            };                                                               \n\
                                                                             \n\
            [TheName].prototype._resultCancelled = function() {              \n\
                [CancellationCode]                                           \n\
            };                                                               \n\
                                                                             \n\
            return [TheName];                                                \n\
        }(tryCatch, errorObj, Promise);                                      \n\
        ";
                  code = code.replace(/\[TheName\]/g, name).replace(/\[TheTotal\]/g, total).replace(/\[ThePassedArguments\]/g, passedArguments).replace(/\[TheProperties\]/g, assignment).replace(/\[CancellationCode\]/g, cancellationCode);
                  return new Function("tryCatch", "errorObj", "Promise", code)(tryCatch, errorObj, Promise);
                };
                var holderClasses = [];
                var thenCallbacks = [];
                var promiseSetters = [];
                for (var i = 0; i < 8; ++i) {
                  holderClasses.push(generateHolderClass(i + 1));
                  thenCallbacks.push(thenCallback(i + 1));
                  promiseSetters.push(promiseSetter(i + 1));
                }
                reject = function(reason) {
                  this._reject(reason);
                };
              }
            }
            Promise.join = function() {
              var last = arguments.length - 1;
              var fn;
              if (last > 0 && typeof arguments[last] === "function") {
                fn = arguments[last];
                if (!true) {
                  if (last <= 8 && canEvaluate) {
                    var ret = new Promise(INTERNAL);
                    ret._captureStackTrace();
                    var HolderClass = holderClasses[last - 1];
                    var holder = new HolderClass(fn);
                    var callbacks = thenCallbacks;
                    for (var i = 0; i < last; ++i) {
                      var maybePromise = tryConvertToPromise(arguments[i], ret);
                      if (maybePromise instanceof Promise) {
                        maybePromise = maybePromise._target();
                        var bitField = maybePromise._bitField;
                        ;
                        if (((bitField & 50397184) === 0)) {
                          maybePromise._then(callbacks[i], reject, undefined, ret, holder);
                          promiseSetters[i](maybePromise, holder);
                        } else if (((bitField & 33554432) !== 0)) {
                          callbacks[i].call(ret, maybePromise._value(), holder);
                        } else if (((bitField & 16777216) !== 0)) {
                          ret._reject(maybePromise._reason());
                        } else {
                          ret._cancel();
                        }
                      } else {
                        callbacks[i].call(ret, maybePromise, holder);
                      }
                    }
                    if (!ret._isFateSealed()) {
                      ret._setAsyncGuaranteed();
                      ret._setOnCancel(holder);
                    }
                    return ret;
                  }
                }
              }
              var args = [].slice.call(arguments);
              ;
              if (fn)
                args.pop();
              var ret = new PromiseArray(args).promise();
              return fn !== undefined ? ret.spread(fn) : ret;
            };
          };
        }, {"./util": 36}],
        18: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
            var getDomain = Promise._getDomain;
            var util = _dereq_("./util");
            var tryCatch = util.tryCatch;
            var errorObj = util.errorObj;
            var EMPTY_ARRAY = [];
            function MappingPromiseArray(promises, fn, limit, _filter) {
              this.constructor$(promises);
              this._promise._captureStackTrace();
              var domain = getDomain();
              this._callback = domain === null ? fn : domain.bind(fn);
              this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null;
              this._limit = limit;
              this._inFlight = 0;
              this._queue = limit >= 1 ? [] : EMPTY_ARRAY;
              this._init$(undefined, -2);
            }
            util.inherits(MappingPromiseArray, PromiseArray);
            MappingPromiseArray.prototype._init = function() {};
            MappingPromiseArray.prototype._promiseFulfilled = function(value, index) {
              var values = this._values;
              var length = this.length();
              var preservedValues = this._preservedValues;
              var limit = this._limit;
              if (index < 0) {
                index = (index * -1) - 1;
                values[index] = value;
                if (limit >= 1) {
                  this._inFlight--;
                  this._drainQueue();
                  if (this._isResolved())
                    return true;
                }
              } else {
                if (limit >= 1 && this._inFlight >= limit) {
                  values[index] = value;
                  this._queue.push(index);
                  return false;
                }
                if (preservedValues !== null)
                  preservedValues[index] = value;
                var promise = this._promise;
                var callback = this._callback;
                var receiver = promise._boundValue();
                promise._pushContext();
                var ret = tryCatch(callback).call(receiver, value, index, length);
                var promiseCreated = promise._popContext();
                debug.checkForgottenReturns(ret, promiseCreated, preservedValues !== null ? "Promise.filter" : "Promise.map", promise);
                if (ret === errorObj) {
                  this._reject(ret.e);
                  return true;
                }
                var maybePromise = tryConvertToPromise(ret, this._promise);
                if (maybePromise instanceof Promise) {
                  maybePromise = maybePromise._target();
                  var bitField = maybePromise._bitField;
                  ;
                  if (((bitField & 50397184) === 0)) {
                    if (limit >= 1)
                      this._inFlight++;
                    values[index] = maybePromise;
                    maybePromise._proxy(this, (index + 1) * -1);
                    return false;
                  } else if (((bitField & 33554432) !== 0)) {
                    ret = maybePromise._value();
                  } else if (((bitField & 16777216) !== 0)) {
                    this._reject(maybePromise._reason());
                    return true;
                  } else {
                    this._cancel();
                    return true;
                  }
                }
                values[index] = ret;
              }
              var totalResolved = ++this._totalResolved;
              if (totalResolved >= length) {
                if (preservedValues !== null) {
                  this._filter(values, preservedValues);
                } else {
                  this._resolve(values);
                }
                return true;
              }
              return false;
            };
            MappingPromiseArray.prototype._drainQueue = function() {
              var queue = this._queue;
              var limit = this._limit;
              var values = this._values;
              while (queue.length > 0 && this._inFlight < limit) {
                if (this._isResolved())
                  return;
                var index = queue.pop();
                this._promiseFulfilled(values[index], index);
              }
            };
            MappingPromiseArray.prototype._filter = function(booleans, values) {
              var len = values.length;
              var ret = new Array(len);
              var j = 0;
              for (var i = 0; i < len; ++i) {
                if (booleans[i])
                  ret[j++] = values[i];
              }
              ret.length = j;
              this._resolve(ret);
            };
            MappingPromiseArray.prototype.preservedValues = function() {
              return this._preservedValues;
            };
            function map(promises, fn, options, _filter) {
              if (typeof fn !== "function") {
                return apiRejection("expecting a function but got " + util.classString(fn));
              }
              var limit = 0;
              if (options !== undefined) {
                if (typeof options === "object" && options !== null) {
                  if (typeof options.concurrency !== "number") {
                    return Promise.reject(new TypeError("'concurrency' must be a number but it is " + util.classString(options.concurrency)));
                  }
                  limit = options.concurrency;
                } else {
                  return Promise.reject(new TypeError("options argument must be an object but it is " + util.classString(options)));
                }
              }
              limit = typeof limit === "number" && isFinite(limit) && limit >= 1 ? limit : 0;
              return new MappingPromiseArray(promises, fn, limit, _filter).promise();
            }
            Promise.prototype.map = function(fn, options) {
              return map(this, fn, options, null);
            };
            Promise.map = function(promises, fn, options, _filter) {
              return map(promises, fn, options, _filter);
            };
          };
        }, {"./util": 36}],
        19: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug) {
            var util = _dereq_("./util");
            var tryCatch = util.tryCatch;
            Promise.method = function(fn) {
              if (typeof fn !== "function") {
                throw new Promise.TypeError("expecting a function but got " + util.classString(fn));
              }
              return function() {
                var ret = new Promise(INTERNAL);
                ret._captureStackTrace();
                ret._pushContext();
                var value = tryCatch(fn).apply(this, arguments);
                var promiseCreated = ret._popContext();
                debug.checkForgottenReturns(value, promiseCreated, "Promise.method", ret);
                ret._resolveFromSyncValue(value);
                return ret;
              };
            };
            Promise.attempt = Promise["try"] = function(fn) {
              if (typeof fn !== "function") {
                return apiRejection("expecting a function but got " + util.classString(fn));
              }
              var ret = new Promise(INTERNAL);
              ret._captureStackTrace();
              ret._pushContext();
              var value;
              if (arguments.length > 1) {
                debug.deprecated("calling Promise.try with more than 1 argument");
                var arg = arguments[1];
                var ctx = arguments[2];
                value = util.isArray(arg) ? tryCatch(fn).apply(ctx, arg) : tryCatch(fn).call(ctx, arg);
              } else {
                value = tryCatch(fn)();
              }
              var promiseCreated = ret._popContext();
              debug.checkForgottenReturns(value, promiseCreated, "Promise.try", ret);
              ret._resolveFromSyncValue(value);
              return ret;
            };
            Promise.prototype._resolveFromSyncValue = function(value) {
              if (value === util.errorObj) {
                this._rejectCallback(value.e, false);
              } else {
                this._resolveCallback(value, true);
              }
            };
          };
        }, {"./util": 36}],
        20: [function(_dereq_, module, exports) {
          "use strict";
          var util = _dereq_("./util");
          var maybeWrapAsError = util.maybeWrapAsError;
          var errors = _dereq_("./errors");
          var OperationalError = errors.OperationalError;
          var es5 = _dereq_("./es5");
          function isUntypedError(obj) {
            return obj instanceof Error && es5.getPrototypeOf(obj) === Error.prototype;
          }
          var rErrorKey = /^(?:name|message|stack|cause)$/;
          function wrapAsOperationalError(obj) {
            var ret;
            if (isUntypedError(obj)) {
              ret = new OperationalError(obj);
              ret.name = obj.name;
              ret.message = obj.message;
              ret.stack = obj.stack;
              var keys = es5.keys(obj);
              for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                if (!rErrorKey.test(key)) {
                  ret[key] = obj[key];
                }
              }
              return ret;
            }
            util.markAsOriginatingFromRejection(obj);
            return obj;
          }
          function nodebackForPromise(promise, multiArgs) {
            return function(err, value) {
              if (promise === null)
                return;
              if (err) {
                var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
                promise._attachExtraTrace(wrapped);
                promise._reject(wrapped);
              } else if (!multiArgs) {
                promise._fulfill(value);
              } else {
                var args = [].slice.call(arguments, 1);
                ;
                promise._fulfill(args);
              }
              promise = null;
            };
          }
          module.exports = nodebackForPromise;
        }, {
          "./errors": 12,
          "./es5": 13,
          "./util": 36
        }],
        21: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise) {
            var util = _dereq_("./util");
            var async = Promise._async;
            var tryCatch = util.tryCatch;
            var errorObj = util.errorObj;
            function spreadAdapter(val, nodeback) {
              var promise = this;
              if (!util.isArray(val))
                return successAdapter.call(promise, val, nodeback);
              var ret = tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));
              if (ret === errorObj) {
                async.throwLater(ret.e);
              }
            }
            function successAdapter(val, nodeback) {
              var promise = this;
              var receiver = promise._boundValue();
              var ret = val === undefined ? tryCatch(nodeback).call(receiver, null) : tryCatch(nodeback).call(receiver, null, val);
              if (ret === errorObj) {
                async.throwLater(ret.e);
              }
            }
            function errorAdapter(reason, nodeback) {
              var promise = this;
              if (!reason) {
                var newReason = new Error(reason + "");
                newReason.cause = reason;
                reason = newReason;
              }
              var ret = tryCatch(nodeback).call(promise._boundValue(), reason);
              if (ret === errorObj) {
                async.throwLater(ret.e);
              }
            }
            Promise.prototype.asCallback = Promise.prototype.nodeify = function(nodeback, options) {
              if (typeof nodeback == "function") {
                var adapter = successAdapter;
                if (options !== undefined && Object(options).spread) {
                  adapter = spreadAdapter;
                }
                this._then(adapter, errorAdapter, undefined, this, nodeback);
              }
              return this;
            };
          };
        }, {"./util": 36}],
        22: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function() {
            var makeSelfResolutionError = function() {
              return new TypeError("circular promise resolution chain\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
            };
            var reflectHandler = function() {
              return new Promise.PromiseInspection(this._target());
            };
            var apiRejection = function(msg) {
              return Promise.reject(new TypeError(msg));
            };
            function Proxyable() {}
            var UNDEFINED_BINDING = {};
            var util = _dereq_("./util");
            var getDomain;
            if (util.isNode) {
              getDomain = function() {
                var ret = process.domain;
                if (ret === undefined)
                  ret = null;
                return ret;
              };
            } else {
              getDomain = function() {
                return null;
              };
            }
            util.notEnumerableProp(Promise, "_getDomain", getDomain);
            var es5 = _dereq_("./es5");
            var Async = _dereq_("./async");
            var async = new Async();
            es5.defineProperty(Promise, "_async", {value: async});
            var errors = _dereq_("./errors");
            var TypeError = Promise.TypeError = errors.TypeError;
            Promise.RangeError = errors.RangeError;
            var CancellationError = Promise.CancellationError = errors.CancellationError;
            Promise.TimeoutError = errors.TimeoutError;
            Promise.OperationalError = errors.OperationalError;
            Promise.RejectionError = errors.OperationalError;
            Promise.AggregateError = errors.AggregateError;
            var INTERNAL = function() {};
            var APPLY = {};
            var NEXT_FILTER = {};
            var tryConvertToPromise = _dereq_("./thenables")(Promise, INTERNAL);
            var PromiseArray = _dereq_("./promise_array")(Promise, INTERNAL, tryConvertToPromise, apiRejection, Proxyable);
            var Context = _dereq_("./context")(Promise);
            var createContext = Context.create;
            var debug = _dereq_("./debuggability")(Promise, Context);
            var CapturedTrace = debug.CapturedTrace;
            var PassThroughHandlerContext = _dereq_("./finally")(Promise, tryConvertToPromise);
            var catchFilter = _dereq_("./catch_filter")(NEXT_FILTER);
            var nodebackForPromise = _dereq_("./nodeback");
            var errorObj = util.errorObj;
            var tryCatch = util.tryCatch;
            function check(self, executor) {
              if (typeof executor !== "function") {
                throw new TypeError("expecting a function but got " + util.classString(executor));
              }
              if (self.constructor !== Promise) {
                throw new TypeError("the promise constructor cannot be invoked directly\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
              }
            }
            function Promise(executor) {
              this._bitField = 0;
              this._fulfillmentHandler0 = undefined;
              this._rejectionHandler0 = undefined;
              this._promise0 = undefined;
              this._receiver0 = undefined;
              if (executor !== INTERNAL) {
                check(this, executor);
                this._resolveFromExecutor(executor);
              }
              this._promiseCreated();
              this._fireEvent("promiseCreated", this);
            }
            Promise.prototype.toString = function() {
              return "[object Promise]";
            };
            Promise.prototype.caught = Promise.prototype["catch"] = function(fn) {
              var len = arguments.length;
              if (len > 1) {
                var catchInstances = new Array(len - 1),
                    j = 0,
                    i;
                for (i = 0; i < len - 1; ++i) {
                  var item = arguments[i];
                  if (util.isObject(item)) {
                    catchInstances[j++] = item;
                  } else {
                    return apiRejection("expecting an object but got " + util.classString(item));
                  }
                }
                catchInstances.length = j;
                fn = arguments[i];
                return this.then(undefined, catchFilter(catchInstances, fn, this));
              }
              return this.then(undefined, fn);
            };
            Promise.prototype.reflect = function() {
              return this._then(reflectHandler, reflectHandler, undefined, this, undefined);
            };
            Promise.prototype.then = function(didFulfill, didReject) {
              if (debug.warnings() && arguments.length > 0 && typeof didFulfill !== "function" && typeof didReject !== "function") {
                var msg = ".then() only accepts functions but was passed: " + util.classString(didFulfill);
                if (arguments.length > 1) {
                  msg += ", " + util.classString(didReject);
                }
                this._warn(msg);
              }
              return this._then(didFulfill, didReject, undefined, undefined, undefined);
            };
            Promise.prototype.done = function(didFulfill, didReject) {
              var promise = this._then(didFulfill, didReject, undefined, undefined, undefined);
              promise._setIsFinal();
            };
            Promise.prototype.spread = function(fn) {
              if (typeof fn !== "function") {
                return apiRejection("expecting a function but got " + util.classString(fn));
              }
              return this.all()._then(fn, undefined, undefined, APPLY, undefined);
            };
            Promise.prototype.toJSON = function() {
              var ret = {
                isFulfilled: false,
                isRejected: false,
                fulfillmentValue: undefined,
                rejectionReason: undefined
              };
              if (this.isFulfilled()) {
                ret.fulfillmentValue = this.value();
                ret.isFulfilled = true;
              } else if (this.isRejected()) {
                ret.rejectionReason = this.reason();
                ret.isRejected = true;
              }
              return ret;
            };
            Promise.prototype.all = function() {
              if (arguments.length > 0) {
                this._warn(".all() was passed arguments but it does not take any");
              }
              return new PromiseArray(this).promise();
            };
            Promise.prototype.error = function(fn) {
              return this.caught(util.originatesFromRejection, fn);
            };
            Promise.getNewLibraryCopy = module.exports;
            Promise.is = function(val) {
              return val instanceof Promise;
            };
            Promise.fromNode = Promise.fromCallback = function(fn) {
              var ret = new Promise(INTERNAL);
              ret._captureStackTrace();
              var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs : false;
              var result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));
              if (result === errorObj) {
                ret._rejectCallback(result.e, true);
              }
              if (!ret._isFateSealed())
                ret._setAsyncGuaranteed();
              return ret;
            };
            Promise.all = function(promises) {
              return new PromiseArray(promises).promise();
            };
            Promise.cast = function(obj) {
              var ret = tryConvertToPromise(obj);
              if (!(ret instanceof Promise)) {
                ret = new Promise(INTERNAL);
                ret._captureStackTrace();
                ret._setFulfilled();
                ret._rejectionHandler0 = obj;
              }
              return ret;
            };
            Promise.resolve = Promise.fulfilled = Promise.cast;
            Promise.reject = Promise.rejected = function(reason) {
              var ret = new Promise(INTERNAL);
              ret._captureStackTrace();
              ret._rejectCallback(reason, true);
              return ret;
            };
            Promise.setScheduler = function(fn) {
              if (typeof fn !== "function") {
                throw new TypeError("expecting a function but got " + util.classString(fn));
              }
              return async.setScheduler(fn);
            };
            Promise.prototype._then = function(didFulfill, didReject, _, receiver, internalData) {
              var haveInternalData = internalData !== undefined;
              var promise = haveInternalData ? internalData : new Promise(INTERNAL);
              var target = this._target();
              var bitField = target._bitField;
              if (!haveInternalData) {
                promise._propagateFrom(this, 3);
                promise._captureStackTrace();
                if (receiver === undefined && ((this._bitField & 2097152) !== 0)) {
                  if (!((bitField & 50397184) === 0)) {
                    receiver = this._boundValue();
                  } else {
                    receiver = target === this ? undefined : this._boundTo;
                  }
                }
                this._fireEvent("promiseChained", this, promise);
              }
              var domain = getDomain();
              if (!((bitField & 50397184) === 0)) {
                var handler,
                    value,
                    settler = target._settlePromiseCtx;
                if (((bitField & 33554432) !== 0)) {
                  value = target._rejectionHandler0;
                  handler = didFulfill;
                } else if (((bitField & 16777216) !== 0)) {
                  value = target._fulfillmentHandler0;
                  handler = didReject;
                  target._unsetRejectionIsUnhandled();
                } else {
                  settler = target._settlePromiseLateCancellationObserver;
                  value = new CancellationError("late cancellation observer");
                  target._attachExtraTrace(value);
                  handler = didReject;
                }
                async.invoke(settler, target, {
                  handler: domain === null ? handler : (typeof handler === "function" && domain.bind(handler)),
                  promise: promise,
                  receiver: receiver,
                  value: value
                });
              } else {
                target._addCallbacks(didFulfill, didReject, promise, receiver, domain);
              }
              return promise;
            };
            Promise.prototype._length = function() {
              return this._bitField & 65535;
            };
            Promise.prototype._isFateSealed = function() {
              return (this._bitField & 117506048) !== 0;
            };
            Promise.prototype._isFollowing = function() {
              return (this._bitField & 67108864) === 67108864;
            };
            Promise.prototype._setLength = function(len) {
              this._bitField = (this._bitField & -65536) | (len & 65535);
            };
            Promise.prototype._setFulfilled = function() {
              this._bitField = this._bitField | 33554432;
              this._fireEvent("promiseFulfilled", this);
            };
            Promise.prototype._setRejected = function() {
              this._bitField = this._bitField | 16777216;
              this._fireEvent("promiseRejected", this);
            };
            Promise.prototype._setFollowing = function() {
              this._bitField = this._bitField | 67108864;
              this._fireEvent("promiseResolved", this);
            };
            Promise.prototype._setIsFinal = function() {
              this._bitField = this._bitField | 4194304;
            };
            Promise.prototype._isFinal = function() {
              return (this._bitField & 4194304) > 0;
            };
            Promise.prototype._unsetCancelled = function() {
              this._bitField = this._bitField & (~65536);
            };
            Promise.prototype._setCancelled = function() {
              this._bitField = this._bitField | 65536;
              this._fireEvent("promiseCancelled", this);
            };
            Promise.prototype._setAsyncGuaranteed = function() {
              if (async.hasCustomScheduler())
                return;
              this._bitField = this._bitField | 134217728;
            };
            Promise.prototype._receiverAt = function(index) {
              var ret = index === 0 ? this._receiver0 : this[index * 4 - 4 + 3];
              if (ret === UNDEFINED_BINDING) {
                return undefined;
              } else if (ret === undefined && this._isBound()) {
                return this._boundValue();
              }
              return ret;
            };
            Promise.prototype._promiseAt = function(index) {
              return this[index * 4 - 4 + 2];
            };
            Promise.prototype._fulfillmentHandlerAt = function(index) {
              return this[index * 4 - 4 + 0];
            };
            Promise.prototype._rejectionHandlerAt = function(index) {
              return this[index * 4 - 4 + 1];
            };
            Promise.prototype._boundValue = function() {};
            Promise.prototype._migrateCallback0 = function(follower) {
              var bitField = follower._bitField;
              var fulfill = follower._fulfillmentHandler0;
              var reject = follower._rejectionHandler0;
              var promise = follower._promise0;
              var receiver = follower._receiverAt(0);
              if (receiver === undefined)
                receiver = UNDEFINED_BINDING;
              this._addCallbacks(fulfill, reject, promise, receiver, null);
            };
            Promise.prototype._migrateCallbackAt = function(follower, index) {
              var fulfill = follower._fulfillmentHandlerAt(index);
              var reject = follower._rejectionHandlerAt(index);
              var promise = follower._promiseAt(index);
              var receiver = follower._receiverAt(index);
              if (receiver === undefined)
                receiver = UNDEFINED_BINDING;
              this._addCallbacks(fulfill, reject, promise, receiver, null);
            };
            Promise.prototype._addCallbacks = function(fulfill, reject, promise, receiver, domain) {
              var index = this._length();
              if (index >= 65535 - 4) {
                index = 0;
                this._setLength(0);
              }
              if (index === 0) {
                this._promise0 = promise;
                this._receiver0 = receiver;
                if (typeof fulfill === "function") {
                  this._fulfillmentHandler0 = domain === null ? fulfill : domain.bind(fulfill);
                }
                if (typeof reject === "function") {
                  this._rejectionHandler0 = domain === null ? reject : domain.bind(reject);
                }
              } else {
                var base = index * 4 - 4;
                this[base + 2] = promise;
                this[base + 3] = receiver;
                if (typeof fulfill === "function") {
                  this[base + 0] = domain === null ? fulfill : domain.bind(fulfill);
                }
                if (typeof reject === "function") {
                  this[base + 1] = domain === null ? reject : domain.bind(reject);
                }
              }
              this._setLength(index + 1);
              return index;
            };
            Promise.prototype._proxy = function(proxyable, arg) {
              this._addCallbacks(undefined, undefined, arg, proxyable, null);
            };
            Promise.prototype._resolveCallback = function(value, shouldBind) {
              if (((this._bitField & 117506048) !== 0))
                return;
              if (value === this)
                return this._rejectCallback(makeSelfResolutionError(), false);
              var maybePromise = tryConvertToPromise(value, this);
              if (!(maybePromise instanceof Promise))
                return this._fulfill(value);
              if (shouldBind)
                this._propagateFrom(maybePromise, 2);
              var promise = maybePromise._target();
              if (promise === this) {
                this._reject(makeSelfResolutionError());
                return;
              }
              var bitField = promise._bitField;
              if (((bitField & 50397184) === 0)) {
                var len = this._length();
                if (len > 0)
                  promise._migrateCallback0(this);
                for (var i = 1; i < len; ++i) {
                  promise._migrateCallbackAt(this, i);
                }
                this._setFollowing();
                this._setLength(0);
                this._setFollowee(promise);
              } else if (((bitField & 33554432) !== 0)) {
                this._fulfill(promise._value());
              } else if (((bitField & 16777216) !== 0)) {
                this._reject(promise._reason());
              } else {
                var reason = new CancellationError("late cancellation observer");
                promise._attachExtraTrace(reason);
                this._reject(reason);
              }
            };
            Promise.prototype._rejectCallback = function(reason, synchronous, ignoreNonErrorWarnings) {
              var trace = util.ensureErrorObject(reason);
              var hasStack = trace === reason;
              if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
                var message = "a promise was rejected with a non-error: " + util.classString(reason);
                this._warn(message, true);
              }
              this._attachExtraTrace(trace, synchronous ? hasStack : false);
              this._reject(reason);
            };
            Promise.prototype._resolveFromExecutor = function(executor) {
              var promise = this;
              this._captureStackTrace();
              this._pushContext();
              var synchronous = true;
              var r = this._execute(executor, function(value) {
                promise._resolveCallback(value);
              }, function(reason) {
                promise._rejectCallback(reason, synchronous);
              });
              synchronous = false;
              this._popContext();
              if (r !== undefined) {
                promise._rejectCallback(r, true);
              }
            };
            Promise.prototype._settlePromiseFromHandler = function(handler, receiver, value, promise) {
              var bitField = promise._bitField;
              if (((bitField & 65536) !== 0))
                return;
              promise._pushContext();
              var x;
              if (receiver === APPLY) {
                if (!value || typeof value.length !== "number") {
                  x = errorObj;
                  x.e = new TypeError("cannot .spread() a non-array: " + util.classString(value));
                } else {
                  x = tryCatch(handler).apply(this._boundValue(), value);
                }
              } else {
                x = tryCatch(handler).call(receiver, value);
              }
              var promiseCreated = promise._popContext();
              bitField = promise._bitField;
              if (((bitField & 65536) !== 0))
                return;
              if (x === NEXT_FILTER) {
                promise._reject(value);
              } else if (x === errorObj) {
                promise._rejectCallback(x.e, false);
              } else {
                debug.checkForgottenReturns(x, promiseCreated, "", promise, this);
                promise._resolveCallback(x);
              }
            };
            Promise.prototype._target = function() {
              var ret = this;
              while (ret._isFollowing())
                ret = ret._followee();
              return ret;
            };
            Promise.prototype._followee = function() {
              return this._rejectionHandler0;
            };
            Promise.prototype._setFollowee = function(promise) {
              this._rejectionHandler0 = promise;
            };
            Promise.prototype._settlePromise = function(promise, handler, receiver, value) {
              var isPromise = promise instanceof Promise;
              var bitField = this._bitField;
              var asyncGuaranteed = ((bitField & 134217728) !== 0);
              if (((bitField & 65536) !== 0)) {
                if (isPromise)
                  promise._invokeInternalOnCancel();
                if (receiver instanceof PassThroughHandlerContext && receiver.isFinallyHandler()) {
                  receiver.cancelPromise = promise;
                  if (tryCatch(handler).call(receiver, value) === errorObj) {
                    promise._reject(errorObj.e);
                  }
                } else if (handler === reflectHandler) {
                  promise._fulfill(reflectHandler.call(receiver));
                } else if (receiver instanceof Proxyable) {
                  receiver._promiseCancelled(promise);
                } else if (isPromise || promise instanceof PromiseArray) {
                  promise._cancel();
                } else {
                  receiver.cancel();
                }
              } else if (typeof handler === "function") {
                if (!isPromise) {
                  handler.call(receiver, value, promise);
                } else {
                  if (asyncGuaranteed)
                    promise._setAsyncGuaranteed();
                  this._settlePromiseFromHandler(handler, receiver, value, promise);
                }
              } else if (receiver instanceof Proxyable) {
                if (!receiver._isResolved()) {
                  if (((bitField & 33554432) !== 0)) {
                    receiver._promiseFulfilled(value, promise);
                  } else {
                    receiver._promiseRejected(value, promise);
                  }
                }
              } else if (isPromise) {
                if (asyncGuaranteed)
                  promise._setAsyncGuaranteed();
                if (((bitField & 33554432) !== 0)) {
                  promise._fulfill(value);
                } else {
                  promise._reject(value);
                }
              }
            };
            Promise.prototype._settlePromiseLateCancellationObserver = function(ctx) {
              var handler = ctx.handler;
              var promise = ctx.promise;
              var receiver = ctx.receiver;
              var value = ctx.value;
              if (typeof handler === "function") {
                if (!(promise instanceof Promise)) {
                  handler.call(receiver, value, promise);
                } else {
                  this._settlePromiseFromHandler(handler, receiver, value, promise);
                }
              } else if (promise instanceof Promise) {
                promise._reject(value);
              }
            };
            Promise.prototype._settlePromiseCtx = function(ctx) {
              this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
            };
            Promise.prototype._settlePromise0 = function(handler, value, bitField) {
              var promise = this._promise0;
              var receiver = this._receiverAt(0);
              this._promise0 = undefined;
              this._receiver0 = undefined;
              this._settlePromise(promise, handler, receiver, value);
            };
            Promise.prototype._clearCallbackDataAtIndex = function(index) {
              var base = index * 4 - 4;
              this[base + 2] = this[base + 3] = this[base + 0] = this[base + 1] = undefined;
            };
            Promise.prototype._fulfill = function(value) {
              var bitField = this._bitField;
              if (((bitField & 117506048) >>> 16))
                return;
              if (value === this) {
                var err = makeSelfResolutionError();
                this._attachExtraTrace(err);
                return this._reject(err);
              }
              this._setFulfilled();
              this._rejectionHandler0 = value;
              if ((bitField & 65535) > 0) {
                if (((bitField & 134217728) !== 0)) {
                  this._settlePromises();
                } else {
                  async.settlePromises(this);
                }
              }
            };
            Promise.prototype._reject = function(reason) {
              var bitField = this._bitField;
              if (((bitField & 117506048) >>> 16))
                return;
              this._setRejected();
              this._fulfillmentHandler0 = reason;
              if (this._isFinal()) {
                return async.fatalError(reason, util.isNode);
              }
              if ((bitField & 65535) > 0) {
                async.settlePromises(this);
              } else {
                this._ensurePossibleRejectionHandled();
              }
            };
            Promise.prototype._fulfillPromises = function(len, value) {
              for (var i = 1; i < len; i++) {
                var handler = this._fulfillmentHandlerAt(i);
                var promise = this._promiseAt(i);
                var receiver = this._receiverAt(i);
                this._clearCallbackDataAtIndex(i);
                this._settlePromise(promise, handler, receiver, value);
              }
            };
            Promise.prototype._rejectPromises = function(len, reason) {
              for (var i = 1; i < len; i++) {
                var handler = this._rejectionHandlerAt(i);
                var promise = this._promiseAt(i);
                var receiver = this._receiverAt(i);
                this._clearCallbackDataAtIndex(i);
                this._settlePromise(promise, handler, receiver, reason);
              }
            };
            Promise.prototype._settlePromises = function() {
              var bitField = this._bitField;
              var len = (bitField & 65535);
              if (len > 0) {
                if (((bitField & 16842752) !== 0)) {
                  var reason = this._fulfillmentHandler0;
                  this._settlePromise0(this._rejectionHandler0, reason, bitField);
                  this._rejectPromises(len, reason);
                } else {
                  var value = this._rejectionHandler0;
                  this._settlePromise0(this._fulfillmentHandler0, value, bitField);
                  this._fulfillPromises(len, value);
                }
                this._setLength(0);
              }
              this._clearCancellationData();
            };
            Promise.prototype._settledValue = function() {
              var bitField = this._bitField;
              if (((bitField & 33554432) !== 0)) {
                return this._rejectionHandler0;
              } else if (((bitField & 16777216) !== 0)) {
                return this._fulfillmentHandler0;
              }
            };
            function deferResolve(v) {
              this.promise._resolveCallback(v);
            }
            function deferReject(v) {
              this.promise._rejectCallback(v, false);
            }
            Promise.defer = Promise.pending = function() {
              debug.deprecated("Promise.defer", "new Promise");
              var promise = new Promise(INTERNAL);
              return {
                promise: promise,
                resolve: deferResolve,
                reject: deferReject
              };
            };
            util.notEnumerableProp(Promise, "_makeSelfResolutionError", makeSelfResolutionError);
            _dereq_("./method")(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug);
            _dereq_("./bind")(Promise, INTERNAL, tryConvertToPromise, debug);
            _dereq_("./cancel")(Promise, PromiseArray, apiRejection, debug);
            _dereq_("./direct_resolve")(Promise);
            _dereq_("./synchronous_inspection")(Promise);
            _dereq_("./join")(Promise, PromiseArray, tryConvertToPromise, INTERNAL, debug);
            Promise.Promise = Promise;
            Promise.version = "3.4.0";
            _dereq_('./map.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
            _dereq_('./call_get.js')(Promise);
            _dereq_('./using.js')(Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);
            _dereq_('./timers.js')(Promise, INTERNAL, debug);
            _dereq_('./generators.js')(Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);
            _dereq_('./nodeify.js')(Promise);
            _dereq_('./promisify.js')(Promise, INTERNAL);
            _dereq_('./props.js')(Promise, PromiseArray, tryConvertToPromise, apiRejection);
            _dereq_('./race.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);
            _dereq_('./reduce.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
            _dereq_('./settle.js')(Promise, PromiseArray, debug);
            _dereq_('./some.js')(Promise, PromiseArray, apiRejection);
            _dereq_('./filter.js')(Promise, INTERNAL);
            _dereq_('./each.js')(Promise, INTERNAL);
            _dereq_('./any.js')(Promise);
            util.toFastProperties(Promise);
            util.toFastProperties(Promise.prototype);
            function fillTypes(value) {
              var p = new Promise(INTERNAL);
              p._fulfillmentHandler0 = value;
              p._rejectionHandler0 = value;
              p._promise0 = value;
              p._receiver0 = value;
            }
            fillTypes({a: 1});
            fillTypes({b: 2});
            fillTypes({c: 3});
            fillTypes(1);
            fillTypes(function() {});
            fillTypes(undefined);
            fillTypes(false);
            fillTypes(new Promise(INTERNAL));
            debug.setBounds(Async.firstLineError, util.lastLineError);
            return Promise;
          };
        }, {
          "./any.js": 1,
          "./async": 2,
          "./bind": 3,
          "./call_get.js": 5,
          "./cancel": 6,
          "./catch_filter": 7,
          "./context": 8,
          "./debuggability": 9,
          "./direct_resolve": 10,
          "./each.js": 11,
          "./errors": 12,
          "./es5": 13,
          "./filter.js": 14,
          "./finally": 15,
          "./generators.js": 16,
          "./join": 17,
          "./map.js": 18,
          "./method": 19,
          "./nodeback": 20,
          "./nodeify.js": 21,
          "./promise_array": 23,
          "./promisify.js": 24,
          "./props.js": 25,
          "./race.js": 27,
          "./reduce.js": 28,
          "./settle.js": 30,
          "./some.js": 31,
          "./synchronous_inspection": 32,
          "./thenables": 33,
          "./timers.js": 34,
          "./using.js": 35,
          "./util": 36
        }],
        23: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, INTERNAL, tryConvertToPromise, apiRejection, Proxyable) {
            var util = _dereq_("./util");
            var isArray = util.isArray;
            function toResolutionValue(val) {
              switch (val) {
                case -2:
                  return [];
                case -3:
                  return {};
              }
            }
            function PromiseArray(values) {
              var promise = this._promise = new Promise(INTERNAL);
              if (values instanceof Promise) {
                promise._propagateFrom(values, 3);
              }
              promise._setOnCancel(this);
              this._values = values;
              this._length = 0;
              this._totalResolved = 0;
              this._init(undefined, -2);
            }
            util.inherits(PromiseArray, Proxyable);
            PromiseArray.prototype.length = function() {
              return this._length;
            };
            PromiseArray.prototype.promise = function() {
              return this._promise;
            };
            PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
              var values = tryConvertToPromise(this._values, this._promise);
              if (values instanceof Promise) {
                values = values._target();
                var bitField = values._bitField;
                ;
                this._values = values;
                if (((bitField & 50397184) === 0)) {
                  this._promise._setAsyncGuaranteed();
                  return values._then(init, this._reject, undefined, this, resolveValueIfEmpty);
                } else if (((bitField & 33554432) !== 0)) {
                  values = values._value();
                } else if (((bitField & 16777216) !== 0)) {
                  return this._reject(values._reason());
                } else {
                  return this._cancel();
                }
              }
              values = util.asArray(values);
              if (values === null) {
                var err = apiRejection("expecting an array or an iterable object but got " + util.classString(values)).reason();
                this._promise._rejectCallback(err, false);
                return;
              }
              if (values.length === 0) {
                if (resolveValueIfEmpty === -5) {
                  this._resolveEmptyArray();
                } else {
                  this._resolve(toResolutionValue(resolveValueIfEmpty));
                }
                return;
              }
              this._iterate(values);
            };
            PromiseArray.prototype._iterate = function(values) {
              var len = this.getActualLength(values.length);
              this._length = len;
              this._values = this.shouldCopyValues() ? new Array(len) : this._values;
              var result = this._promise;
              var isResolved = false;
              var bitField = null;
              for (var i = 0; i < len; ++i) {
                var maybePromise = tryConvertToPromise(values[i], result);
                if (maybePromise instanceof Promise) {
                  maybePromise = maybePromise._target();
                  bitField = maybePromise._bitField;
                } else {
                  bitField = null;
                }
                if (isResolved) {
                  if (bitField !== null) {
                    maybePromise.suppressUnhandledRejections();
                  }
                } else if (bitField !== null) {
                  if (((bitField & 50397184) === 0)) {
                    maybePromise._proxy(this, i);
                    this._values[i] = maybePromise;
                  } else if (((bitField & 33554432) !== 0)) {
                    isResolved = this._promiseFulfilled(maybePromise._value(), i);
                  } else if (((bitField & 16777216) !== 0)) {
                    isResolved = this._promiseRejected(maybePromise._reason(), i);
                  } else {
                    isResolved = this._promiseCancelled(i);
                  }
                } else {
                  isResolved = this._promiseFulfilled(maybePromise, i);
                }
              }
              if (!isResolved)
                result._setAsyncGuaranteed();
            };
            PromiseArray.prototype._isResolved = function() {
              return this._values === null;
            };
            PromiseArray.prototype._resolve = function(value) {
              this._values = null;
              this._promise._fulfill(value);
            };
            PromiseArray.prototype._cancel = function() {
              if (this._isResolved() || !this._promise.isCancellable())
                return;
              this._values = null;
              this._promise._cancel();
            };
            PromiseArray.prototype._reject = function(reason) {
              this._values = null;
              this._promise._rejectCallback(reason, false);
            };
            PromiseArray.prototype._promiseFulfilled = function(value, index) {
              this._values[index] = value;
              var totalResolved = ++this._totalResolved;
              if (totalResolved >= this._length) {
                this._resolve(this._values);
                return true;
              }
              return false;
            };
            PromiseArray.prototype._promiseCancelled = function() {
              this._cancel();
              return true;
            };
            PromiseArray.prototype._promiseRejected = function(reason) {
              this._totalResolved++;
              this._reject(reason);
              return true;
            };
            PromiseArray.prototype._resultCancelled = function() {
              if (this._isResolved())
                return;
              var values = this._values;
              this._cancel();
              if (values instanceof Promise) {
                values.cancel();
              } else {
                for (var i = 0; i < values.length; ++i) {
                  if (values[i] instanceof Promise) {
                    values[i].cancel();
                  }
                }
              }
            };
            PromiseArray.prototype.shouldCopyValues = function() {
              return true;
            };
            PromiseArray.prototype.getActualLength = function(len) {
              return len;
            };
            return PromiseArray;
          };
        }, {"./util": 36}],
        24: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, INTERNAL) {
            var THIS = {};
            var util = _dereq_("./util");
            var nodebackForPromise = _dereq_("./nodeback");
            var withAppended = util.withAppended;
            var maybeWrapAsError = util.maybeWrapAsError;
            var canEvaluate = util.canEvaluate;
            var TypeError = _dereq_("./errors").TypeError;
            var defaultSuffix = "Async";
            var defaultPromisified = {__isPromisified__: true};
            var noCopyProps = ["arity", "length", "name", "arguments", "caller", "callee", "prototype", "__isPromisified__"];
            var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");
            var defaultFilter = function(name) {
              return util.isIdentifier(name) && name.charAt(0) !== "_" && name !== "constructor";
            };
            function propsFilter(key) {
              return !noCopyPropsPattern.test(key);
            }
            function isPromisified(fn) {
              try {
                return fn.__isPromisified__ === true;
              } catch (e) {
                return false;
              }
            }
            function hasPromisified(obj, key, suffix) {
              var val = util.getDataPropertyOrDefault(obj, key + suffix, defaultPromisified);
              return val ? isPromisified(val) : false;
            }
            function checkValid(ret, suffix, suffixRegexp) {
              for (var i = 0; i < ret.length; i += 2) {
                var key = ret[i];
                if (suffixRegexp.test(key)) {
                  var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
                  for (var j = 0; j < ret.length; j += 2) {
                    if (ret[j] === keyWithoutAsyncSuffix) {
                      throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\u000a\u000a    See http://goo.gl/MqrFmX\u000a".replace("%s", suffix));
                    }
                  }
                }
              }
            }
            function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
              var keys = util.inheritedDataKeys(obj);
              var ret = [];
              for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                var value = obj[key];
                var passesDefaultFilter = filter === defaultFilter ? true : defaultFilter(key, value, obj);
                if (typeof value === "function" && !isPromisified(value) && !hasPromisified(obj, key, suffix) && filter(key, value, obj, passesDefaultFilter)) {
                  ret.push(key, value);
                }
              }
              checkValid(ret, suffix, suffixRegexp);
              return ret;
            }
            var escapeIdentRegex = function(str) {
              return str.replace(/([$])/, "\\$");
            };
            var makeNodePromisifiedEval;
            if (!true) {
              var switchCaseArgumentOrder = function(likelyArgumentCount) {
                var ret = [likelyArgumentCount];
                var min = Math.max(0, likelyArgumentCount - 1 - 3);
                for (var i = likelyArgumentCount - 1; i >= min; --i) {
                  ret.push(i);
                }
                for (var i = likelyArgumentCount + 1; i <= 3; ++i) {
                  ret.push(i);
                }
                return ret;
              };
              var argumentSequence = function(argumentCount) {
                return util.filledRange(argumentCount, "_arg", "");
              };
              var parameterDeclaration = function(parameterCount) {
                return util.filledRange(Math.max(parameterCount, 3), "_arg", "");
              };
              var parameterCount = function(fn) {
                if (typeof fn.length === "number") {
                  return Math.max(Math.min(fn.length, 1023 + 1), 0);
                }
                return 0;
              };
              makeNodePromisifiedEval = function(callback, receiver, originalName, fn, _, multiArgs) {
                var newParameterCount = Math.max(0, parameterCount(fn) - 1);
                var argumentOrder = switchCaseArgumentOrder(newParameterCount);
                var shouldProxyThis = typeof callback === "string" || receiver === THIS;
                function generateCallForArgumentCount(count) {
                  var args = argumentSequence(count).join(", ");
                  var comma = count > 0 ? ", " : "";
                  var ret;
                  if (shouldProxyThis) {
                    ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
                  } else {
                    ret = receiver === undefined ? "ret = callback({{args}}, nodeback); break;\n" : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
                  }
                  return ret.replace("{{args}}", args).replace(", ", comma);
                }
                function generateArgumentSwitchCase() {
                  var ret = "";
                  for (var i = 0; i < argumentOrder.length; ++i) {
                    ret += "case " + argumentOrder[i] + ":" + generateCallForArgumentCount(argumentOrder[i]);
                  }
                  ret += "                                                             \n\
        default:                                                             \n\
            var args = new Array(len + 1);                                   \n\
            var i = 0;                                                       \n\
            for (var i = 0; i < len; ++i) {                                  \n\
               args[i] = arguments[i];                                       \n\
            }                                                                \n\
            args[i] = nodeback;                                              \n\
            [CodeForCall]                                                    \n\
            break;                                                           \n\
        ".replace("[CodeForCall]", (shouldProxyThis ? "ret = callback.apply(this, args);\n" : "ret = callback.apply(receiver, args);\n"));
                  return ret;
                }
                var getFunctionCode = typeof callback === "string" ? ("this != null ? this['" + callback + "'] : fn") : "fn";
                var body = "'use strict';                                                \n\
        var ret = function (Parameters) {                                    \n\
            'use strict';                                                    \n\
            var len = arguments.length;                                      \n\
            var promise = new Promise(INTERNAL);                             \n\
            promise._captureStackTrace();                                    \n\
            var nodeback = nodebackForPromise(promise, " + multiArgs + ");   \n\
            var ret;                                                         \n\
            var callback = tryCatch([GetFunctionCode]);                      \n\
            switch(len) {                                                    \n\
                [CodeForSwitchCase]                                          \n\
            }                                                                \n\
            if (ret === errorObj) {                                          \n\
                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n\
            }                                                                \n\
            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n\
            return promise;                                                  \n\
        };                                                                   \n\
        notEnumerableProp(ret, '__isPromisified__', true);                   \n\
        return ret;                                                          \n\
    ".replace("[CodeForSwitchCase]", generateArgumentSwitchCase()).replace("[GetFunctionCode]", getFunctionCode);
                body = body.replace("Parameters", parameterDeclaration(newParameterCount));
                return new Function("Promise", "fn", "receiver", "withAppended", "maybeWrapAsError", "nodebackForPromise", "tryCatch", "errorObj", "notEnumerableProp", "INTERNAL", body)(Promise, fn, receiver, withAppended, maybeWrapAsError, nodebackForPromise, util.tryCatch, util.errorObj, util.notEnumerableProp, INTERNAL);
              };
            }
            function makeNodePromisifiedClosure(callback, receiver, _, fn, __, multiArgs) {
              var defaultThis = (function() {
                return this;
              })();
              var method = callback;
              if (typeof method === "string") {
                callback = fn;
              }
              function promisified() {
                var _receiver = receiver;
                if (receiver === THIS)
                  _receiver = this;
                var promise = new Promise(INTERNAL);
                promise._captureStackTrace();
                var cb = typeof method === "string" && this !== defaultThis ? this[method] : callback;
                var fn = nodebackForPromise(promise, multiArgs);
                try {
                  cb.apply(_receiver, withAppended(arguments, fn));
                } catch (e) {
                  promise._rejectCallback(maybeWrapAsError(e), true, true);
                }
                if (!promise._isFateSealed())
                  promise._setAsyncGuaranteed();
                return promise;
              }
              util.notEnumerableProp(promisified, "__isPromisified__", true);
              return promisified;
            }
            var makeNodePromisified = canEvaluate ? makeNodePromisifiedEval : makeNodePromisifiedClosure;
            function promisifyAll(obj, suffix, filter, promisifier, multiArgs) {
              var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
              var methods = promisifiableMethods(obj, suffix, suffixRegexp, filter);
              for (var i = 0,
                  len = methods.length; i < len; i += 2) {
                var key = methods[i];
                var fn = methods[i + 1];
                var promisifiedKey = key + suffix;
                if (promisifier === makeNodePromisified) {
                  obj[promisifiedKey] = makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
                } else {
                  var promisified = promisifier(fn, function() {
                    return makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
                  });
                  util.notEnumerableProp(promisified, "__isPromisified__", true);
                  obj[promisifiedKey] = promisified;
                }
              }
              util.toFastProperties(obj);
              return obj;
            }
            function promisify(callback, receiver, multiArgs) {
              return makeNodePromisified(callback, receiver, undefined, callback, null, multiArgs);
            }
            Promise.promisify = function(fn, options) {
              if (typeof fn !== "function") {
                throw new TypeError("expecting a function but got " + util.classString(fn));
              }
              if (isPromisified(fn)) {
                return fn;
              }
              options = Object(options);
              var receiver = options.context === undefined ? THIS : options.context;
              var multiArgs = !!options.multiArgs;
              var ret = promisify(fn, receiver, multiArgs);
              util.copyDescriptors(fn, ret, propsFilter);
              return ret;
            };
            Promise.promisifyAll = function(target, options) {
              if (typeof target !== "function" && typeof target !== "object") {
                throw new TypeError("the target of promisifyAll must be an object or a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
              }
              options = Object(options);
              var multiArgs = !!options.multiArgs;
              var suffix = options.suffix;
              if (typeof suffix !== "string")
                suffix = defaultSuffix;
              var filter = options.filter;
              if (typeof filter !== "function")
                filter = defaultFilter;
              var promisifier = options.promisifier;
              if (typeof promisifier !== "function")
                promisifier = makeNodePromisified;
              if (!util.isIdentifier(suffix)) {
                throw new RangeError("suffix must be a valid identifier\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
              }
              var keys = util.inheritedDataKeys(target);
              for (var i = 0; i < keys.length; ++i) {
                var value = target[keys[i]];
                if (keys[i] !== "constructor" && util.isClass(value)) {
                  promisifyAll(value.prototype, suffix, filter, promisifier, multiArgs);
                  promisifyAll(value, suffix, filter, promisifier, multiArgs);
                }
              }
              return promisifyAll(target, suffix, filter, promisifier, multiArgs);
            };
          };
        }, {
          "./errors": 12,
          "./nodeback": 20,
          "./util": 36
        }],
        25: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, PromiseArray, tryConvertToPromise, apiRejection) {
            var util = _dereq_("./util");
            var isObject = util.isObject;
            var es5 = _dereq_("./es5");
            var Es6Map;
            if (typeof Map === "function")
              Es6Map = Map;
            var mapToEntries = (function() {
              var index = 0;
              var size = 0;
              function extractEntry(value, key) {
                this[index] = value;
                this[index + size] = key;
                index++;
              }
              return function mapToEntries(map) {
                size = map.size;
                index = 0;
                var ret = new Array(map.size * 2);
                map.forEach(extractEntry, ret);
                return ret;
              };
            })();
            var entriesToMap = function(entries) {
              var ret = new Es6Map();
              var length = entries.length / 2 | 0;
              for (var i = 0; i < length; ++i) {
                var key = entries[length + i];
                var value = entries[i];
                ret.set(key, value);
              }
              return ret;
            };
            function PropertiesPromiseArray(obj) {
              var isMap = false;
              var entries;
              if (Es6Map !== undefined && obj instanceof Es6Map) {
                entries = mapToEntries(obj);
                isMap = true;
              } else {
                var keys = es5.keys(obj);
                var len = keys.length;
                entries = new Array(len * 2);
                for (var i = 0; i < len; ++i) {
                  var key = keys[i];
                  entries[i] = obj[key];
                  entries[i + len] = key;
                }
              }
              this.constructor$(entries);
              this._isMap = isMap;
              this._init$(undefined, -3);
            }
            util.inherits(PropertiesPromiseArray, PromiseArray);
            PropertiesPromiseArray.prototype._init = function() {};
            PropertiesPromiseArray.prototype._promiseFulfilled = function(value, index) {
              this._values[index] = value;
              var totalResolved = ++this._totalResolved;
              if (totalResolved >= this._length) {
                var val;
                if (this._isMap) {
                  val = entriesToMap(this._values);
                } else {
                  val = {};
                  var keyOffset = this.length();
                  for (var i = 0,
                      len = this.length(); i < len; ++i) {
                    val[this._values[i + keyOffset]] = this._values[i];
                  }
                }
                this._resolve(val);
                return true;
              }
              return false;
            };
            PropertiesPromiseArray.prototype.shouldCopyValues = function() {
              return false;
            };
            PropertiesPromiseArray.prototype.getActualLength = function(len) {
              return len >> 1;
            };
            function props(promises) {
              var ret;
              var castValue = tryConvertToPromise(promises);
              if (!isObject(castValue)) {
                return apiRejection("cannot await properties of a non-object\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
              } else if (castValue instanceof Promise) {
                ret = castValue._then(Promise.props, undefined, undefined, undefined, undefined);
              } else {
                ret = new PropertiesPromiseArray(castValue).promise();
              }
              if (castValue instanceof Promise) {
                ret._propagateFrom(castValue, 2);
              }
              return ret;
            }
            Promise.prototype.props = function() {
              return props(this);
            };
            Promise.props = function(promises) {
              return props(promises);
            };
          };
        }, {
          "./es5": 13,
          "./util": 36
        }],
        26: [function(_dereq_, module, exports) {
          "use strict";
          function arrayMove(src, srcIndex, dst, dstIndex, len) {
            for (var j = 0; j < len; ++j) {
              dst[j + dstIndex] = src[j + srcIndex];
              src[j + srcIndex] = void 0;
            }
          }
          function Queue(capacity) {
            this._capacity = capacity;
            this._length = 0;
            this._front = 0;
          }
          Queue.prototype._willBeOverCapacity = function(size) {
            return this._capacity < size;
          };
          Queue.prototype._pushOne = function(arg) {
            var length = this.length();
            this._checkCapacity(length + 1);
            var i = (this._front + length) & (this._capacity - 1);
            this[i] = arg;
            this._length = length + 1;
          };
          Queue.prototype._unshiftOne = function(value) {
            var capacity = this._capacity;
            this._checkCapacity(this.length() + 1);
            var front = this._front;
            var i = ((((front - 1) & (capacity - 1)) ^ capacity) - capacity);
            this[i] = value;
            this._front = i;
            this._length = this.length() + 1;
          };
          Queue.prototype.unshift = function(fn, receiver, arg) {
            this._unshiftOne(arg);
            this._unshiftOne(receiver);
            this._unshiftOne(fn);
          };
          Queue.prototype.push = function(fn, receiver, arg) {
            var length = this.length() + 3;
            if (this._willBeOverCapacity(length)) {
              this._pushOne(fn);
              this._pushOne(receiver);
              this._pushOne(arg);
              return;
            }
            var j = this._front + length - 3;
            this._checkCapacity(length);
            var wrapMask = this._capacity - 1;
            this[(j + 0) & wrapMask] = fn;
            this[(j + 1) & wrapMask] = receiver;
            this[(j + 2) & wrapMask] = arg;
            this._length = length;
          };
          Queue.prototype.shift = function() {
            var front = this._front,
                ret = this[front];
            this[front] = undefined;
            this._front = (front + 1) & (this._capacity - 1);
            this._length--;
            return ret;
          };
          Queue.prototype.length = function() {
            return this._length;
          };
          Queue.prototype._checkCapacity = function(size) {
            if (this._capacity < size) {
              this._resizeTo(this._capacity << 1);
            }
          };
          Queue.prototype._resizeTo = function(capacity) {
            var oldCapacity = this._capacity;
            this._capacity = capacity;
            var front = this._front;
            var length = this._length;
            var moveItemsCount = (front + length) & (oldCapacity - 1);
            arrayMove(this, 0, this, oldCapacity, moveItemsCount);
          };
          module.exports = Queue;
        }, {}],
        27: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, INTERNAL, tryConvertToPromise, apiRejection) {
            var util = _dereq_("./util");
            var raceLater = function(promise) {
              return promise.then(function(array) {
                return race(array, promise);
              });
            };
            function race(promises, parent) {
              var maybePromise = tryConvertToPromise(promises);
              if (maybePromise instanceof Promise) {
                return raceLater(maybePromise);
              } else {
                promises = util.asArray(promises);
                if (promises === null)
                  return apiRejection("expecting an array or an iterable object but got " + util.classString(promises));
              }
              var ret = new Promise(INTERNAL);
              if (parent !== undefined) {
                ret._propagateFrom(parent, 3);
              }
              var fulfill = ret._fulfill;
              var reject = ret._reject;
              for (var i = 0,
                  len = promises.length; i < len; ++i) {
                var val = promises[i];
                if (val === undefined && !(i in promises)) {
                  continue;
                }
                Promise.cast(val)._then(fulfill, reject, undefined, ret, null);
              }
              return ret;
            }
            Promise.race = function(promises) {
              return race(promises, undefined);
            };
            Promise.prototype.race = function() {
              return race(this, undefined);
            };
          };
        }, {"./util": 36}],
        28: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
            var getDomain = Promise._getDomain;
            var util = _dereq_("./util");
            var tryCatch = util.tryCatch;
            function ReductionPromiseArray(promises, fn, initialValue, _each) {
              this.constructor$(promises);
              var domain = getDomain();
              this._fn = domain === null ? fn : domain.bind(fn);
              if (initialValue !== undefined) {
                initialValue = Promise.resolve(initialValue);
                initialValue._attachCancellationCallback(this);
              }
              this._initialValue = initialValue;
              this._currentCancellable = null;
              this._eachValues = _each === INTERNAL ? [] : undefined;
              this._promise._captureStackTrace();
              this._init$(undefined, -5);
            }
            util.inherits(ReductionPromiseArray, PromiseArray);
            ReductionPromiseArray.prototype._gotAccum = function(accum) {
              if (this._eachValues !== undefined && accum !== INTERNAL) {
                this._eachValues.push(accum);
              }
            };
            ReductionPromiseArray.prototype._eachComplete = function(value) {
              this._eachValues.push(value);
              return this._eachValues;
            };
            ReductionPromiseArray.prototype._init = function() {};
            ReductionPromiseArray.prototype._resolveEmptyArray = function() {
              this._resolve(this._eachValues !== undefined ? this._eachValues : this._initialValue);
            };
            ReductionPromiseArray.prototype.shouldCopyValues = function() {
              return false;
            };
            ReductionPromiseArray.prototype._resolve = function(value) {
              this._promise._resolveCallback(value);
              this._values = null;
            };
            ReductionPromiseArray.prototype._resultCancelled = function(sender) {
              if (sender === this._initialValue)
                return this._cancel();
              if (this._isResolved())
                return;
              this._resultCancelled$();
              if (this._currentCancellable instanceof Promise) {
                this._currentCancellable.cancel();
              }
              if (this._initialValue instanceof Promise) {
                this._initialValue.cancel();
              }
            };
            ReductionPromiseArray.prototype._iterate = function(values) {
              this._values = values;
              var value;
              var i;
              var length = values.length;
              if (this._initialValue !== undefined) {
                value = this._initialValue;
                i = 0;
              } else {
                value = Promise.resolve(values[0]);
                i = 1;
              }
              this._currentCancellable = value;
              if (!value.isRejected()) {
                for (; i < length; ++i) {
                  var ctx = {
                    accum: null,
                    value: values[i],
                    index: i,
                    length: length,
                    array: this
                  };
                  value = value._then(gotAccum, undefined, undefined, ctx, undefined);
                }
              }
              if (this._eachValues !== undefined) {
                value = value._then(this._eachComplete, undefined, undefined, this, undefined);
              }
              value._then(completed, completed, undefined, value, this);
            };
            Promise.prototype.reduce = function(fn, initialValue) {
              return reduce(this, fn, initialValue, null);
            };
            Promise.reduce = function(promises, fn, initialValue, _each) {
              return reduce(promises, fn, initialValue, _each);
            };
            function completed(valueOrReason, array) {
              if (this.isFulfilled()) {
                array._resolve(valueOrReason);
              } else {
                array._reject(valueOrReason);
              }
            }
            function reduce(promises, fn, initialValue, _each) {
              if (typeof fn !== "function") {
                return apiRejection("expecting a function but got " + util.classString(fn));
              }
              var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
              return array.promise();
            }
            function gotAccum(accum) {
              this.accum = accum;
              this.array._gotAccum(accum);
              var value = tryConvertToPromise(this.value, this.array._promise);
              if (value instanceof Promise) {
                this.array._currentCancellable = value;
                return value._then(gotValue, undefined, undefined, this, undefined);
              } else {
                return gotValue.call(this, value);
              }
            }
            function gotValue(value) {
              var array = this.array;
              var promise = array._promise;
              var fn = tryCatch(array._fn);
              promise._pushContext();
              var ret;
              if (array._eachValues !== undefined) {
                ret = fn.call(promise._boundValue(), value, this.index, this.length);
              } else {
                ret = fn.call(promise._boundValue(), this.accum, value, this.index, this.length);
              }
              if (ret instanceof Promise) {
                array._currentCancellable = ret;
              }
              var promiseCreated = promise._popContext();
              debug.checkForgottenReturns(ret, promiseCreated, array._eachValues !== undefined ? "Promise.each" : "Promise.reduce", promise);
              return ret;
            }
          };
        }, {"./util": 36}],
        29: [function(_dereq_, module, exports) {
          "use strict";
          var util = _dereq_("./util");
          var schedule;
          var noAsyncScheduler = function() {
            throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
          };
          var NativePromise = util.getNativePromise();
          if (util.isNode && typeof MutationObserver === "undefined") {
            var GlobalSetImmediate = global.setImmediate;
            var ProcessNextTick = process.nextTick;
            schedule = util.isRecentNode ? function(fn) {
              GlobalSetImmediate.call(global, fn);
            } : function(fn) {
              ProcessNextTick.call(process, fn);
            };
          } else if (typeof NativePromise === "function") {
            var nativePromise = NativePromise.resolve();
            schedule = function(fn) {
              nativePromise.then(fn);
            };
          } else if ((typeof MutationObserver !== "undefined") && !(typeof window !== "undefined" && window.navigator && window.navigator.standalone)) {
            schedule = (function() {
              var div = document.createElement("div");
              var opts = {attributes: true};
              var toggleScheduled = false;
              var div2 = document.createElement("div");
              var o2 = new MutationObserver(function() {
                div.classList.toggle("foo");
                toggleScheduled = false;
              });
              o2.observe(div2, opts);
              var scheduleToggle = function() {
                if (toggleScheduled)
                  return;
                toggleScheduled = true;
                div2.classList.toggle("foo");
              };
              return function schedule(fn) {
                var o = new MutationObserver(function() {
                  o.disconnect();
                  fn();
                });
                o.observe(div, opts);
                scheduleToggle();
              };
            })();
          } else if (typeof setImmediate !== "undefined") {
            schedule = function(fn) {
              setImmediate(fn);
            };
          } else if (typeof setTimeout !== "undefined") {
            schedule = function(fn) {
              setTimeout(fn, 0);
            };
          } else {
            schedule = noAsyncScheduler;
          }
          module.exports = schedule;
        }, {"./util": 36}],
        30: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, PromiseArray, debug) {
            var PromiseInspection = Promise.PromiseInspection;
            var util = _dereq_("./util");
            function SettledPromiseArray(values) {
              this.constructor$(values);
            }
            util.inherits(SettledPromiseArray, PromiseArray);
            SettledPromiseArray.prototype._promiseResolved = function(index, inspection) {
              this._values[index] = inspection;
              var totalResolved = ++this._totalResolved;
              if (totalResolved >= this._length) {
                this._resolve(this._values);
                return true;
              }
              return false;
            };
            SettledPromiseArray.prototype._promiseFulfilled = function(value, index) {
              var ret = new PromiseInspection();
              ret._bitField = 33554432;
              ret._settledValueField = value;
              return this._promiseResolved(index, ret);
            };
            SettledPromiseArray.prototype._promiseRejected = function(reason, index) {
              var ret = new PromiseInspection();
              ret._bitField = 16777216;
              ret._settledValueField = reason;
              return this._promiseResolved(index, ret);
            };
            Promise.settle = function(promises) {
              debug.deprecated(".settle()", ".reflect()");
              return new SettledPromiseArray(promises).promise();
            };
            Promise.prototype.settle = function() {
              return Promise.settle(this);
            };
          };
        }, {"./util": 36}],
        31: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, PromiseArray, apiRejection) {
            var util = _dereq_("./util");
            var RangeError = _dereq_("./errors").RangeError;
            var AggregateError = _dereq_("./errors").AggregateError;
            var isArray = util.isArray;
            var CANCELLATION = {};
            function SomePromiseArray(values) {
              this.constructor$(values);
              this._howMany = 0;
              this._unwrap = false;
              this._initialized = false;
            }
            util.inherits(SomePromiseArray, PromiseArray);
            SomePromiseArray.prototype._init = function() {
              if (!this._initialized) {
                return;
              }
              if (this._howMany === 0) {
                this._resolve([]);
                return;
              }
              this._init$(undefined, -5);
              var isArrayResolved = isArray(this._values);
              if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {
                this._reject(this._getRangeError(this.length()));
              }
            };
            SomePromiseArray.prototype.init = function() {
              this._initialized = true;
              this._init();
            };
            SomePromiseArray.prototype.setUnwrap = function() {
              this._unwrap = true;
            };
            SomePromiseArray.prototype.howMany = function() {
              return this._howMany;
            };
            SomePromiseArray.prototype.setHowMany = function(count) {
              this._howMany = count;
            };
            SomePromiseArray.prototype._promiseFulfilled = function(value) {
              this._addFulfilled(value);
              if (this._fulfilled() === this.howMany()) {
                this._values.length = this.howMany();
                if (this.howMany() === 1 && this._unwrap) {
                  this._resolve(this._values[0]);
                } else {
                  this._resolve(this._values);
                }
                return true;
              }
              return false;
            };
            SomePromiseArray.prototype._promiseRejected = function(reason) {
              this._addRejected(reason);
              return this._checkOutcome();
            };
            SomePromiseArray.prototype._promiseCancelled = function() {
              if (this._values instanceof Promise || this._values == null) {
                return this._cancel();
              }
              this._addRejected(CANCELLATION);
              return this._checkOutcome();
            };
            SomePromiseArray.prototype._checkOutcome = function() {
              if (this.howMany() > this._canPossiblyFulfill()) {
                var e = new AggregateError();
                for (var i = this.length(); i < this._values.length; ++i) {
                  if (this._values[i] !== CANCELLATION) {
                    e.push(this._values[i]);
                  }
                }
                if (e.length > 0) {
                  this._reject(e);
                } else {
                  this._cancel();
                }
                return true;
              }
              return false;
            };
            SomePromiseArray.prototype._fulfilled = function() {
              return this._totalResolved;
            };
            SomePromiseArray.prototype._rejected = function() {
              return this._values.length - this.length();
            };
            SomePromiseArray.prototype._addRejected = function(reason) {
              this._values.push(reason);
            };
            SomePromiseArray.prototype._addFulfilled = function(value) {
              this._values[this._totalResolved++] = value;
            };
            SomePromiseArray.prototype._canPossiblyFulfill = function() {
              return this.length() - this._rejected();
            };
            SomePromiseArray.prototype._getRangeError = function(count) {
              var message = "Input array must contain at least " + this._howMany + " items but contains only " + count + " items";
              return new RangeError(message);
            };
            SomePromiseArray.prototype._resolveEmptyArray = function() {
              this._reject(this._getRangeError(0));
            };
            function some(promises, howMany) {
              if ((howMany | 0) !== howMany || howMany < 0) {
                return apiRejection("expecting a positive integer\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
              }
              var ret = new SomePromiseArray(promises);
              var promise = ret.promise();
              ret.setHowMany(howMany);
              ret.init();
              return promise;
            }
            Promise.some = function(promises, howMany) {
              return some(promises, howMany);
            };
            Promise.prototype.some = function(howMany) {
              return some(this, howMany);
            };
            Promise._SomePromiseArray = SomePromiseArray;
          };
        }, {
          "./errors": 12,
          "./util": 36
        }],
        32: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise) {
            function PromiseInspection(promise) {
              if (promise !== undefined) {
                promise = promise._target();
                this._bitField = promise._bitField;
                this._settledValueField = promise._isFateSealed() ? promise._settledValue() : undefined;
              } else {
                this._bitField = 0;
                this._settledValueField = undefined;
              }
            }
            PromiseInspection.prototype._settledValue = function() {
              return this._settledValueField;
            };
            var value = PromiseInspection.prototype.value = function() {
              if (!this.isFulfilled()) {
                throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
              }
              return this._settledValue();
            };
            var reason = PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function() {
              if (!this.isRejected()) {
                throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
              }
              return this._settledValue();
            };
            var isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
              return (this._bitField & 33554432) !== 0;
            };
            var isRejected = PromiseInspection.prototype.isRejected = function() {
              return (this._bitField & 16777216) !== 0;
            };
            var isPending = PromiseInspection.prototype.isPending = function() {
              return (this._bitField & 50397184) === 0;
            };
            var isResolved = PromiseInspection.prototype.isResolved = function() {
              return (this._bitField & 50331648) !== 0;
            };
            PromiseInspection.prototype.isCancelled = Promise.prototype._isCancelled = function() {
              return (this._bitField & 65536) === 65536;
            };
            Promise.prototype.isCancelled = function() {
              return this._target()._isCancelled();
            };
            Promise.prototype.isPending = function() {
              return isPending.call(this._target());
            };
            Promise.prototype.isRejected = function() {
              return isRejected.call(this._target());
            };
            Promise.prototype.isFulfilled = function() {
              return isFulfilled.call(this._target());
            };
            Promise.prototype.isResolved = function() {
              return isResolved.call(this._target());
            };
            Promise.prototype.value = function() {
              return value.call(this._target());
            };
            Promise.prototype.reason = function() {
              var target = this._target();
              target._unsetRejectionIsUnhandled();
              return reason.call(target);
            };
            Promise.prototype._value = function() {
              return this._settledValue();
            };
            Promise.prototype._reason = function() {
              this._unsetRejectionIsUnhandled();
              return this._settledValue();
            };
            Promise.PromiseInspection = PromiseInspection;
          };
        }, {}],
        33: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, INTERNAL) {
            var util = _dereq_("./util");
            var errorObj = util.errorObj;
            var isObject = util.isObject;
            function tryConvertToPromise(obj, context) {
              if (isObject(obj)) {
                if (obj instanceof Promise)
                  return obj;
                var then = getThen(obj);
                if (then === errorObj) {
                  if (context)
                    context._pushContext();
                  var ret = Promise.reject(then.e);
                  if (context)
                    context._popContext();
                  return ret;
                } else if (typeof then === "function") {
                  if (isAnyBluebirdPromise(obj)) {
                    var ret = new Promise(INTERNAL);
                    obj._then(ret._fulfill, ret._reject, undefined, ret, null);
                    return ret;
                  }
                  return doThenable(obj, then, context);
                }
              }
              return obj;
            }
            function doGetThen(obj) {
              return obj.then;
            }
            function getThen(obj) {
              try {
                return doGetThen(obj);
              } catch (e) {
                errorObj.e = e;
                return errorObj;
              }
            }
            var hasProp = {}.hasOwnProperty;
            function isAnyBluebirdPromise(obj) {
              try {
                return hasProp.call(obj, "_promise0");
              } catch (e) {
                return false;
              }
            }
            function doThenable(x, then, context) {
              var promise = new Promise(INTERNAL);
              var ret = promise;
              if (context)
                context._pushContext();
              promise._captureStackTrace();
              if (context)
                context._popContext();
              var synchronous = true;
              var result = util.tryCatch(then).call(x, resolve, reject);
              synchronous = false;
              if (promise && result === errorObj) {
                promise._rejectCallback(result.e, true, true);
                promise = null;
              }
              function resolve(value) {
                if (!promise)
                  return;
                promise._resolveCallback(value);
                promise = null;
              }
              function reject(reason) {
                if (!promise)
                  return;
                promise._rejectCallback(reason, synchronous, true);
                promise = null;
              }
              return ret;
            }
            return tryConvertToPromise;
          };
        }, {"./util": 36}],
        34: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, INTERNAL, debug) {
            var util = _dereq_("./util");
            var TimeoutError = Promise.TimeoutError;
            function HandleWrapper(handle) {
              this.handle = handle;
            }
            HandleWrapper.prototype._resultCancelled = function() {
              clearTimeout(this.handle);
            };
            var afterValue = function(value) {
              return delay(+this).thenReturn(value);
            };
            var delay = Promise.delay = function(ms, value) {
              var ret;
              var handle;
              if (value !== undefined) {
                ret = Promise.resolve(value)._then(afterValue, null, null, ms, undefined);
                if (debug.cancellation() && value instanceof Promise) {
                  ret._setOnCancel(value);
                }
              } else {
                ret = new Promise(INTERNAL);
                handle = setTimeout(function() {
                  ret._fulfill();
                }, +ms);
                if (debug.cancellation()) {
                  ret._setOnCancel(new HandleWrapper(handle));
                }
              }
              ret._setAsyncGuaranteed();
              return ret;
            };
            Promise.prototype.delay = function(ms) {
              return delay(ms, this);
            };
            var afterTimeout = function(promise, message, parent) {
              var err;
              if (typeof message !== "string") {
                if (message instanceof Error) {
                  err = message;
                } else {
                  err = new TimeoutError("operation timed out");
                }
              } else {
                err = new TimeoutError(message);
              }
              util.markAsOriginatingFromRejection(err);
              promise._attachExtraTrace(err);
              promise._reject(err);
              if (parent != null) {
                parent.cancel();
              }
            };
            function successClear(value) {
              clearTimeout(this.handle);
              return value;
            }
            function failureClear(reason) {
              clearTimeout(this.handle);
              throw reason;
            }
            Promise.prototype.timeout = function(ms, message) {
              ms = +ms;
              var ret,
                  parent;
              var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
                if (ret.isPending()) {
                  afterTimeout(ret, message, parent);
                }
              }, ms));
              if (debug.cancellation()) {
                parent = this.then();
                ret = parent._then(successClear, failureClear, undefined, handleWrapper, undefined);
                ret._setOnCancel(handleWrapper);
              } else {
                ret = this._then(successClear, failureClear, undefined, handleWrapper, undefined);
              }
              return ret;
            };
          };
        }, {"./util": 36}],
        35: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug) {
            var util = _dereq_("./util");
            var TypeError = _dereq_("./errors").TypeError;
            var inherits = _dereq_("./util").inherits;
            var errorObj = util.errorObj;
            var tryCatch = util.tryCatch;
            var NULL = {};
            function thrower(e) {
              setTimeout(function() {
                throw e;
              }, 0);
            }
            function castPreservingDisposable(thenable) {
              var maybePromise = tryConvertToPromise(thenable);
              if (maybePromise !== thenable && typeof thenable._isDisposable === "function" && typeof thenable._getDisposer === "function" && thenable._isDisposable()) {
                maybePromise._setDisposable(thenable._getDisposer());
              }
              return maybePromise;
            }
            function dispose(resources, inspection) {
              var i = 0;
              var len = resources.length;
              var ret = new Promise(INTERNAL);
              function iterator() {
                if (i >= len)
                  return ret._fulfill();
                var maybePromise = castPreservingDisposable(resources[i++]);
                if (maybePromise instanceof Promise && maybePromise._isDisposable()) {
                  try {
                    maybePromise = tryConvertToPromise(maybePromise._getDisposer().tryDispose(inspection), resources.promise);
                  } catch (e) {
                    return thrower(e);
                  }
                  if (maybePromise instanceof Promise) {
                    return maybePromise._then(iterator, thrower, null, null, null);
                  }
                }
                iterator();
              }
              iterator();
              return ret;
            }
            function Disposer(data, promise, context) {
              this._data = data;
              this._promise = promise;
              this._context = context;
            }
            Disposer.prototype.data = function() {
              return this._data;
            };
            Disposer.prototype.promise = function() {
              return this._promise;
            };
            Disposer.prototype.resource = function() {
              if (this.promise().isFulfilled()) {
                return this.promise().value();
              }
              return NULL;
            };
            Disposer.prototype.tryDispose = function(inspection) {
              var resource = this.resource();
              var context = this._context;
              if (context !== undefined)
                context._pushContext();
              var ret = resource !== NULL ? this.doDispose(resource, inspection) : null;
              if (context !== undefined)
                context._popContext();
              this._promise._unsetDisposable();
              this._data = null;
              return ret;
            };
            Disposer.isDisposer = function(d) {
              return (d != null && typeof d.resource === "function" && typeof d.tryDispose === "function");
            };
            function FunctionDisposer(fn, promise, context) {
              this.constructor$(fn, promise, context);
            }
            inherits(FunctionDisposer, Disposer);
            FunctionDisposer.prototype.doDispose = function(resource, inspection) {
              var fn = this.data();
              return fn.call(resource, resource, inspection);
            };
            function maybeUnwrapDisposer(value) {
              if (Disposer.isDisposer(value)) {
                this.resources[this.index]._setDisposable(value);
                return value.promise();
              }
              return value;
            }
            function ResourceList(length) {
              this.length = length;
              this.promise = null;
              this[length - 1] = null;
            }
            ResourceList.prototype._resultCancelled = function() {
              var len = this.length;
              for (var i = 0; i < len; ++i) {
                var item = this[i];
                if (item instanceof Promise) {
                  item.cancel();
                }
              }
            };
            Promise.using = function() {
              var len = arguments.length;
              if (len < 2)
                return apiRejection("you must pass at least 2 arguments to Promise.using");
              var fn = arguments[len - 1];
              if (typeof fn !== "function") {
                return apiRejection("expecting a function but got " + util.classString(fn));
              }
              var input;
              var spreadArgs = true;
              if (len === 2 && Array.isArray(arguments[0])) {
                input = arguments[0];
                len = input.length;
                spreadArgs = false;
              } else {
                input = arguments;
                len--;
              }
              var resources = new ResourceList(len);
              for (var i = 0; i < len; ++i) {
                var resource = input[i];
                if (Disposer.isDisposer(resource)) {
                  var disposer = resource;
                  resource = resource.promise();
                  resource._setDisposable(disposer);
                } else {
                  var maybePromise = tryConvertToPromise(resource);
                  if (maybePromise instanceof Promise) {
                    resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
                      resources: resources,
                      index: i
                    }, undefined);
                  }
                }
                resources[i] = resource;
              }
              var reflectedResources = new Array(resources.length);
              for (var i = 0; i < reflectedResources.length; ++i) {
                reflectedResources[i] = Promise.resolve(resources[i]).reflect();
              }
              var resultPromise = Promise.all(reflectedResources).then(function(inspections) {
                for (var i = 0; i < inspections.length; ++i) {
                  var inspection = inspections[i];
                  if (inspection.isRejected()) {
                    errorObj.e = inspection.error();
                    return errorObj;
                  } else if (!inspection.isFulfilled()) {
                    resultPromise.cancel();
                    return;
                  }
                  inspections[i] = inspection.value();
                }
                promise._pushContext();
                fn = tryCatch(fn);
                var ret = spreadArgs ? fn.apply(undefined, inspections) : fn(inspections);
                var promiseCreated = promise._popContext();
                debug.checkForgottenReturns(ret, promiseCreated, "Promise.using", promise);
                return ret;
              });
              var promise = resultPromise.lastly(function() {
                var inspection = new Promise.PromiseInspection(resultPromise);
                return dispose(resources, inspection);
              });
              resources.promise = promise;
              promise._setOnCancel(resources);
              return promise;
            };
            Promise.prototype._setDisposable = function(disposer) {
              this._bitField = this._bitField | 131072;
              this._disposer = disposer;
            };
            Promise.prototype._isDisposable = function() {
              return (this._bitField & 131072) > 0;
            };
            Promise.prototype._getDisposer = function() {
              return this._disposer;
            };
            Promise.prototype._unsetDisposable = function() {
              this._bitField = this._bitField & (~131072);
              this._disposer = undefined;
            };
            Promise.prototype.disposer = function(fn) {
              if (typeof fn === "function") {
                return new FunctionDisposer(fn, this, createContext());
              }
              throw new TypeError();
            };
          };
        }, {
          "./errors": 12,
          "./util": 36
        }],
        36: [function(_dereq_, module, exports) {
          "use strict";
          var es5 = _dereq_("./es5");
          var canEvaluate = typeof navigator == "undefined";
          var errorObj = {e: {}};
          var tryCatchTarget;
          var globalObject = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : this !== undefined ? this : null;
          function tryCatcher() {
            try {
              var target = tryCatchTarget;
              tryCatchTarget = null;
              return target.apply(this, arguments);
            } catch (e) {
              errorObj.e = e;
              return errorObj;
            }
          }
          function tryCatch(fn) {
            tryCatchTarget = fn;
            return tryCatcher;
          }
          var inherits = function(Child, Parent) {
            var hasProp = {}.hasOwnProperty;
            function T() {
              this.constructor = Child;
              this.constructor$ = Parent;
              for (var propertyName in Parent.prototype) {
                if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== "$") {
                  this[propertyName + "$"] = Parent.prototype[propertyName];
                }
              }
            }
            T.prototype = Parent.prototype;
            Child.prototype = new T();
            return Child.prototype;
          };
          function isPrimitive(val) {
            return val == null || val === true || val === false || typeof val === "string" || typeof val === "number";
          }
          function isObject(value) {
            return typeof value === "function" || typeof value === "object" && value !== null;
          }
          function maybeWrapAsError(maybeError) {
            if (!isPrimitive(maybeError))
              return maybeError;
            return new Error(safeToString(maybeError));
          }
          function withAppended(target, appendee) {
            var len = target.length;
            var ret = new Array(len + 1);
            var i;
            for (i = 0; i < len; ++i) {
              ret[i] = target[i];
            }
            ret[i] = appendee;
            return ret;
          }
          function getDataPropertyOrDefault(obj, key, defaultValue) {
            if (es5.isES5) {
              var desc = Object.getOwnPropertyDescriptor(obj, key);
              if (desc != null) {
                return desc.get == null && desc.set == null ? desc.value : defaultValue;
              }
            } else {
              return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
            }
          }
          function notEnumerableProp(obj, name, value) {
            if (isPrimitive(obj))
              return obj;
            var descriptor = {
              value: value,
              configurable: true,
              enumerable: false,
              writable: true
            };
            es5.defineProperty(obj, name, descriptor);
            return obj;
          }
          function thrower(r) {
            throw r;
          }
          var inheritedDataKeys = (function() {
            var excludedPrototypes = [Array.prototype, Object.prototype, Function.prototype];
            var isExcludedProto = function(val) {
              for (var i = 0; i < excludedPrototypes.length; ++i) {
                if (excludedPrototypes[i] === val) {
                  return true;
                }
              }
              return false;
            };
            if (es5.isES5) {
              var getKeys = Object.getOwnPropertyNames;
              return function(obj) {
                var ret = [];
                var visitedKeys = Object.create(null);
                while (obj != null && !isExcludedProto(obj)) {
                  var keys;
                  try {
                    keys = getKeys(obj);
                  } catch (e) {
                    return ret;
                  }
                  for (var i = 0; i < keys.length; ++i) {
                    var key = keys[i];
                    if (visitedKeys[key])
                      continue;
                    visitedKeys[key] = true;
                    var desc = Object.getOwnPropertyDescriptor(obj, key);
                    if (desc != null && desc.get == null && desc.set == null) {
                      ret.push(key);
                    }
                  }
                  obj = es5.getPrototypeOf(obj);
                }
                return ret;
              };
            } else {
              var hasProp = {}.hasOwnProperty;
              return function(obj) {
                if (isExcludedProto(obj))
                  return [];
                var ret = [];
                enumeration: for (var key in obj) {
                  if (hasProp.call(obj, key)) {
                    ret.push(key);
                  } else {
                    for (var i = 0; i < excludedPrototypes.length; ++i) {
                      if (hasProp.call(excludedPrototypes[i], key)) {
                        continue enumeration;
                      }
                    }
                    ret.push(key);
                  }
                }
                return ret;
              };
            }
          })();
          var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
          function isClass(fn) {
            try {
              if (typeof fn === "function") {
                var keys = es5.names(fn.prototype);
                var hasMethods = es5.isES5 && keys.length > 1;
                var hasMethodsOtherThanConstructor = keys.length > 0 && !(keys.length === 1 && keys[0] === "constructor");
                var hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;
                if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) {
                  return true;
                }
              }
              return false;
            } catch (e) {
              return false;
            }
          }
          function toFastProperties(obj) {
            function FakeConstructor() {}
            FakeConstructor.prototype = obj;
            var l = 8;
            while (l--)
              new FakeConstructor();
            return obj;
            eval(obj);
          }
          var rident = /^[a-z$_][a-z$_0-9]*$/i;
          function isIdentifier(str) {
            return rident.test(str);
          }
          function filledRange(count, prefix, suffix) {
            var ret = new Array(count);
            for (var i = 0; i < count; ++i) {
              ret[i] = prefix + i + suffix;
            }
            return ret;
          }
          function safeToString(obj) {
            try {
              return obj + "";
            } catch (e) {
              return "[no string representation]";
            }
          }
          function isError(obj) {
            return obj !== null && typeof obj === "object" && typeof obj.message === "string" && typeof obj.name === "string";
          }
          function markAsOriginatingFromRejection(e) {
            try {
              notEnumerableProp(e, "isOperational", true);
            } catch (ignore) {}
          }
          function originatesFromRejection(e) {
            if (e == null)
              return false;
            return ((e instanceof Error["__BluebirdErrorTypes__"].OperationalError) || e["isOperational"] === true);
          }
          function canAttachTrace(obj) {
            return isError(obj) && es5.propertyIsWritable(obj, "stack");
          }
          var ensureErrorObject = (function() {
            if (!("stack" in new Error())) {
              return function(value) {
                if (canAttachTrace(value))
                  return value;
                try {
                  throw new Error(safeToString(value));
                } catch (err) {
                  return err;
                }
              };
            } else {
              return function(value) {
                if (canAttachTrace(value))
                  return value;
                return new Error(safeToString(value));
              };
            }
          })();
          function classString(obj) {
            return {}.toString.call(obj);
          }
          function copyDescriptors(from, to, filter) {
            var keys = es5.names(from);
            for (var i = 0; i < keys.length; ++i) {
              var key = keys[i];
              if (filter(key)) {
                try {
                  es5.defineProperty(to, key, es5.getDescriptor(from, key));
                } catch (ignore) {}
              }
            }
          }
          var asArray = function(v) {
            if (es5.isArray(v)) {
              return v;
            }
            return null;
          };
          if (typeof Symbol !== "undefined" && Symbol.iterator) {
            var ArrayFrom = typeof Array.from === "function" ? function(v) {
              return Array.from(v);
            } : function(v) {
              var ret = [];
              var it = v[Symbol.iterator]();
              var itResult;
              while (!((itResult = it.next()).done)) {
                ret.push(itResult.value);
              }
              return ret;
            };
            asArray = function(v) {
              if (es5.isArray(v)) {
                return v;
              } else if (v != null && typeof v[Symbol.iterator] === "function") {
                return ArrayFrom(v);
              }
              return null;
            };
          }
          var isNode = typeof process !== "undefined" && classString(process).toLowerCase() === "[object process]";
          function env(key, def) {
            return isNode ? process.env[key] : def;
          }
          function getNativePromise() {
            if (typeof Promise === "function") {
              try {
                var promise = new Promise(function() {});
                if ({}.toString.call(promise) === "[object Promise]") {
                  return Promise;
                }
              } catch (e) {}
            }
          }
          var ret = {
            isClass: isClass,
            isIdentifier: isIdentifier,
            inheritedDataKeys: inheritedDataKeys,
            getDataPropertyOrDefault: getDataPropertyOrDefault,
            thrower: thrower,
            isArray: es5.isArray,
            asArray: asArray,
            notEnumerableProp: notEnumerableProp,
            isPrimitive: isPrimitive,
            isObject: isObject,
            isError: isError,
            canEvaluate: canEvaluate,
            errorObj: errorObj,
            tryCatch: tryCatch,
            inherits: inherits,
            withAppended: withAppended,
            maybeWrapAsError: maybeWrapAsError,
            toFastProperties: toFastProperties,
            filledRange: filledRange,
            toString: safeToString,
            canAttachTrace: canAttachTrace,
            ensureErrorObject: ensureErrorObject,
            originatesFromRejection: originatesFromRejection,
            markAsOriginatingFromRejection: markAsOriginatingFromRejection,
            classString: classString,
            copyDescriptors: copyDescriptors,
            hasDevTools: typeof chrome !== "undefined" && chrome && typeof chrome.loadTimes === "function",
            isNode: isNode,
            env: env,
            global: globalObject,
            getNativePromise: getNativePromise
          };
          ret.isRecentNode = ret.isNode && (function() {
            var version = process.versions.node.split(".").map(Number);
            return (version[0] === 0 && version[1] > 10) || (version[0] > 0);
          })();
          if (ret.isNode)
            ret.toFastProperties(process);
          try {
            throw new Error();
          } catch (e) {
            ret.lastLineError = e;
          }
          module.exports = ret;
        }, {"./es5": 13}]
      }, {}, [4])(4);
    });
    ;
    if (typeof window !== 'undefined' && window !== null) {
      window.P = window.Promise;
    } else if (typeof self !== 'undefined' && self !== null) {
      self.P = self.Promise;
    }
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("52", ["51"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('51');
  return module.exports;
});

$__System.registerDynamic("53", ["4d", "4e", "50", "48", "52", "47", "54", "4f", "55", "56"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _classCallCheck2 = $__require('4d');
  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
  var _createClass2 = $__require('4e');
  var _createClass3 = _interopRequireDefault(_createClass2);
  var _dec,
      _class;
  var _moment = $__require('50');
  var _moment2 = _interopRequireDefault(_moment);
  var _lodash = $__require('48');
  var _lodash2 = _interopRequireDefault(_lodash);
  var _bluebird = $__require('52');
  var _bluebird2 = _interopRequireDefault(_bluebird);
  var _parserHelper = $__require('47');
  var _parserHelper2 = _interopRequireDefault(_parserHelper);
  var _dataModel = $__require('54');
  var _dataModel2 = _interopRequireDefault(_dataModel);
  var _index = $__require('4f');
  var _index2 = _interopRequireDefault(_index);
  var _responseLogger = $__require('55');
  var _responseLogger2 = _interopRequireDefault(_responseLogger);
  var _ngDecorators = $__require('56');
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var ID_PROP,
      API_BASE;
  var AbstractService = (_dec = (0, _ngDecorators.Inject)('$http', '$state', '$rootScope', '$injector'), _dec(_class = function() {
    function AbstractService($http, $state, $rootScope, $injector) {
      (0, _classCallCheck3.default)(this, AbstractService);
      this.$http = $http;
      this.route = this.getApiRouteName();
      this.$state = $state;
      this.$rootScope = $rootScope;
      this.stateStore = $injector.get("stateStore");
      this.$injector = $injector;
      ID_PROP = _index2.default.config.getIdPropertyName();
      API_BASE = _index2.default.config.getApiBase();
    }
    (0, _createClass3.default)(AbstractService, [{
      key: 'getApiRouteName',
      value: function getApiRouteName() {
        throw new Error('This service needs a function that returns the api route name');
      }
    }, {
      key: 'getPropertyName',
      value: function getPropertyName() {
        throw new Error('This service needs a function that returns the property name that can be found in a json structure');
      }
    }, {
      key: 'getService',
      value: function getService(name) {
        if (!_lodash2.default.endsWith(name, "Service")) {
          name = name + "Service";
        }
        if (this.$injector.has(name)) {
          return this.$injector.get(name);
        }
        return null;
      }
    }, {
      key: 'getBaseUrl',
      value: function getBaseUrl() {
        return API_BASE + ('' + this.route);
      }
    }, {
      key: 'call',
      value: function call(url) {
        var _this = this;
        var that = this;
        return new _bluebird2.default(function(resolve, reject) {
          _this.$http.get(url).then(function(response) {
            _responseLogger2.default.fire("get", response);
            if (that.isSuccess(response)) {
              _parserHelper2.default.convertToApp(response.data);
              resolve(response.data);
            } else {}
          }).catch(function(response) {
            _responseLogger2.default.fire("get", response);
          });
        });
      }
    }, {
      key: 'getCacheResource',
      value: function getCacheResource() {
        var _this2 = this;
        return new _bluebird2.default(function(resolve, reject) {
          if (_this2.cachedResource) {
            resolve(_this2.cachedResource);
          } else {
            _this2.resource().then(function(data) {
              _this2.cachedResource = data;
              resolve(data);
            }).catch(function(data) {});
          }
        });
      }
    }, {
      key: 'resource',
      value: function resource(id) {
        var _this3 = this;
        var that = this;
        var url = this.getBaseUrl();
        if (id) {
          url += '/' + id;
        }
        return new _bluebird2.default(function(resolve, reject) {
          _this3.$http.get(url).then(function(response) {
            _responseLogger2.default.fire("resource", response);
            if (that.isSuccessJson(response)) {
              _parserHelper2.default.convertToApp(response.data);
              var returnData = _this3.stateStore.registerRequest(_this3, url, response.data);
              if (!id) {
                _this3.cachedResource = returnData;
              }
              resolve(returnData);
            }
          }).catch(function(response) {
            _responseLogger2.default.fire("resource", response);
          });
        });
      }
    }, {
      key: 'get',
      value: function get(id) {
        var _this4 = this;
        var that = this;
        var url = this.getBaseUrl();
        if (id) {
          url += '/' + id;
        }
        return new _bluebird2.default(function(resolve, reject) {
          _this4.$http.get(url).then(function(response) {
            _responseLogger2.default.fire(id ? "get" : "list", response);
            if (that.isSuccessJson(response)) {
              _parserHelper2.default.convertToApp(response.data);
              var returnData = _this4.stateStore.registerRequest(_this4, url, response.data);
              if (!id) {
                _this4.cachedResource = returnData;
              }
              resolve(returnData);
            } else if (response && response.status > 399 && response.status < 500) {
              _this4.$state.go("error");
            }
          }).catch(function(response) {
            _responseLogger2.default.fire(id ? "get" : "list", response);
          });
        });
      }
    }, {
      key: 'list',
      value: function list(params) {
        var _this5 = this;
        var that = this;
        var allowedParamNames = ["filter", "query", "offset", "count", "sorting", "page", "limit"];
        params = angular.copy(params);
        _lodash2.default.each(params, function(value, name) {
          if (allowedParamNames.indexOf(name) === -1) {
            throw new Error("You're trying to pass an unknown param to getList: " + name + ". Check the docs for what you're allowed to send via the front end.");
          }
          if (name == "filter") {
            var filters = {};
            _lodash2.default.each(value, function(value, name) {
              if (value !== null) {
                filters[name] = value;
              }
            });
            params.filter = filters;
          }
        });
        if (_lodash2.default.has(params, "limit")) {
          params.count = params.limit;
        }
        if (_lodash2.default.has(params, "page")) {
          if (!_lodash2.default.has(params, "count") && !_lodash2.default.has(params, "limit")) {
            throw new Error("You're trying to filter by page but haven't declared a limit or count");
          }
          var page = _parserHelper2.default.convertToNumber(params.page);
          if (page === 0) {
            page = 1;
          }
          params.offset = page * params.count - params.count;
        }
        _parserHelper2.default.convertToDateStrings(params);
        var url = this.getBaseUrl();
        return new _bluebird2.default(function(resolve, reject) {
          _this5.$http.get(url, {params: params}).then(function(response) {
            _responseLogger2.default.fire("list", response);
            if (that.isSuccessJson(response)) {
              var responseData = response.data;
              if ((_lodash2.default.isArray(responseData) || !_lodash2.default.has(responseData, "inlineCount")) && response.headers("content-range")) {
                var range = response.headers("content-range").split(" ");
                try {
                  range = range[1].split("/")[1];
                  responseData = {
                    inlineCount: parseInt(range, 10),
                    results: responseData
                  };
                } catch (e) {}
              }
              _parserHelper2.default.convertToApp(responseData);
              response.params = params;
              resolve(_this5.stateStore.registerRequest(_this5, url, responseData));
            } else {
              var data = {
                inlineCount: 0,
                results: []
              };
              resolve(_this5.stateStore.registerRequest(_this5, url, data));
            }
          }).catch(function(response) {
            _responseLogger2.default.fire("list", response);
          });
        });
      }
    }, {
      key: 'save',
      value: function save(resource) {
        if (_lodash2.default.has(resource, ID_PROP)) {
          return this.put(resource);
        } else {
          return this.post(resource);
        }
      }
    }, {
      key: 'post',
      value: function post(newResource, opts) {
        var _this6 = this;
        newResource = this.convertToObject(newResource);
        var that = this;
        newResource = angular.copy(newResource);
        _parserHelper2.default.convertToDB(newResource);
        return new _bluebird2.default(function(resolve, reject) {
          _this6.$http.post(API_BASE + ('' + _this6.route), newResource).then(function(response) {
            _responseLogger2.default.fire("post", response);
            if (that.isSuccessJson(response)) {
              resolve(response.data);
            }
          }).catch(function(response) {
            _responseLogger2.default.fire("post", response);
          });
        });
      }
    }, {
      key: 'put',
      value: function put(updatedResource, opts) {
        var _this7 = this;
        var that = this;
        updatedResource = this.convertToObject(updatedResource);
        updatedResource = angular.copy(updatedResource);
        _parserHelper2.default.convertToDB(updatedResource);
        return new _bluebird2.default(function(resolve, reject) {
          _this7.$http.put(API_BASE + (_this7.route + '/' + updatedResource[ID_PROP]), updatedResource).then(function(response) {
            _responseLogger2.default.fire("put", response);
            if (that.isSuccessJson(response)) {
              resolve(response.data);
            }
          }).catch(function(response) {
            _responseLogger2.default.fire("put", response);
          });
        });
      }
    }, {
      key: 'delete',
      value: function _delete(id) {
        var _this8 = this;
        var that = this;
        return new _bluebird2.default(function(resolve, reject) {
          _this8.$http.delete(API_BASE + (_this8.route + '/' + id)).then(function(response) {
            _responseLogger2.default.fire("delete", response);
            if (that.isSuccess(response)) {
              resolve(response.data);
            }
          }).catch(function(response) {
            _responseLogger2.default.fire("delete", response);
          });
        });
      }
    }, {
      key: 'getRoute',
      value: function getRoute() {
        return this.route;
      }
    }, {
      key: 'convertToObject',
      value: function convertToObject(data) {
        var _this9 = this;
        var returnObj = {};
        var parseData = data;
        if (!_lodash2.default.isArray(data) && !_lodash2.default.isObject(data)) {
          return data;
        }
        _lodash2.default.each(parseData, function(value, key) {
          if (_lodash2.default.isFunction(value)) {
            return;
          }
          switch (true) {
            case value instanceof _dataModel2.default:
              returnObj[key] = value.export();
              break;
            case _lodash2.default.isArray(value):
              var returnArray = [];
              _lodash2.default.each(value, function(item) {
                returnArray.push(_this9.convertToObject(item));
              }, _this9);
              returnObj[key] = returnArray;
              break;
            default:
              if (key.indexOf("_") !== 0) {
                returnObj[key] = value;
              }
          }
        }, this);
        return returnObj;
      }
    }, {
      key: 'isSuccess',
      value: function isSuccess(response) {
        return response && response.status > 199 && response.status < 300;
      }
    }, {
      key: 'isSuccessJson',
      value: function isSuccessJson(response) {
        return this.isSuccess(response) && response.data && _lodash2.default.isObject(response.data);
      }
    }, {
      key: '_getCreatedToastMessage',
      value: function _getCreatedToastMessage(response) {
        var msg = "Record successfully created!";
        if (_lodash2.default.isObject(response) && _lodash2.default.has(response, ID_PROP)) {
          msg = 'Record ' + response[ID_PROP] + ' successfully created!';
        } else if (_lodash2.default.isNumber(response)) {
          msg = 'Record ' + response + ' successfully created!';
        }
        return msg;
      }
    }, {
      key: 'configDataModel',
      value: function configDataModel() {
        return true;
      }
    }, {
      key: 'configDataCollection',
      value: function configDataCollection() {
        return true;
      }
    }]);
    return AbstractService;
  }()) || _class);
  exports.default = AbstractService;
  return module.exports;
});

$__System.registerDynamic("57", ["4d", "4e", "48", "47"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _classCallCheck2 = $__require('4d');
  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
  var _createClass2 = $__require('4e');
  var _createClass3 = _interopRequireDefault(_createClass2);
  var _lodash = $__require('48');
  var _lodash2 = _interopRequireDefault(_lodash);
  var _parserHelper = $__require('47');
  var _parserHelper2 = _interopRequireDefault(_parserHelper);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var AbstractStubPage = function() {
    function AbstractStubPage($scope) {
      (0, _classCallCheck3.default)(this, AbstractStubPage);
      if ($scope.$parent) {
        this._loadParentForm($scope);
      }
    }
    (0, _createClass3.default)(AbstractStubPage, [{
      key: '_loadParentForm',
      value: function _loadParentForm($scope) {
        _parserHelper2.default.setFormInChildScope($scope, $scope.$parent);
      }
    }]);
    return AbstractStubPage;
  }();
  exports.default = AbstractStubPage;
  return module.exports;
});

$__System.registerDynamic("58", ["4d", "4e", "48", "47"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _classCallCheck2 = $__require('4d');
  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
  var _createClass2 = $__require('4e');
  var _createClass3 = _interopRequireDefault(_createClass2);
  var _lodash = $__require('48');
  var _lodash2 = _interopRequireDefault(_lodash);
  var _parserHelper = $__require('47');
  var _parserHelper2 = _interopRequireDefault(_parserHelper);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var AbstractPage = function() {
    function AbstractPage($scope) {
      (0, _classCallCheck3.default)(this, AbstractPage);
      if ($scope.$parent) {
        this._loadParentForm($scope);
      }
    }
    (0, _createClass3.default)(AbstractPage, [{
      key: '_loadParentForm',
      value: function _loadParentForm($scope) {
        _parserHelper2.default.setFormInChildScope($scope, $scope.$parent);
      }
    }]);
    return AbstractPage;
  }();
  exports.default = AbstractPage;
  return module.exports;
});

$__System.registerDynamic("59", ["4d", "4e", "48", "47"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _classCallCheck2 = $__require('4d');
  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
  var _createClass2 = $__require('4e');
  var _createClass3 = _interopRequireDefault(_createClass2);
  var _lodash = $__require('48');
  var _lodash2 = _interopRequireDefault(_lodash);
  var _parserHelper = $__require('47');
  var _parserHelper2 = _interopRequireDefault(_parserHelper);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var AbstractComponent = function() {
    function AbstractComponent($scope) {
      (0, _classCallCheck3.default)(this, AbstractComponent);
      if ($scope.$parent) {
        this._loadParentForm($scope);
      }
    }
    (0, _createClass3.default)(AbstractComponent, [{
      key: '_loadParentForm',
      value: function _loadParentForm($scope) {
        _parserHelper2.default.setFormInChildScope($scope, $scope.$parent);
      }
    }]);
    return AbstractComponent;
  }();
  exports.default = AbstractComponent;
  return module.exports;
});

$__System.registerDynamic("5a", ["37", "4d", "4e", "56", "4f"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _getOwnPropertyDescriptor = $__require('37');
  var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);
  var _classCallCheck2 = $__require('4d');
  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
  var _createClass2 = $__require('4e');
  var _createClass3 = _interopRequireDefault(_createClass2);
  var _dec,
      _desc,
      _value,
      _class;
  var _ngDecorators = $__require('56');
  var _index = $__require('4f');
  var _index2 = _interopRequireDefault(_index);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object['ke' + 'ys'](descriptor).forEach(function(key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function(desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
      Object['define' + 'Property'](target, property, desc);
      desc = null;
    }
    return desc;
  }
  var MockHttpFallthrough = (_dec = (0, _ngDecorators.Run)(), (_class = function() {
    function MockHttpFallthrough() {
      (0, _classCallCheck3.default)(this, MockHttpFallthrough);
    }
    (0, _createClass3.default)(MockHttpFallthrough, [{
      key: 'runFactory',
      value: function runFactory($httpBackend, postLoader) {
        if (!_index2.default.config.isPrototypeMode()) {
          return false;
        }
        postLoader.add(function() {
          $httpBackend.whenGET(/^\/api\/.*/).respond(function(method, url, data, headers) {
            console.log("==========================");
            console.log("   MOCK API FALLTHROUGH   ");
            headers['Content-Type'] = 'application/json;version=1';
            console.log(url);
            throw new Error("No API Service call for " + url + " declared!");
            return [404];
          });
          $httpBackend.whenGET(/^\w+.*/).passThrough();
          $httpBackend.whenPOST(/^\w+.*/).passThrough();
        });
      }
    }]);
    return MockHttpFallthrough;
  }(), (_applyDecoratedDescriptor(_class.prototype, 'runFactory', [_dec], (0, _getOwnPropertyDescriptor2.default)(_class.prototype, 'runFactory'), _class.prototype)), _class));
  exports.default = MockHttpFallthrough;
  return module.exports;
});

$__System.registerDynamic("55", ["4d", "4e", "48", "4f"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _classCallCheck2 = $__require('4d');
  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
  var _createClass2 = $__require('4e');
  var _createClass3 = _interopRequireDefault(_createClass2);
  var _lodash = $__require('48');
  var _lodash2 = _interopRequireDefault(_lodash);
  var _index = $__require('4f');
  var _index2 = _interopRequireDefault(_index);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var ResponseLogger = function() {
    function ResponseLogger() {
      (0, _classCallCheck3.default)(this, ResponseLogger);
      this.listeners = [];
      this.errorListeners = [];
    }
    (0, _createClass3.default)(ResponseLogger, [{
      key: 'fire',
      value: function fire(type, response) {
        var status = response && response.status ? response.status : 500;
        _lodash2.default.each(this.listeners, function(event) {
          if (_lodash2.default.isFunction(event)) {
            event({
              type: type,
              response: response,
              status: status
            });
          }
        }, this);
        if (response && response.status == -1 && _index2.default.config.isPrototypeMode()) {
          return response;
        }
        if (!this.isSuccess(response)) {
          _lodash2.default.each(this.errorListeners, function(event) {
            if (_lodash2.default.isFunction(event)) {
              event({
                type: type,
                response: response,
                status: status
              });
            }
          });
        }
      }
    }, {
      key: 'isSuccess',
      value: function isSuccess(response) {
        return response && response.status > 199 && response.status < 300;
      }
    }, {
      key: 'onErrorResponse',
      value: function onErrorResponse(event) {
        this.errorListeners.push(event);
      }
    }, {
      key: 'onResponse',
      value: function onResponse(event) {
        this.listeners.push(event);
      }
    }]);
    return ResponseLogger;
  }();
  exports.default = new ResponseLogger();
  return module.exports;
});

$__System.registerDynamic("5b", ["5c", "4d", "4e", "48", "55"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _stringify = $__require('5c');
  var _stringify2 = _interopRequireDefault(_stringify);
  var _classCallCheck2 = $__require('4d');
  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
  var _createClass2 = $__require('4e');
  var _createClass3 = _interopRequireDefault(_createClass2);
  var _lodash = $__require('48');
  var _lodash2 = _interopRequireDefault(_lodash);
  var _responseLogger = $__require('55');
  var _responseLogger2 = _interopRequireDefault(_responseLogger);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var ErrorLogger = function() {
    function ErrorLogger() {
      var _this = this;
      (0, _classCallCheck3.default)(this, ErrorLogger);
      this.listeners = [];
      _responseLogger2.default.onErrorResponse(function(event) {
        var response = event.response;
        if (response && response.status) {
          response.statusCode = response.status;
        }
        _this.fireError("server", response);
      });
    }
    (0, _createClass3.default)(ErrorLogger, [{
      key: 'fireError',
      value: function fireError(type, error) {
        var setError = {};
        if (error instanceof Error) {
          if (error.message == "Halt") {
            return true;
          }
          setError = {
            name: error.name,
            message: error.message
          };
          if (error.stack) {
            setError.stack = error.stack.split("\n");
          }
        } else {
          try {
            setError = JSON.parse((0, _stringify2.default)(error));
            if (setError && setError.status) {
              setError.statusCode = setError.status;
            }
          } catch (e) {
            setError = {error: "Couldn't stringify error"};
          }
        }
        _lodash2.default.each(this.listeners, function(event) {
          if (_lodash2.default.isFunction(event)) {
            event({
              type: type,
              error: setError
            });
          }
        }, this);
      }
    }, {
      key: 'onError',
      value: function onError(event) {
        this.listeners.push(event);
      }
    }]);
    return ErrorLogger;
  }();
  exports.default = new ErrorLogger();
  return module.exports;
});

$__System.registerDynamic("5d", ["5e", "4d", "5f", "23", "48", "60"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _getPrototypeOf = $__require('5e');
  var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
  var _classCallCheck2 = $__require('4d');
  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
  var _possibleConstructorReturn2 = $__require('5f');
  var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
  var _inherits2 = $__require('23');
  var _inherits3 = _interopRequireDefault(_inherits2);
  var _lodash = $__require('48');
  var _lodash2 = _interopRequireDefault(_lodash);
  var _abstractTheme = $__require('60');
  var _abstractTheme2 = _interopRequireDefault(_abstractTheme);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var AbstractMaterial = function(_AbstractTheme) {
    (0, _inherits3.default)(AbstractMaterial, _AbstractTheme);
    function AbstractMaterial(args) {
      (0, _classCallCheck3.default)(this, AbstractMaterial);
      var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(AbstractMaterial).call(this, args));
      _this.addRequires([]);
      return _this;
    }
    return AbstractMaterial;
  }(_abstractTheme2.default);
  exports.default = AbstractMaterial;
  return module.exports;
});

$__System.registerDynamic("61", ["62", "63"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var toObject = $__require('62');
  $__require('63')('getPrototypeOf', function($getPrototypeOf) {
    return function getPrototypeOf(it) {
      return $getPrototypeOf(toObject(it));
    };
  });
  return module.exports;
});

$__System.registerDynamic("64", ["61", "65"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('61');
  module.exports = $__require('65').Object.getPrototypeOf;
  return module.exports;
});

$__System.registerDynamic("5e", ["64"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = {
    "default": $__require('64'),
    __esModule: true
  };
  return module.exports;
});

$__System.registerDynamic("66", ["67", "68"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('67'),
      toIObject = $__require('68');
  module.exports = function(object, el) {
    var O = toIObject(object),
        keys = $.getKeys(O),
        length = keys.length,
        index = 0,
        key;
    while (length > index)
      if (O[key = keys[index++]] === el)
        return key;
  };
  return module.exports;
});

$__System.registerDynamic("69", ["68", "67"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var toIObject = $__require('68'),
      getNames = $__require('67').getNames,
      toString = {}.toString;
  var windowNames = typeof window == 'object' && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
  var getWindowNames = function(it) {
    try {
      return getNames(it);
    } catch (e) {
      return windowNames.slice();
    }
  };
  module.exports.get = function getOwnPropertyNames(it) {
    if (windowNames && toString.call(it) == '[object Window]')
      return getWindowNames(it);
    return getNames(toIObject(it));
  };
  return module.exports;
});

$__System.registerDynamic("6a", ["67"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('67');
  module.exports = function(it) {
    var keys = $.getKeys(it),
        getSymbols = $.getSymbols;
    if (getSymbols) {
      var symbols = getSymbols(it),
          isEnum = $.isEnum,
          i = 0,
          key;
      while (symbols.length > i)
        if (isEnum.call(it, key = symbols[i++]))
          keys.push(key);
    }
    return keys;
  };
  return module.exports;
});

$__System.registerDynamic("6b", ["67", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "66", "69", "6a", "76", "77", "68", "78", "79"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('67'),
      global = $__require('6c'),
      has = $__require('6d'),
      DESCRIPTORS = $__require('6e'),
      $export = $__require('6f'),
      redefine = $__require('70'),
      $fails = $__require('71'),
      shared = $__require('72'),
      setToStringTag = $__require('73'),
      uid = $__require('74'),
      wks = $__require('75'),
      keyOf = $__require('66'),
      $names = $__require('69'),
      enumKeys = $__require('6a'),
      isArray = $__require('76'),
      anObject = $__require('77'),
      toIObject = $__require('68'),
      createDesc = $__require('78'),
      getDesc = $.getDesc,
      setDesc = $.setDesc,
      _create = $.create,
      getNames = $names.get,
      $Symbol = global.Symbol,
      $JSON = global.JSON,
      _stringify = $JSON && $JSON.stringify,
      setter = false,
      HIDDEN = wks('_hidden'),
      isEnum = $.isEnum,
      SymbolRegistry = shared('symbol-registry'),
      AllSymbols = shared('symbols'),
      useNative = typeof $Symbol == 'function',
      ObjectProto = Object.prototype;
  var setSymbolDesc = DESCRIPTORS && $fails(function() {
    return _create(setDesc({}, 'a', {get: function() {
        return setDesc(this, 'a', {value: 7}).a;
      }})).a != 7;
  }) ? function(it, key, D) {
    var protoDesc = getDesc(ObjectProto, key);
    if (protoDesc)
      delete ObjectProto[key];
    setDesc(it, key, D);
    if (protoDesc && it !== ObjectProto)
      setDesc(ObjectProto, key, protoDesc);
  } : setDesc;
  var wrap = function(tag) {
    var sym = AllSymbols[tag] = _create($Symbol.prototype);
    sym._k = tag;
    DESCRIPTORS && setter && setSymbolDesc(ObjectProto, tag, {
      configurable: true,
      set: function(value) {
        if (has(this, HIDDEN) && has(this[HIDDEN], tag))
          this[HIDDEN][tag] = false;
        setSymbolDesc(this, tag, createDesc(1, value));
      }
    });
    return sym;
  };
  var isSymbol = function(it) {
    return typeof it == 'symbol';
  };
  var $defineProperty = function defineProperty(it, key, D) {
    if (D && has(AllSymbols, key)) {
      if (!D.enumerable) {
        if (!has(it, HIDDEN))
          setDesc(it, HIDDEN, createDesc(1, {}));
        it[HIDDEN][key] = true;
      } else {
        if (has(it, HIDDEN) && it[HIDDEN][key])
          it[HIDDEN][key] = false;
        D = _create(D, {enumerable: createDesc(0, false)});
      }
      return setSymbolDesc(it, key, D);
    }
    return setDesc(it, key, D);
  };
  var $defineProperties = function defineProperties(it, P) {
    anObject(it);
    var keys = enumKeys(P = toIObject(P)),
        i = 0,
        l = keys.length,
        key;
    while (l > i)
      $defineProperty(it, key = keys[i++], P[key]);
    return it;
  };
  var $create = function create(it, P) {
    return P === undefined ? _create(it) : $defineProperties(_create(it), P);
  };
  var $propertyIsEnumerable = function propertyIsEnumerable(key) {
    var E = isEnum.call(this, key);
    return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
  };
  var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
    var D = getDesc(it = toIObject(it), key);
    if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))
      D.enumerable = true;
    return D;
  };
  var $getOwnPropertyNames = function getOwnPropertyNames(it) {
    var names = getNames(toIObject(it)),
        result = [],
        i = 0,
        key;
    while (names.length > i)
      if (!has(AllSymbols, key = names[i++]) && key != HIDDEN)
        result.push(key);
    return result;
  };
  var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
    var names = getNames(toIObject(it)),
        result = [],
        i = 0,
        key;
    while (names.length > i)
      if (has(AllSymbols, key = names[i++]))
        result.push(AllSymbols[key]);
    return result;
  };
  var $stringify = function stringify(it) {
    if (it === undefined || isSymbol(it))
      return;
    var args = [it],
        i = 1,
        $$ = arguments,
        replacer,
        $replacer;
    while ($$.length > i)
      args.push($$[i++]);
    replacer = args[1];
    if (typeof replacer == 'function')
      $replacer = replacer;
    if ($replacer || !isArray(replacer))
      replacer = function(key, value) {
        if ($replacer)
          value = $replacer.call(this, key, value);
        if (!isSymbol(value))
          return value;
      };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  };
  var buggyJSON = $fails(function() {
    var S = $Symbol();
    return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
  });
  if (!useNative) {
    $Symbol = function Symbol() {
      if (isSymbol(this))
        throw TypeError('Symbol is not a constructor');
      return wrap(uid(arguments.length > 0 ? arguments[0] : undefined));
    };
    redefine($Symbol.prototype, 'toString', function toString() {
      return this._k;
    });
    isSymbol = function(it) {
      return it instanceof $Symbol;
    };
    $.create = $create;
    $.isEnum = $propertyIsEnumerable;
    $.getDesc = $getOwnPropertyDescriptor;
    $.setDesc = $defineProperty;
    $.setDescs = $defineProperties;
    $.getNames = $names.get = $getOwnPropertyNames;
    $.getSymbols = $getOwnPropertySymbols;
    if (DESCRIPTORS && !$__require('79')) {
      redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
    }
  }
  var symbolStatics = {
    'for': function(key) {
      return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
    },
    keyFor: function keyFor(key) {
      return keyOf(SymbolRegistry, key);
    },
    useSetter: function() {
      setter = true;
    },
    useSimple: function() {
      setter = false;
    }
  };
  $.each.call(('hasInstance,isConcatSpreadable,iterator,match,replace,search,' + 'species,split,toPrimitive,toStringTag,unscopables').split(','), function(it) {
    var sym = wks(it);
    symbolStatics[it] = useNative ? sym : wrap(sym);
  });
  setter = true;
  $export($export.G + $export.W, {Symbol: $Symbol});
  $export($export.S, 'Symbol', symbolStatics);
  $export($export.S + $export.F * !useNative, 'Object', {
    create: $create,
    defineProperty: $defineProperty,
    defineProperties: $defineProperties,
    getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
    getOwnPropertyNames: $getOwnPropertyNames,
    getOwnPropertySymbols: $getOwnPropertySymbols
  });
  $JSON && $export($export.S + $export.F * (!useNative || buggyJSON), 'JSON', {stringify: $stringify});
  setToStringTag($Symbol, 'Symbol');
  setToStringTag(Math, 'Math', true);
  setToStringTag(global.JSON, 'JSON', true);
  return module.exports;
});

$__System.registerDynamic("7a", ["6b", "7b", "65"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('6b');
  $__require('7b');
  module.exports = $__require('65').Symbol;
  return module.exports;
});

$__System.registerDynamic("7c", ["7a"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('7a');
  return module.exports;
});

$__System.registerDynamic("7d", ["7c"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = {
    "default": $__require('7c'),
    __esModule: true
  };
  return module.exports;
});

$__System.registerDynamic("4b", ["7d"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var _Symbol = $__require('7d')["default"];
  exports["default"] = function(obj) {
    return obj && obj.constructor === _Symbol ? "symbol" : typeof obj;
  };
  exports.__esModule = true;
  return module.exports;
});

$__System.registerDynamic("5f", ["4b"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  exports.__esModule = true;
  var _typeof2 = $__require('4b');
  var _typeof3 = _interopRequireDefault(_typeof2);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  exports.default = function(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
  };
  return module.exports;
});

$__System.registerDynamic("7e", ["67", "7f", "77", "80"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var getDesc = $__require('67').getDesc,
      isObject = $__require('7f'),
      anObject = $__require('77');
  var check = function(O, proto) {
    anObject(O);
    if (!isObject(proto) && proto !== null)
      throw TypeError(proto + ": can't set as prototype!");
  };
  module.exports = {
    set: Object.setPrototypeOf || ('__proto__' in {} ? function(test, buggy, set) {
      try {
        set = $__require('80')(Function.call, getDesc(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) {
        buggy = true;
      }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy)
          O.__proto__ = proto;
        else
          set(O, proto);
        return O;
      };
    }({}, false) : undefined),
    check: check
  };
  return module.exports;
});

$__System.registerDynamic("81", ["6f", "7e"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('6f');
  $export($export.S, 'Object', {setPrototypeOf: $__require('7e').set});
  return module.exports;
});

$__System.registerDynamic("82", ["81", "65"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('81');
  module.exports = $__require('65').Object.setPrototypeOf;
  return module.exports;
});

$__System.registerDynamic("83", ["82"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = {
    "default": $__require('82'),
    __esModule: true
  };
  return module.exports;
});

$__System.registerDynamic("23", ["84", "83"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var _Object$create = $__require('84')["default"];
  var _Object$setPrototypeOf = $__require('83')["default"];
  exports["default"] = function(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = _Object$create(superClass && superClass.prototype, {constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }});
    if (superClass)
      _Object$setPrototypeOf ? _Object$setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };
  exports.__esModule = true;
  return module.exports;
});

$__System.registerDynamic("60", ["4d", "4e", "48"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _classCallCheck2 = $__require('4d');
  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
  var _createClass2 = $__require('4e');
  var _createClass3 = _interopRequireDefault(_createClass2);
  var _lodash = $__require('48');
  var _lodash2 = _interopRequireDefault(_lodash);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var AbstractTheme = function() {
    (0, _createClass3.default)(AbstractTheme, [{
      key: 'initialize',
      value: function initialize() {}
    }]);
    function AbstractTheme(args) {
      (0, _classCallCheck3.default)(this, AbstractTheme);
      this.params = args || {};
      if (!this.params || !_lodash2.default.isObject(this.params)) {
        throw new Error("You must pass an object as the first param for initializing a theme");
      }
      if (!_lodash2.default.has(this.params, "appModule")) {
        throw new Error("You must pass the module returned from ScaffiUi.initialize");
      }
      this.initialize();
    }
    (0, _createClass3.default)(AbstractTheme, [{
      key: 'getApp',
      value: function getApp() {
        return this.params.appModule;
      }
    }, {
      key: 'addRequires',
      value: function addRequires(requiresArr) {
        var mainModule = this.getApp();
        mainModule.requires = mainModule.requires.concat(requiresArr);
      }
    }]);
    return AbstractTheme;
  }();
  exports.default = AbstractTheme;
  return module.exports;
});

$__System.registerDynamic("85", ["5e", "4d", "5f", "23", "48", "60"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _getPrototypeOf = $__require('5e');
  var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
  var _classCallCheck2 = $__require('4d');
  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
  var _possibleConstructorReturn2 = $__require('5f');
  var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
  var _inherits2 = $__require('23');
  var _inherits3 = _interopRequireDefault(_inherits2);
  var _lodash = $__require('48');
  var _lodash2 = _interopRequireDefault(_lodash);
  var _abstractTheme = $__require('60');
  var _abstractTheme2 = _interopRequireDefault(_abstractTheme);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var AbstractBootstrap = function(_AbstractTheme) {
    (0, _inherits3.default)(AbstractBootstrap, _AbstractTheme);
    function AbstractBootstrap(args) {
      (0, _classCallCheck3.default)(this, AbstractBootstrap);
      var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(AbstractBootstrap).call(this, args));
      _this.addRequires([]);
      return _this;
    }
    return AbstractBootstrap;
  }(_abstractTheme2.default);
  exports.default = AbstractBootstrap;
  return module.exports;
});

$__System.registerDynamic("86", ["37", "4d", "4e", "87", "88", "56", "4f"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var _getOwnPropertyDescriptor = $__require('37');
  var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);
  var _classCallCheck2 = $__require('4d');
  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
  var _createClass2 = $__require('4e');
  var _createClass3 = _interopRequireDefault(_createClass2);
  var _dec,
      _desc,
      _value,
      _class,
      _dec2,
      _desc2,
      _value2,
      _class2;
  $__require('87');
  var _angular = $__require('88');
  var _angular2 = _interopRequireDefault(_angular);
  var _ngDecorators = $__require('56');
  var _index = $__require('4f');
  var _index2 = _interopRequireDefault(_index);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object['ke' + 'ys'](descriptor).forEach(function(key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function(desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
      Object['define' + 'Property'](target, property, desc);
      desc = null;
    }
    return desc;
  }
  var OnConfigDev = (_dec = (0, _ngDecorators.Config)(), (_class = function() {
    function OnConfigDev() {
      (0, _classCallCheck3.default)(this, OnConfigDev);
    }
    (0, _createClass3.default)(OnConfigDev, null, [{
      key: 'configFactory',
      value: function configFactory($provide) {
        if (_index2.default.config.isDevelopmentMode()) {
          console.log("config dev");
        }
      }
    }]);
    return OnConfigDev;
  }(), (_applyDecoratedDescriptor(_class, 'configFactory', [_dec], (0, _getOwnPropertyDescriptor2.default)(_class, 'configFactory'), _class)), _class));
  var OnRunDev = (_dec2 = (0, _ngDecorators.Run)(), (_class2 = function() {
    function OnRunDev() {
      (0, _classCallCheck3.default)(this, OnRunDev);
    }
    (0, _createClass3.default)(OnRunDev, null, [{
      key: 'runFactory',
      value: function runFactory($rootScope) {}
    }]);
    return OnRunDev;
  }(), (_applyDecoratedDescriptor(_class2, 'runFactory', [_dec2], (0, _getOwnPropertyDescriptor2.default)(_class2, 'runFactory'), _class2)), _class2));
  return module.exports;
});

$__System.registerDynamic("89", ["37", "4d", "4e", "87", "88", "56", "4f"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var _getOwnPropertyDescriptor = $__require('37');
  var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);
  var _classCallCheck2 = $__require('4d');
  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
  var _createClass2 = $__require('4e');
  var _createClass3 = _interopRequireDefault(_createClass2);
  var _dec,
      _desc,
      _value,
      _class,
      _dec2,
      _desc2,
      _value2,
      _class2;
  $__require('87');
  var _angular = $__require('88');
  var _angular2 = _interopRequireDefault(_angular);
  var _ngDecorators = $__require('56');
  var _index = $__require('4f');
  var _index2 = _interopRequireDefault(_index);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object['ke' + 'ys'](descriptor).forEach(function(key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function(desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
      Object['define' + 'Property'](target, property, desc);
      desc = null;
    }
    return desc;
  }
  var OnConfigPrototype = (_dec = (0, _ngDecorators.Config)(), (_class = function() {
    function OnConfigPrototype() {
      (0, _classCallCheck3.default)(this, OnConfigPrototype);
    }
    (0, _createClass3.default)(OnConfigPrototype, null, [{
      key: 'configFactory',
      value: function configFactory($provide) {
        if (_index2.default.config.isPrototypeMode()) {
          $provide.decorator('$httpBackend', _angular2.default.mock.e2e.$httpBackendDecorator);
        }
      }
    }]);
    return OnConfigPrototype;
  }(), (_applyDecoratedDescriptor(_class, 'configFactory', [_dec], (0, _getOwnPropertyDescriptor2.default)(_class, 'configFactory'), _class)), _class));
  var OnRunPrototype = (_dec2 = (0, _ngDecorators.Run)(), (_class2 = function() {
    function OnRunPrototype() {
      (0, _classCallCheck3.default)(this, OnRunPrototype);
    }
    (0, _createClass3.default)(OnRunPrototype, null, [{
      key: 'runFactory',
      value: function runFactory($rootScope) {}
    }]);
    return OnRunPrototype;
  }(), (_applyDecoratedDescriptor(_class2, 'runFactory', [_dec2], (0, _getOwnPropertyDescriptor2.default)(_class2, 'runFactory'), _class2)), _class2));
  return module.exports;
});

$__System.registerDynamic("8a", [], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, "angular", null);
  (function() {
    "format global";
    "exports angular";
    (function(window) {
      'use strict';
      function minErr(module, ErrorConstructor) {
        ErrorConstructor = ErrorConstructor || Error;
        return function() {
          var SKIP_INDEXES = 2;
          var templateArgs = arguments,
              code = templateArgs[0],
              message = '[' + (module ? module + ':' : '') + code + '] ',
              template = templateArgs[1],
              paramPrefix,
              i;
          message += template.replace(/\{\d+\}/g, function(match) {
            var index = +match.slice(1, -1),
                shiftedIndex = index + SKIP_INDEXES;
            if (shiftedIndex < templateArgs.length) {
              return toDebugString(templateArgs[shiftedIndex]);
            }
            return match;
          });
          message += '\nhttp://errors.angularjs.org/1.5.8/' + (module ? module + '/' : '') + code;
          for (i = SKIP_INDEXES, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {
            message += paramPrefix + 'p' + (i - SKIP_INDEXES) + '=' + encodeURIComponent(toDebugString(templateArgs[i]));
          }
          return new ErrorConstructor(message);
        };
      }
      var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
      var VALIDITY_STATE_PROPERTY = 'validity';
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var lowercase = function(string) {
        return isString(string) ? string.toLowerCase() : string;
      };
      var uppercase = function(string) {
        return isString(string) ? string.toUpperCase() : string;
      };
      var manualLowercase = function(s) {
        return isString(s) ? s.replace(/[A-Z]/g, function(ch) {
          return String.fromCharCode(ch.charCodeAt(0) | 32);
        }) : s;
      };
      var manualUppercase = function(s) {
        return isString(s) ? s.replace(/[a-z]/g, function(ch) {
          return String.fromCharCode(ch.charCodeAt(0) & ~32);
        }) : s;
      };
      if ('i' !== 'I'.toLowerCase()) {
        lowercase = manualLowercase;
        uppercase = manualUppercase;
      }
      var msie,
          jqLite,
          jQuery,
          slice = [].slice,
          splice = [].splice,
          push = [].push,
          toString = Object.prototype.toString,
          getPrototypeOf = Object.getPrototypeOf,
          ngMinErr = minErr('ng'),
          angular = window.angular || (window.angular = {}),
          angularModule,
          uid = 0;
      msie = window.document.documentMode;
      function isArrayLike(obj) {
        if (obj == null || isWindow(obj))
          return false;
        if (isArray(obj) || isString(obj) || (jqLite && obj instanceof jqLite))
          return true;
        var length = "length" in Object(obj) && obj.length;
        return isNumber(length) && (length >= 0 && ((length - 1) in obj || obj instanceof Array) || typeof obj.item == 'function');
      }
      function forEach(obj, iterator, context) {
        var key,
            length;
        if (obj) {
          if (isFunction(obj)) {
            for (key in obj) {
              if (key != 'prototype' && key != 'length' && key != 'name' && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else if (isArray(obj) || isArrayLike(obj)) {
            var isPrimitive = typeof obj !== 'object';
            for (key = 0, length = obj.length; key < length; key++) {
              if (isPrimitive || key in obj) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else if (obj.forEach && obj.forEach !== forEach) {
            obj.forEach(iterator, context, obj);
          } else if (isBlankObject(obj)) {
            for (key in obj) {
              iterator.call(context, obj[key], key, obj);
            }
          } else if (typeof obj.hasOwnProperty === 'function') {
            for (key in obj) {
              if (obj.hasOwnProperty(key)) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else {
            for (key in obj) {
              if (hasOwnProperty.call(obj, key)) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          }
        }
        return obj;
      }
      function forEachSorted(obj, iterator, context) {
        var keys = Object.keys(obj).sort();
        for (var i = 0; i < keys.length; i++) {
          iterator.call(context, obj[keys[i]], keys[i]);
        }
        return keys;
      }
      function reverseParams(iteratorFn) {
        return function(value, key) {
          iteratorFn(key, value);
        };
      }
      function nextUid() {
        return ++uid;
      }
      function setHashKey(obj, h) {
        if (h) {
          obj.$$hashKey = h;
        } else {
          delete obj.$$hashKey;
        }
      }
      function baseExtend(dst, objs, deep) {
        var h = dst.$$hashKey;
        for (var i = 0,
            ii = objs.length; i < ii; ++i) {
          var obj = objs[i];
          if (!isObject(obj) && !isFunction(obj))
            continue;
          var keys = Object.keys(obj);
          for (var j = 0,
              jj = keys.length; j < jj; j++) {
            var key = keys[j];
            var src = obj[key];
            if (deep && isObject(src)) {
              if (isDate(src)) {
                dst[key] = new Date(src.valueOf());
              } else if (isRegExp(src)) {
                dst[key] = new RegExp(src);
              } else if (src.nodeName) {
                dst[key] = src.cloneNode(true);
              } else if (isElement(src)) {
                dst[key] = src.clone();
              } else {
                if (!isObject(dst[key]))
                  dst[key] = isArray(src) ? [] : {};
                baseExtend(dst[key], [src], true);
              }
            } else {
              dst[key] = src;
            }
          }
        }
        setHashKey(dst, h);
        return dst;
      }
      function extend(dst) {
        return baseExtend(dst, slice.call(arguments, 1), false);
      }
      function merge(dst) {
        return baseExtend(dst, slice.call(arguments, 1), true);
      }
      function toInt(str) {
        return parseInt(str, 10);
      }
      function inherit(parent, extra) {
        return extend(Object.create(parent), extra);
      }
      function noop() {}
      noop.$inject = [];
      function identity($) {
        return $;
      }
      identity.$inject = [];
      function valueFn(value) {
        return function valueRef() {
          return value;
        };
      }
      function hasCustomToString(obj) {
        return isFunction(obj.toString) && obj.toString !== toString;
      }
      function isUndefined(value) {
        return typeof value === 'undefined';
      }
      function isDefined(value) {
        return typeof value !== 'undefined';
      }
      function isObject(value) {
        return value !== null && typeof value === 'object';
      }
      function isBlankObject(value) {
        return value !== null && typeof value === 'object' && !getPrototypeOf(value);
      }
      function isString(value) {
        return typeof value === 'string';
      }
      function isNumber(value) {
        return typeof value === 'number';
      }
      function isDate(value) {
        return toString.call(value) === '[object Date]';
      }
      var isArray = Array.isArray;
      function isFunction(value) {
        return typeof value === 'function';
      }
      function isRegExp(value) {
        return toString.call(value) === '[object RegExp]';
      }
      function isWindow(obj) {
        return obj && obj.window === obj;
      }
      function isScope(obj) {
        return obj && obj.$evalAsync && obj.$watch;
      }
      function isFile(obj) {
        return toString.call(obj) === '[object File]';
      }
      function isFormData(obj) {
        return toString.call(obj) === '[object FormData]';
      }
      function isBlob(obj) {
        return toString.call(obj) === '[object Blob]';
      }
      function isBoolean(value) {
        return typeof value === 'boolean';
      }
      function isPromiseLike(obj) {
        return obj && isFunction(obj.then);
      }
      var TYPED_ARRAY_REGEXP = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array\]$/;
      function isTypedArray(value) {
        return value && isNumber(value.length) && TYPED_ARRAY_REGEXP.test(toString.call(value));
      }
      function isArrayBuffer(obj) {
        return toString.call(obj) === '[object ArrayBuffer]';
      }
      var trim = function(value) {
        return isString(value) ? value.trim() : value;
      };
      var escapeForRegexp = function(s) {
        return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
      };
      function isElement(node) {
        return !!(node && (node.nodeName || (node.prop && node.attr && node.find)));
      }
      function makeMap(str) {
        var obj = {},
            items = str.split(','),
            i;
        for (i = 0; i < items.length; i++) {
          obj[items[i]] = true;
        }
        return obj;
      }
      function nodeName_(element) {
        return lowercase(element.nodeName || (element[0] && element[0].nodeName));
      }
      function includes(array, obj) {
        return Array.prototype.indexOf.call(array, obj) != -1;
      }
      function arrayRemove(array, value) {
        var index = array.indexOf(value);
        if (index >= 0) {
          array.splice(index, 1);
        }
        return index;
      }
      function copy(source, destination) {
        var stackSource = [];
        var stackDest = [];
        if (destination) {
          if (isTypedArray(destination) || isArrayBuffer(destination)) {
            throw ngMinErr('cpta', "Can't copy! TypedArray destination cannot be mutated.");
          }
          if (source === destination) {
            throw ngMinErr('cpi', "Can't copy! Source and destination are identical.");
          }
          if (isArray(destination)) {
            destination.length = 0;
          } else {
            forEach(destination, function(value, key) {
              if (key !== '$$hashKey') {
                delete destination[key];
              }
            });
          }
          stackSource.push(source);
          stackDest.push(destination);
          return copyRecurse(source, destination);
        }
        return copyElement(source);
        function copyRecurse(source, destination) {
          var h = destination.$$hashKey;
          var key;
          if (isArray(source)) {
            for (var i = 0,
                ii = source.length; i < ii; i++) {
              destination.push(copyElement(source[i]));
            }
          } else if (isBlankObject(source)) {
            for (key in source) {
              destination[key] = copyElement(source[key]);
            }
          } else if (source && typeof source.hasOwnProperty === 'function') {
            for (key in source) {
              if (source.hasOwnProperty(key)) {
                destination[key] = copyElement(source[key]);
              }
            }
          } else {
            for (key in source) {
              if (hasOwnProperty.call(source, key)) {
                destination[key] = copyElement(source[key]);
              }
            }
          }
          setHashKey(destination, h);
          return destination;
        }
        function copyElement(source) {
          if (!isObject(source)) {
            return source;
          }
          var index = stackSource.indexOf(source);
          if (index !== -1) {
            return stackDest[index];
          }
          if (isWindow(source) || isScope(source)) {
            throw ngMinErr('cpws', "Can't copy! Making copies of Window or Scope instances is not supported.");
          }
          var needsRecurse = false;
          var destination = copyType(source);
          if (destination === undefined) {
            destination = isArray(source) ? [] : Object.create(getPrototypeOf(source));
            needsRecurse = true;
          }
          stackSource.push(source);
          stackDest.push(destination);
          return needsRecurse ? copyRecurse(source, destination) : destination;
        }
        function copyType(source) {
          switch (toString.call(source)) {
            case '[object Int8Array]':
            case '[object Int16Array]':
            case '[object Int32Array]':
            case '[object Float32Array]':
            case '[object Float64Array]':
            case '[object Uint8Array]':
            case '[object Uint8ClampedArray]':
            case '[object Uint16Array]':
            case '[object Uint32Array]':
              return new source.constructor(copyElement(source.buffer), source.byteOffset, source.length);
            case '[object ArrayBuffer]':
              if (!source.slice) {
                var copied = new ArrayBuffer(source.byteLength);
                new Uint8Array(copied).set(new Uint8Array(source));
                return copied;
              }
              return source.slice(0);
            case '[object Boolean]':
            case '[object Number]':
            case '[object String]':
            case '[object Date]':
              return new source.constructor(source.valueOf());
            case '[object RegExp]':
              var re = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
              re.lastIndex = source.lastIndex;
              return re;
            case '[object Blob]':
              return new source.constructor([source], {type: source.type});
          }
          if (isFunction(source.cloneNode)) {
            return source.cloneNode(true);
          }
        }
      }
      function equals(o1, o2) {
        if (o1 === o2)
          return true;
        if (o1 === null || o2 === null)
          return false;
        if (o1 !== o1 && o2 !== o2)
          return true;
        var t1 = typeof o1,
            t2 = typeof o2,
            length,
            key,
            keySet;
        if (t1 == t2 && t1 == 'object') {
          if (isArray(o1)) {
            if (!isArray(o2))
              return false;
            if ((length = o1.length) == o2.length) {
              for (key = 0; key < length; key++) {
                if (!equals(o1[key], o2[key]))
                  return false;
              }
              return true;
            }
          } else if (isDate(o1)) {
            if (!isDate(o2))
              return false;
            return equals(o1.getTime(), o2.getTime());
          } else if (isRegExp(o1)) {
            if (!isRegExp(o2))
              return false;
            return o1.toString() == o2.toString();
          } else {
            if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2) || isDate(o2) || isRegExp(o2))
              return false;
            keySet = createMap();
            for (key in o1) {
              if (key.charAt(0) === '$' || isFunction(o1[key]))
                continue;
              if (!equals(o1[key], o2[key]))
                return false;
              keySet[key] = true;
            }
            for (key in o2) {
              if (!(key in keySet) && key.charAt(0) !== '$' && isDefined(o2[key]) && !isFunction(o2[key]))
                return false;
            }
            return true;
          }
        }
        return false;
      }
      var csp = function() {
        if (!isDefined(csp.rules)) {
          var ngCspElement = (window.document.querySelector('[ng-csp]') || window.document.querySelector('[data-ng-csp]'));
          if (ngCspElement) {
            var ngCspAttribute = ngCspElement.getAttribute('ng-csp') || ngCspElement.getAttribute('data-ng-csp');
            csp.rules = {
              noUnsafeEval: !ngCspAttribute || (ngCspAttribute.indexOf('no-unsafe-eval') !== -1),
              noInlineStyle: !ngCspAttribute || (ngCspAttribute.indexOf('no-inline-style') !== -1)
            };
          } else {
            csp.rules = {
              noUnsafeEval: noUnsafeEval(),
              noInlineStyle: false
            };
          }
        }
        return csp.rules;
        function noUnsafeEval() {
          try {
            new Function('');
            return false;
          } catch (e) {
            return true;
          }
        }
      };
      var jq = function() {
        if (isDefined(jq.name_))
          return jq.name_;
        var el;
        var i,
            ii = ngAttrPrefixes.length,
            prefix,
            name;
        for (i = 0; i < ii; ++i) {
          prefix = ngAttrPrefixes[i];
          if (el = window.document.querySelector('[' + prefix.replace(':', '\\:') + 'jq]')) {
            name = el.getAttribute(prefix + 'jq');
            break;
          }
        }
        return (jq.name_ = name);
      };
      function concat(array1, array2, index) {
        return array1.concat(slice.call(array2, index));
      }
      function sliceArgs(args, startIndex) {
        return slice.call(args, startIndex || 0);
      }
      function bind(self, fn) {
        var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
        if (isFunction(fn) && !(fn instanceof RegExp)) {
          return curryArgs.length ? function() {
            return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs);
          } : function() {
            return arguments.length ? fn.apply(self, arguments) : fn.call(self);
          };
        } else {
          return fn;
        }
      }
      function toJsonReplacer(key, value) {
        var val = value;
        if (typeof key === 'string' && key.charAt(0) === '$' && key.charAt(1) === '$') {
          val = undefined;
        } else if (isWindow(value)) {
          val = '$WINDOW';
        } else if (value && window.document === value) {
          val = '$DOCUMENT';
        } else if (isScope(value)) {
          val = '$SCOPE';
        }
        return val;
      }
      function toJson(obj, pretty) {
        if (isUndefined(obj))
          return undefined;
        if (!isNumber(pretty)) {
          pretty = pretty ? 2 : null;
        }
        return JSON.stringify(obj, toJsonReplacer, pretty);
      }
      function fromJson(json) {
        return isString(json) ? JSON.parse(json) : json;
      }
      var ALL_COLONS = /:/g;
      function timezoneToOffset(timezone, fallback) {
        timezone = timezone.replace(ALL_COLONS, '');
        var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
        return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
      }
      function addDateMinutes(date, minutes) {
        date = new Date(date.getTime());
        date.setMinutes(date.getMinutes() + minutes);
        return date;
      }
      function convertTimezoneToLocal(date, timezone, reverse) {
        reverse = reverse ? -1 : 1;
        var dateTimezoneOffset = date.getTimezoneOffset();
        var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
        return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));
      }
      function startingTag(element) {
        element = jqLite(element).clone();
        try {
          element.empty();
        } catch (e) {}
        var elemHtml = jqLite('<div>').append(element).html();
        try {
          return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function(match, nodeName) {
            return '<' + lowercase(nodeName);
          });
        } catch (e) {
          return lowercase(elemHtml);
        }
      }
      function tryDecodeURIComponent(value) {
        try {
          return decodeURIComponent(value);
        } catch (e) {}
      }
      function parseKeyValue(keyValue) {
        var obj = {};
        forEach((keyValue || "").split('&'), function(keyValue) {
          var splitPoint,
              key,
              val;
          if (keyValue) {
            key = keyValue = keyValue.replace(/\+/g, '%20');
            splitPoint = keyValue.indexOf('=');
            if (splitPoint !== -1) {
              key = keyValue.substring(0, splitPoint);
              val = keyValue.substring(splitPoint + 1);
            }
            key = tryDecodeURIComponent(key);
            if (isDefined(key)) {
              val = isDefined(val) ? tryDecodeURIComponent(val) : true;
              if (!hasOwnProperty.call(obj, key)) {
                obj[key] = val;
              } else if (isArray(obj[key])) {
                obj[key].push(val);
              } else {
                obj[key] = [obj[key], val];
              }
            }
          }
        });
        return obj;
      }
      function toKeyValue(obj) {
        var parts = [];
        forEach(obj, function(value, key) {
          if (isArray(value)) {
            forEach(value, function(arrayValue) {
              parts.push(encodeUriQuery(key, true) + (arrayValue === true ? '' : '=' + encodeUriQuery(arrayValue, true)));
            });
          } else {
            parts.push(encodeUriQuery(key, true) + (value === true ? '' : '=' + encodeUriQuery(value, true)));
          }
        });
        return parts.length ? parts.join('&') : '';
      }
      function encodeUriSegment(val) {
        return encodeUriQuery(val, true).replace(/%26/gi, '&').replace(/%3D/gi, '=').replace(/%2B/gi, '+');
      }
      function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%3B/gi, ';').replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));
      }
      var ngAttrPrefixes = ['ng-', 'data-ng-', 'ng:', 'x-ng-'];
      function getNgAttribute(element, ngAttr) {
        var attr,
            i,
            ii = ngAttrPrefixes.length;
        for (i = 0; i < ii; ++i) {
          attr = ngAttrPrefixes[i] + ngAttr;
          if (isString(attr = element.getAttribute(attr))) {
            return attr;
          }
        }
        return null;
      }
      function angularInit(element, bootstrap) {
        var appElement,
            module,
            config = {};
        forEach(ngAttrPrefixes, function(prefix) {
          var name = prefix + 'app';
          if (!appElement && element.hasAttribute && element.hasAttribute(name)) {
            appElement = element;
            module = element.getAttribute(name);
          }
        });
        forEach(ngAttrPrefixes, function(prefix) {
          var name = prefix + 'app';
          var candidate;
          if (!appElement && (candidate = element.querySelector('[' + name.replace(':', '\\:') + ']'))) {
            appElement = candidate;
            module = candidate.getAttribute(name);
          }
        });
        if (appElement) {
          config.strictDi = getNgAttribute(appElement, "strict-di") !== null;
          bootstrap(appElement, module ? [module] : [], config);
        }
      }
      function bootstrap(element, modules, config) {
        if (!isObject(config))
          config = {};
        var defaultConfig = {strictDi: false};
        config = extend(defaultConfig, config);
        var doBootstrap = function() {
          element = jqLite(element);
          if (element.injector()) {
            var tag = (element[0] === window.document) ? 'document' : startingTag(element);
            throw ngMinErr('btstrpd', "App already bootstrapped with this element '{0}'", tag.replace(/</, '&lt;').replace(/>/, '&gt;'));
          }
          modules = modules || [];
          modules.unshift(['$provide', function($provide) {
            $provide.value('$rootElement', element);
          }]);
          if (config.debugInfoEnabled) {
            modules.push(['$compileProvider', function($compileProvider) {
              $compileProvider.debugInfoEnabled(true);
            }]);
          }
          modules.unshift('ng');
          var injector = createInjector(modules, config.strictDi);
          injector.invoke(['$rootScope', '$rootElement', '$compile', '$injector', function bootstrapApply(scope, element, compile, injector) {
            scope.$apply(function() {
              element.data('$injector', injector);
              compile(element)(scope);
            });
          }]);
          return injector;
        };
        var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;
        var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
        if (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {
          config.debugInfoEnabled = true;
          window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, '');
        }
        if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
          return doBootstrap();
        }
        window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');
        angular.resumeBootstrap = function(extraModules) {
          forEach(extraModules, function(module) {
            modules.push(module);
          });
          return doBootstrap();
        };
        if (isFunction(angular.resumeDeferredBootstrap)) {
          angular.resumeDeferredBootstrap();
        }
      }
      function reloadWithDebugInfo() {
        window.name = 'NG_ENABLE_DEBUG_INFO!' + window.name;
        window.location.reload();
      }
      function getTestability(rootElement) {
        var injector = angular.element(rootElement).injector();
        if (!injector) {
          throw ngMinErr('test', 'no injector found for element argument to getTestability');
        }
        return injector.get('$$testability');
      }
      var SNAKE_CASE_REGEXP = /[A-Z]/g;
      function snake_case(name, separator) {
        separator = separator || '_';
        return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
          return (pos ? separator : '') + letter.toLowerCase();
        });
      }
      var bindJQueryFired = false;
      function bindJQuery() {
        var originalCleanData;
        if (bindJQueryFired) {
          return;
        }
        var jqName = jq();
        jQuery = isUndefined(jqName) ? window.jQuery : !jqName ? undefined : window[jqName];
        if (jQuery && jQuery.fn.on) {
          jqLite = jQuery;
          extend(jQuery.fn, {
            scope: JQLitePrototype.scope,
            isolateScope: JQLitePrototype.isolateScope,
            controller: JQLitePrototype.controller,
            injector: JQLitePrototype.injector,
            inheritedData: JQLitePrototype.inheritedData
          });
          originalCleanData = jQuery.cleanData;
          jQuery.cleanData = function(elems) {
            var events;
            for (var i = 0,
                elem; (elem = elems[i]) != null; i++) {
              events = jQuery._data(elem, "events");
              if (events && events.$destroy) {
                jQuery(elem).triggerHandler('$destroy');
              }
            }
            originalCleanData(elems);
          };
        } else {
          jqLite = JQLite;
        }
        angular.element = jqLite;
        bindJQueryFired = true;
      }
      function assertArg(arg, name, reason) {
        if (!arg) {
          throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
        }
        return arg;
      }
      function assertArgFn(arg, name, acceptArrayAnnotation) {
        if (acceptArrayAnnotation && isArray(arg)) {
          arg = arg[arg.length - 1];
        }
        assertArg(isFunction(arg), name, 'not a function, got ' + (arg && typeof arg === 'object' ? arg.constructor.name || 'Object' : typeof arg));
        return arg;
      }
      function assertNotHasOwnProperty(name, context) {
        if (name === 'hasOwnProperty') {
          throw ngMinErr('badname', "hasOwnProperty is not a valid {0} name", context);
        }
      }
      function getter(obj, path, bindFnToScope) {
        if (!path)
          return obj;
        var keys = path.split('.');
        var key;
        var lastInstance = obj;
        var len = keys.length;
        for (var i = 0; i < len; i++) {
          key = keys[i];
          if (obj) {
            obj = (lastInstance = obj)[key];
          }
        }
        if (!bindFnToScope && isFunction(obj)) {
          return bind(lastInstance, obj);
        }
        return obj;
      }
      function getBlockNodes(nodes) {
        var node = nodes[0];
        var endNode = nodes[nodes.length - 1];
        var blockNodes;
        for (var i = 1; node !== endNode && (node = node.nextSibling); i++) {
          if (blockNodes || nodes[i] !== node) {
            if (!blockNodes) {
              blockNodes = jqLite(slice.call(nodes, 0, i));
            }
            blockNodes.push(node);
          }
        }
        return blockNodes || nodes;
      }
      function createMap() {
        return Object.create(null);
      }
      var NODE_TYPE_ELEMENT = 1;
      var NODE_TYPE_ATTRIBUTE = 2;
      var NODE_TYPE_TEXT = 3;
      var NODE_TYPE_COMMENT = 8;
      var NODE_TYPE_DOCUMENT = 9;
      var NODE_TYPE_DOCUMENT_FRAGMENT = 11;
      function setupModuleLoader(window) {
        var $injectorMinErr = minErr('$injector');
        var ngMinErr = minErr('ng');
        function ensure(obj, name, factory) {
          return obj[name] || (obj[name] = factory());
        }
        var angular = ensure(window, 'angular', Object);
        angular.$$minErr = angular.$$minErr || minErr;
        return ensure(angular, 'module', function() {
          var modules = {};
          return function module(name, requires, configFn) {
            var assertNotHasOwnProperty = function(name, context) {
              if (name === 'hasOwnProperty') {
                throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);
              }
            };
            assertNotHasOwnProperty(name, 'module');
            if (requires && modules.hasOwnProperty(name)) {
              modules[name] = null;
            }
            return ensure(modules, name, function() {
              if (!requires) {
                throw $injectorMinErr('nomod', "Module '{0}' is not available! You either misspelled " + "the module name or forgot to load it. If registering a module ensure that you " + "specify the dependencies as the second argument.", name);
              }
              var invokeQueue = [];
              var configBlocks = [];
              var runBlocks = [];
              var config = invokeLater('$injector', 'invoke', 'push', configBlocks);
              var moduleInstance = {
                _invokeQueue: invokeQueue,
                _configBlocks: configBlocks,
                _runBlocks: runBlocks,
                requires: requires,
                name: name,
                provider: invokeLaterAndSetModuleName('$provide', 'provider'),
                factory: invokeLaterAndSetModuleName('$provide', 'factory'),
                service: invokeLaterAndSetModuleName('$provide', 'service'),
                value: invokeLater('$provide', 'value'),
                constant: invokeLater('$provide', 'constant', 'unshift'),
                decorator: invokeLaterAndSetModuleName('$provide', 'decorator'),
                animation: invokeLaterAndSetModuleName('$animateProvider', 'register'),
                filter: invokeLaterAndSetModuleName('$filterProvider', 'register'),
                controller: invokeLaterAndSetModuleName('$controllerProvider', 'register'),
                directive: invokeLaterAndSetModuleName('$compileProvider', 'directive'),
                component: invokeLaterAndSetModuleName('$compileProvider', 'component'),
                config: config,
                run: function(block) {
                  runBlocks.push(block);
                  return this;
                }
              };
              if (configFn) {
                config(configFn);
              }
              return moduleInstance;
              function invokeLater(provider, method, insertMethod, queue) {
                if (!queue)
                  queue = invokeQueue;
                return function() {
                  queue[insertMethod || 'push']([provider, method, arguments]);
                  return moduleInstance;
                };
              }
              function invokeLaterAndSetModuleName(provider, method) {
                return function(recipeName, factoryFunction) {
                  if (factoryFunction && isFunction(factoryFunction))
                    factoryFunction.$$moduleName = name;
                  invokeQueue.push([provider, method, arguments]);
                  return moduleInstance;
                };
              }
            });
          };
        });
      }
      function shallowCopy(src, dst) {
        if (isArray(src)) {
          dst = dst || [];
          for (var i = 0,
              ii = src.length; i < ii; i++) {
            dst[i] = src[i];
          }
        } else if (isObject(src)) {
          dst = dst || {};
          for (var key in src) {
            if (!(key.charAt(0) === '$' && key.charAt(1) === '$')) {
              dst[key] = src[key];
            }
          }
        }
        return dst || src;
      }
      function serializeObject(obj) {
        var seen = [];
        return JSON.stringify(obj, function(key, val) {
          val = toJsonReplacer(key, val);
          if (isObject(val)) {
            if (seen.indexOf(val) >= 0)
              return '...';
            seen.push(val);
          }
          return val;
        });
      }
      function toDebugString(obj) {
        if (typeof obj === 'function') {
          return obj.toString().replace(/ \{[\s\S]*$/, '');
        } else if (isUndefined(obj)) {
          return 'undefined';
        } else if (typeof obj !== 'string') {
          return serializeObject(obj);
        }
        return obj;
      }
      var version = {
        full: '1.5.8',
        major: 1,
        minor: 5,
        dot: 8,
        codeName: 'arbitrary-fallbacks'
      };
      function publishExternalAPI(angular) {
        extend(angular, {
          'bootstrap': bootstrap,
          'copy': copy,
          'extend': extend,
          'merge': merge,
          'equals': equals,
          'element': jqLite,
          'forEach': forEach,
          'injector': createInjector,
          'noop': noop,
          'bind': bind,
          'toJson': toJson,
          'fromJson': fromJson,
          'identity': identity,
          'isUndefined': isUndefined,
          'isDefined': isDefined,
          'isString': isString,
          'isFunction': isFunction,
          'isObject': isObject,
          'isNumber': isNumber,
          'isElement': isElement,
          'isArray': isArray,
          'version': version,
          'isDate': isDate,
          'lowercase': lowercase,
          'uppercase': uppercase,
          'callbacks': {$$counter: 0},
          'getTestability': getTestability,
          '$$minErr': minErr,
          '$$csp': csp,
          'reloadWithDebugInfo': reloadWithDebugInfo
        });
        angularModule = setupModuleLoader(window);
        angularModule('ng', ['ngLocale'], ['$provide', function ngModule($provide) {
          $provide.provider({$$sanitizeUri: $$SanitizeUriProvider});
          $provide.provider('$compile', $CompileProvider).directive({
            a: htmlAnchorDirective,
            input: inputDirective,
            textarea: inputDirective,
            form: formDirective,
            script: scriptDirective,
            select: selectDirective,
            style: styleDirective,
            option: optionDirective,
            ngBind: ngBindDirective,
            ngBindHtml: ngBindHtmlDirective,
            ngBindTemplate: ngBindTemplateDirective,
            ngClass: ngClassDirective,
            ngClassEven: ngClassEvenDirective,
            ngClassOdd: ngClassOddDirective,
            ngCloak: ngCloakDirective,
            ngController: ngControllerDirective,
            ngForm: ngFormDirective,
            ngHide: ngHideDirective,
            ngIf: ngIfDirective,
            ngInclude: ngIncludeDirective,
            ngInit: ngInitDirective,
            ngNonBindable: ngNonBindableDirective,
            ngPluralize: ngPluralizeDirective,
            ngRepeat: ngRepeatDirective,
            ngShow: ngShowDirective,
            ngStyle: ngStyleDirective,
            ngSwitch: ngSwitchDirective,
            ngSwitchWhen: ngSwitchWhenDirective,
            ngSwitchDefault: ngSwitchDefaultDirective,
            ngOptions: ngOptionsDirective,
            ngTransclude: ngTranscludeDirective,
            ngModel: ngModelDirective,
            ngList: ngListDirective,
            ngChange: ngChangeDirective,
            pattern: patternDirective,
            ngPattern: patternDirective,
            required: requiredDirective,
            ngRequired: requiredDirective,
            minlength: minlengthDirective,
            ngMinlength: minlengthDirective,
            maxlength: maxlengthDirective,
            ngMaxlength: maxlengthDirective,
            ngValue: ngValueDirective,
            ngModelOptions: ngModelOptionsDirective
          }).directive({ngInclude: ngIncludeFillContentDirective}).directive(ngAttributeAliasDirectives).directive(ngEventDirectives);
          $provide.provider({
            $anchorScroll: $AnchorScrollProvider,
            $animate: $AnimateProvider,
            $animateCss: $CoreAnimateCssProvider,
            $$animateJs: $$CoreAnimateJsProvider,
            $$animateQueue: $$CoreAnimateQueueProvider,
            $$AnimateRunner: $$AnimateRunnerFactoryProvider,
            $$animateAsyncRun: $$AnimateAsyncRunFactoryProvider,
            $browser: $BrowserProvider,
            $cacheFactory: $CacheFactoryProvider,
            $controller: $ControllerProvider,
            $document: $DocumentProvider,
            $exceptionHandler: $ExceptionHandlerProvider,
            $filter: $FilterProvider,
            $$forceReflow: $$ForceReflowProvider,
            $interpolate: $InterpolateProvider,
            $interval: $IntervalProvider,
            $http: $HttpProvider,
            $httpParamSerializer: $HttpParamSerializerProvider,
            $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
            $httpBackend: $HttpBackendProvider,
            $xhrFactory: $xhrFactoryProvider,
            $jsonpCallbacks: $jsonpCallbacksProvider,
            $location: $LocationProvider,
            $log: $LogProvider,
            $parse: $ParseProvider,
            $rootScope: $RootScopeProvider,
            $q: $QProvider,
            $$q: $$QProvider,
            $sce: $SceProvider,
            $sceDelegate: $SceDelegateProvider,
            $sniffer: $SnifferProvider,
            $templateCache: $TemplateCacheProvider,
            $templateRequest: $TemplateRequestProvider,
            $$testability: $$TestabilityProvider,
            $timeout: $TimeoutProvider,
            $window: $WindowProvider,
            $$rAF: $$RAFProvider,
            $$jqLite: $$jqLiteProvider,
            $$HashMap: $$HashMapProvider,
            $$cookieReader: $$CookieReaderProvider
          });
        }]);
      }
      JQLite.expando = 'ng339';
      var jqCache = JQLite.cache = {},
          jqId = 1,
          addEventListenerFn = function(element, type, fn) {
            element.addEventListener(type, fn, false);
          },
          removeEventListenerFn = function(element, type, fn) {
            element.removeEventListener(type, fn, false);
          };
      JQLite._data = function(node) {
        return this.cache[node[this.expando]] || {};
      };
      function jqNextId() {
        return ++jqId;
      }
      var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
      var MOZ_HACK_REGEXP = /^moz([A-Z])/;
      var MOUSE_EVENT_MAP = {
        mouseleave: "mouseout",
        mouseenter: "mouseover"
      };
      var jqLiteMinErr = minErr('jqLite');
      function camelCase(name) {
        return name.replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
          return offset ? letter.toUpperCase() : letter;
        }).replace(MOZ_HACK_REGEXP, 'Moz$1');
      }
      var SINGLE_TAG_REGEXP = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/;
      var HTML_REGEXP = /<|&#?\w+;/;
      var TAG_NAME_REGEXP = /<([\w:-]+)/;
      var XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi;
      var wrapMap = {
        'option': [1, '<select multiple="multiple">', '</select>'],
        'thead': [1, '<table>', '</table>'],
        'col': [2, '<table><colgroup>', '</colgroup></table>'],
        'tr': [2, '<table><tbody>', '</tbody></table>'],
        'td': [3, '<table><tbody><tr>', '</tr></tbody></table>'],
        '_default': [0, "", ""]
      };
      wrapMap.optgroup = wrapMap.option;
      wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
      wrapMap.th = wrapMap.td;
      function jqLiteIsTextNode(html) {
        return !HTML_REGEXP.test(html);
      }
      function jqLiteAcceptsData(node) {
        var nodeType = node.nodeType;
        return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
      }
      function jqLiteHasData(node) {
        for (var key in jqCache[node.ng339]) {
          return true;
        }
        return false;
      }
      function jqLiteCleanData(nodes) {
        for (var i = 0,
            ii = nodes.length; i < ii; i++) {
          jqLiteRemoveData(nodes[i]);
        }
      }
      function jqLiteBuildFragment(html, context) {
        var tmp,
            tag,
            wrap,
            fragment = context.createDocumentFragment(),
            nodes = [],
            i;
        if (jqLiteIsTextNode(html)) {
          nodes.push(context.createTextNode(html));
        } else {
          tmp = fragment.appendChild(context.createElement("div"));
          tag = (TAG_NAME_REGEXP.exec(html) || ["", ""])[1].toLowerCase();
          wrap = wrapMap[tag] || wrapMap._default;
          tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2];
          i = wrap[0];
          while (i--) {
            tmp = tmp.lastChild;
          }
          nodes = concat(nodes, tmp.childNodes);
          tmp = fragment.firstChild;
          tmp.textContent = "";
        }
        fragment.textContent = "";
        fragment.innerHTML = "";
        forEach(nodes, function(node) {
          fragment.appendChild(node);
        });
        return fragment;
      }
      function jqLiteParseHTML(html, context) {
        context = context || window.document;
        var parsed;
        if ((parsed = SINGLE_TAG_REGEXP.exec(html))) {
          return [context.createElement(parsed[1])];
        }
        if ((parsed = jqLiteBuildFragment(html, context))) {
          return parsed.childNodes;
        }
        return [];
      }
      function jqLiteWrapNode(node, wrapper) {
        var parent = node.parentNode;
        if (parent) {
          parent.replaceChild(wrapper, node);
        }
        wrapper.appendChild(node);
      }
      var jqLiteContains = window.Node.prototype.contains || function(arg) {
        return !!(this.compareDocumentPosition(arg) & 16);
      };
      function JQLite(element) {
        if (element instanceof JQLite) {
          return element;
        }
        var argIsString;
        if (isString(element)) {
          element = trim(element);
          argIsString = true;
        }
        if (!(this instanceof JQLite)) {
          if (argIsString && element.charAt(0) != '<') {
            throw jqLiteMinErr('nosel', 'Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element');
          }
          return new JQLite(element);
        }
        if (argIsString) {
          jqLiteAddNodes(this, jqLiteParseHTML(element));
        } else {
          jqLiteAddNodes(this, element);
        }
      }
      function jqLiteClone(element) {
        return element.cloneNode(true);
      }
      function jqLiteDealoc(element, onlyDescendants) {
        if (!onlyDescendants)
          jqLiteRemoveData(element);
        if (element.querySelectorAll) {
          var descendants = element.querySelectorAll('*');
          for (var i = 0,
              l = descendants.length; i < l; i++) {
            jqLiteRemoveData(descendants[i]);
          }
        }
      }
      function jqLiteOff(element, type, fn, unsupported) {
        if (isDefined(unsupported))
          throw jqLiteMinErr('offargs', 'jqLite#off() does not support the `selector` argument');
        var expandoStore = jqLiteExpandoStore(element);
        var events = expandoStore && expandoStore.events;
        var handle = expandoStore && expandoStore.handle;
        if (!handle)
          return;
        if (!type) {
          for (type in events) {
            if (type !== '$destroy') {
              removeEventListenerFn(element, type, handle);
            }
            delete events[type];
          }
        } else {
          var removeHandler = function(type) {
            var listenerFns = events[type];
            if (isDefined(fn)) {
              arrayRemove(listenerFns || [], fn);
            }
            if (!(isDefined(fn) && listenerFns && listenerFns.length > 0)) {
              removeEventListenerFn(element, type, handle);
              delete events[type];
            }
          };
          forEach(type.split(' '), function(type) {
            removeHandler(type);
            if (MOUSE_EVENT_MAP[type]) {
              removeHandler(MOUSE_EVENT_MAP[type]);
            }
          });
        }
      }
      function jqLiteRemoveData(element, name) {
        var expandoId = element.ng339;
        var expandoStore = expandoId && jqCache[expandoId];
        if (expandoStore) {
          if (name) {
            delete expandoStore.data[name];
            return;
          }
          if (expandoStore.handle) {
            if (expandoStore.events.$destroy) {
              expandoStore.handle({}, '$destroy');
            }
            jqLiteOff(element);
          }
          delete jqCache[expandoId];
          element.ng339 = undefined;
        }
      }
      function jqLiteExpandoStore(element, createIfNecessary) {
        var expandoId = element.ng339,
            expandoStore = expandoId && jqCache[expandoId];
        if (createIfNecessary && !expandoStore) {
          element.ng339 = expandoId = jqNextId();
          expandoStore = jqCache[expandoId] = {
            events: {},
            data: {},
            handle: undefined
          };
        }
        return expandoStore;
      }
      function jqLiteData(element, key, value) {
        if (jqLiteAcceptsData(element)) {
          var isSimpleSetter = isDefined(value);
          var isSimpleGetter = !isSimpleSetter && key && !isObject(key);
          var massGetter = !key;
          var expandoStore = jqLiteExpandoStore(element, !isSimpleGetter);
          var data = expandoStore && expandoStore.data;
          if (isSimpleSetter) {
            data[key] = value;
          } else {
            if (massGetter) {
              return data;
            } else {
              if (isSimpleGetter) {
                return data && data[key];
              } else {
                extend(data, key);
              }
            }
          }
        }
      }
      function jqLiteHasClass(element, selector) {
        if (!element.getAttribute)
          return false;
        return ((" " + (element.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1);
      }
      function jqLiteRemoveClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
          forEach(cssClasses.split(' '), function(cssClass) {
            element.setAttribute('class', trim((" " + (element.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").replace(" " + trim(cssClass) + " ", " ")));
          });
        }
      }
      function jqLiteAddClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
          var existingClasses = (' ' + (element.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, " ");
          forEach(cssClasses.split(' '), function(cssClass) {
            cssClass = trim(cssClass);
            if (existingClasses.indexOf(' ' + cssClass + ' ') === -1) {
              existingClasses += cssClass + ' ';
            }
          });
          element.setAttribute('class', trim(existingClasses));
        }
      }
      function jqLiteAddNodes(root, elements) {
        if (elements) {
          if (elements.nodeType) {
            root[root.length++] = elements;
          } else {
            var length = elements.length;
            if (typeof length === 'number' && elements.window !== elements) {
              if (length) {
                for (var i = 0; i < length; i++) {
                  root[root.length++] = elements[i];
                }
              }
            } else {
              root[root.length++] = elements;
            }
          }
        }
      }
      function jqLiteController(element, name) {
        return jqLiteInheritedData(element, '$' + (name || 'ngController') + 'Controller');
      }
      function jqLiteInheritedData(element, name, value) {
        if (element.nodeType == NODE_TYPE_DOCUMENT) {
          element = element.documentElement;
        }
        var names = isArray(name) ? name : [name];
        while (element) {
          for (var i = 0,
              ii = names.length; i < ii; i++) {
            if (isDefined(value = jqLite.data(element, names[i])))
              return value;
          }
          element = element.parentNode || (element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host);
        }
      }
      function jqLiteEmpty(element) {
        jqLiteDealoc(element, true);
        while (element.firstChild) {
          element.removeChild(element.firstChild);
        }
      }
      function jqLiteRemove(element, keepData) {
        if (!keepData)
          jqLiteDealoc(element);
        var parent = element.parentNode;
        if (parent)
          parent.removeChild(element);
      }
      function jqLiteDocumentLoaded(action, win) {
        win = win || window;
        if (win.document.readyState === 'complete') {
          win.setTimeout(action);
        } else {
          jqLite(win).on('load', action);
        }
      }
      var JQLitePrototype = JQLite.prototype = {
        ready: function(fn) {
          var fired = false;
          function trigger() {
            if (fired)
              return;
            fired = true;
            fn();
          }
          if (window.document.readyState === 'complete') {
            window.setTimeout(trigger);
          } else {
            this.on('DOMContentLoaded', trigger);
            JQLite(window).on('load', trigger);
          }
        },
        toString: function() {
          var value = [];
          forEach(this, function(e) {
            value.push('' + e);
          });
          return '[' + value.join(', ') + ']';
        },
        eq: function(index) {
          return (index >= 0) ? jqLite(this[index]) : jqLite(this[this.length + index]);
        },
        length: 0,
        push: push,
        sort: [].sort,
        splice: [].splice
      };
      var BOOLEAN_ATTR = {};
      forEach('multiple,selected,checked,disabled,readOnly,required,open'.split(','), function(value) {
        BOOLEAN_ATTR[lowercase(value)] = value;
      });
      var BOOLEAN_ELEMENTS = {};
      forEach('input,select,option,textarea,button,form,details'.split(','), function(value) {
        BOOLEAN_ELEMENTS[value] = true;
      });
      var ALIASED_ATTR = {
        'ngMinlength': 'minlength',
        'ngMaxlength': 'maxlength',
        'ngMin': 'min',
        'ngMax': 'max',
        'ngPattern': 'pattern'
      };
      function getBooleanAttrName(element, name) {
        var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
        return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
      }
      function getAliasedAttrName(name) {
        return ALIASED_ATTR[name];
      }
      forEach({
        data: jqLiteData,
        removeData: jqLiteRemoveData,
        hasData: jqLiteHasData,
        cleanData: jqLiteCleanData
      }, function(fn, name) {
        JQLite[name] = fn;
      });
      forEach({
        data: jqLiteData,
        inheritedData: jqLiteInheritedData,
        scope: function(element) {
          return jqLite.data(element, '$scope') || jqLiteInheritedData(element.parentNode || element, ['$isolateScope', '$scope']);
        },
        isolateScope: function(element) {
          return jqLite.data(element, '$isolateScope') || jqLite.data(element, '$isolateScopeNoTemplate');
        },
        controller: jqLiteController,
        injector: function(element) {
          return jqLiteInheritedData(element, '$injector');
        },
        removeAttr: function(element, name) {
          element.removeAttribute(name);
        },
        hasClass: jqLiteHasClass,
        css: function(element, name, value) {
          name = camelCase(name);
          if (isDefined(value)) {
            element.style[name] = value;
          } else {
            return element.style[name];
          }
        },
        attr: function(element, name, value) {
          var nodeType = element.nodeType;
          if (nodeType === NODE_TYPE_TEXT || nodeType === NODE_TYPE_ATTRIBUTE || nodeType === NODE_TYPE_COMMENT) {
            return;
          }
          var lowercasedName = lowercase(name);
          if (BOOLEAN_ATTR[lowercasedName]) {
            if (isDefined(value)) {
              if (!!value) {
                element[name] = true;
                element.setAttribute(name, lowercasedName);
              } else {
                element[name] = false;
                element.removeAttribute(lowercasedName);
              }
            } else {
              return (element[name] || (element.attributes.getNamedItem(name) || noop).specified) ? lowercasedName : undefined;
            }
          } else if (isDefined(value)) {
            element.setAttribute(name, value);
          } else if (element.getAttribute) {
            var ret = element.getAttribute(name, 2);
            return ret === null ? undefined : ret;
          }
        },
        prop: function(element, name, value) {
          if (isDefined(value)) {
            element[name] = value;
          } else {
            return element[name];
          }
        },
        text: (function() {
          getText.$dv = '';
          return getText;
          function getText(element, value) {
            if (isUndefined(value)) {
              var nodeType = element.nodeType;
              return (nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT) ? element.textContent : '';
            }
            element.textContent = value;
          }
        })(),
        val: function(element, value) {
          if (isUndefined(value)) {
            if (element.multiple && nodeName_(element) === 'select') {
              var result = [];
              forEach(element.options, function(option) {
                if (option.selected) {
                  result.push(option.value || option.text);
                }
              });
              return result.length === 0 ? null : result;
            }
            return element.value;
          }
          element.value = value;
        },
        html: function(element, value) {
          if (isUndefined(value)) {
            return element.innerHTML;
          }
          jqLiteDealoc(element, true);
          element.innerHTML = value;
        },
        empty: jqLiteEmpty
      }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2) {
          var i,
              key;
          var nodeCount = this.length;
          if (fn !== jqLiteEmpty && (isUndefined((fn.length == 2 && (fn !== jqLiteHasClass && fn !== jqLiteController)) ? arg1 : arg2))) {
            if (isObject(arg1)) {
              for (i = 0; i < nodeCount; i++) {
                if (fn === jqLiteData) {
                  fn(this[i], arg1);
                } else {
                  for (key in arg1) {
                    fn(this[i], key, arg1[key]);
                  }
                }
              }
              return this;
            } else {
              var value = fn.$dv;
              var jj = (isUndefined(value)) ? Math.min(nodeCount, 1) : nodeCount;
              for (var j = 0; j < jj; j++) {
                var nodeValue = fn(this[j], arg1, arg2);
                value = value ? value + nodeValue : nodeValue;
              }
              return value;
            }
          } else {
            for (i = 0; i < nodeCount; i++) {
              fn(this[i], arg1, arg2);
            }
            return this;
          }
        };
      });
      function createEventHandler(element, events) {
        var eventHandler = function(event, type) {
          event.isDefaultPrevented = function() {
            return event.defaultPrevented;
          };
          var eventFns = events[type || event.type];
          var eventFnsLength = eventFns ? eventFns.length : 0;
          if (!eventFnsLength)
            return;
          if (isUndefined(event.immediatePropagationStopped)) {
            var originalStopImmediatePropagation = event.stopImmediatePropagation;
            event.stopImmediatePropagation = function() {
              event.immediatePropagationStopped = true;
              if (event.stopPropagation) {
                event.stopPropagation();
              }
              if (originalStopImmediatePropagation) {
                originalStopImmediatePropagation.call(event);
              }
            };
          }
          event.isImmediatePropagationStopped = function() {
            return event.immediatePropagationStopped === true;
          };
          var handlerWrapper = eventFns.specialHandlerWrapper || defaultHandlerWrapper;
          if ((eventFnsLength > 1)) {
            eventFns = shallowCopy(eventFns);
          }
          for (var i = 0; i < eventFnsLength; i++) {
            if (!event.isImmediatePropagationStopped()) {
              handlerWrapper(element, event, eventFns[i]);
            }
          }
        };
        eventHandler.elem = element;
        return eventHandler;
      }
      function defaultHandlerWrapper(element, event, handler) {
        handler.call(element, event);
      }
      function specialMouseHandlerWrapper(target, event, handler) {
        var related = event.relatedTarget;
        if (!related || (related !== target && !jqLiteContains.call(target, related))) {
          handler.call(target, event);
        }
      }
      forEach({
        removeData: jqLiteRemoveData,
        on: function jqLiteOn(element, type, fn, unsupported) {
          if (isDefined(unsupported))
            throw jqLiteMinErr('onargs', 'jqLite#on() does not support the `selector` or `eventData` parameters');
          if (!jqLiteAcceptsData(element)) {
            return;
          }
          var expandoStore = jqLiteExpandoStore(element, true);
          var events = expandoStore.events;
          var handle = expandoStore.handle;
          if (!handle) {
            handle = expandoStore.handle = createEventHandler(element, events);
          }
          var types = type.indexOf(' ') >= 0 ? type.split(' ') : [type];
          var i = types.length;
          var addHandler = function(type, specialHandlerWrapper, noEventListener) {
            var eventFns = events[type];
            if (!eventFns) {
              eventFns = events[type] = [];
              eventFns.specialHandlerWrapper = specialHandlerWrapper;
              if (type !== '$destroy' && !noEventListener) {
                addEventListenerFn(element, type, handle);
              }
            }
            eventFns.push(fn);
          };
          while (i--) {
            type = types[i];
            if (MOUSE_EVENT_MAP[type]) {
              addHandler(MOUSE_EVENT_MAP[type], specialMouseHandlerWrapper);
              addHandler(type, undefined, true);
            } else {
              addHandler(type);
            }
          }
        },
        off: jqLiteOff,
        one: function(element, type, fn) {
          element = jqLite(element);
          element.on(type, function onFn() {
            element.off(type, fn);
            element.off(type, onFn);
          });
          element.on(type, fn);
        },
        replaceWith: function(element, replaceNode) {
          var index,
              parent = element.parentNode;
          jqLiteDealoc(element);
          forEach(new JQLite(replaceNode), function(node) {
            if (index) {
              parent.insertBefore(node, index.nextSibling);
            } else {
              parent.replaceChild(node, element);
            }
            index = node;
          });
        },
        children: function(element) {
          var children = [];
          forEach(element.childNodes, function(element) {
            if (element.nodeType === NODE_TYPE_ELEMENT) {
              children.push(element);
            }
          });
          return children;
        },
        contents: function(element) {
          return element.contentDocument || element.childNodes || [];
        },
        append: function(element, node) {
          var nodeType = element.nodeType;
          if (nodeType !== NODE_TYPE_ELEMENT && nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT)
            return;
          node = new JQLite(node);
          for (var i = 0,
              ii = node.length; i < ii; i++) {
            var child = node[i];
            element.appendChild(child);
          }
        },
        prepend: function(element, node) {
          if (element.nodeType === NODE_TYPE_ELEMENT) {
            var index = element.firstChild;
            forEach(new JQLite(node), function(child) {
              element.insertBefore(child, index);
            });
          }
        },
        wrap: function(element, wrapNode) {
          jqLiteWrapNode(element, jqLite(wrapNode).eq(0).clone()[0]);
        },
        remove: jqLiteRemove,
        detach: function(element) {
          jqLiteRemove(element, true);
        },
        after: function(element, newElement) {
          var index = element,
              parent = element.parentNode;
          newElement = new JQLite(newElement);
          for (var i = 0,
              ii = newElement.length; i < ii; i++) {
            var node = newElement[i];
            parent.insertBefore(node, index.nextSibling);
            index = node;
          }
        },
        addClass: jqLiteAddClass,
        removeClass: jqLiteRemoveClass,
        toggleClass: function(element, selector, condition) {
          if (selector) {
            forEach(selector.split(' '), function(className) {
              var classCondition = condition;
              if (isUndefined(classCondition)) {
                classCondition = !jqLiteHasClass(element, className);
              }
              (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
            });
          }
        },
        parent: function(element) {
          var parent = element.parentNode;
          return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
        },
        next: function(element) {
          return element.nextElementSibling;
        },
        find: function(element, selector) {
          if (element.getElementsByTagName) {
            return element.getElementsByTagName(selector);
          } else {
            return [];
          }
        },
        clone: jqLiteClone,
        triggerHandler: function(element, event, extraParameters) {
          var dummyEvent,
              eventFnsCopy,
              handlerArgs;
          var eventName = event.type || event;
          var expandoStore = jqLiteExpandoStore(element);
          var events = expandoStore && expandoStore.events;
          var eventFns = events && events[eventName];
          if (eventFns) {
            dummyEvent = {
              preventDefault: function() {
                this.defaultPrevented = true;
              },
              isDefaultPrevented: function() {
                return this.defaultPrevented === true;
              },
              stopImmediatePropagation: function() {
                this.immediatePropagationStopped = true;
              },
              isImmediatePropagationStopped: function() {
                return this.immediatePropagationStopped === true;
              },
              stopPropagation: noop,
              type: eventName,
              target: element
            };
            if (event.type) {
              dummyEvent = extend(dummyEvent, event);
            }
            eventFnsCopy = shallowCopy(eventFns);
            handlerArgs = extraParameters ? [dummyEvent].concat(extraParameters) : [dummyEvent];
            forEach(eventFnsCopy, function(fn) {
              if (!dummyEvent.isImmediatePropagationStopped()) {
                fn.apply(element, handlerArgs);
              }
            });
          }
        }
      }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2, arg3) {
          var value;
          for (var i = 0,
              ii = this.length; i < ii; i++) {
            if (isUndefined(value)) {
              value = fn(this[i], arg1, arg2, arg3);
              if (isDefined(value)) {
                value = jqLite(value);
              }
            } else {
              jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
            }
          }
          return isDefined(value) ? value : this;
        };
        JQLite.prototype.bind = JQLite.prototype.on;
        JQLite.prototype.unbind = JQLite.prototype.off;
      });
      function $$jqLiteProvider() {
        this.$get = function $$jqLite() {
          return extend(JQLite, {
            hasClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteHasClass(node, classes);
            },
            addClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteAddClass(node, classes);
            },
            removeClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteRemoveClass(node, classes);
            }
          });
        };
      }
      function hashKey(obj, nextUidFn) {
        var key = obj && obj.$$hashKey;
        if (key) {
          if (typeof key === 'function') {
            key = obj.$$hashKey();
          }
          return key;
        }
        var objType = typeof obj;
        if (objType == 'function' || (objType == 'object' && obj !== null)) {
          key = obj.$$hashKey = objType + ':' + (nextUidFn || nextUid)();
        } else {
          key = objType + ':' + obj;
        }
        return key;
      }
      function HashMap(array, isolatedUid) {
        if (isolatedUid) {
          var uid = 0;
          this.nextUid = function() {
            return ++uid;
          };
        }
        forEach(array, this.put, this);
      }
      HashMap.prototype = {
        put: function(key, value) {
          this[hashKey(key, this.nextUid)] = value;
        },
        get: function(key) {
          return this[hashKey(key, this.nextUid)];
        },
        remove: function(key) {
          var value = this[key = hashKey(key, this.nextUid)];
          delete this[key];
          return value;
        }
      };
      var $$HashMapProvider = [function() {
        this.$get = [function() {
          return HashMap;
        }];
      }];
      var ARROW_ARG = /^([^\(]+?)=>/;
      var FN_ARGS = /^[^\(]*\(\s*([^\)]*)\)/m;
      var FN_ARG_SPLIT = /,/;
      var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
      var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
      var $injectorMinErr = minErr('$injector');
      function stringifyFn(fn) {
        return Function.prototype.toString.call(fn) + ' ';
      }
      function extractArgs(fn) {
        var fnText = stringifyFn(fn).replace(STRIP_COMMENTS, ''),
            args = fnText.match(ARROW_ARG) || fnText.match(FN_ARGS);
        return args;
      }
      function anonFn(fn) {
        var args = extractArgs(fn);
        if (args) {
          return 'function(' + (args[1] || '').replace(/[\s\r\n]+/, ' ') + ')';
        }
        return 'fn';
      }
      function annotate(fn, strictDi, name) {
        var $inject,
            argDecl,
            last;
        if (typeof fn === 'function') {
          if (!($inject = fn.$inject)) {
            $inject = [];
            if (fn.length) {
              if (strictDi) {
                if (!isString(name) || !name) {
                  name = fn.name || anonFn(fn);
                }
                throw $injectorMinErr('strictdi', '{0} is not using explicit annotation and cannot be invoked in strict mode', name);
              }
              argDecl = extractArgs(fn);
              forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
                arg.replace(FN_ARG, function(all, underscore, name) {
                  $inject.push(name);
                });
              });
            }
            fn.$inject = $inject;
          }
        } else if (isArray(fn)) {
          last = fn.length - 1;
          assertArgFn(fn[last], 'fn');
          $inject = fn.slice(0, last);
        } else {
          assertArgFn(fn, 'fn', true);
        }
        return $inject;
      }
      function createInjector(modulesToLoad, strictDi) {
        strictDi = (strictDi === true);
        var INSTANTIATING = {},
            providerSuffix = 'Provider',
            path = [],
            loadedModules = new HashMap([], true),
            providerCache = {$provide: {
                provider: supportObject(provider),
                factory: supportObject(factory),
                service: supportObject(service),
                value: supportObject(value),
                constant: supportObject(constant),
                decorator: decorator
              }},
            providerInjector = (providerCache.$injector = createInternalInjector(providerCache, function(serviceName, caller) {
              if (angular.isString(caller)) {
                path.push(caller);
              }
              throw $injectorMinErr('unpr', "Unknown provider: {0}", path.join(' <- '));
            })),
            instanceCache = {},
            protoInstanceInjector = createInternalInjector(instanceCache, function(serviceName, caller) {
              var provider = providerInjector.get(serviceName + providerSuffix, caller);
              return instanceInjector.invoke(provider.$get, provider, undefined, serviceName);
            }),
            instanceInjector = protoInstanceInjector;
        providerCache['$injector' + providerSuffix] = {$get: valueFn(protoInstanceInjector)};
        var runBlocks = loadModules(modulesToLoad);
        instanceInjector = protoInstanceInjector.get('$injector');
        instanceInjector.strictDi = strictDi;
        forEach(runBlocks, function(fn) {
          if (fn)
            instanceInjector.invoke(fn);
        });
        return instanceInjector;
        function supportObject(delegate) {
          return function(key, value) {
            if (isObject(key)) {
              forEach(key, reverseParams(delegate));
            } else {
              return delegate(key, value);
            }
          };
        }
        function provider(name, provider_) {
          assertNotHasOwnProperty(name, 'service');
          if (isFunction(provider_) || isArray(provider_)) {
            provider_ = providerInjector.instantiate(provider_);
          }
          if (!provider_.$get) {
            throw $injectorMinErr('pget', "Provider '{0}' must define $get factory method.", name);
          }
          return providerCache[name + providerSuffix] = provider_;
        }
        function enforceReturnValue(name, factory) {
          return function enforcedReturnValue() {
            var result = instanceInjector.invoke(factory, this);
            if (isUndefined(result)) {
              throw $injectorMinErr('undef', "Provider '{0}' must return a value from $get factory method.", name);
            }
            return result;
          };
        }
        function factory(name, factoryFn, enforce) {
          return provider(name, {$get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn});
        }
        function service(name, constructor) {
          return factory(name, ['$injector', function($injector) {
            return $injector.instantiate(constructor);
          }]);
        }
        function value(name, val) {
          return factory(name, valueFn(val), false);
        }
        function constant(name, value) {
          assertNotHasOwnProperty(name, 'constant');
          providerCache[name] = value;
          instanceCache[name] = value;
        }
        function decorator(serviceName, decorFn) {
          var origProvider = providerInjector.get(serviceName + providerSuffix),
              orig$get = origProvider.$get;
          origProvider.$get = function() {
            var origInstance = instanceInjector.invoke(orig$get, origProvider);
            return instanceInjector.invoke(decorFn, null, {$delegate: origInstance});
          };
        }
        function loadModules(modulesToLoad) {
          assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), 'modulesToLoad', 'not an array');
          var runBlocks = [],
              moduleFn;
          forEach(modulesToLoad, function(module) {
            if (loadedModules.get(module))
              return;
            loadedModules.put(module, true);
            function runInvokeQueue(queue) {
              var i,
                  ii;
              for (i = 0, ii = queue.length; i < ii; i++) {
                var invokeArgs = queue[i],
                    provider = providerInjector.get(invokeArgs[0]);
                provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
              }
            }
            try {
              if (isString(module)) {
                moduleFn = angularModule(module);
                runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
                runInvokeQueue(moduleFn._invokeQueue);
                runInvokeQueue(moduleFn._configBlocks);
              } else if (isFunction(module)) {
                runBlocks.push(providerInjector.invoke(module));
              } else if (isArray(module)) {
                runBlocks.push(providerInjector.invoke(module));
              } else {
                assertArgFn(module, 'module');
              }
            } catch (e) {
              if (isArray(module)) {
                module = module[module.length - 1];
              }
              if (e.message && e.stack && e.stack.indexOf(e.message) == -1) {
                e = e.message + '\n' + e.stack;
              }
              throw $injectorMinErr('modulerr', "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e);
            }
          });
          return runBlocks;
        }
        function createInternalInjector(cache, factory) {
          function getService(serviceName, caller) {
            if (cache.hasOwnProperty(serviceName)) {
              if (cache[serviceName] === INSTANTIATING) {
                throw $injectorMinErr('cdep', 'Circular dependency found: {0}', serviceName + ' <- ' + path.join(' <- '));
              }
              return cache[serviceName];
            } else {
              try {
                path.unshift(serviceName);
                cache[serviceName] = INSTANTIATING;
                return cache[serviceName] = factory(serviceName, caller);
              } catch (err) {
                if (cache[serviceName] === INSTANTIATING) {
                  delete cache[serviceName];
                }
                throw err;
              } finally {
                path.shift();
              }
            }
          }
          function injectionArgs(fn, locals, serviceName) {
            var args = [],
                $inject = createInjector.$$annotate(fn, strictDi, serviceName);
            for (var i = 0,
                length = $inject.length; i < length; i++) {
              var key = $inject[i];
              if (typeof key !== 'string') {
                throw $injectorMinErr('itkn', 'Incorrect injection token! Expected service name as string, got {0}', key);
              }
              args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName));
            }
            return args;
          }
          function isClass(func) {
            if (msie <= 11) {
              return false;
            }
            return typeof func === 'function' && /^(?:class\b|constructor\()/.test(stringifyFn(func));
          }
          function invoke(fn, self, locals, serviceName) {
            if (typeof locals === 'string') {
              serviceName = locals;
              locals = null;
            }
            var args = injectionArgs(fn, locals, serviceName);
            if (isArray(fn)) {
              fn = fn[fn.length - 1];
            }
            if (!isClass(fn)) {
              return fn.apply(self, args);
            } else {
              args.unshift(null);
              return new (Function.prototype.bind.apply(fn, args))();
            }
          }
          function instantiate(Type, locals, serviceName) {
            var ctor = (isArray(Type) ? Type[Type.length - 1] : Type);
            var args = injectionArgs(Type, locals, serviceName);
            args.unshift(null);
            return new (Function.prototype.bind.apply(ctor, args))();
          }
          return {
            invoke: invoke,
            instantiate: instantiate,
            get: getService,
            annotate: createInjector.$$annotate,
            has: function(name) {
              return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
            }
          };
        }
      }
      createInjector.$$annotate = annotate;
      function $AnchorScrollProvider() {
        var autoScrollingEnabled = true;
        this.disableAutoScrolling = function() {
          autoScrollingEnabled = false;
        };
        this.$get = ['$window', '$location', '$rootScope', function($window, $location, $rootScope) {
          var document = $window.document;
          function getFirstAnchor(list) {
            var result = null;
            Array.prototype.some.call(list, function(element) {
              if (nodeName_(element) === 'a') {
                result = element;
                return true;
              }
            });
            return result;
          }
          function getYOffset() {
            var offset = scroll.yOffset;
            if (isFunction(offset)) {
              offset = offset();
            } else if (isElement(offset)) {
              var elem = offset[0];
              var style = $window.getComputedStyle(elem);
              if (style.position !== 'fixed') {
                offset = 0;
              } else {
                offset = elem.getBoundingClientRect().bottom;
              }
            } else if (!isNumber(offset)) {
              offset = 0;
            }
            return offset;
          }
          function scrollTo(elem) {
            if (elem) {
              elem.scrollIntoView();
              var offset = getYOffset();
              if (offset) {
                var elemTop = elem.getBoundingClientRect().top;
                $window.scrollBy(0, elemTop - offset);
              }
            } else {
              $window.scrollTo(0, 0);
            }
          }
          function scroll(hash) {
            hash = isString(hash) ? hash : $location.hash();
            var elm;
            if (!hash)
              scrollTo(null);
            else if ((elm = document.getElementById(hash)))
              scrollTo(elm);
            else if ((elm = getFirstAnchor(document.getElementsByName(hash))))
              scrollTo(elm);
            else if (hash === 'top')
              scrollTo(null);
          }
          if (autoScrollingEnabled) {
            $rootScope.$watch(function autoScrollWatch() {
              return $location.hash();
            }, function autoScrollWatchAction(newVal, oldVal) {
              if (newVal === oldVal && newVal === '')
                return;
              jqLiteDocumentLoaded(function() {
                $rootScope.$evalAsync(scroll);
              });
            });
          }
          return scroll;
        }];
      }
      var $animateMinErr = minErr('$animate');
      var ELEMENT_NODE = 1;
      var NG_ANIMATE_CLASSNAME = 'ng-animate';
      function mergeClasses(a, b) {
        if (!a && !b)
          return '';
        if (!a)
          return b;
        if (!b)
          return a;
        if (isArray(a))
          a = a.join(' ');
        if (isArray(b))
          b = b.join(' ');
        return a + ' ' + b;
      }
      function extractElementNode(element) {
        for (var i = 0; i < element.length; i++) {
          var elm = element[i];
          if (elm.nodeType === ELEMENT_NODE) {
            return elm;
          }
        }
      }
      function splitClasses(classes) {
        if (isString(classes)) {
          classes = classes.split(' ');
        }
        var obj = createMap();
        forEach(classes, function(klass) {
          if (klass.length) {
            obj[klass] = true;
          }
        });
        return obj;
      }
      function prepareAnimateOptions(options) {
        return isObject(options) ? options : {};
      }
      var $$CoreAnimateJsProvider = function() {
        this.$get = noop;
      };
      var $$CoreAnimateQueueProvider = function() {
        var postDigestQueue = new HashMap();
        var postDigestElements = [];
        this.$get = ['$$AnimateRunner', '$rootScope', function($$AnimateRunner, $rootScope) {
          return {
            enabled: noop,
            on: noop,
            off: noop,
            pin: noop,
            push: function(element, event, options, domOperation) {
              domOperation && domOperation();
              options = options || {};
              options.from && element.css(options.from);
              options.to && element.css(options.to);
              if (options.addClass || options.removeClass) {
                addRemoveClassesPostDigest(element, options.addClass, options.removeClass);
              }
              var runner = new $$AnimateRunner();
              runner.complete();
              return runner;
            }
          };
          function updateData(data, classes, value) {
            var changed = false;
            if (classes) {
              classes = isString(classes) ? classes.split(' ') : isArray(classes) ? classes : [];
              forEach(classes, function(className) {
                if (className) {
                  changed = true;
                  data[className] = value;
                }
              });
            }
            return changed;
          }
          function handleCSSClassChanges() {
            forEach(postDigestElements, function(element) {
              var data = postDigestQueue.get(element);
              if (data) {
                var existing = splitClasses(element.attr('class'));
                var toAdd = '';
                var toRemove = '';
                forEach(data, function(status, className) {
                  var hasClass = !!existing[className];
                  if (status !== hasClass) {
                    if (status) {
                      toAdd += (toAdd.length ? ' ' : '') + className;
                    } else {
                      toRemove += (toRemove.length ? ' ' : '') + className;
                    }
                  }
                });
                forEach(element, function(elm) {
                  toAdd && jqLiteAddClass(elm, toAdd);
                  toRemove && jqLiteRemoveClass(elm, toRemove);
                });
                postDigestQueue.remove(element);
              }
            });
            postDigestElements.length = 0;
          }
          function addRemoveClassesPostDigest(element, add, remove) {
            var data = postDigestQueue.get(element) || {};
            var classesAdded = updateData(data, add, true);
            var classesRemoved = updateData(data, remove, false);
            if (classesAdded || classesRemoved) {
              postDigestQueue.put(element, data);
              postDigestElements.push(element);
              if (postDigestElements.length === 1) {
                $rootScope.$$postDigest(handleCSSClassChanges);
              }
            }
          }
        }];
      };
      var $AnimateProvider = ['$provide', function($provide) {
        var provider = this;
        this.$$registeredAnimations = Object.create(null);
        this.register = function(name, factory) {
          if (name && name.charAt(0) !== '.') {
            throw $animateMinErr('notcsel', "Expecting class selector starting with '.' got '{0}'.", name);
          }
          var key = name + '-animation';
          provider.$$registeredAnimations[name.substr(1)] = key;
          $provide.factory(key, factory);
        };
        this.classNameFilter = function(expression) {
          if (arguments.length === 1) {
            this.$$classNameFilter = (expression instanceof RegExp) ? expression : null;
            if (this.$$classNameFilter) {
              var reservedRegex = new RegExp("(\\s+|\\/)" + NG_ANIMATE_CLASSNAME + "(\\s+|\\/)");
              if (reservedRegex.test(this.$$classNameFilter.toString())) {
                throw $animateMinErr('nongcls', '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', NG_ANIMATE_CLASSNAME);
              }
            }
          }
          return this.$$classNameFilter;
        };
        this.$get = ['$$animateQueue', function($$animateQueue) {
          function domInsert(element, parentElement, afterElement) {
            if (afterElement) {
              var afterNode = extractElementNode(afterElement);
              if (afterNode && !afterNode.parentNode && !afterNode.previousElementSibling) {
                afterElement = null;
              }
            }
            afterElement ? afterElement.after(element) : parentElement.prepend(element);
          }
          return {
            on: $$animateQueue.on,
            off: $$animateQueue.off,
            pin: $$animateQueue.pin,
            enabled: $$animateQueue.enabled,
            cancel: function(runner) {
              runner.end && runner.end();
            },
            enter: function(element, parent, after, options) {
              parent = parent && jqLite(parent);
              after = after && jqLite(after);
              parent = parent || after.parent();
              domInsert(element, parent, after);
              return $$animateQueue.push(element, 'enter', prepareAnimateOptions(options));
            },
            move: function(element, parent, after, options) {
              parent = parent && jqLite(parent);
              after = after && jqLite(after);
              parent = parent || after.parent();
              domInsert(element, parent, after);
              return $$animateQueue.push(element, 'move', prepareAnimateOptions(options));
            },
            leave: function(element, options) {
              return $$animateQueue.push(element, 'leave', prepareAnimateOptions(options), function() {
                element.remove();
              });
            },
            addClass: function(element, className, options) {
              options = prepareAnimateOptions(options);
              options.addClass = mergeClasses(options.addclass, className);
              return $$animateQueue.push(element, 'addClass', options);
            },
            removeClass: function(element, className, options) {
              options = prepareAnimateOptions(options);
              options.removeClass = mergeClasses(options.removeClass, className);
              return $$animateQueue.push(element, 'removeClass', options);
            },
            setClass: function(element, add, remove, options) {
              options = prepareAnimateOptions(options);
              options.addClass = mergeClasses(options.addClass, add);
              options.removeClass = mergeClasses(options.removeClass, remove);
              return $$animateQueue.push(element, 'setClass', options);
            },
            animate: function(element, from, to, className, options) {
              options = prepareAnimateOptions(options);
              options.from = options.from ? extend(options.from, from) : from;
              options.to = options.to ? extend(options.to, to) : to;
              className = className || 'ng-inline-animate';
              options.tempClasses = mergeClasses(options.tempClasses, className);
              return $$animateQueue.push(element, 'animate', options);
            }
          };
        }];
      }];
      var $$AnimateAsyncRunFactoryProvider = function() {
        this.$get = ['$$rAF', function($$rAF) {
          var waitQueue = [];
          function waitForTick(fn) {
            waitQueue.push(fn);
            if (waitQueue.length > 1)
              return;
            $$rAF(function() {
              for (var i = 0; i < waitQueue.length; i++) {
                waitQueue[i]();
              }
              waitQueue = [];
            });
          }
          return function() {
            var passed = false;
            waitForTick(function() {
              passed = true;
            });
            return function(callback) {
              passed ? callback() : waitForTick(callback);
            };
          };
        }];
      };
      var $$AnimateRunnerFactoryProvider = function() {
        this.$get = ['$q', '$sniffer', '$$animateAsyncRun', '$document', '$timeout', function($q, $sniffer, $$animateAsyncRun, $document, $timeout) {
          var INITIAL_STATE = 0;
          var DONE_PENDING_STATE = 1;
          var DONE_COMPLETE_STATE = 2;
          AnimateRunner.chain = function(chain, callback) {
            var index = 0;
            next();
            function next() {
              if (index === chain.length) {
                callback(true);
                return;
              }
              chain[index](function(response) {
                if (response === false) {
                  callback(false);
                  return;
                }
                index++;
                next();
              });
            }
          };
          AnimateRunner.all = function(runners, callback) {
            var count = 0;
            var status = true;
            forEach(runners, function(runner) {
              runner.done(onProgress);
            });
            function onProgress(response) {
              status = status && response;
              if (++count === runners.length) {
                callback(status);
              }
            }
          };
          function AnimateRunner(host) {
            this.setHost(host);
            var rafTick = $$animateAsyncRun();
            var timeoutTick = function(fn) {
              $timeout(fn, 0, false);
            };
            this._doneCallbacks = [];
            this._tick = function(fn) {
              var doc = $document[0];
              if (doc && doc.hidden) {
                timeoutTick(fn);
              } else {
                rafTick(fn);
              }
            };
            this._state = 0;
          }
          AnimateRunner.prototype = {
            setHost: function(host) {
              this.host = host || {};
            },
            done: function(fn) {
              if (this._state === DONE_COMPLETE_STATE) {
                fn();
              } else {
                this._doneCallbacks.push(fn);
              }
            },
            progress: noop,
            getPromise: function() {
              if (!this.promise) {
                var self = this;
                this.promise = $q(function(resolve, reject) {
                  self.done(function(status) {
                    status === false ? reject() : resolve();
                  });
                });
              }
              return this.promise;
            },
            then: function(resolveHandler, rejectHandler) {
              return this.getPromise().then(resolveHandler, rejectHandler);
            },
            'catch': function(handler) {
              return this.getPromise()['catch'](handler);
            },
            'finally': function(handler) {
              return this.getPromise()['finally'](handler);
            },
            pause: function() {
              if (this.host.pause) {
                this.host.pause();
              }
            },
            resume: function() {
              if (this.host.resume) {
                this.host.resume();
              }
            },
            end: function() {
              if (this.host.end) {
                this.host.end();
              }
              this._resolve(true);
            },
            cancel: function() {
              if (this.host.cancel) {
                this.host.cancel();
              }
              this._resolve(false);
            },
            complete: function(response) {
              var self = this;
              if (self._state === INITIAL_STATE) {
                self._state = DONE_PENDING_STATE;
                self._tick(function() {
                  self._resolve(response);
                });
              }
            },
            _resolve: function(response) {
              if (this._state !== DONE_COMPLETE_STATE) {
                forEach(this._doneCallbacks, function(fn) {
                  fn(response);
                });
                this._doneCallbacks.length = 0;
                this._state = DONE_COMPLETE_STATE;
              }
            }
          };
          return AnimateRunner;
        }];
      };
      var $CoreAnimateCssProvider = function() {
        this.$get = ['$$rAF', '$q', '$$AnimateRunner', function($$rAF, $q, $$AnimateRunner) {
          return function(element, initialOptions) {
            var options = initialOptions || {};
            if (!options.$$prepared) {
              options = copy(options);
            }
            if (options.cleanupStyles) {
              options.from = options.to = null;
            }
            if (options.from) {
              element.css(options.from);
              options.from = null;
            }
            var closed,
                runner = new $$AnimateRunner();
            return {
              start: run,
              end: run
            };
            function run() {
              $$rAF(function() {
                applyAnimationContents();
                if (!closed) {
                  runner.complete();
                }
                closed = true;
              });
              return runner;
            }
            function applyAnimationContents() {
              if (options.addClass) {
                element.addClass(options.addClass);
                options.addClass = null;
              }
              if (options.removeClass) {
                element.removeClass(options.removeClass);
                options.removeClass = null;
              }
              if (options.to) {
                element.css(options.to);
                options.to = null;
              }
            }
          };
        }];
      };
      function Browser(window, document, $log, $sniffer) {
        var self = this,
            location = window.location,
            history = window.history,
            setTimeout = window.setTimeout,
            clearTimeout = window.clearTimeout,
            pendingDeferIds = {};
        self.isMock = false;
        var outstandingRequestCount = 0;
        var outstandingRequestCallbacks = [];
        self.$$completeOutstandingRequest = completeOutstandingRequest;
        self.$$incOutstandingRequestCount = function() {
          outstandingRequestCount++;
        };
        function completeOutstandingRequest(fn) {
          try {
            fn.apply(null, sliceArgs(arguments, 1));
          } finally {
            outstandingRequestCount--;
            if (outstandingRequestCount === 0) {
              while (outstandingRequestCallbacks.length) {
                try {
                  outstandingRequestCallbacks.pop()();
                } catch (e) {
                  $log.error(e);
                }
              }
            }
          }
        }
        function getHash(url) {
          var index = url.indexOf('#');
          return index === -1 ? '' : url.substr(index);
        }
        self.notifyWhenNoOutstandingRequests = function(callback) {
          if (outstandingRequestCount === 0) {
            callback();
          } else {
            outstandingRequestCallbacks.push(callback);
          }
        };
        var cachedState,
            lastHistoryState,
            lastBrowserUrl = location.href,
            baseElement = document.find('base'),
            pendingLocation = null,
            getCurrentState = !$sniffer.history ? noop : function getCurrentState() {
              try {
                return history.state;
              } catch (e) {}
            };
        cacheState();
        lastHistoryState = cachedState;
        self.url = function(url, replace, state) {
          if (isUndefined(state)) {
            state = null;
          }
          if (location !== window.location)
            location = window.location;
          if (history !== window.history)
            history = window.history;
          if (url) {
            var sameState = lastHistoryState === state;
            if (lastBrowserUrl === url && (!$sniffer.history || sameState)) {
              return self;
            }
            var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
            lastBrowserUrl = url;
            lastHistoryState = state;
            if ($sniffer.history && (!sameBase || !sameState)) {
              history[replace ? 'replaceState' : 'pushState'](state, '', url);
              cacheState();
              lastHistoryState = cachedState;
            } else {
              if (!sameBase) {
                pendingLocation = url;
              }
              if (replace) {
                location.replace(url);
              } else if (!sameBase) {
                location.href = url;
              } else {
                location.hash = getHash(url);
              }
              if (location.href !== url) {
                pendingLocation = url;
              }
            }
            if (pendingLocation) {
              pendingLocation = url;
            }
            return self;
          } else {
            return pendingLocation || location.href.replace(/%27/g, "'");
          }
        };
        self.state = function() {
          return cachedState;
        };
        var urlChangeListeners = [],
            urlChangeInit = false;
        function cacheStateAndFireUrlChange() {
          pendingLocation = null;
          cacheState();
          fireUrlChange();
        }
        var lastCachedState = null;
        function cacheState() {
          cachedState = getCurrentState();
          cachedState = isUndefined(cachedState) ? null : cachedState;
          if (equals(cachedState, lastCachedState)) {
            cachedState = lastCachedState;
          }
          lastCachedState = cachedState;
        }
        function fireUrlChange() {
          if (lastBrowserUrl === self.url() && lastHistoryState === cachedState) {
            return;
          }
          lastBrowserUrl = self.url();
          lastHistoryState = cachedState;
          forEach(urlChangeListeners, function(listener) {
            listener(self.url(), cachedState);
          });
        }
        self.onUrlChange = function(callback) {
          if (!urlChangeInit) {
            if ($sniffer.history)
              jqLite(window).on('popstate', cacheStateAndFireUrlChange);
            jqLite(window).on('hashchange', cacheStateAndFireUrlChange);
            urlChangeInit = true;
          }
          urlChangeListeners.push(callback);
          return callback;
        };
        self.$$applicationDestroyed = function() {
          jqLite(window).off('hashchange popstate', cacheStateAndFireUrlChange);
        };
        self.$$checkUrlChange = fireUrlChange;
        self.baseHref = function() {
          var href = baseElement.attr('href');
          return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, '') : '';
        };
        self.defer = function(fn, delay) {
          var timeoutId;
          outstandingRequestCount++;
          timeoutId = setTimeout(function() {
            delete pendingDeferIds[timeoutId];
            completeOutstandingRequest(fn);
          }, delay || 0);
          pendingDeferIds[timeoutId] = true;
          return timeoutId;
        };
        self.defer.cancel = function(deferId) {
          if (pendingDeferIds[deferId]) {
            delete pendingDeferIds[deferId];
            clearTimeout(deferId);
            completeOutstandingRequest(noop);
            return true;
          }
          return false;
        };
      }
      function $BrowserProvider() {
        this.$get = ['$window', '$log', '$sniffer', '$document', function($window, $log, $sniffer, $document) {
          return new Browser($window, $document, $log, $sniffer);
        }];
      }
      function $CacheFactoryProvider() {
        this.$get = function() {
          var caches = {};
          function cacheFactory(cacheId, options) {
            if (cacheId in caches) {
              throw minErr('$cacheFactory')('iid', "CacheId '{0}' is already taken!", cacheId);
            }
            var size = 0,
                stats = extend({}, options, {id: cacheId}),
                data = createMap(),
                capacity = (options && options.capacity) || Number.MAX_VALUE,
                lruHash = createMap(),
                freshEnd = null,
                staleEnd = null;
            return caches[cacheId] = {
              put: function(key, value) {
                if (isUndefined(value))
                  return;
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key] || (lruHash[key] = {key: key});
                  refresh(lruEntry);
                }
                if (!(key in data))
                  size++;
                data[key] = value;
                if (size > capacity) {
                  this.remove(staleEnd.key);
                }
                return value;
              },
              get: function(key) {
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key];
                  if (!lruEntry)
                    return;
                  refresh(lruEntry);
                }
                return data[key];
              },
              remove: function(key) {
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key];
                  if (!lruEntry)
                    return;
                  if (lruEntry == freshEnd)
                    freshEnd = lruEntry.p;
                  if (lruEntry == staleEnd)
                    staleEnd = lruEntry.n;
                  link(lruEntry.n, lruEntry.p);
                  delete lruHash[key];
                }
                if (!(key in data))
                  return;
                delete data[key];
                size--;
              },
              removeAll: function() {
                data = createMap();
                size = 0;
                lruHash = createMap();
                freshEnd = staleEnd = null;
              },
              destroy: function() {
                data = null;
                stats = null;
                lruHash = null;
                delete caches[cacheId];
              },
              info: function() {
                return extend({}, stats, {size: size});
              }
            };
            function refresh(entry) {
              if (entry != freshEnd) {
                if (!staleEnd) {
                  staleEnd = entry;
                } else if (staleEnd == entry) {
                  staleEnd = entry.n;
                }
                link(entry.n, entry.p);
                link(entry, freshEnd);
                freshEnd = entry;
                freshEnd.n = null;
              }
            }
            function link(nextEntry, prevEntry) {
              if (nextEntry != prevEntry) {
                if (nextEntry)
                  nextEntry.p = prevEntry;
                if (prevEntry)
                  prevEntry.n = nextEntry;
              }
            }
          }
          cacheFactory.info = function() {
            var info = {};
            forEach(caches, function(cache, cacheId) {
              info[cacheId] = cache.info();
            });
            return info;
          };
          cacheFactory.get = function(cacheId) {
            return caches[cacheId];
          };
          return cacheFactory;
        };
      }
      function $TemplateCacheProvider() {
        this.$get = ['$cacheFactory', function($cacheFactory) {
          return $cacheFactory('templates');
        }];
      }
      var $compileMinErr = minErr('$compile');
      function UNINITIALIZED_VALUE() {}
      var _UNINITIALIZED_VALUE = new UNINITIALIZED_VALUE();
      $CompileProvider.$inject = ['$provide', '$$sanitizeUriProvider'];
      function $CompileProvider($provide, $$sanitizeUriProvider) {
        var hasDirectives = {},
            Suffix = 'Directive',
            COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/,
            CLASS_DIRECTIVE_REGEXP = /(([\w\-]+)(?:\:([^;]+))?;?)/,
            ALL_OR_NOTHING_ATTRS = makeMap('ngSrc,ngSrcset,src,srcset'),
            REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
        var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
        var bindingCache = createMap();
        function parseIsolateBindings(scope, directiveName, isController) {
          var LOCAL_REGEXP = /^\s*([@&<]|=(\*?))(\??)\s*(\w*)\s*$/;
          var bindings = createMap();
          forEach(scope, function(definition, scopeName) {
            if (definition in bindingCache) {
              bindings[scopeName] = bindingCache[definition];
              return;
            }
            var match = definition.match(LOCAL_REGEXP);
            if (!match) {
              throw $compileMinErr('iscp', "Invalid {3} for directive '{0}'." + " Definition: {... {1}: '{2}' ...}", directiveName, scopeName, definition, (isController ? "controller bindings definition" : "isolate scope definition"));
            }
            bindings[scopeName] = {
              mode: match[1][0],
              collection: match[2] === '*',
              optional: match[3] === '?',
              attrName: match[4] || scopeName
            };
            if (match[4]) {
              bindingCache[definition] = bindings[scopeName];
            }
          });
          return bindings;
        }
        function parseDirectiveBindings(directive, directiveName) {
          var bindings = {
            isolateScope: null,
            bindToController: null
          };
          if (isObject(directive.scope)) {
            if (directive.bindToController === true) {
              bindings.bindToController = parseIsolateBindings(directive.scope, directiveName, true);
              bindings.isolateScope = {};
            } else {
              bindings.isolateScope = parseIsolateBindings(directive.scope, directiveName, false);
            }
          }
          if (isObject(directive.bindToController)) {
            bindings.bindToController = parseIsolateBindings(directive.bindToController, directiveName, true);
          }
          if (isObject(bindings.bindToController)) {
            var controller = directive.controller;
            var controllerAs = directive.controllerAs;
            if (!controller) {
              throw $compileMinErr('noctrl', "Cannot bind to controller without directive '{0}'s controller.", directiveName);
            } else if (!identifierForController(controller, controllerAs)) {
              throw $compileMinErr('noident', "Cannot bind to controller without identifier for directive '{0}'.", directiveName);
            }
          }
          return bindings;
        }
        function assertValidDirectiveName(name) {
          var letter = name.charAt(0);
          if (!letter || letter !== lowercase(letter)) {
            throw $compileMinErr('baddir', "Directive/Component name '{0}' is invalid. The first character must be a lowercase letter", name);
          }
          if (name !== name.trim()) {
            throw $compileMinErr('baddir', "Directive/Component name '{0}' is invalid. The name should not contain leading or trailing whitespaces", name);
          }
        }
        function getDirectiveRequire(directive) {
          var require = directive.require || (directive.controller && directive.name);
          if (!isArray(require) && isObject(require)) {
            forEach(require, function(value, key) {
              var match = value.match(REQUIRE_PREFIX_REGEXP);
              var name = value.substring(match[0].length);
              if (!name)
                require[key] = match[0] + key;
            });
          }
          return require;
        }
        this.directive = function registerDirective(name, directiveFactory) {
          assertNotHasOwnProperty(name, 'directive');
          if (isString(name)) {
            assertValidDirectiveName(name);
            assertArg(directiveFactory, 'directiveFactory');
            if (!hasDirectives.hasOwnProperty(name)) {
              hasDirectives[name] = [];
              $provide.factory(name + Suffix, ['$injector', '$exceptionHandler', function($injector, $exceptionHandler) {
                var directives = [];
                forEach(hasDirectives[name], function(directiveFactory, index) {
                  try {
                    var directive = $injector.invoke(directiveFactory);
                    if (isFunction(directive)) {
                      directive = {compile: valueFn(directive)};
                    } else if (!directive.compile && directive.link) {
                      directive.compile = valueFn(directive.link);
                    }
                    directive.priority = directive.priority || 0;
                    directive.index = index;
                    directive.name = directive.name || name;
                    directive.require = getDirectiveRequire(directive);
                    directive.restrict = directive.restrict || 'EA';
                    directive.$$moduleName = directiveFactory.$$moduleName;
                    directives.push(directive);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                });
                return directives;
              }]);
            }
            hasDirectives[name].push(directiveFactory);
          } else {
            forEach(name, reverseParams(registerDirective));
          }
          return this;
        };
        this.component = function registerComponent(name, options) {
          var controller = options.controller || function() {};
          function factory($injector) {
            function makeInjectable(fn) {
              if (isFunction(fn) || isArray(fn)) {
                return function(tElement, tAttrs) {
                  return $injector.invoke(fn, this, {
                    $element: tElement,
                    $attrs: tAttrs
                  });
                };
              } else {
                return fn;
              }
            }
            var template = (!options.template && !options.templateUrl ? '' : options.template);
            var ddo = {
              controller: controller,
              controllerAs: identifierForController(options.controller) || options.controllerAs || '$ctrl',
              template: makeInjectable(template),
              templateUrl: makeInjectable(options.templateUrl),
              transclude: options.transclude,
              scope: {},
              bindToController: options.bindings || {},
              restrict: 'E',
              require: options.require
            };
            forEach(options, function(val, key) {
              if (key.charAt(0) === '$')
                ddo[key] = val;
            });
            return ddo;
          }
          forEach(options, function(val, key) {
            if (key.charAt(0) === '$') {
              factory[key] = val;
              if (isFunction(controller))
                controller[key] = val;
            }
          });
          factory.$inject = ['$injector'];
          return this.directive(name, factory);
        };
        this.aHrefSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
            return this;
          } else {
            return $$sanitizeUriProvider.aHrefSanitizationWhitelist();
          }
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
            return this;
          } else {
            return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
          }
        };
        var debugInfoEnabled = true;
        this.debugInfoEnabled = function(enabled) {
          if (isDefined(enabled)) {
            debugInfoEnabled = enabled;
            return this;
          }
          return debugInfoEnabled;
        };
        var TTL = 10;
        this.onChangesTtl = function(value) {
          if (arguments.length) {
            TTL = value;
            return this;
          }
          return TTL;
        };
        this.$get = ['$injector', '$interpolate', '$exceptionHandler', '$templateRequest', '$parse', '$controller', '$rootScope', '$sce', '$animate', '$$sanitizeUri', function($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $sce, $animate, $$sanitizeUri) {
          var SIMPLE_ATTR_NAME = /^\w/;
          var specialAttrHolder = window.document.createElement('div');
          var onChangesTtl = TTL;
          var onChangesQueue;
          function flushOnChangesQueue() {
            try {
              if (!(--onChangesTtl)) {
                onChangesQueue = undefined;
                throw $compileMinErr('infchng', '{0} $onChanges() iterations reached. Aborting!\n', TTL);
              }
              $rootScope.$apply(function() {
                var errors = [];
                for (var i = 0,
                    ii = onChangesQueue.length; i < ii; ++i) {
                  try {
                    onChangesQueue[i]();
                  } catch (e) {
                    errors.push(e);
                  }
                }
                onChangesQueue = undefined;
                if (errors.length) {
                  throw errors;
                }
              });
            } finally {
              onChangesTtl++;
            }
          }
          function Attributes(element, attributesToCopy) {
            if (attributesToCopy) {
              var keys = Object.keys(attributesToCopy);
              var i,
                  l,
                  key;
              for (i = 0, l = keys.length; i < l; i++) {
                key = keys[i];
                this[key] = attributesToCopy[key];
              }
            } else {
              this.$attr = {};
            }
            this.$$element = element;
          }
          Attributes.prototype = {
            $normalize: directiveNormalize,
            $addClass: function(classVal) {
              if (classVal && classVal.length > 0) {
                $animate.addClass(this.$$element, classVal);
              }
            },
            $removeClass: function(classVal) {
              if (classVal && classVal.length > 0) {
                $animate.removeClass(this.$$element, classVal);
              }
            },
            $updateClass: function(newClasses, oldClasses) {
              var toAdd = tokenDifference(newClasses, oldClasses);
              if (toAdd && toAdd.length) {
                $animate.addClass(this.$$element, toAdd);
              }
              var toRemove = tokenDifference(oldClasses, newClasses);
              if (toRemove && toRemove.length) {
                $animate.removeClass(this.$$element, toRemove);
              }
            },
            $set: function(key, value, writeAttr, attrName) {
              var node = this.$$element[0],
                  booleanKey = getBooleanAttrName(node, key),
                  aliasedKey = getAliasedAttrName(key),
                  observer = key,
                  nodeName;
              if (booleanKey) {
                this.$$element.prop(key, value);
                attrName = booleanKey;
              } else if (aliasedKey) {
                this[aliasedKey] = value;
                observer = aliasedKey;
              }
              this[key] = value;
              if (attrName) {
                this.$attr[key] = attrName;
              } else {
                attrName = this.$attr[key];
                if (!attrName) {
                  this.$attr[key] = attrName = snake_case(key, '-');
                }
              }
              nodeName = nodeName_(this.$$element);
              if ((nodeName === 'a' && (key === 'href' || key === 'xlinkHref')) || (nodeName === 'img' && key === 'src')) {
                this[key] = value = $$sanitizeUri(value, key === 'src');
              } else if (nodeName === 'img' && key === 'srcset' && isDefined(value)) {
                var result = "";
                var trimmedSrcset = trim(value);
                var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
                var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;
                var rawUris = trimmedSrcset.split(pattern);
                var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
                for (var i = 0; i < nbrUrisWith2parts; i++) {
                  var innerIdx = i * 2;
                  result += $$sanitizeUri(trim(rawUris[innerIdx]), true);
                  result += (" " + trim(rawUris[innerIdx + 1]));
                }
                var lastTuple = trim(rawUris[i * 2]).split(/\s/);
                result += $$sanitizeUri(trim(lastTuple[0]), true);
                if (lastTuple.length === 2) {
                  result += (" " + trim(lastTuple[1]));
                }
                this[key] = value = result;
              }
              if (writeAttr !== false) {
                if (value === null || isUndefined(value)) {
                  this.$$element.removeAttr(attrName);
                } else {
                  if (SIMPLE_ATTR_NAME.test(attrName)) {
                    this.$$element.attr(attrName, value);
                  } else {
                    setSpecialAttr(this.$$element[0], attrName, value);
                  }
                }
              }
              var $$observers = this.$$observers;
              $$observers && forEach($$observers[observer], function(fn) {
                try {
                  fn(value);
                } catch (e) {
                  $exceptionHandler(e);
                }
              });
            },
            $observe: function(key, fn) {
              var attrs = this,
                  $$observers = (attrs.$$observers || (attrs.$$observers = createMap())),
                  listeners = ($$observers[key] || ($$observers[key] = []));
              listeners.push(fn);
              $rootScope.$evalAsync(function() {
                if (!listeners.$$inter && attrs.hasOwnProperty(key) && !isUndefined(attrs[key])) {
                  fn(attrs[key]);
                }
              });
              return function() {
                arrayRemove(listeners, fn);
              };
            }
          };
          function setSpecialAttr(element, attrName, value) {
            specialAttrHolder.innerHTML = "<span " + attrName + ">";
            var attributes = specialAttrHolder.firstChild.attributes;
            var attribute = attributes[0];
            attributes.removeNamedItem(attribute.name);
            attribute.value = value;
            element.attributes.setNamedItem(attribute);
          }
          function safeAddClass($element, className) {
            try {
              $element.addClass(className);
            } catch (e) {}
          }
          var startSymbol = $interpolate.startSymbol(),
              endSymbol = $interpolate.endSymbol(),
              denormalizeTemplate = (startSymbol == '{{' && endSymbol == '}}') ? identity : function denormalizeTemplate(template) {
                return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
              },
              NG_ATTR_BINDING = /^ngAttr[A-Z]/;
          var MULTI_ELEMENT_DIR_RE = /^(.+)Start$/;
          compile.$$addBindingInfo = debugInfoEnabled ? function $$addBindingInfo($element, binding) {
            var bindings = $element.data('$binding') || [];
            if (isArray(binding)) {
              bindings = bindings.concat(binding);
            } else {
              bindings.push(binding);
            }
            $element.data('$binding', bindings);
          } : noop;
          compile.$$addBindingClass = debugInfoEnabled ? function $$addBindingClass($element) {
            safeAddClass($element, 'ng-binding');
          } : noop;
          compile.$$addScopeInfo = debugInfoEnabled ? function $$addScopeInfo($element, scope, isolated, noTemplate) {
            var dataName = isolated ? (noTemplate ? '$isolateScopeNoTemplate' : '$isolateScope') : '$scope';
            $element.data(dataName, scope);
          } : noop;
          compile.$$addScopeClass = debugInfoEnabled ? function $$addScopeClass($element, isolated) {
            safeAddClass($element, isolated ? 'ng-isolate-scope' : 'ng-scope');
          } : noop;
          compile.$$createComment = function(directiveName, comment) {
            var content = '';
            if (debugInfoEnabled) {
              content = ' ' + (directiveName || '') + ': ';
              if (comment)
                content += comment + ' ';
            }
            return window.document.createComment(content);
          };
          return compile;
          function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
            if (!($compileNodes instanceof jqLite)) {
              $compileNodes = jqLite($compileNodes);
            }
            var NOT_EMPTY = /\S+/;
            for (var i = 0,
                len = $compileNodes.length; i < len; i++) {
              var domNode = $compileNodes[i];
              if (domNode.nodeType === NODE_TYPE_TEXT && domNode.nodeValue.match(NOT_EMPTY)) {
                jqLiteWrapNode(domNode, $compileNodes[i] = window.document.createElement('span'));
              }
            }
            var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
            compile.$$addScopeClass($compileNodes);
            var namespace = null;
            return function publicLinkFn(scope, cloneConnectFn, options) {
              assertArg(scope, 'scope');
              if (previousCompileContext && previousCompileContext.needsNewScope) {
                scope = scope.$parent.$new();
              }
              options = options || {};
              var parentBoundTranscludeFn = options.parentBoundTranscludeFn,
                  transcludeControllers = options.transcludeControllers,
                  futureParentElement = options.futureParentElement;
              if (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude) {
                parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
              }
              if (!namespace) {
                namespace = detectNamespaceForChildElements(futureParentElement);
              }
              var $linkNode;
              if (namespace !== 'html') {
                $linkNode = jqLite(wrapTemplate(namespace, jqLite('<div>').append($compileNodes).html()));
              } else if (cloneConnectFn) {
                $linkNode = JQLitePrototype.clone.call($compileNodes);
              } else {
                $linkNode = $compileNodes;
              }
              if (transcludeControllers) {
                for (var controllerName in transcludeControllers) {
                  $linkNode.data('$' + controllerName + 'Controller', transcludeControllers[controllerName].instance);
                }
              }
              compile.$$addScopeInfo($linkNode, scope);
              if (cloneConnectFn)
                cloneConnectFn($linkNode, scope);
              if (compositeLinkFn)
                compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
              return $linkNode;
            };
          }
          function detectNamespaceForChildElements(parentElement) {
            var node = parentElement && parentElement[0];
            if (!node) {
              return 'html';
            } else {
              return nodeName_(node) !== 'foreignobject' && toString.call(node).match(/SVG/) ? 'svg' : 'html';
            }
          }
          function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
            var linkFns = [],
                attrs,
                directives,
                nodeLinkFn,
                childNodes,
                childLinkFn,
                linkFnFound,
                nodeLinkFnFound;
            for (var i = 0; i < nodeList.length; i++) {
              attrs = new Attributes();
              directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined, ignoreDirective);
              nodeLinkFn = (directives.length) ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null;
              if (nodeLinkFn && nodeLinkFn.scope) {
                compile.$$addScopeClass(attrs.$$element);
              }
              childLinkFn = (nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length) ? null : compileNodes(childNodes, nodeLinkFn ? ((nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude) : transcludeFn);
              if (nodeLinkFn || childLinkFn) {
                linkFns.push(i, nodeLinkFn, childLinkFn);
                linkFnFound = true;
                nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
              }
              previousCompileContext = null;
            }
            return linkFnFound ? compositeLinkFn : null;
            function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
              var nodeLinkFn,
                  childLinkFn,
                  node,
                  childScope,
                  i,
                  ii,
                  idx,
                  childBoundTranscludeFn;
              var stableNodeList;
              if (nodeLinkFnFound) {
                var nodeListLength = nodeList.length;
                stableNodeList = new Array(nodeListLength);
                for (i = 0; i < linkFns.length; i += 3) {
                  idx = linkFns[i];
                  stableNodeList[idx] = nodeList[idx];
                }
              } else {
                stableNodeList = nodeList;
              }
              for (i = 0, ii = linkFns.length; i < ii; ) {
                node = stableNodeList[linkFns[i++]];
                nodeLinkFn = linkFns[i++];
                childLinkFn = linkFns[i++];
                if (nodeLinkFn) {
                  if (nodeLinkFn.scope) {
                    childScope = scope.$new();
                    compile.$$addScopeInfo(jqLite(node), childScope);
                  } else {
                    childScope = scope;
                  }
                  if (nodeLinkFn.transcludeOnThisElement) {
                    childBoundTranscludeFn = createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn);
                  } else if (!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn) {
                    childBoundTranscludeFn = parentBoundTranscludeFn;
                  } else if (!parentBoundTranscludeFn && transcludeFn) {
                    childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);
                  } else {
                    childBoundTranscludeFn = null;
                  }
                  nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn);
                } else if (childLinkFn) {
                  childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
                }
              }
            }
          }
          function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
            function boundTranscludeFn(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
              if (!transcludedScope) {
                transcludedScope = scope.$new(false, containingScope);
                transcludedScope.$$transcluded = true;
              }
              return transcludeFn(transcludedScope, cloneFn, {
                parentBoundTranscludeFn: previousBoundTranscludeFn,
                transcludeControllers: controllers,
                futureParentElement: futureParentElement
              });
            }
            var boundSlots = boundTranscludeFn.$$slots = createMap();
            for (var slotName in transcludeFn.$$slots) {
              if (transcludeFn.$$slots[slotName]) {
                boundSlots[slotName] = createBoundTranscludeFn(scope, transcludeFn.$$slots[slotName], previousBoundTranscludeFn);
              } else {
                boundSlots[slotName] = null;
              }
            }
            return boundTranscludeFn;
          }
          function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
            var nodeType = node.nodeType,
                attrsMap = attrs.$attr,
                match,
                className;
            switch (nodeType) {
              case NODE_TYPE_ELEMENT:
                addDirective(directives, directiveNormalize(nodeName_(node)), 'E', maxPriority, ignoreDirective);
                for (var attr,
                    name,
                    nName,
                    ngAttrName,
                    value,
                    isNgAttr,
                    nAttrs = node.attributes,
                    j = 0,
                    jj = nAttrs && nAttrs.length; j < jj; j++) {
                  var attrStartName = false;
                  var attrEndName = false;
                  attr = nAttrs[j];
                  name = attr.name;
                  value = trim(attr.value);
                  ngAttrName = directiveNormalize(name);
                  if (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) {
                    name = name.replace(PREFIX_REGEXP, '').substr(8).replace(/_(.)/g, function(match, letter) {
                      return letter.toUpperCase();
                    });
                  }
                  var multiElementMatch = ngAttrName.match(MULTI_ELEMENT_DIR_RE);
                  if (multiElementMatch && directiveIsMultiElement(multiElementMatch[1])) {
                    attrStartName = name;
                    attrEndName = name.substr(0, name.length - 5) + 'end';
                    name = name.substr(0, name.length - 6);
                  }
                  nName = directiveNormalize(name.toLowerCase());
                  attrsMap[nName] = name;
                  if (isNgAttr || !attrs.hasOwnProperty(nName)) {
                    attrs[nName] = value;
                    if (getBooleanAttrName(node, nName)) {
                      attrs[nName] = true;
                    }
                  }
                  addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);
                  addDirective(directives, nName, 'A', maxPriority, ignoreDirective, attrStartName, attrEndName);
                }
                className = node.className;
                if (isObject(className)) {
                  className = className.animVal;
                }
                if (isString(className) && className !== '') {
                  while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                    nName = directiveNormalize(match[2]);
                    if (addDirective(directives, nName, 'C', maxPriority, ignoreDirective)) {
                      attrs[nName] = trim(match[3]);
                    }
                    className = className.substr(match.index + match[0].length);
                  }
                }
                break;
              case NODE_TYPE_TEXT:
                if (msie === 11) {
                  while (node.parentNode && node.nextSibling && node.nextSibling.nodeType === NODE_TYPE_TEXT) {
                    node.nodeValue = node.nodeValue + node.nextSibling.nodeValue;
                    node.parentNode.removeChild(node.nextSibling);
                  }
                }
                addTextInterpolateDirective(directives, node.nodeValue);
                break;
              case NODE_TYPE_COMMENT:
                collectCommentDirectives(node, directives, attrs, maxPriority, ignoreDirective);
                break;
            }
            directives.sort(byPriority);
            return directives;
          }
          function collectCommentDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
            try {
              var match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
              if (match) {
                var nName = directiveNormalize(match[1]);
                if (addDirective(directives, nName, 'M', maxPriority, ignoreDirective)) {
                  attrs[nName] = trim(match[2]);
                }
              }
            } catch (e) {}
          }
          function groupScan(node, attrStart, attrEnd) {
            var nodes = [];
            var depth = 0;
            if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
              do {
                if (!node) {
                  throw $compileMinErr('uterdir', "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                }
                if (node.nodeType == NODE_TYPE_ELEMENT) {
                  if (node.hasAttribute(attrStart))
                    depth++;
                  if (node.hasAttribute(attrEnd))
                    depth--;
                }
                nodes.push(node);
                node = node.nextSibling;
              } while (depth > 0);
            } else {
              nodes.push(node);
            }
            return jqLite(nodes);
          }
          function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
            return function groupedElementsLink(scope, element, attrs, controllers, transcludeFn) {
              element = groupScan(element[0], attrStart, attrEnd);
              return linkFn(scope, element, attrs, controllers, transcludeFn);
            };
          }
          function compilationGenerator(eager, $compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
            var compiled;
            if (eager) {
              return compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext);
            }
            return function lazyCompilation() {
              if (!compiled) {
                compiled = compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext);
                $compileNodes = transcludeFn = previousCompileContext = null;
              }
              return compiled.apply(this, arguments);
            };
          }
          function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
            previousCompileContext = previousCompileContext || {};
            var terminalPriority = -Number.MAX_VALUE,
                newScopeDirective = previousCompileContext.newScopeDirective,
                controllerDirectives = previousCompileContext.controllerDirectives,
                newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective,
                templateDirective = previousCompileContext.templateDirective,
                nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective,
                hasTranscludeDirective = false,
                hasTemplate = false,
                hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective,
                $compileNode = templateAttrs.$$element = jqLite(compileNode),
                directive,
                directiveName,
                $template,
                replaceDirective = originalReplaceDirective,
                childTranscludeFn = transcludeFn,
                linkFn,
                didScanForMultipleTransclusion = false,
                mightHaveMultipleTransclusionError = false,
                directiveValue;
            for (var i = 0,
                ii = directives.length; i < ii; i++) {
              directive = directives[i];
              var attrStart = directive.$$start;
              var attrEnd = directive.$$end;
              if (attrStart) {
                $compileNode = groupScan(compileNode, attrStart, attrEnd);
              }
              $template = undefined;
              if (terminalPriority > directive.priority) {
                break;
              }
              if (directiveValue = directive.scope) {
                if (!directive.templateUrl) {
                  if (isObject(directiveValue)) {
                    assertNoDuplicate('new/isolated scope', newIsolateScopeDirective || newScopeDirective, directive, $compileNode);
                    newIsolateScopeDirective = directive;
                  } else {
                    assertNoDuplicate('new/isolated scope', newIsolateScopeDirective, directive, $compileNode);
                  }
                }
                newScopeDirective = newScopeDirective || directive;
              }
              directiveName = directive.name;
              if (!didScanForMultipleTransclusion && ((directive.replace && (directive.templateUrl || directive.template)) || (directive.transclude && !directive.$$tlb))) {
                var candidateDirective;
                for (var scanningIndex = i + 1; candidateDirective = directives[scanningIndex++]; ) {
                  if ((candidateDirective.transclude && !candidateDirective.$$tlb) || (candidateDirective.replace && (candidateDirective.templateUrl || candidateDirective.template))) {
                    mightHaveMultipleTransclusionError = true;
                    break;
                  }
                }
                didScanForMultipleTransclusion = true;
              }
              if (!directive.templateUrl && directive.controller) {
                directiveValue = directive.controller;
                controllerDirectives = controllerDirectives || createMap();
                assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode);
                controllerDirectives[directiveName] = directive;
              }
              if (directiveValue = directive.transclude) {
                hasTranscludeDirective = true;
                if (!directive.$$tlb) {
                  assertNoDuplicate('transclusion', nonTlbTranscludeDirective, directive, $compileNode);
                  nonTlbTranscludeDirective = directive;
                }
                if (directiveValue == 'element') {
                  hasElementTranscludeDirective = true;
                  terminalPriority = directive.priority;
                  $template = $compileNode;
                  $compileNode = templateAttrs.$$element = jqLite(compile.$$createComment(directiveName, templateAttrs[directiveName]));
                  compileNode = $compileNode[0];
                  replaceWith(jqCollection, sliceArgs($template), compileNode);
                  $template[0].$$parentNode = $template[0].parentNode;
                  childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {nonTlbTranscludeDirective: nonTlbTranscludeDirective});
                } else {
                  var slots = createMap();
                  $template = jqLite(jqLiteClone(compileNode)).contents();
                  if (isObject(directiveValue)) {
                    $template = [];
                    var slotMap = createMap();
                    var filledSlots = createMap();
                    forEach(directiveValue, function(elementSelector, slotName) {
                      var optional = (elementSelector.charAt(0) === '?');
                      elementSelector = optional ? elementSelector.substring(1) : elementSelector;
                      slotMap[elementSelector] = slotName;
                      slots[slotName] = null;
                      filledSlots[slotName] = optional;
                    });
                    forEach($compileNode.contents(), function(node) {
                      var slotName = slotMap[directiveNormalize(nodeName_(node))];
                      if (slotName) {
                        filledSlots[slotName] = true;
                        slots[slotName] = slots[slotName] || [];
                        slots[slotName].push(node);
                      } else {
                        $template.push(node);
                      }
                    });
                    forEach(filledSlots, function(filled, slotName) {
                      if (!filled) {
                        throw $compileMinErr('reqslot', 'Required transclusion slot `{0}` was not filled.', slotName);
                      }
                    });
                    for (var slotName in slots) {
                      if (slots[slotName]) {
                        slots[slotName] = compilationGenerator(mightHaveMultipleTransclusionError, slots[slotName], transcludeFn);
                      }
                    }
                  }
                  $compileNode.empty();
                  childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, undefined, undefined, {needsNewScope: directive.$$isolateScope || directive.$$newScope});
                  childTranscludeFn.$$slots = slots;
                }
              }
              if (directive.template) {
                hasTemplate = true;
                assertNoDuplicate('template', templateDirective, directive, $compileNode);
                templateDirective = directive;
                directiveValue = (isFunction(directive.template)) ? directive.template($compileNode, templateAttrs) : directive.template;
                directiveValue = denormalizeTemplate(directiveValue);
                if (directive.replace) {
                  replaceDirective = directive;
                  if (jqLiteIsTextNode(directiveValue)) {
                    $template = [];
                  } else {
                    $template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));
                  }
                  compileNode = $template[0];
                  if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                    throw $compileMinErr('tplrt', "Template for directive '{0}' must have exactly one root element. {1}", directiveName, '');
                  }
                  replaceWith(jqCollection, $compileNode, compileNode);
                  var newTemplateAttrs = {$attr: {}};
                  var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
                  var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                  if (newIsolateScopeDirective || newScopeDirective) {
                    markDirectiveScope(templateDirectives, newIsolateScopeDirective, newScopeDirective);
                  }
                  directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
                  mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                  ii = directives.length;
                } else {
                  $compileNode.html(directiveValue);
                }
              }
              if (directive.templateUrl) {
                hasTemplate = true;
                assertNoDuplicate('template', templateDirective, directive, $compileNode);
                templateDirective = directive;
                if (directive.replace) {
                  replaceDirective = directive;
                }
                nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                  controllerDirectives: controllerDirectives,
                  newScopeDirective: (newScopeDirective !== directive) && newScopeDirective,
                  newIsolateScopeDirective: newIsolateScopeDirective,
                  templateDirective: templateDirective,
                  nonTlbTranscludeDirective: nonTlbTranscludeDirective
                });
                ii = directives.length;
              } else if (directive.compile) {
                try {
                  linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                  var context = directive.$$originalDirective || directive;
                  if (isFunction(linkFn)) {
                    addLinkFns(null, bind(context, linkFn), attrStart, attrEnd);
                  } else if (linkFn) {
                    addLinkFns(bind(context, linkFn.pre), bind(context, linkFn.post), attrStart, attrEnd);
                  }
                } catch (e) {
                  $exceptionHandler(e, startingTag($compileNode));
                }
              }
              if (directive.terminal) {
                nodeLinkFn.terminal = true;
                terminalPriority = Math.max(terminalPriority, directive.priority);
              }
            }
            nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === true;
            nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
            nodeLinkFn.templateOnThisElement = hasTemplate;
            nodeLinkFn.transclude = childTranscludeFn;
            previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;
            return nodeLinkFn;
            function addLinkFns(pre, post, attrStart, attrEnd) {
              if (pre) {
                if (attrStart)
                  pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
                pre.require = directive.require;
                pre.directiveName = directiveName;
                if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                  pre = cloneAndAnnotateFn(pre, {isolateScope: true});
                }
                preLinkFns.push(pre);
              }
              if (post) {
                if (attrStart)
                  post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
                post.require = directive.require;
                post.directiveName = directiveName;
                if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                  post = cloneAndAnnotateFn(post, {isolateScope: true});
                }
                postLinkFns.push(post);
              }
            }
            function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
              var i,
                  ii,
                  linkFn,
                  isolateScope,
                  controllerScope,
                  elementControllers,
                  transcludeFn,
                  $element,
                  attrs,
                  scopeBindingInfo;
              if (compileNode === linkNode) {
                attrs = templateAttrs;
                $element = templateAttrs.$$element;
              } else {
                $element = jqLite(linkNode);
                attrs = new Attributes($element, templateAttrs);
              }
              controllerScope = scope;
              if (newIsolateScopeDirective) {
                isolateScope = scope.$new(true);
              } else if (newScopeDirective) {
                controllerScope = scope.$parent;
              }
              if (boundTranscludeFn) {
                transcludeFn = controllersBoundTransclude;
                transcludeFn.$$boundTransclude = boundTranscludeFn;
                transcludeFn.isSlotFilled = function(slotName) {
                  return !!boundTranscludeFn.$$slots[slotName];
                };
              }
              if (controllerDirectives) {
                elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective);
              }
              if (newIsolateScopeDirective) {
                compile.$$addScopeInfo($element, isolateScope, true, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective)));
                compile.$$addScopeClass($element, true);
                isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings;
                scopeBindingInfo = initializeDirectiveBindings(scope, attrs, isolateScope, isolateScope.$$isolateBindings, newIsolateScopeDirective);
                if (scopeBindingInfo.removeWatches) {
                  isolateScope.$on('$destroy', scopeBindingInfo.removeWatches);
                }
              }
              for (var name in elementControllers) {
                var controllerDirective = controllerDirectives[name];
                var controller = elementControllers[name];
                var bindings = controllerDirective.$$bindings.bindToController;
                if (controller.identifier && bindings) {
                  controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                } else {
                  controller.bindingInfo = {};
                }
                var controllerResult = controller();
                if (controllerResult !== controller.instance) {
                  controller.instance = controllerResult;
                  $element.data('$' + controllerDirective.name + 'Controller', controllerResult);
                  controller.bindingInfo.removeWatches && controller.bindingInfo.removeWatches();
                  controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                }
              }
              forEach(controllerDirectives, function(controllerDirective, name) {
                var require = controllerDirective.require;
                if (controllerDirective.bindToController && !isArray(require) && isObject(require)) {
                  extend(elementControllers[name].instance, getControllers(name, require, $element, elementControllers));
                }
              });
              forEach(elementControllers, function(controller) {
                var controllerInstance = controller.instance;
                if (isFunction(controllerInstance.$onChanges)) {
                  try {
                    controllerInstance.$onChanges(controller.bindingInfo.initialChanges);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (isFunction(controllerInstance.$onInit)) {
                  try {
                    controllerInstance.$onInit();
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (isFunction(controllerInstance.$doCheck)) {
                  controllerScope.$watch(function() {
                    controllerInstance.$doCheck();
                  });
                  controllerInstance.$doCheck();
                }
                if (isFunction(controllerInstance.$onDestroy)) {
                  controllerScope.$on('$destroy', function callOnDestroyHook() {
                    controllerInstance.$onDestroy();
                  });
                }
              });
              for (i = 0, ii = preLinkFns.length; i < ii; i++) {
                linkFn = preLinkFns[i];
                invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
              }
              var scopeToChild = scope;
              if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
                scopeToChild = isolateScope;
              }
              childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);
              for (i = postLinkFns.length - 1; i >= 0; i--) {
                linkFn = postLinkFns[i];
                invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
              }
              forEach(elementControllers, function(controller) {
                var controllerInstance = controller.instance;
                if (isFunction(controllerInstance.$postLink)) {
                  controllerInstance.$postLink();
                }
              });
              function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement, slotName) {
                var transcludeControllers;
                if (!isScope(scope)) {
                  slotName = futureParentElement;
                  futureParentElement = cloneAttachFn;
                  cloneAttachFn = scope;
                  scope = undefined;
                }
                if (hasElementTranscludeDirective) {
                  transcludeControllers = elementControllers;
                }
                if (!futureParentElement) {
                  futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element;
                }
                if (slotName) {
                  var slotTranscludeFn = boundTranscludeFn.$$slots[slotName];
                  if (slotTranscludeFn) {
                    return slotTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                  } else if (isUndefined(slotTranscludeFn)) {
                    throw $compileMinErr('noslot', 'No parent directive that requires a transclusion with slot name "{0}". ' + 'Element: {1}', slotName, startingTag($element));
                  }
                } else {
                  return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                }
              }
            }
          }
          function getControllers(directiveName, require, $element, elementControllers) {
            var value;
            if (isString(require)) {
              var match = require.match(REQUIRE_PREFIX_REGEXP);
              var name = require.substring(match[0].length);
              var inheritType = match[1] || match[3];
              var optional = match[2] === '?';
              if (inheritType === '^^') {
                $element = $element.parent();
              } else {
                value = elementControllers && elementControllers[name];
                value = value && value.instance;
              }
              if (!value) {
                var dataName = '$' + name + 'Controller';
                value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
              }
              if (!value && !optional) {
                throw $compileMinErr('ctreq', "Controller '{0}', required by directive '{1}', can't be found!", name, directiveName);
              }
            } else if (isArray(require)) {
              value = [];
              for (var i = 0,
                  ii = require.length; i < ii; i++) {
                value[i] = getControllers(directiveName, require[i], $element, elementControllers);
              }
            } else if (isObject(require)) {
              value = {};
              forEach(require, function(controller, property) {
                value[property] = getControllers(directiveName, controller, $element, elementControllers);
              });
            }
            return value || null;
          }
          function setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective) {
            var elementControllers = createMap();
            for (var controllerKey in controllerDirectives) {
              var directive = controllerDirectives[controllerKey];
              var locals = {
                $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                $element: $element,
                $attrs: attrs,
                $transclude: transcludeFn
              };
              var controller = directive.controller;
              if (controller == '@') {
                controller = attrs[directive.name];
              }
              var controllerInstance = $controller(controller, locals, true, directive.controllerAs);
              elementControllers[directive.name] = controllerInstance;
              $element.data('$' + directive.name + 'Controller', controllerInstance.instance);
            }
            return elementControllers;
          }
          function markDirectiveScope(directives, isolateScope, newScope) {
            for (var j = 0,
                jj = directives.length; j < jj; j++) {
              directives[j] = inherit(directives[j], {
                $$isolateScope: isolateScope,
                $$newScope: newScope
              });
            }
          }
          function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
            if (name === ignoreDirective)
              return null;
            var match = null;
            if (hasDirectives.hasOwnProperty(name)) {
              for (var directive,
                  directives = $injector.get(name + Suffix),
                  i = 0,
                  ii = directives.length; i < ii; i++) {
                try {
                  directive = directives[i];
                  if ((isUndefined(maxPriority) || maxPriority > directive.priority) && directive.restrict.indexOf(location) != -1) {
                    if (startAttrName) {
                      directive = inherit(directive, {
                        $$start: startAttrName,
                        $$end: endAttrName
                      });
                    }
                    if (!directive.$$bindings) {
                      var bindings = directive.$$bindings = parseDirectiveBindings(directive, directive.name);
                      if (isObject(bindings.isolateScope)) {
                        directive.$$isolateBindings = bindings.isolateScope;
                      }
                    }
                    tDirectives.push(directive);
                    match = directive;
                  }
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
            }
            return match;
          }
          function directiveIsMultiElement(name) {
            if (hasDirectives.hasOwnProperty(name)) {
              for (var directive,
                  directives = $injector.get(name + Suffix),
                  i = 0,
                  ii = directives.length; i < ii; i++) {
                directive = directives[i];
                if (directive.multiElement) {
                  return true;
                }
              }
            }
            return false;
          }
          function mergeTemplateAttributes(dst, src) {
            var srcAttr = src.$attr,
                dstAttr = dst.$attr,
                $element = dst.$$element;
            forEach(dst, function(value, key) {
              if (key.charAt(0) != '$') {
                if (src[key] && src[key] !== value) {
                  value += (key === 'style' ? ';' : ' ') + src[key];
                }
                dst.$set(key, value, true, srcAttr[key]);
              }
            });
            forEach(src, function(value, key) {
              if (!dst.hasOwnProperty(key) && key.charAt(0) !== '$') {
                dst[key] = value;
                if (key !== 'class' && key !== 'style') {
                  dstAttr[key] = srcAttr[key];
                }
              }
            });
          }
          function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
            var linkQueue = [],
                afterTemplateNodeLinkFn,
                afterTemplateChildLinkFn,
                beforeTemplateCompileNode = $compileNode[0],
                origAsyncDirective = directives.shift(),
                derivedSyncDirective = inherit(origAsyncDirective, {
                  templateUrl: null,
                  transclude: null,
                  replace: null,
                  $$originalDirective: origAsyncDirective
                }),
                templateUrl = (isFunction(origAsyncDirective.templateUrl)) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl,
                templateNamespace = origAsyncDirective.templateNamespace;
            $compileNode.empty();
            $templateRequest(templateUrl).then(function(content) {
              var compileNode,
                  tempTemplateAttrs,
                  $template,
                  childBoundTranscludeFn;
              content = denormalizeTemplate(content);
              if (origAsyncDirective.replace) {
                if (jqLiteIsTextNode(content)) {
                  $template = [];
                } else {
                  $template = removeComments(wrapTemplate(templateNamespace, trim(content)));
                }
                compileNode = $template[0];
                if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                  throw $compileMinErr('tplrt', "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                }
                tempTemplateAttrs = {$attr: {}};
                replaceWith($rootElement, $compileNode, compileNode);
                var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                if (isObject(origAsyncDirective.scope)) {
                  markDirectiveScope(templateDirectives, true);
                }
                directives = templateDirectives.concat(directives);
                mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
              } else {
                compileNode = beforeTemplateCompileNode;
                $compileNode.html(content);
              }
              directives.unshift(derivedSyncDirective);
              afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext);
              forEach($rootElement, function(node, i) {
                if (node == compileNode) {
                  $rootElement[i] = $compileNode[0];
                }
              });
              afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
              while (linkQueue.length) {
                var scope = linkQueue.shift(),
                    beforeTemplateLinkNode = linkQueue.shift(),
                    linkRootElement = linkQueue.shift(),
                    boundTranscludeFn = linkQueue.shift(),
                    linkNode = $compileNode[0];
                if (scope.$$destroyed)
                  continue;
                if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                  var oldClasses = beforeTemplateLinkNode.className;
                  if (!(previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace)) {
                    linkNode = jqLiteClone(compileNode);
                  }
                  replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
                  safeAddClass(jqLite(linkNode), oldClasses);
                }
                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                  childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                } else {
                  childBoundTranscludeFn = boundTranscludeFn;
                }
                afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn);
              }
              linkQueue = null;
            });
            return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
              var childBoundTranscludeFn = boundTranscludeFn;
              if (scope.$$destroyed)
                return;
              if (linkQueue) {
                linkQueue.push(scope, node, rootElement, childBoundTranscludeFn);
              } else {
                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                  childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                }
                afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn);
              }
            };
          }
          function byPriority(a, b) {
            var diff = b.priority - a.priority;
            if (diff !== 0)
              return diff;
            if (a.name !== b.name)
              return (a.name < b.name) ? -1 : 1;
            return a.index - b.index;
          }
          function assertNoDuplicate(what, previousDirective, directive, element) {
            function wrapModuleNameIfDefined(moduleName) {
              return moduleName ? (' (module: ' + moduleName + ')') : '';
            }
            if (previousDirective) {
              throw $compileMinErr('multidir', 'Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}', previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName), directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element));
            }
          }
          function addTextInterpolateDirective(directives, text) {
            var interpolateFn = $interpolate(text, true);
            if (interpolateFn) {
              directives.push({
                priority: 0,
                compile: function textInterpolateCompileFn(templateNode) {
                  var templateNodeParent = templateNode.parent(),
                      hasCompileParent = !!templateNodeParent.length;
                  if (hasCompileParent)
                    compile.$$addBindingClass(templateNodeParent);
                  return function textInterpolateLinkFn(scope, node) {
                    var parent = node.parent();
                    if (!hasCompileParent)
                      compile.$$addBindingClass(parent);
                    compile.$$addBindingInfo(parent, interpolateFn.expressions);
                    scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                      node[0].nodeValue = value;
                    });
                  };
                }
              });
            }
          }
          function wrapTemplate(type, template) {
            type = lowercase(type || 'html');
            switch (type) {
              case 'svg':
              case 'math':
                var wrapper = window.document.createElement('div');
                wrapper.innerHTML = '<' + type + '>' + template + '</' + type + '>';
                return wrapper.childNodes[0].childNodes;
              default:
                return template;
            }
          }
          function getTrustedContext(node, attrNormalizedName) {
            if (attrNormalizedName == "srcdoc") {
              return $sce.HTML;
            }
            var tag = nodeName_(node);
            if (attrNormalizedName == "xlinkHref" || (tag == "form" && attrNormalizedName == "action") || (tag != "img" && (attrNormalizedName == "src" || attrNormalizedName == "ngSrc"))) {
              return $sce.RESOURCE_URL;
            }
          }
          function addAttrInterpolateDirective(node, directives, value, name, allOrNothing) {
            var trustedContext = getTrustedContext(node, name);
            allOrNothing = ALL_OR_NOTHING_ATTRS[name] || allOrNothing;
            var interpolateFn = $interpolate(value, true, trustedContext, allOrNothing);
            if (!interpolateFn)
              return;
            if (name === "multiple" && nodeName_(node) === "select") {
              throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
            }
            directives.push({
              priority: 100,
              compile: function() {
                return {pre: function attrInterpolatePreLinkFn(scope, element, attr) {
                    var $$observers = (attr.$$observers || (attr.$$observers = createMap()));
                    if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
                      throw $compileMinErr('nodomevents', "Interpolations for HTML DOM event attributes are disallowed.  Please use the " + "ng- versions (such as ng-click instead of onclick) instead.");
                    }
                    var newValue = attr[name];
                    if (newValue !== value) {
                      interpolateFn = newValue && $interpolate(newValue, true, trustedContext, allOrNothing);
                      value = newValue;
                    }
                    if (!interpolateFn)
                      return;
                    attr[name] = interpolateFn(scope);
                    ($$observers[name] || ($$observers[name] = [])).$$inter = true;
                    (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {
                      if (name === 'class' && newValue != oldValue) {
                        attr.$updateClass(newValue, oldValue);
                      } else {
                        attr.$set(name, newValue);
                      }
                    });
                  }};
              }
            });
          }
          function replaceWith($rootElement, elementsToRemove, newNode) {
            var firstElementToRemove = elementsToRemove[0],
                removeCount = elementsToRemove.length,
                parent = firstElementToRemove.parentNode,
                i,
                ii;
            if ($rootElement) {
              for (i = 0, ii = $rootElement.length; i < ii; i++) {
                if ($rootElement[i] == firstElementToRemove) {
                  $rootElement[i++] = newNode;
                  for (var j = i,
                      j2 = j + removeCount - 1,
                      jj = $rootElement.length; j < jj; j++, j2++) {
                    if (j2 < jj) {
                      $rootElement[j] = $rootElement[j2];
                    } else {
                      delete $rootElement[j];
                    }
                  }
                  $rootElement.length -= removeCount - 1;
                  if ($rootElement.context === firstElementToRemove) {
                    $rootElement.context = newNode;
                  }
                  break;
                }
              }
            }
            if (parent) {
              parent.replaceChild(newNode, firstElementToRemove);
            }
            var fragment = window.document.createDocumentFragment();
            for (i = 0; i < removeCount; i++) {
              fragment.appendChild(elementsToRemove[i]);
            }
            if (jqLite.hasData(firstElementToRemove)) {
              jqLite.data(newNode, jqLite.data(firstElementToRemove));
              jqLite(firstElementToRemove).off('$destroy');
            }
            jqLite.cleanData(fragment.querySelectorAll('*'));
            for (i = 1; i < removeCount; i++) {
              delete elementsToRemove[i];
            }
            elementsToRemove[0] = newNode;
            elementsToRemove.length = 1;
          }
          function cloneAndAnnotateFn(fn, annotation) {
            return extend(function() {
              return fn.apply(null, arguments);
            }, fn, annotation);
          }
          function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
            try {
              linkFn(scope, $element, attrs, controllers, transcludeFn);
            } catch (e) {
              $exceptionHandler(e, startingTag($element));
            }
          }
          function initializeDirectiveBindings(scope, attrs, destination, bindings, directive) {
            var removeWatchCollection = [];
            var initialChanges = {};
            var changes;
            forEach(bindings, function initializeBinding(definition, scopeName) {
              var attrName = definition.attrName,
                  optional = definition.optional,
                  mode = definition.mode,
                  lastValue,
                  parentGet,
                  parentSet,
                  compare,
                  removeWatch;
              switch (mode) {
                case '@':
                  if (!optional && !hasOwnProperty.call(attrs, attrName)) {
                    destination[scopeName] = attrs[attrName] = void 0;
                  }
                  attrs.$observe(attrName, function(value) {
                    if (isString(value) || isBoolean(value)) {
                      var oldValue = destination[scopeName];
                      recordChanges(scopeName, value, oldValue);
                      destination[scopeName] = value;
                    }
                  });
                  attrs.$$observers[attrName].$$scope = scope;
                  lastValue = attrs[attrName];
                  if (isString(lastValue)) {
                    destination[scopeName] = $interpolate(lastValue)(scope);
                  } else if (isBoolean(lastValue)) {
                    destination[scopeName] = lastValue;
                  }
                  initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]);
                  break;
                case '=':
                  if (!hasOwnProperty.call(attrs, attrName)) {
                    if (optional)
                      break;
                    attrs[attrName] = void 0;
                  }
                  if (optional && !attrs[attrName])
                    break;
                  parentGet = $parse(attrs[attrName]);
                  if (parentGet.literal) {
                    compare = equals;
                  } else {
                    compare = function simpleCompare(a, b) {
                      return a === b || (a !== a && b !== b);
                    };
                  }
                  parentSet = parentGet.assign || function() {
                    lastValue = destination[scopeName] = parentGet(scope);
                    throw $compileMinErr('nonassign', "Expression '{0}' in attribute '{1}' used with directive '{2}' is non-assignable!", attrs[attrName], attrName, directive.name);
                  };
                  lastValue = destination[scopeName] = parentGet(scope);
                  var parentValueWatch = function parentValueWatch(parentValue) {
                    if (!compare(parentValue, destination[scopeName])) {
                      if (!compare(parentValue, lastValue)) {
                        destination[scopeName] = parentValue;
                      } else {
                        parentSet(scope, parentValue = destination[scopeName]);
                      }
                    }
                    return lastValue = parentValue;
                  };
                  parentValueWatch.$stateful = true;
                  if (definition.collection) {
                    removeWatch = scope.$watchCollection(attrs[attrName], parentValueWatch);
                  } else {
                    removeWatch = scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal);
                  }
                  removeWatchCollection.push(removeWatch);
                  break;
                case '<':
                  if (!hasOwnProperty.call(attrs, attrName)) {
                    if (optional)
                      break;
                    attrs[attrName] = void 0;
                  }
                  if (optional && !attrs[attrName])
                    break;
                  parentGet = $parse(attrs[attrName]);
                  var initialValue = destination[scopeName] = parentGet(scope);
                  initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]);
                  removeWatch = scope.$watch(parentGet, function parentValueWatchAction(newValue, oldValue) {
                    if (oldValue === newValue) {
                      if (oldValue === initialValue)
                        return;
                      oldValue = initialValue;
                    }
                    recordChanges(scopeName, newValue, oldValue);
                    destination[scopeName] = newValue;
                  }, parentGet.literal);
                  removeWatchCollection.push(removeWatch);
                  break;
                case '&':
                  parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop;
                  if (parentGet === noop && optional)
                    break;
                  destination[scopeName] = function(locals) {
                    return parentGet(scope, locals);
                  };
                  break;
              }
            });
            function recordChanges(key, currentValue, previousValue) {
              if (isFunction(destination.$onChanges) && currentValue !== previousValue) {
                if (!onChangesQueue) {
                  scope.$$postDigest(flushOnChangesQueue);
                  onChangesQueue = [];
                }
                if (!changes) {
                  changes = {};
                  onChangesQueue.push(triggerOnChangesHook);
                }
                if (changes[key]) {
                  previousValue = changes[key].previousValue;
                }
                changes[key] = new SimpleChange(previousValue, currentValue);
              }
            }
            function triggerOnChangesHook() {
              destination.$onChanges(changes);
              changes = undefined;
            }
            return {
              initialChanges: initialChanges,
              removeWatches: removeWatchCollection.length && function removeWatches() {
                for (var i = 0,
                    ii = removeWatchCollection.length; i < ii; ++i) {
                  removeWatchCollection[i]();
                }
              }
            };
          }
        }];
      }
      function SimpleChange(previous, current) {
        this.previousValue = previous;
        this.currentValue = current;
      }
      SimpleChange.prototype.isFirstChange = function() {
        return this.previousValue === _UNINITIALIZED_VALUE;
      };
      var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i;
      function directiveNormalize(name) {
        return camelCase(name.replace(PREFIX_REGEXP, ''));
      }
      function nodesetLinkingFn(scope, nodeList, rootElement, boundTranscludeFn) {}
      function directiveLinkingFn(nodesetLinkingFn, scope, node, rootElement, boundTranscludeFn) {}
      function tokenDifference(str1, str2) {
        var values = '',
            tokens1 = str1.split(/\s+/),
            tokens2 = str2.split(/\s+/);
        outer: for (var i = 0; i < tokens1.length; i++) {
          var token = tokens1[i];
          for (var j = 0; j < tokens2.length; j++) {
            if (token == tokens2[j])
              continue outer;
          }
          values += (values.length > 0 ? ' ' : '') + token;
        }
        return values;
      }
      function removeComments(jqNodes) {
        jqNodes = jqLite(jqNodes);
        var i = jqNodes.length;
        if (i <= 1) {
          return jqNodes;
        }
        while (i--) {
          var node = jqNodes[i];
          if (node.nodeType === NODE_TYPE_COMMENT) {
            splice.call(jqNodes, i, 1);
          }
        }
        return jqNodes;
      }
      var $controllerMinErr = minErr('$controller');
      var CNTRL_REG = /^(\S+)(\s+as\s+([\w$]+))?$/;
      function identifierForController(controller, ident) {
        if (ident && isString(ident))
          return ident;
        if (isString(controller)) {
          var match = CNTRL_REG.exec(controller);
          if (match)
            return match[3];
        }
      }
      function $ControllerProvider() {
        var controllers = {},
            globals = false;
        this.has = function(name) {
          return controllers.hasOwnProperty(name);
        };
        this.register = function(name, constructor) {
          assertNotHasOwnProperty(name, 'controller');
          if (isObject(name)) {
            extend(controllers, name);
          } else {
            controllers[name] = constructor;
          }
        };
        this.allowGlobals = function() {
          globals = true;
        };
        this.$get = ['$injector', '$window', function($injector, $window) {
          return function $controller(expression, locals, later, ident) {
            var instance,
                match,
                constructor,
                identifier;
            later = later === true;
            if (ident && isString(ident)) {
              identifier = ident;
            }
            if (isString(expression)) {
              match = expression.match(CNTRL_REG);
              if (!match) {
                throw $controllerMinErr('ctrlfmt', "Badly formed controller string '{0}'. " + "Must match `__name__ as __id__` or `__name__`.", expression);
              }
              constructor = match[1], identifier = identifier || match[3];
              expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, true) || (globals ? getter($window, constructor, true) : undefined);
              assertArgFn(expression, constructor, true);
            }
            if (later) {
              var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
              instance = Object.create(controllerPrototype || null);
              if (identifier) {
                addIdentifier(locals, identifier, instance, constructor || expression.name);
              }
              var instantiate;
              return instantiate = extend(function $controllerInit() {
                var result = $injector.invoke(expression, instance, locals, constructor);
                if (result !== instance && (isObject(result) || isFunction(result))) {
                  instance = result;
                  if (identifier) {
                    addIdentifier(locals, identifier, instance, constructor || expression.name);
                  }
                }
                return instance;
              }, {
                instance: instance,
                identifier: identifier
              });
            }
            instance = $injector.instantiate(expression, locals, constructor);
            if (identifier) {
              addIdentifier(locals, identifier, instance, constructor || expression.name);
            }
            return instance;
          };
          function addIdentifier(locals, identifier, instance, name) {
            if (!(locals && isObject(locals.$scope))) {
              throw minErr('$controller')('noscp', "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", name, identifier);
            }
            locals.$scope[identifier] = instance;
          }
        }];
      }
      function $DocumentProvider() {
        this.$get = ['$window', function(window) {
          return jqLite(window.document);
        }];
      }
      function $ExceptionHandlerProvider() {
        this.$get = ['$log', function($log) {
          return function(exception, cause) {
            $log.error.apply($log, arguments);
          };
        }];
      }
      var $$ForceReflowProvider = function() {
        this.$get = ['$document', function($document) {
          return function(domNode) {
            if (domNode) {
              if (!domNode.nodeType && domNode instanceof jqLite) {
                domNode = domNode[0];
              }
            } else {
              domNode = $document[0].body;
            }
            return domNode.offsetWidth + 1;
          };
        }];
      };
      var APPLICATION_JSON = 'application/json';
      var CONTENT_TYPE_APPLICATION_JSON = {'Content-Type': APPLICATION_JSON + ';charset=utf-8'};
      var JSON_START = /^\[|^\{(?!\{)/;
      var JSON_ENDS = {
        '[': /]$/,
        '{': /}$/
      };
      var JSON_PROTECTION_PREFIX = /^\)\]\}',?\n/;
      var $httpMinErr = minErr('$http');
      var $httpMinErrLegacyFn = function(method) {
        return function() {
          throw $httpMinErr('legacy', 'The method `{0}` on the promise returned from `$http` has been disabled.', method);
        };
      };
      function serializeValue(v) {
        if (isObject(v)) {
          return isDate(v) ? v.toISOString() : toJson(v);
        }
        return v;
      }
      function $HttpParamSerializerProvider() {
        this.$get = function() {
          return function ngParamSerializer(params) {
            if (!params)
              return '';
            var parts = [];
            forEachSorted(params, function(value, key) {
              if (value === null || isUndefined(value))
                return;
              if (isArray(value)) {
                forEach(value, function(v) {
                  parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(v)));
                });
              } else {
                parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(value)));
              }
            });
            return parts.join('&');
          };
        };
      }
      function $HttpParamSerializerJQLikeProvider() {
        this.$get = function() {
          return function jQueryLikeParamSerializer(params) {
            if (!params)
              return '';
            var parts = [];
            serialize(params, '', true);
            return parts.join('&');
            function serialize(toSerialize, prefix, topLevel) {
              if (toSerialize === null || isUndefined(toSerialize))
                return;
              if (isArray(toSerialize)) {
                forEach(toSerialize, function(value, index) {
                  serialize(value, prefix + '[' + (isObject(value) ? index : '') + ']');
                });
              } else if (isObject(toSerialize) && !isDate(toSerialize)) {
                forEachSorted(toSerialize, function(value, key) {
                  serialize(value, prefix + (topLevel ? '' : '[') + key + (topLevel ? '' : ']'));
                });
              } else {
                parts.push(encodeUriQuery(prefix) + '=' + encodeUriQuery(serializeValue(toSerialize)));
              }
            }
          };
        };
      }
      function defaultHttpResponseTransform(data, headers) {
        if (isString(data)) {
          var tempData = data.replace(JSON_PROTECTION_PREFIX, '').trim();
          if (tempData) {
            var contentType = headers('Content-Type');
            if ((contentType && (contentType.indexOf(APPLICATION_JSON) === 0)) || isJsonLike(tempData)) {
              data = fromJson(tempData);
            }
          }
        }
        return data;
      }
      function isJsonLike(str) {
        var jsonStart = str.match(JSON_START);
        return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
      }
      function parseHeaders(headers) {
        var parsed = createMap(),
            i;
        function fillInParsed(key, val) {
          if (key) {
            parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
          }
        }
        if (isString(headers)) {
          forEach(headers.split('\n'), function(line) {
            i = line.indexOf(':');
            fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));
          });
        } else if (isObject(headers)) {
          forEach(headers, function(headerVal, headerKey) {
            fillInParsed(lowercase(headerKey), trim(headerVal));
          });
        }
        return parsed;
      }
      function headersGetter(headers) {
        var headersObj;
        return function(name) {
          if (!headersObj)
            headersObj = parseHeaders(headers);
          if (name) {
            var value = headersObj[lowercase(name)];
            if (value === void 0) {
              value = null;
            }
            return value;
          }
          return headersObj;
        };
      }
      function transformData(data, headers, status, fns) {
        if (isFunction(fns)) {
          return fns(data, headers, status);
        }
        forEach(fns, function(fn) {
          data = fn(data, headers, status);
        });
        return data;
      }
      function isSuccess(status) {
        return 200 <= status && status < 300;
      }
      function $HttpProvider() {
        var defaults = this.defaults = {
          transformResponse: [defaultHttpResponseTransform],
          transformRequest: [function(d) {
            return isObject(d) && !isFile(d) && !isBlob(d) && !isFormData(d) ? toJson(d) : d;
          }],
          headers: {
            common: {'Accept': 'application/json, text/plain, */*'},
            post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
            put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
            patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
          },
          xsrfCookieName: 'XSRF-TOKEN',
          xsrfHeaderName: 'X-XSRF-TOKEN',
          paramSerializer: '$httpParamSerializer'
        };
        var useApplyAsync = false;
        this.useApplyAsync = function(value) {
          if (isDefined(value)) {
            useApplyAsync = !!value;
            return this;
          }
          return useApplyAsync;
        };
        var useLegacyPromise = true;
        this.useLegacyPromiseExtensions = function(value) {
          if (isDefined(value)) {
            useLegacyPromise = !!value;
            return this;
          }
          return useLegacyPromise;
        };
        var interceptorFactories = this.interceptors = [];
        this.$get = ['$httpBackend', '$$cookieReader', '$cacheFactory', '$rootScope', '$q', '$injector', function($httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector) {
          var defaultCache = $cacheFactory('$http');
          defaults.paramSerializer = isString(defaults.paramSerializer) ? $injector.get(defaults.paramSerializer) : defaults.paramSerializer;
          var reversedInterceptors = [];
          forEach(interceptorFactories, function(interceptorFactory) {
            reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
          });
          function $http(requestConfig) {
            if (!isObject(requestConfig)) {
              throw minErr('$http')('badreq', 'Http request configuration must be an object.  Received: {0}', requestConfig);
            }
            if (!isString(requestConfig.url)) {
              throw minErr('$http')('badreq', 'Http request configuration url must be a string.  Received: {0}', requestConfig.url);
            }
            var config = extend({
              method: 'get',
              transformRequest: defaults.transformRequest,
              transformResponse: defaults.transformResponse,
              paramSerializer: defaults.paramSerializer
            }, requestConfig);
            config.headers = mergeHeaders(requestConfig);
            config.method = uppercase(config.method);
            config.paramSerializer = isString(config.paramSerializer) ? $injector.get(config.paramSerializer) : config.paramSerializer;
            var requestInterceptors = [];
            var responseInterceptors = [];
            var promise = $q.when(config);
            forEach(reversedInterceptors, function(interceptor) {
              if (interceptor.request || interceptor.requestError) {
                requestInterceptors.unshift(interceptor.request, interceptor.requestError);
              }
              if (interceptor.response || interceptor.responseError) {
                responseInterceptors.push(interceptor.response, interceptor.responseError);
              }
            });
            promise = chainInterceptors(promise, requestInterceptors);
            promise = promise.then(serverRequest);
            promise = chainInterceptors(promise, responseInterceptors);
            if (useLegacyPromise) {
              promise.success = function(fn) {
                assertArgFn(fn, 'fn');
                promise.then(function(response) {
                  fn(response.data, response.status, response.headers, config);
                });
                return promise;
              };
              promise.error = function(fn) {
                assertArgFn(fn, 'fn');
                promise.then(null, function(response) {
                  fn(response.data, response.status, response.headers, config);
                });
                return promise;
              };
            } else {
              promise.success = $httpMinErrLegacyFn('success');
              promise.error = $httpMinErrLegacyFn('error');
            }
            return promise;
            function chainInterceptors(promise, interceptors) {
              for (var i = 0,
                  ii = interceptors.length; i < ii; ) {
                var thenFn = interceptors[i++];
                var rejectFn = interceptors[i++];
                promise = promise.then(thenFn, rejectFn);
              }
              interceptors.length = 0;
              return promise;
            }
            function executeHeaderFns(headers, config) {
              var headerContent,
                  processedHeaders = {};
              forEach(headers, function(headerFn, header) {
                if (isFunction(headerFn)) {
                  headerContent = headerFn(config);
                  if (headerContent != null) {
                    processedHeaders[header] = headerContent;
                  }
                } else {
                  processedHeaders[header] = headerFn;
                }
              });
              return processedHeaders;
            }
            function mergeHeaders(config) {
              var defHeaders = defaults.headers,
                  reqHeaders = extend({}, config.headers),
                  defHeaderName,
                  lowercaseDefHeaderName,
                  reqHeaderName;
              defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
              defaultHeadersIteration: for (defHeaderName in defHeaders) {
                lowercaseDefHeaderName = lowercase(defHeaderName);
                for (reqHeaderName in reqHeaders) {
                  if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
                    continue defaultHeadersIteration;
                  }
                }
                reqHeaders[defHeaderName] = defHeaders[defHeaderName];
              }
              return executeHeaderFns(reqHeaders, shallowCopy(config));
            }
            function serverRequest(config) {
              var headers = config.headers;
              var reqData = transformData(config.data, headersGetter(headers), undefined, config.transformRequest);
              if (isUndefined(reqData)) {
                forEach(headers, function(value, header) {
                  if (lowercase(header) === 'content-type') {
                    delete headers[header];
                  }
                });
              }
              if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
                config.withCredentials = defaults.withCredentials;
              }
              return sendReq(config, reqData).then(transformResponse, transformResponse);
            }
            function transformResponse(response) {
              var resp = extend({}, response);
              resp.data = transformData(response.data, response.headers, response.status, config.transformResponse);
              return (isSuccess(response.status)) ? resp : $q.reject(resp);
            }
          }
          $http.pendingRequests = [];
          createShortMethods('get', 'delete', 'head', 'jsonp');
          createShortMethodsWithData('post', 'put', 'patch');
          $http.defaults = defaults;
          return $http;
          function createShortMethods(names) {
            forEach(arguments, function(name) {
              $http[name] = function(url, config) {
                return $http(extend({}, config || {}, {
                  method: name,
                  url: url
                }));
              };
            });
          }
          function createShortMethodsWithData(name) {
            forEach(arguments, function(name) {
              $http[name] = function(url, data, config) {
                return $http(extend({}, config || {}, {
                  method: name,
                  url: url,
                  data: data
                }));
              };
            });
          }
          function sendReq(config, reqData) {
            var deferred = $q.defer(),
                promise = deferred.promise,
                cache,
                cachedResp,
                reqHeaders = config.headers,
                url = buildUrl(config.url, config.paramSerializer(config.params));
            $http.pendingRequests.push(config);
            promise.then(removePendingReq, removePendingReq);
            if ((config.cache || defaults.cache) && config.cache !== false && (config.method === 'GET' || config.method === 'JSONP')) {
              cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache;
            }
            if (cache) {
              cachedResp = cache.get(url);
              if (isDefined(cachedResp)) {
                if (isPromiseLike(cachedResp)) {
                  cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult);
                } else {
                  if (isArray(cachedResp)) {
                    resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]);
                  } else {
                    resolvePromise(cachedResp, 200, {}, 'OK');
                  }
                }
              } else {
                cache.put(url, promise);
              }
            }
            if (isUndefined(cachedResp)) {
              var xsrfValue = urlIsSameOrigin(config.url) ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined;
              if (xsrfValue) {
                reqHeaders[(config.xsrfHeaderName || defaults.xsrfHeaderName)] = xsrfValue;
              }
              $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType, createApplyHandlers(config.eventHandlers), createApplyHandlers(config.uploadEventHandlers));
            }
            return promise;
            function createApplyHandlers(eventHandlers) {
              if (eventHandlers) {
                var applyHandlers = {};
                forEach(eventHandlers, function(eventHandler, key) {
                  applyHandlers[key] = function(event) {
                    if (useApplyAsync) {
                      $rootScope.$applyAsync(callEventHandler);
                    } else if ($rootScope.$$phase) {
                      callEventHandler();
                    } else {
                      $rootScope.$apply(callEventHandler);
                    }
                    function callEventHandler() {
                      eventHandler(event);
                    }
                  };
                });
                return applyHandlers;
              }
            }
            function done(status, response, headersString, statusText) {
              if (cache) {
                if (isSuccess(status)) {
                  cache.put(url, [status, response, parseHeaders(headersString), statusText]);
                } else {
                  cache.remove(url);
                }
              }
              function resolveHttpPromise() {
                resolvePromise(response, status, headersString, statusText);
              }
              if (useApplyAsync) {
                $rootScope.$applyAsync(resolveHttpPromise);
              } else {
                resolveHttpPromise();
                if (!$rootScope.$$phase)
                  $rootScope.$apply();
              }
            }
            function resolvePromise(response, status, headers, statusText) {
              status = status >= -1 ? status : 0;
              (isSuccess(status) ? deferred.resolve : deferred.reject)({
                data: response,
                status: status,
                headers: headersGetter(headers),
                config: config,
                statusText: statusText
              });
            }
            function resolvePromiseWithResult(result) {
              resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText);
            }
            function removePendingReq() {
              var idx = $http.pendingRequests.indexOf(config);
              if (idx !== -1)
                $http.pendingRequests.splice(idx, 1);
            }
          }
          function buildUrl(url, serializedParams) {
            if (serializedParams.length > 0) {
              url += ((url.indexOf('?') == -1) ? '?' : '&') + serializedParams;
            }
            return url;
          }
        }];
      }
      function $xhrFactoryProvider() {
        this.$get = function() {
          return function createXhr() {
            return new window.XMLHttpRequest();
          };
        };
      }
      function $HttpBackendProvider() {
        this.$get = ['$browser', '$jsonpCallbacks', '$document', '$xhrFactory', function($browser, $jsonpCallbacks, $document, $xhrFactory) {
          return createHttpBackend($browser, $xhrFactory, $browser.defer, $jsonpCallbacks, $document[0]);
        }];
      }
      function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
        return function(method, url, post, callback, headers, timeout, withCredentials, responseType, eventHandlers, uploadEventHandlers) {
          $browser.$$incOutstandingRequestCount();
          url = url || $browser.url();
          if (lowercase(method) === 'jsonp') {
            var callbackPath = callbacks.createCallback(url);
            var jsonpDone = jsonpReq(url, callbackPath, function(status, text) {
              var response = (status === 200) && callbacks.getResponse(callbackPath);
              completeRequest(callback, status, response, "", text);
              callbacks.removeCallback(callbackPath);
            });
          } else {
            var xhr = createXhr(method, url);
            xhr.open(method, url, true);
            forEach(headers, function(value, key) {
              if (isDefined(value)) {
                xhr.setRequestHeader(key, value);
              }
            });
            xhr.onload = function requestLoaded() {
              var statusText = xhr.statusText || '';
              var response = ('response' in xhr) ? xhr.response : xhr.responseText;
              var status = xhr.status === 1223 ? 204 : xhr.status;
              if (status === 0) {
                status = response ? 200 : urlResolve(url).protocol == 'file' ? 404 : 0;
              }
              completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText);
            };
            var requestError = function() {
              completeRequest(callback, -1, null, null, '');
            };
            xhr.onerror = requestError;
            xhr.onabort = requestError;
            forEach(eventHandlers, function(value, key) {
              xhr.addEventListener(key, value);
            });
            forEach(uploadEventHandlers, function(value, key) {
              xhr.upload.addEventListener(key, value);
            });
            if (withCredentials) {
              xhr.withCredentials = true;
            }
            if (responseType) {
              try {
                xhr.responseType = responseType;
              } catch (e) {
                if (responseType !== 'json') {
                  throw e;
                }
              }
            }
            xhr.send(isUndefined(post) ? null : post);
          }
          if (timeout > 0) {
            var timeoutId = $browserDefer(timeoutRequest, timeout);
          } else if (isPromiseLike(timeout)) {
            timeout.then(timeoutRequest);
          }
          function timeoutRequest() {
            jsonpDone && jsonpDone();
            xhr && xhr.abort();
          }
          function completeRequest(callback, status, response, headersString, statusText) {
            if (isDefined(timeoutId)) {
              $browserDefer.cancel(timeoutId);
            }
            jsonpDone = xhr = null;
            callback(status, response, headersString, statusText);
            $browser.$$completeOutstandingRequest(noop);
          }
        };
        function jsonpReq(url, callbackPath, done) {
          url = url.replace('JSON_CALLBACK', callbackPath);
          var script = rawDocument.createElement('script'),
              callback = null;
          script.type = "text/javascript";
          script.src = url;
          script.async = true;
          callback = function(event) {
            removeEventListenerFn(script, "load", callback);
            removeEventListenerFn(script, "error", callback);
            rawDocument.body.removeChild(script);
            script = null;
            var status = -1;
            var text = "unknown";
            if (event) {
              if (event.type === "load" && !callbacks.wasCalled(callbackPath)) {
                event = {type: "error"};
              }
              text = event.type;
              status = event.type === "error" ? 404 : 200;
            }
            if (done) {
              done(status, text);
            }
          };
          addEventListenerFn(script, "load", callback);
          addEventListenerFn(script, "error", callback);
          rawDocument.body.appendChild(script);
          return callback;
        }
      }
      var $interpolateMinErr = angular.$interpolateMinErr = minErr('$interpolate');
      $interpolateMinErr.throwNoconcat = function(text) {
        throw $interpolateMinErr('noconcat', "Error while interpolating: {0}\nStrict Contextual Escaping disallows " + "interpolations that concatenate multiple expressions when a trusted value is " + "required.  See http://docs.angularjs.org/api/ng.$sce", text);
      };
      $interpolateMinErr.interr = function(text, err) {
        return $interpolateMinErr('interr', "Can't interpolate: {0}\n{1}", text, err.toString());
      };
      function $InterpolateProvider() {
        var startSymbol = '{{';
        var endSymbol = '}}';
        this.startSymbol = function(value) {
          if (value) {
            startSymbol = value;
            return this;
          } else {
            return startSymbol;
          }
        };
        this.endSymbol = function(value) {
          if (value) {
            endSymbol = value;
            return this;
          } else {
            return endSymbol;
          }
        };
        this.$get = ['$parse', '$exceptionHandler', '$sce', function($parse, $exceptionHandler, $sce) {
          var startSymbolLength = startSymbol.length,
              endSymbolLength = endSymbol.length,
              escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), 'g'),
              escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), 'g');
          function escape(ch) {
            return '\\\\\\' + ch;
          }
          function unescapeText(text) {
            return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol);
          }
          function stringify(value) {
            if (value == null) {
              return '';
            }
            switch (typeof value) {
              case 'string':
                break;
              case 'number':
                value = '' + value;
                break;
              default:
                value = toJson(value);
            }
            return value;
          }
          function constantWatchDelegate(scope, listener, objectEquality, constantInterp) {
            var unwatch;
            return unwatch = scope.$watch(function constantInterpolateWatch(scope) {
              unwatch();
              return constantInterp(scope);
            }, listener, objectEquality);
          }
          function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
            if (!text.length || text.indexOf(startSymbol) === -1) {
              var constantInterp;
              if (!mustHaveExpression) {
                var unescapedText = unescapeText(text);
                constantInterp = valueFn(unescapedText);
                constantInterp.exp = text;
                constantInterp.expressions = [];
                constantInterp.$$watchDelegate = constantWatchDelegate;
              }
              return constantInterp;
            }
            allOrNothing = !!allOrNothing;
            var startIndex,
                endIndex,
                index = 0,
                expressions = [],
                parseFns = [],
                textLength = text.length,
                exp,
                concat = [],
                expressionPositions = [];
            while (index < textLength) {
              if (((startIndex = text.indexOf(startSymbol, index)) != -1) && ((endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1)) {
                if (index !== startIndex) {
                  concat.push(unescapeText(text.substring(index, startIndex)));
                }
                exp = text.substring(startIndex + startSymbolLength, endIndex);
                expressions.push(exp);
                parseFns.push($parse(exp, parseStringifyInterceptor));
                index = endIndex + endSymbolLength;
                expressionPositions.push(concat.length);
                concat.push('');
              } else {
                if (index !== textLength) {
                  concat.push(unescapeText(text.substring(index)));
                }
                break;
              }
            }
            if (trustedContext && concat.length > 1) {
              $interpolateMinErr.throwNoconcat(text);
            }
            if (!mustHaveExpression || expressions.length) {
              var compute = function(values) {
                for (var i = 0,
                    ii = expressions.length; i < ii; i++) {
                  if (allOrNothing && isUndefined(values[i]))
                    return;
                  concat[expressionPositions[i]] = values[i];
                }
                return concat.join('');
              };
              var getValue = function(value) {
                return trustedContext ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value);
              };
              return extend(function interpolationFn(context) {
                var i = 0;
                var ii = expressions.length;
                var values = new Array(ii);
                try {
                  for (; i < ii; i++) {
                    values[i] = parseFns[i](context);
                  }
                  return compute(values);
                } catch (err) {
                  $exceptionHandler($interpolateMinErr.interr(text, err));
                }
              }, {
                exp: text,
                expressions: expressions,
                $$watchDelegate: function(scope, listener) {
                  var lastValue;
                  return scope.$watchGroup(parseFns, function interpolateFnWatcher(values, oldValues) {
                    var currValue = compute(values);
                    if (isFunction(listener)) {
                      listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope);
                    }
                    lastValue = currValue;
                  });
                }
              });
            }
            function parseStringifyInterceptor(value) {
              try {
                value = getValue(value);
                return allOrNothing && !isDefined(value) ? value : stringify(value);
              } catch (err) {
                $exceptionHandler($interpolateMinErr.interr(text, err));
              }
            }
          }
          $interpolate.startSymbol = function() {
            return startSymbol;
          };
          $interpolate.endSymbol = function() {
            return endSymbol;
          };
          return $interpolate;
        }];
      }
      function $IntervalProvider() {
        this.$get = ['$rootScope', '$window', '$q', '$$q', '$browser', function($rootScope, $window, $q, $$q, $browser) {
          var intervals = {};
          function interval(fn, delay, count, invokeApply) {
            var hasParams = arguments.length > 4,
                args = hasParams ? sliceArgs(arguments, 4) : [],
                setInterval = $window.setInterval,
                clearInterval = $window.clearInterval,
                iteration = 0,
                skipApply = (isDefined(invokeApply) && !invokeApply),
                deferred = (skipApply ? $$q : $q).defer(),
                promise = deferred.promise;
            count = isDefined(count) ? count : 0;
            promise.$$intervalId = setInterval(function tick() {
              if (skipApply) {
                $browser.defer(callback);
              } else {
                $rootScope.$evalAsync(callback);
              }
              deferred.notify(iteration++);
              if (count > 0 && iteration >= count) {
                deferred.resolve(iteration);
                clearInterval(promise.$$intervalId);
                delete intervals[promise.$$intervalId];
              }
              if (!skipApply)
                $rootScope.$apply();
            }, delay);
            intervals[promise.$$intervalId] = deferred;
            return promise;
            function callback() {
              if (!hasParams) {
                fn(iteration);
              } else {
                fn.apply(null, args);
              }
            }
          }
          interval.cancel = function(promise) {
            if (promise && promise.$$intervalId in intervals) {
              intervals[promise.$$intervalId].reject('canceled');
              $window.clearInterval(promise.$$intervalId);
              delete intervals[promise.$$intervalId];
              return true;
            }
            return false;
          };
          return interval;
        }];
      }
      var $jsonpCallbacksProvider = function() {
        this.$get = ['$window', function($window) {
          var callbacks = $window.angular.callbacks;
          var callbackMap = {};
          function createCallback(callbackId) {
            var callback = function(data) {
              callback.data = data;
              callback.called = true;
            };
            callback.id = callbackId;
            return callback;
          }
          return {
            createCallback: function(url) {
              var callbackId = '_' + (callbacks.$$counter++).toString(36);
              var callbackPath = 'angular.callbacks.' + callbackId;
              var callback = createCallback(callbackId);
              callbackMap[callbackPath] = callbacks[callbackId] = callback;
              return callbackPath;
            },
            wasCalled: function(callbackPath) {
              return callbackMap[callbackPath].called;
            },
            getResponse: function(callbackPath) {
              return callbackMap[callbackPath].data;
            },
            removeCallback: function(callbackPath) {
              var callback = callbackMap[callbackPath];
              delete callbacks[callback.id];
              delete callbackMap[callbackPath];
            }
          };
        }];
      };
      var PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/,
          DEFAULT_PORTS = {
            'http': 80,
            'https': 443,
            'ftp': 21
          };
      var $locationMinErr = minErr('$location');
      function encodePath(path) {
        var segments = path.split('/'),
            i = segments.length;
        while (i--) {
          segments[i] = encodeUriSegment(segments[i]);
        }
        return segments.join('/');
      }
      function parseAbsoluteUrl(absoluteUrl, locationObj) {
        var parsedUrl = urlResolve(absoluteUrl);
        locationObj.$$protocol = parsedUrl.protocol;
        locationObj.$$host = parsedUrl.hostname;
        locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
      }
      function parseAppUrl(relativeUrl, locationObj) {
        var prefixed = (relativeUrl.charAt(0) !== '/');
        if (prefixed) {
          relativeUrl = '/' + relativeUrl;
        }
        var match = urlResolve(relativeUrl);
        locationObj.$$path = decodeURIComponent(prefixed && match.pathname.charAt(0) === '/' ? match.pathname.substring(1) : match.pathname);
        locationObj.$$search = parseKeyValue(match.search);
        locationObj.$$hash = decodeURIComponent(match.hash);
        if (locationObj.$$path && locationObj.$$path.charAt(0) != '/') {
          locationObj.$$path = '/' + locationObj.$$path;
        }
      }
      function startsWith(haystack, needle) {
        return haystack.lastIndexOf(needle, 0) === 0;
      }
      function stripBaseUrl(base, url) {
        if (startsWith(url, base)) {
          return url.substr(base.length);
        }
      }
      function stripHash(url) {
        var index = url.indexOf('#');
        return index == -1 ? url : url.substr(0, index);
      }
      function trimEmptyHash(url) {
        return url.replace(/(#.+)|#$/, '$1');
      }
      function stripFile(url) {
        return url.substr(0, stripHash(url).lastIndexOf('/') + 1);
      }
      function serverBase(url) {
        return url.substring(0, url.indexOf('/', url.indexOf('//') + 2));
      }
      function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
        this.$$html5 = true;
        basePrefix = basePrefix || '';
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
          var pathUrl = stripBaseUrl(appBaseNoFile, url);
          if (!isString(pathUrl)) {
            throw $locationMinErr('ipthprfx', 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
          }
          parseAppUrl(pathUrl, this);
          if (!this.$$path) {
            this.$$path = '/';
          }
          this.$$compose();
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
        };
        this.$$parseLinkUrl = function(url, relHref) {
          if (relHref && relHref[0] === '#') {
            this.hash(relHref.slice(1));
            return true;
          }
          var appUrl,
              prevAppUrl;
          var rewrittenUrl;
          if (isDefined(appUrl = stripBaseUrl(appBase, url))) {
            prevAppUrl = appUrl;
            if (isDefined(appUrl = stripBaseUrl(basePrefix, appUrl))) {
              rewrittenUrl = appBaseNoFile + (stripBaseUrl('/', appUrl) || appUrl);
            } else {
              rewrittenUrl = appBase + prevAppUrl;
            }
          } else if (isDefined(appUrl = stripBaseUrl(appBaseNoFile, url))) {
            rewrittenUrl = appBaseNoFile + appUrl;
          } else if (appBaseNoFile == url + '/') {
            rewrittenUrl = appBaseNoFile;
          }
          if (rewrittenUrl) {
            this.$$parse(rewrittenUrl);
          }
          return !!rewrittenUrl;
        };
      }
      function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
          var withoutBaseUrl = stripBaseUrl(appBase, url) || stripBaseUrl(appBaseNoFile, url);
          var withoutHashUrl;
          if (!isUndefined(withoutBaseUrl) && withoutBaseUrl.charAt(0) === '#') {
            withoutHashUrl = stripBaseUrl(hashPrefix, withoutBaseUrl);
            if (isUndefined(withoutHashUrl)) {
              withoutHashUrl = withoutBaseUrl;
            }
          } else {
            if (this.$$html5) {
              withoutHashUrl = withoutBaseUrl;
            } else {
              withoutHashUrl = '';
              if (isUndefined(withoutBaseUrl)) {
                appBase = url;
                this.replace();
              }
            }
          }
          parseAppUrl(withoutHashUrl, this);
          this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);
          this.$$compose();
          function removeWindowsDriveName(path, url, base) {
            var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
            var firstPathSegmentMatch;
            if (startsWith(url, base)) {
              url = url.replace(base, '');
            }
            if (windowsFilePathExp.exec(url)) {
              return path;
            }
            firstPathSegmentMatch = windowsFilePathExp.exec(path);
            return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
          }
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : '');
        };
        this.$$parseLinkUrl = function(url, relHref) {
          if (stripHash(appBase) == stripHash(url)) {
            this.$$parse(url);
            return true;
          }
          return false;
        };
      }
      function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
        this.$$html5 = true;
        LocationHashbangUrl.apply(this, arguments);
        this.$$parseLinkUrl = function(url, relHref) {
          if (relHref && relHref[0] === '#') {
            this.hash(relHref.slice(1));
            return true;
          }
          var rewrittenUrl;
          var appUrl;
          if (appBase == stripHash(url)) {
            rewrittenUrl = url;
          } else if ((appUrl = stripBaseUrl(appBaseNoFile, url))) {
            rewrittenUrl = appBase + hashPrefix + appUrl;
          } else if (appBaseNoFile === url + '/') {
            rewrittenUrl = appBaseNoFile;
          }
          if (rewrittenUrl) {
            this.$$parse(rewrittenUrl);
          }
          return !!rewrittenUrl;
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBase + hashPrefix + this.$$url;
        };
      }
      var locationPrototype = {
        $$absUrl: '',
        $$html5: false,
        $$replace: false,
        absUrl: locationGetter('$$absUrl'),
        url: function(url) {
          if (isUndefined(url)) {
            return this.$$url;
          }
          var match = PATH_MATCH.exec(url);
          if (match[1] || url === '')
            this.path(decodeURIComponent(match[1]));
          if (match[2] || match[1] || url === '')
            this.search(match[3] || '');
          this.hash(match[5] || '');
          return this;
        },
        protocol: locationGetter('$$protocol'),
        host: locationGetter('$$host'),
        port: locationGetter('$$port'),
        path: locationGetterSetter('$$path', function(path) {
          path = path !== null ? path.toString() : '';
          return path.charAt(0) == '/' ? path : '/' + path;
        }),
        search: function(search, paramValue) {
          switch (arguments.length) {
            case 0:
              return this.$$search;
            case 1:
              if (isString(search) || isNumber(search)) {
                search = search.toString();
                this.$$search = parseKeyValue(search);
              } else if (isObject(search)) {
                search = copy(search, {});
                forEach(search, function(value, key) {
                  if (value == null)
                    delete search[key];
                });
                this.$$search = search;
              } else {
                throw $locationMinErr('isrcharg', 'The first argument of the `$location#search()` call must be a string or an object.');
              }
              break;
            default:
              if (isUndefined(paramValue) || paramValue === null) {
                delete this.$$search[search];
              } else {
                this.$$search[search] = paramValue;
              }
          }
          this.$$compose();
          return this;
        },
        hash: locationGetterSetter('$$hash', function(hash) {
          return hash !== null ? hash.toString() : '';
        }),
        replace: function() {
          this.$$replace = true;
          return this;
        }
      };
      forEach([LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url], function(Location) {
        Location.prototype = Object.create(locationPrototype);
        Location.prototype.state = function(state) {
          if (!arguments.length) {
            return this.$$state;
          }
          if (Location !== LocationHtml5Url || !this.$$html5) {
            throw $locationMinErr('nostate', 'History API state support is available only ' + 'in HTML5 mode and only in browsers supporting HTML5 History API');
          }
          this.$$state = isUndefined(state) ? null : state;
          return this;
        };
      });
      function locationGetter(property) {
        return function() {
          return this[property];
        };
      }
      function locationGetterSetter(property, preprocess) {
        return function(value) {
          if (isUndefined(value)) {
            return this[property];
          }
          this[property] = preprocess(value);
          this.$$compose();
          return this;
        };
      }
      function $LocationProvider() {
        var hashPrefix = '',
            html5Mode = {
              enabled: false,
              requireBase: true,
              rewriteLinks: true
            };
        this.hashPrefix = function(prefix) {
          if (isDefined(prefix)) {
            hashPrefix = prefix;
            return this;
          } else {
            return hashPrefix;
          }
        };
        this.html5Mode = function(mode) {
          if (isBoolean(mode)) {
            html5Mode.enabled = mode;
            return this;
          } else if (isObject(mode)) {
            if (isBoolean(mode.enabled)) {
              html5Mode.enabled = mode.enabled;
            }
            if (isBoolean(mode.requireBase)) {
              html5Mode.requireBase = mode.requireBase;
            }
            if (isBoolean(mode.rewriteLinks)) {
              html5Mode.rewriteLinks = mode.rewriteLinks;
            }
            return this;
          } else {
            return html5Mode;
          }
        };
        this.$get = ['$rootScope', '$browser', '$sniffer', '$rootElement', '$window', function($rootScope, $browser, $sniffer, $rootElement, $window) {
          var $location,
              LocationMode,
              baseHref = $browser.baseHref(),
              initialUrl = $browser.url(),
              appBase;
          if (html5Mode.enabled) {
            if (!baseHref && html5Mode.requireBase) {
              throw $locationMinErr('nobase', "$location in HTML5 mode requires a <base> tag to be present!");
            }
            appBase = serverBase(initialUrl) + (baseHref || '/');
            LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
          } else {
            appBase = stripHash(initialUrl);
            LocationMode = LocationHashbangUrl;
          }
          var appBaseNoFile = stripFile(appBase);
          $location = new LocationMode(appBase, appBaseNoFile, '#' + hashPrefix);
          $location.$$parseLinkUrl(initialUrl, initialUrl);
          $location.$$state = $browser.state();
          var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
          function setBrowserUrlWithFallback(url, replace, state) {
            var oldUrl = $location.url();
            var oldState = $location.$$state;
            try {
              $browser.url(url, replace, state);
              $location.$$state = $browser.state();
            } catch (e) {
              $location.url(oldUrl);
              $location.$$state = oldState;
              throw e;
            }
          }
          $rootElement.on('click', function(event) {
            if (!html5Mode.rewriteLinks || event.ctrlKey || event.metaKey || event.shiftKey || event.which == 2 || event.button == 2)
              return;
            var elm = jqLite(event.target);
            while (nodeName_(elm[0]) !== 'a') {
              if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0])
                return;
            }
            var absHref = elm.prop('href');
            var relHref = elm.attr('href') || elm.attr('xlink:href');
            if (isObject(absHref) && absHref.toString() === '[object SVGAnimatedString]') {
              absHref = urlResolve(absHref.animVal).href;
            }
            if (IGNORE_URI_REGEXP.test(absHref))
              return;
            if (absHref && !elm.attr('target') && !event.isDefaultPrevented()) {
              if ($location.$$parseLinkUrl(absHref, relHref)) {
                event.preventDefault();
                if ($location.absUrl() != $browser.url()) {
                  $rootScope.$apply();
                  $window.angular['ff-684208-preventDefault'] = true;
                }
              }
            }
          });
          if (trimEmptyHash($location.absUrl()) != trimEmptyHash(initialUrl)) {
            $browser.url($location.absUrl(), true);
          }
          var initializing = true;
          $browser.onUrlChange(function(newUrl, newState) {
            if (isUndefined(stripBaseUrl(appBaseNoFile, newUrl))) {
              $window.location.href = newUrl;
              return;
            }
            $rootScope.$evalAsync(function() {
              var oldUrl = $location.absUrl();
              var oldState = $location.$$state;
              var defaultPrevented;
              newUrl = trimEmptyHash(newUrl);
              $location.$$parse(newUrl);
              $location.$$state = newState;
              defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, newState, oldState).defaultPrevented;
              if ($location.absUrl() !== newUrl)
                return;
              if (defaultPrevented) {
                $location.$$parse(oldUrl);
                $location.$$state = oldState;
                setBrowserUrlWithFallback(oldUrl, false, oldState);
              } else {
                initializing = false;
                afterLocationChange(oldUrl, oldState);
              }
            });
            if (!$rootScope.$$phase)
              $rootScope.$digest();
          });
          $rootScope.$watch(function $locationWatch() {
            var oldUrl = trimEmptyHash($browser.url());
            var newUrl = trimEmptyHash($location.absUrl());
            var oldState = $browser.state();
            var currentReplace = $location.$$replace;
            var urlOrStateChanged = oldUrl !== newUrl || ($location.$$html5 && $sniffer.history && oldState !== $location.$$state);
            if (initializing || urlOrStateChanged) {
              initializing = false;
              $rootScope.$evalAsync(function() {
                var newUrl = $location.absUrl();
                var defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                if ($location.absUrl() !== newUrl)
                  return;
                if (defaultPrevented) {
                  $location.$$parse(oldUrl);
                  $location.$$state = oldState;
                } else {
                  if (urlOrStateChanged) {
                    setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state);
                  }
                  afterLocationChange(oldUrl, oldState);
                }
              });
            }
            $location.$$replace = false;
          });
          return $location;
          function afterLocationChange(oldUrl, oldState) {
            $rootScope.$broadcast('$locationChangeSuccess', $location.absUrl(), oldUrl, $location.$$state, oldState);
          }
        }];
      }
      function $LogProvider() {
        var debug = true,
            self = this;
        this.debugEnabled = function(flag) {
          if (isDefined(flag)) {
            debug = flag;
            return this;
          } else {
            return debug;
          }
        };
        this.$get = ['$window', function($window) {
          return {
            log: consoleLog('log'),
            info: consoleLog('info'),
            warn: consoleLog('warn'),
            error: consoleLog('error'),
            debug: (function() {
              var fn = consoleLog('debug');
              return function() {
                if (debug) {
                  fn.apply(self, arguments);
                }
              };
            }())
          };
          function formatError(arg) {
            if (arg instanceof Error) {
              if (arg.stack) {
                arg = (arg.message && arg.stack.indexOf(arg.message) === -1) ? 'Error: ' + arg.message + '\n' + arg.stack : arg.stack;
              } else if (arg.sourceURL) {
                arg = arg.message + '\n' + arg.sourceURL + ':' + arg.line;
              }
            }
            return arg;
          }
          function consoleLog(type) {
            var console = $window.console || {},
                logFn = console[type] || console.log || noop,
                hasApply = false;
            try {
              hasApply = !!logFn.apply;
            } catch (e) {}
            if (hasApply) {
              return function() {
                var args = [];
                forEach(arguments, function(arg) {
                  args.push(formatError(arg));
                });
                return logFn.apply(console, args);
              };
            }
            return function(arg1, arg2) {
              logFn(arg1, arg2 == null ? '' : arg2);
            };
          }
        }];
      }
      var $parseMinErr = minErr('$parse');
      function ensureSafeMemberName(name, fullExpression) {
        if (name === "__defineGetter__" || name === "__defineSetter__" || name === "__lookupGetter__" || name === "__lookupSetter__" || name === "__proto__") {
          throw $parseMinErr('isecfld', 'Attempting to access a disallowed field in Angular expressions! ' + 'Expression: {0}', fullExpression);
        }
        return name;
      }
      function getStringValue(name) {
        return name + '';
      }
      function ensureSafeObject(obj, fullExpression) {
        if (obj) {
          if (obj.constructor === obj) {
            throw $parseMinErr('isecfn', 'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj.window === obj) {
            throw $parseMinErr('isecwindow', 'Referencing the Window in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj.children && (obj.nodeName || (obj.prop && obj.attr && obj.find))) {
            throw $parseMinErr('isecdom', 'Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj === Object) {
            throw $parseMinErr('isecobj', 'Referencing Object in Angular expressions is disallowed! Expression: {0}', fullExpression);
          }
        }
        return obj;
      }
      var CALL = Function.prototype.call;
      var APPLY = Function.prototype.apply;
      var BIND = Function.prototype.bind;
      function ensureSafeFunction(obj, fullExpression) {
        if (obj) {
          if (obj.constructor === obj) {
            throw $parseMinErr('isecfn', 'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj === CALL || obj === APPLY || obj === BIND) {
            throw $parseMinErr('isecff', 'Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}', fullExpression);
          }
        }
      }
      function ensureSafeAssignContext(obj, fullExpression) {
        if (obj) {
          if (obj === (0).constructor || obj === (false).constructor || obj === ''.constructor || obj === {}.constructor || obj === [].constructor || obj === Function.constructor) {
            throw $parseMinErr('isecaf', 'Assigning to a constructor is disallowed! Expression: {0}', fullExpression);
          }
        }
      }
      var OPERATORS = createMap();
      forEach('+ - * / % === !== == != < > <= >= && || ! = |'.split(' '), function(operator) {
        OPERATORS[operator] = true;
      });
      var ESCAPE = {
        "n": "\n",
        "f": "\f",
        "r": "\r",
        "t": "\t",
        "v": "\v",
        "'": "'",
        '"': '"'
      };
      var Lexer = function(options) {
        this.options = options;
      };
      Lexer.prototype = {
        constructor: Lexer,
        lex: function(text) {
          this.text = text;
          this.index = 0;
          this.tokens = [];
          while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            if (ch === '"' || ch === "'") {
              this.readString(ch);
            } else if (this.isNumber(ch) || ch === '.' && this.isNumber(this.peek())) {
              this.readNumber();
            } else if (this.isIdentifierStart(this.peekMultichar())) {
              this.readIdent();
            } else if (this.is(ch, '(){}[].,;:?')) {
              this.tokens.push({
                index: this.index,
                text: ch
              });
              this.index++;
            } else if (this.isWhitespace(ch)) {
              this.index++;
            } else {
              var ch2 = ch + this.peek();
              var ch3 = ch2 + this.peek(2);
              var op1 = OPERATORS[ch];
              var op2 = OPERATORS[ch2];
              var op3 = OPERATORS[ch3];
              if (op1 || op2 || op3) {
                var token = op3 ? ch3 : (op2 ? ch2 : ch);
                this.tokens.push({
                  index: this.index,
                  text: token,
                  operator: true
                });
                this.index += token.length;
              } else {
                this.throwError('Unexpected next character ', this.index, this.index + 1);
              }
            }
          }
          return this.tokens;
        },
        is: function(ch, chars) {
          return chars.indexOf(ch) !== -1;
        },
        peek: function(i) {
          var num = i || 1;
          return (this.index + num < this.text.length) ? this.text.charAt(this.index + num) : false;
        },
        isNumber: function(ch) {
          return ('0' <= ch && ch <= '9') && typeof ch === "string";
        },
        isWhitespace: function(ch) {
          return (ch === ' ' || ch === '\r' || ch === '\t' || ch === '\n' || ch === '\v' || ch === '\u00A0');
        },
        isIdentifierStart: function(ch) {
          return this.options.isIdentifierStart ? this.options.isIdentifierStart(ch, this.codePointAt(ch)) : this.isValidIdentifierStart(ch);
        },
        isValidIdentifierStart: function(ch) {
          return ('a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || '_' === ch || ch === '$');
        },
        isIdentifierContinue: function(ch) {
          return this.options.isIdentifierContinue ? this.options.isIdentifierContinue(ch, this.codePointAt(ch)) : this.isValidIdentifierContinue(ch);
        },
        isValidIdentifierContinue: function(ch, cp) {
          return this.isValidIdentifierStart(ch, cp) || this.isNumber(ch);
        },
        codePointAt: function(ch) {
          if (ch.length === 1)
            return ch.charCodeAt(0);
          return (ch.charCodeAt(0) << 10) + ch.charCodeAt(1) - 0x35FDC00;
        },
        peekMultichar: function() {
          var ch = this.text.charAt(this.index);
          var peek = this.peek();
          if (!peek) {
            return ch;
          }
          var cp1 = ch.charCodeAt(0);
          var cp2 = peek.charCodeAt(0);
          if (cp1 >= 0xD800 && cp1 <= 0xDBFF && cp2 >= 0xDC00 && cp2 <= 0xDFFF) {
            return ch + peek;
          }
          return ch;
        },
        isExpOperator: function(ch) {
          return (ch === '-' || ch === '+' || this.isNumber(ch));
        },
        throwError: function(error, start, end) {
          end = end || this.index;
          var colStr = (isDefined(start) ? 's ' + start + '-' + this.index + ' [' + this.text.substring(start, end) + ']' : ' ' + end);
          throw $parseMinErr('lexerr', 'Lexer Error: {0} at column{1} in expression [{2}].', error, colStr, this.text);
        },
        readNumber: function() {
          var number = '';
          var start = this.index;
          while (this.index < this.text.length) {
            var ch = lowercase(this.text.charAt(this.index));
            if (ch == '.' || this.isNumber(ch)) {
              number += ch;
            } else {
              var peekCh = this.peek();
              if (ch == 'e' && this.isExpOperator(peekCh)) {
                number += ch;
              } else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && number.charAt(number.length - 1) == 'e') {
                number += ch;
              } else if (this.isExpOperator(ch) && (!peekCh || !this.isNumber(peekCh)) && number.charAt(number.length - 1) == 'e') {
                this.throwError('Invalid exponent');
              } else {
                break;
              }
            }
            this.index++;
          }
          this.tokens.push({
            index: start,
            text: number,
            constant: true,
            value: Number(number)
          });
        },
        readIdent: function() {
          var start = this.index;
          this.index += this.peekMultichar().length;
          while (this.index < this.text.length) {
            var ch = this.peekMultichar();
            if (!this.isIdentifierContinue(ch)) {
              break;
            }
            this.index += ch.length;
          }
          this.tokens.push({
            index: start,
            text: this.text.slice(start, this.index),
            identifier: true
          });
        },
        readString: function(quote) {
          var start = this.index;
          this.index++;
          var string = '';
          var rawString = quote;
          var escape = false;
          while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            rawString += ch;
            if (escape) {
              if (ch === 'u') {
                var hex = this.text.substring(this.index + 1, this.index + 5);
                if (!hex.match(/[\da-f]{4}/i)) {
                  this.throwError('Invalid unicode escape [\\u' + hex + ']');
                }
                this.index += 4;
                string += String.fromCharCode(parseInt(hex, 16));
              } else {
                var rep = ESCAPE[ch];
                string = string + (rep || ch);
              }
              escape = false;
            } else if (ch === '\\') {
              escape = true;
            } else if (ch === quote) {
              this.index++;
              this.tokens.push({
                index: start,
                text: rawString,
                constant: true,
                value: string
              });
              return;
            } else {
              string += ch;
            }
            this.index++;
          }
          this.throwError('Unterminated quote', start);
        }
      };
      var AST = function(lexer, options) {
        this.lexer = lexer;
        this.options = options;
      };
      AST.Program = 'Program';
      AST.ExpressionStatement = 'ExpressionStatement';
      AST.AssignmentExpression = 'AssignmentExpression';
      AST.ConditionalExpression = 'ConditionalExpression';
      AST.LogicalExpression = 'LogicalExpression';
      AST.BinaryExpression = 'BinaryExpression';
      AST.UnaryExpression = 'UnaryExpression';
      AST.CallExpression = 'CallExpression';
      AST.MemberExpression = 'MemberExpression';
      AST.Identifier = 'Identifier';
      AST.Literal = 'Literal';
      AST.ArrayExpression = 'ArrayExpression';
      AST.Property = 'Property';
      AST.ObjectExpression = 'ObjectExpression';
      AST.ThisExpression = 'ThisExpression';
      AST.LocalsExpression = 'LocalsExpression';
      AST.NGValueParameter = 'NGValueParameter';
      AST.prototype = {
        ast: function(text) {
          this.text = text;
          this.tokens = this.lexer.lex(text);
          var value = this.program();
          if (this.tokens.length !== 0) {
            this.throwError('is an unexpected token', this.tokens[0]);
          }
          return value;
        },
        program: function() {
          var body = [];
          while (true) {
            if (this.tokens.length > 0 && !this.peek('}', ')', ';', ']'))
              body.push(this.expressionStatement());
            if (!this.expect(';')) {
              return {
                type: AST.Program,
                body: body
              };
            }
          }
        },
        expressionStatement: function() {
          return {
            type: AST.ExpressionStatement,
            expression: this.filterChain()
          };
        },
        filterChain: function() {
          var left = this.expression();
          var token;
          while ((token = this.expect('|'))) {
            left = this.filter(left);
          }
          return left;
        },
        expression: function() {
          return this.assignment();
        },
        assignment: function() {
          var result = this.ternary();
          if (this.expect('=')) {
            result = {
              type: AST.AssignmentExpression,
              left: result,
              right: this.assignment(),
              operator: '='
            };
          }
          return result;
        },
        ternary: function() {
          var test = this.logicalOR();
          var alternate;
          var consequent;
          if (this.expect('?')) {
            alternate = this.expression();
            if (this.consume(':')) {
              consequent = this.expression();
              return {
                type: AST.ConditionalExpression,
                test: test,
                alternate: alternate,
                consequent: consequent
              };
            }
          }
          return test;
        },
        logicalOR: function() {
          var left = this.logicalAND();
          while (this.expect('||')) {
            left = {
              type: AST.LogicalExpression,
              operator: '||',
              left: left,
              right: this.logicalAND()
            };
          }
          return left;
        },
        logicalAND: function() {
          var left = this.equality();
          while (this.expect('&&')) {
            left = {
              type: AST.LogicalExpression,
              operator: '&&',
              left: left,
              right: this.equality()
            };
          }
          return left;
        },
        equality: function() {
          var left = this.relational();
          var token;
          while ((token = this.expect('==', '!=', '===', '!=='))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.relational()
            };
          }
          return left;
        },
        relational: function() {
          var left = this.additive();
          var token;
          while ((token = this.expect('<', '>', '<=', '>='))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.additive()
            };
          }
          return left;
        },
        additive: function() {
          var left = this.multiplicative();
          var token;
          while ((token = this.expect('+', '-'))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.multiplicative()
            };
          }
          return left;
        },
        multiplicative: function() {
          var left = this.unary();
          var token;
          while ((token = this.expect('*', '/', '%'))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.unary()
            };
          }
          return left;
        },
        unary: function() {
          var token;
          if ((token = this.expect('+', '-', '!'))) {
            return {
              type: AST.UnaryExpression,
              operator: token.text,
              prefix: true,
              argument: this.unary()
            };
          } else {
            return this.primary();
          }
        },
        primary: function() {
          var primary;
          if (this.expect('(')) {
            primary = this.filterChain();
            this.consume(')');
          } else if (this.expect('[')) {
            primary = this.arrayDeclaration();
          } else if (this.expect('{')) {
            primary = this.object();
          } else if (this.selfReferential.hasOwnProperty(this.peek().text)) {
            primary = copy(this.selfReferential[this.consume().text]);
          } else if (this.options.literals.hasOwnProperty(this.peek().text)) {
            primary = {
              type: AST.Literal,
              value: this.options.literals[this.consume().text]
            };
          } else if (this.peek().identifier) {
            primary = this.identifier();
          } else if (this.peek().constant) {
            primary = this.constant();
          } else {
            this.throwError('not a primary expression', this.peek());
          }
          var next;
          while ((next = this.expect('(', '[', '.'))) {
            if (next.text === '(') {
              primary = {
                type: AST.CallExpression,
                callee: primary,
                arguments: this.parseArguments()
              };
              this.consume(')');
            } else if (next.text === '[') {
              primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.expression(),
                computed: true
              };
              this.consume(']');
            } else if (next.text === '.') {
              primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.identifier(),
                computed: false
              };
            } else {
              this.throwError('IMPOSSIBLE');
            }
          }
          return primary;
        },
        filter: function(baseExpression) {
          var args = [baseExpression];
          var result = {
            type: AST.CallExpression,
            callee: this.identifier(),
            arguments: args,
            filter: true
          };
          while (this.expect(':')) {
            args.push(this.expression());
          }
          return result;
        },
        parseArguments: function() {
          var args = [];
          if (this.peekToken().text !== ')') {
            do {
              args.push(this.filterChain());
            } while (this.expect(','));
          }
          return args;
        },
        identifier: function() {
          var token = this.consume();
          if (!token.identifier) {
            this.throwError('is not a valid identifier', token);
          }
          return {
            type: AST.Identifier,
            name: token.text
          };
        },
        constant: function() {
          return {
            type: AST.Literal,
            value: this.consume().value
          };
        },
        arrayDeclaration: function() {
          var elements = [];
          if (this.peekToken().text !== ']') {
            do {
              if (this.peek(']')) {
                break;
              }
              elements.push(this.expression());
            } while (this.expect(','));
          }
          this.consume(']');
          return {
            type: AST.ArrayExpression,
            elements: elements
          };
        },
        object: function() {
          var properties = [],
              property;
          if (this.peekToken().text !== '}') {
            do {
              if (this.peek('}')) {
                break;
              }
              property = {
                type: AST.Property,
                kind: 'init'
              };
              if (this.peek().constant) {
                property.key = this.constant();
                property.computed = false;
                this.consume(':');
                property.value = this.expression();
              } else if (this.peek().identifier) {
                property.key = this.identifier();
                property.computed = false;
                if (this.peek(':')) {
                  this.consume(':');
                  property.value = this.expression();
                } else {
                  property.value = property.key;
                }
              } else if (this.peek('[')) {
                this.consume('[');
                property.key = this.expression();
                this.consume(']');
                property.computed = true;
                this.consume(':');
                property.value = this.expression();
              } else {
                this.throwError("invalid key", this.peek());
              }
              properties.push(property);
            } while (this.expect(','));
          }
          this.consume('}');
          return {
            type: AST.ObjectExpression,
            properties: properties
          };
        },
        throwError: function(msg, token) {
          throw $parseMinErr('syntax', 'Syntax Error: Token \'{0}\' {1} at column {2} of the expression [{3}] starting at [{4}].', token.text, msg, (token.index + 1), this.text, this.text.substring(token.index));
        },
        consume: function(e1) {
          if (this.tokens.length === 0) {
            throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
          }
          var token = this.expect(e1);
          if (!token) {
            this.throwError('is unexpected, expecting [' + e1 + ']', this.peek());
          }
          return token;
        },
        peekToken: function() {
          if (this.tokens.length === 0) {
            throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
          }
          return this.tokens[0];
        },
        peek: function(e1, e2, e3, e4) {
          return this.peekAhead(0, e1, e2, e3, e4);
        },
        peekAhead: function(i, e1, e2, e3, e4) {
          if (this.tokens.length > i) {
            var token = this.tokens[i];
            var t = token.text;
            if (t === e1 || t === e2 || t === e3 || t === e4 || (!e1 && !e2 && !e3 && !e4)) {
              return token;
            }
          }
          return false;
        },
        expect: function(e1, e2, e3, e4) {
          var token = this.peek(e1, e2, e3, e4);
          if (token) {
            this.tokens.shift();
            return token;
          }
          return false;
        },
        selfReferential: {
          'this': {type: AST.ThisExpression},
          '$locals': {type: AST.LocalsExpression}
        }
      };
      function ifDefined(v, d) {
        return typeof v !== 'undefined' ? v : d;
      }
      function plusFn(l, r) {
        if (typeof l === 'undefined')
          return r;
        if (typeof r === 'undefined')
          return l;
        return l + r;
      }
      function isStateless($filter, filterName) {
        var fn = $filter(filterName);
        return !fn.$stateful;
      }
      function findConstantAndWatchExpressions(ast, $filter) {
        var allConstants;
        var argsToWatch;
        switch (ast.type) {
          case AST.Program:
            allConstants = true;
            forEach(ast.body, function(expr) {
              findConstantAndWatchExpressions(expr.expression, $filter);
              allConstants = allConstants && expr.expression.constant;
            });
            ast.constant = allConstants;
            break;
          case AST.Literal:
            ast.constant = true;
            ast.toWatch = [];
            break;
          case AST.UnaryExpression:
            findConstantAndWatchExpressions(ast.argument, $filter);
            ast.constant = ast.argument.constant;
            ast.toWatch = ast.argument.toWatch;
            break;
          case AST.BinaryExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
            break;
          case AST.LogicalExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = ast.constant ? [] : [ast];
            break;
          case AST.ConditionalExpression:
            findConstantAndWatchExpressions(ast.test, $filter);
            findConstantAndWatchExpressions(ast.alternate, $filter);
            findConstantAndWatchExpressions(ast.consequent, $filter);
            ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant;
            ast.toWatch = ast.constant ? [] : [ast];
            break;
          case AST.Identifier:
            ast.constant = false;
            ast.toWatch = [ast];
            break;
          case AST.MemberExpression:
            findConstantAndWatchExpressions(ast.object, $filter);
            if (ast.computed) {
              findConstantAndWatchExpressions(ast.property, $filter);
            }
            ast.constant = ast.object.constant && (!ast.computed || ast.property.constant);
            ast.toWatch = [ast];
            break;
          case AST.CallExpression:
            allConstants = ast.filter ? isStateless($filter, ast.callee.name) : false;
            argsToWatch = [];
            forEach(ast.arguments, function(expr) {
              findConstantAndWatchExpressions(expr, $filter);
              allConstants = allConstants && expr.constant;
              if (!expr.constant) {
                argsToWatch.push.apply(argsToWatch, expr.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = ast.filter && isStateless($filter, ast.callee.name) ? argsToWatch : [ast];
            break;
          case AST.AssignmentExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = [ast];
            break;
          case AST.ArrayExpression:
            allConstants = true;
            argsToWatch = [];
            forEach(ast.elements, function(expr) {
              findConstantAndWatchExpressions(expr, $filter);
              allConstants = allConstants && expr.constant;
              if (!expr.constant) {
                argsToWatch.push.apply(argsToWatch, expr.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = argsToWatch;
            break;
          case AST.ObjectExpression:
            allConstants = true;
            argsToWatch = [];
            forEach(ast.properties, function(property) {
              findConstantAndWatchExpressions(property.value, $filter);
              allConstants = allConstants && property.value.constant && !property.computed;
              if (!property.value.constant) {
                argsToWatch.push.apply(argsToWatch, property.value.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = argsToWatch;
            break;
          case AST.ThisExpression:
            ast.constant = false;
            ast.toWatch = [];
            break;
          case AST.LocalsExpression:
            ast.constant = false;
            ast.toWatch = [];
            break;
        }
      }
      function getInputs(body) {
        if (body.length != 1)
          return;
        var lastExpression = body[0].expression;
        var candidate = lastExpression.toWatch;
        if (candidate.length !== 1)
          return candidate;
        return candidate[0] !== lastExpression ? candidate : undefined;
      }
      function isAssignable(ast) {
        return ast.type === AST.Identifier || ast.type === AST.MemberExpression;
      }
      function assignableAST(ast) {
        if (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {
          return {
            type: AST.AssignmentExpression,
            left: ast.body[0].expression,
            right: {type: AST.NGValueParameter},
            operator: '='
          };
        }
      }
      function isLiteral(ast) {
        return ast.body.length === 0 || ast.body.length === 1 && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression);
      }
      function isConstant(ast) {
        return ast.constant;
      }
      function ASTCompiler(astBuilder, $filter) {
        this.astBuilder = astBuilder;
        this.$filter = $filter;
      }
      ASTCompiler.prototype = {
        compile: function(expression, expensiveChecks) {
          var self = this;
          var ast = this.astBuilder.ast(expression);
          this.state = {
            nextId: 0,
            filters: {},
            expensiveChecks: expensiveChecks,
            fn: {
              vars: [],
              body: [],
              own: {}
            },
            assign: {
              vars: [],
              body: [],
              own: {}
            },
            inputs: []
          };
          findConstantAndWatchExpressions(ast, self.$filter);
          var extra = '';
          var assignable;
          this.stage = 'assign';
          if ((assignable = assignableAST(ast))) {
            this.state.computing = 'assign';
            var result = this.nextId();
            this.recurse(assignable, result);
            this.return_(result);
            extra = 'fn.assign=' + this.generateFunction('assign', 's,v,l');
          }
          var toWatch = getInputs(ast.body);
          self.stage = 'inputs';
          forEach(toWatch, function(watch, key) {
            var fnKey = 'fn' + key;
            self.state[fnKey] = {
              vars: [],
              body: [],
              own: {}
            };
            self.state.computing = fnKey;
            var intoId = self.nextId();
            self.recurse(watch, intoId);
            self.return_(intoId);
            self.state.inputs.push(fnKey);
            watch.watchId = key;
          });
          this.state.computing = 'fn';
          this.stage = 'main';
          this.recurse(ast);
          var fnString = '"' + this.USE + ' ' + this.STRICT + '";\n' + this.filterPrefix() + 'var fn=' + this.generateFunction('fn', 's,l,a,i') + extra + this.watchFns() + 'return fn;';
          var fn = (new Function('$filter', 'ensureSafeMemberName', 'ensureSafeObject', 'ensureSafeFunction', 'getStringValue', 'ensureSafeAssignContext', 'ifDefined', 'plus', 'text', fnString))(this.$filter, ensureSafeMemberName, ensureSafeObject, ensureSafeFunction, getStringValue, ensureSafeAssignContext, ifDefined, plusFn, expression);
          this.state = this.stage = undefined;
          fn.literal = isLiteral(ast);
          fn.constant = isConstant(ast);
          return fn;
        },
        USE: 'use',
        STRICT: 'strict',
        watchFns: function() {
          var result = [];
          var fns = this.state.inputs;
          var self = this;
          forEach(fns, function(name) {
            result.push('var ' + name + '=' + self.generateFunction(name, 's'));
          });
          if (fns.length) {
            result.push('fn.inputs=[' + fns.join(',') + '];');
          }
          return result.join('');
        },
        generateFunction: function(name, params) {
          return 'function(' + params + '){' + this.varsPrefix(name) + this.body(name) + '};';
        },
        filterPrefix: function() {
          var parts = [];
          var self = this;
          forEach(this.state.filters, function(id, filter) {
            parts.push(id + '=$filter(' + self.escape(filter) + ')');
          });
          if (parts.length)
            return 'var ' + parts.join(',') + ';';
          return '';
        },
        varsPrefix: function(section) {
          return this.state[section].vars.length ? 'var ' + this.state[section].vars.join(',') + ';' : '';
        },
        body: function(section) {
          return this.state[section].body.join('');
        },
        recurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
          var left,
              right,
              self = this,
              args,
              expression,
              computed;
          recursionFn = recursionFn || noop;
          if (!skipWatchIdCheck && isDefined(ast.watchId)) {
            intoId = intoId || this.nextId();
            this.if_('i', this.lazyAssign(intoId, this.computedMember('i', ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, true));
            return;
          }
          switch (ast.type) {
            case AST.Program:
              forEach(ast.body, function(expression, pos) {
                self.recurse(expression.expression, undefined, undefined, function(expr) {
                  right = expr;
                });
                if (pos !== ast.body.length - 1) {
                  self.current().body.push(right, ';');
                } else {
                  self.return_(right);
                }
              });
              break;
            case AST.Literal:
              expression = this.escape(ast.value);
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.UnaryExpression:
              this.recurse(ast.argument, undefined, undefined, function(expr) {
                right = expr;
              });
              expression = ast.operator + '(' + this.ifDefined(right, 0) + ')';
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.BinaryExpression:
              this.recurse(ast.left, undefined, undefined, function(expr) {
                left = expr;
              });
              this.recurse(ast.right, undefined, undefined, function(expr) {
                right = expr;
              });
              if (ast.operator === '+') {
                expression = this.plus(left, right);
              } else if (ast.operator === '-') {
                expression = this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);
              } else {
                expression = '(' + left + ')' + ast.operator + '(' + right + ')';
              }
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.LogicalExpression:
              intoId = intoId || this.nextId();
              self.recurse(ast.left, intoId);
              self.if_(ast.operator === '&&' ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId));
              recursionFn(intoId);
              break;
            case AST.ConditionalExpression:
              intoId = intoId || this.nextId();
              self.recurse(ast.test, intoId);
              self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId));
              recursionFn(intoId);
              break;
            case AST.Identifier:
              intoId = intoId || this.nextId();
              if (nameId) {
                nameId.context = self.stage === 'inputs' ? 's' : this.assign(this.nextId(), this.getHasOwnProperty('l', ast.name) + '?l:s');
                nameId.computed = false;
                nameId.name = ast.name;
              }
              ensureSafeMemberName(ast.name);
              self.if_(self.stage === 'inputs' || self.not(self.getHasOwnProperty('l', ast.name)), function() {
                self.if_(self.stage === 'inputs' || 's', function() {
                  if (create && create !== 1) {
                    self.if_(self.not(self.nonComputedMember('s', ast.name)), self.lazyAssign(self.nonComputedMember('s', ast.name), '{}'));
                  }
                  self.assign(intoId, self.nonComputedMember('s', ast.name));
                });
              }, intoId && self.lazyAssign(intoId, self.nonComputedMember('l', ast.name)));
              if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.name)) {
                self.addEnsureSafeObject(intoId);
              }
              recursionFn(intoId);
              break;
            case AST.MemberExpression:
              left = nameId && (nameId.context = this.nextId()) || this.nextId();
              intoId = intoId || this.nextId();
              self.recurse(ast.object, left, undefined, function() {
                self.if_(self.notNull(left), function() {
                  if (create && create !== 1) {
                    self.addEnsureSafeAssignContext(left);
                  }
                  if (ast.computed) {
                    right = self.nextId();
                    self.recurse(ast.property, right);
                    self.getStringValue(right);
                    self.addEnsureSafeMemberName(right);
                    if (create && create !== 1) {
                      self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), '{}'));
                    }
                    expression = self.ensureSafeObject(self.computedMember(left, right));
                    self.assign(intoId, expression);
                    if (nameId) {
                      nameId.computed = true;
                      nameId.name = right;
                    }
                  } else {
                    ensureSafeMemberName(ast.property.name);
                    if (create && create !== 1) {
                      self.if_(self.not(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), '{}'));
                    }
                    expression = self.nonComputedMember(left, ast.property.name);
                    if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.property.name)) {
                      expression = self.ensureSafeObject(expression);
                    }
                    self.assign(intoId, expression);
                    if (nameId) {
                      nameId.computed = false;
                      nameId.name = ast.property.name;
                    }
                  }
                }, function() {
                  self.assign(intoId, 'undefined');
                });
                recursionFn(intoId);
              }, !!create);
              break;
            case AST.CallExpression:
              intoId = intoId || this.nextId();
              if (ast.filter) {
                right = self.filter(ast.callee.name);
                args = [];
                forEach(ast.arguments, function(expr) {
                  var argument = self.nextId();
                  self.recurse(expr, argument);
                  args.push(argument);
                });
                expression = right + '(' + args.join(',') + ')';
                self.assign(intoId, expression);
                recursionFn(intoId);
              } else {
                right = self.nextId();
                left = {};
                args = [];
                self.recurse(ast.callee, right, left, function() {
                  self.if_(self.notNull(right), function() {
                    self.addEnsureSafeFunction(right);
                    forEach(ast.arguments, function(expr) {
                      self.recurse(expr, self.nextId(), undefined, function(argument) {
                        args.push(self.ensureSafeObject(argument));
                      });
                    });
                    if (left.name) {
                      if (!self.state.expensiveChecks) {
                        self.addEnsureSafeObject(left.context);
                      }
                      expression = self.member(left.context, left.name, left.computed) + '(' + args.join(',') + ')';
                    } else {
                      expression = right + '(' + args.join(',') + ')';
                    }
                    expression = self.ensureSafeObject(expression);
                    self.assign(intoId, expression);
                  }, function() {
                    self.assign(intoId, 'undefined');
                  });
                  recursionFn(intoId);
                });
              }
              break;
            case AST.AssignmentExpression:
              right = this.nextId();
              left = {};
              if (!isAssignable(ast.left)) {
                throw $parseMinErr('lval', 'Trying to assign a value to a non l-value');
              }
              this.recurse(ast.left, undefined, left, function() {
                self.if_(self.notNull(left.context), function() {
                  self.recurse(ast.right, right);
                  self.addEnsureSafeObject(self.member(left.context, left.name, left.computed));
                  self.addEnsureSafeAssignContext(left.context);
                  expression = self.member(left.context, left.name, left.computed) + ast.operator + right;
                  self.assign(intoId, expression);
                  recursionFn(intoId || expression);
                });
              }, 1);
              break;
            case AST.ArrayExpression:
              args = [];
              forEach(ast.elements, function(expr) {
                self.recurse(expr, self.nextId(), undefined, function(argument) {
                  args.push(argument);
                });
              });
              expression = '[' + args.join(',') + ']';
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.ObjectExpression:
              args = [];
              computed = false;
              forEach(ast.properties, function(property) {
                if (property.computed) {
                  computed = true;
                }
              });
              if (computed) {
                intoId = intoId || this.nextId();
                this.assign(intoId, '{}');
                forEach(ast.properties, function(property) {
                  if (property.computed) {
                    left = self.nextId();
                    self.recurse(property.key, left);
                  } else {
                    left = property.key.type === AST.Identifier ? property.key.name : ('' + property.key.value);
                  }
                  right = self.nextId();
                  self.recurse(property.value, right);
                  self.assign(self.member(intoId, left, property.computed), right);
                });
              } else {
                forEach(ast.properties, function(property) {
                  self.recurse(property.value, ast.constant ? undefined : self.nextId(), undefined, function(expr) {
                    args.push(self.escape(property.key.type === AST.Identifier ? property.key.name : ('' + property.key.value)) + ':' + expr);
                  });
                });
                expression = '{' + args.join(',') + '}';
                this.assign(intoId, expression);
              }
              recursionFn(intoId || expression);
              break;
            case AST.ThisExpression:
              this.assign(intoId, 's');
              recursionFn('s');
              break;
            case AST.LocalsExpression:
              this.assign(intoId, 'l');
              recursionFn('l');
              break;
            case AST.NGValueParameter:
              this.assign(intoId, 'v');
              recursionFn('v');
              break;
          }
        },
        getHasOwnProperty: function(element, property) {
          var key = element + '.' + property;
          var own = this.current().own;
          if (!own.hasOwnProperty(key)) {
            own[key] = this.nextId(false, element + '&&(' + this.escape(property) + ' in ' + element + ')');
          }
          return own[key];
        },
        assign: function(id, value) {
          if (!id)
            return;
          this.current().body.push(id, '=', value, ';');
          return id;
        },
        filter: function(filterName) {
          if (!this.state.filters.hasOwnProperty(filterName)) {
            this.state.filters[filterName] = this.nextId(true);
          }
          return this.state.filters[filterName];
        },
        ifDefined: function(id, defaultValue) {
          return 'ifDefined(' + id + ',' + this.escape(defaultValue) + ')';
        },
        plus: function(left, right) {
          return 'plus(' + left + ',' + right + ')';
        },
        return_: function(id) {
          this.current().body.push('return ', id, ';');
        },
        if_: function(test, alternate, consequent) {
          if (test === true) {
            alternate();
          } else {
            var body = this.current().body;
            body.push('if(', test, '){');
            alternate();
            body.push('}');
            if (consequent) {
              body.push('else{');
              consequent();
              body.push('}');
            }
          }
        },
        not: function(expression) {
          return '!(' + expression + ')';
        },
        notNull: function(expression) {
          return expression + '!=null';
        },
        nonComputedMember: function(left, right) {
          var SAFE_IDENTIFIER = /[$_a-zA-Z][$_a-zA-Z0-9]*/;
          var UNSAFE_CHARACTERS = /[^$_a-zA-Z0-9]/g;
          if (SAFE_IDENTIFIER.test(right)) {
            return left + '.' + right;
          } else {
            return left + '["' + right.replace(UNSAFE_CHARACTERS, this.stringEscapeFn) + '"]';
          }
        },
        computedMember: function(left, right) {
          return left + '[' + right + ']';
        },
        member: function(left, right, computed) {
          if (computed)
            return this.computedMember(left, right);
          return this.nonComputedMember(left, right);
        },
        addEnsureSafeObject: function(item) {
          this.current().body.push(this.ensureSafeObject(item), ';');
        },
        addEnsureSafeMemberName: function(item) {
          this.current().body.push(this.ensureSafeMemberName(item), ';');
        },
        addEnsureSafeFunction: function(item) {
          this.current().body.push(this.ensureSafeFunction(item), ';');
        },
        addEnsureSafeAssignContext: function(item) {
          this.current().body.push(this.ensureSafeAssignContext(item), ';');
        },
        ensureSafeObject: function(item) {
          return 'ensureSafeObject(' + item + ',text)';
        },
        ensureSafeMemberName: function(item) {
          return 'ensureSafeMemberName(' + item + ',text)';
        },
        ensureSafeFunction: function(item) {
          return 'ensureSafeFunction(' + item + ',text)';
        },
        getStringValue: function(item) {
          this.assign(item, 'getStringValue(' + item + ')');
        },
        ensureSafeAssignContext: function(item) {
          return 'ensureSafeAssignContext(' + item + ',text)';
        },
        lazyRecurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
          var self = this;
          return function() {
            self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
          };
        },
        lazyAssign: function(id, value) {
          var self = this;
          return function() {
            self.assign(id, value);
          };
        },
        stringEscapeRegex: /[^ a-zA-Z0-9]/g,
        stringEscapeFn: function(c) {
          return '\\u' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4);
        },
        escape: function(value) {
          if (isString(value))
            return "'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'";
          if (isNumber(value))
            return value.toString();
          if (value === true)
            return 'true';
          if (value === false)
            return 'false';
          if (value === null)
            return 'null';
          if (typeof value === 'undefined')
            return 'undefined';
          throw $parseMinErr('esc', 'IMPOSSIBLE');
        },
        nextId: function(skip, init) {
          var id = 'v' + (this.state.nextId++);
          if (!skip) {
            this.current().vars.push(id + (init ? '=' + init : ''));
          }
          return id;
        },
        current: function() {
          return this.state[this.state.computing];
        }
      };
      function ASTInterpreter(astBuilder, $filter) {
        this.astBuilder = astBuilder;
        this.$filter = $filter;
      }
      ASTInterpreter.prototype = {
        compile: function(expression, expensiveChecks) {
          var self = this;
          var ast = this.astBuilder.ast(expression);
          this.expression = expression;
          this.expensiveChecks = expensiveChecks;
          findConstantAndWatchExpressions(ast, self.$filter);
          var assignable;
          var assign;
          if ((assignable = assignableAST(ast))) {
            assign = this.recurse(assignable);
          }
          var toWatch = getInputs(ast.body);
          var inputs;
          if (toWatch) {
            inputs = [];
            forEach(toWatch, function(watch, key) {
              var input = self.recurse(watch);
              watch.input = input;
              inputs.push(input);
              watch.watchId = key;
            });
          }
          var expressions = [];
          forEach(ast.body, function(expression) {
            expressions.push(self.recurse(expression.expression));
          });
          var fn = ast.body.length === 0 ? noop : ast.body.length === 1 ? expressions[0] : function(scope, locals) {
            var lastValue;
            forEach(expressions, function(exp) {
              lastValue = exp(scope, locals);
            });
            return lastValue;
          };
          if (assign) {
            fn.assign = function(scope, value, locals) {
              return assign(scope, locals, value);
            };
          }
          if (inputs) {
            fn.inputs = inputs;
          }
          fn.literal = isLiteral(ast);
          fn.constant = isConstant(ast);
          return fn;
        },
        recurse: function(ast, context, create) {
          var left,
              right,
              self = this,
              args,
              expression;
          if (ast.input) {
            return this.inputs(ast.input, ast.watchId);
          }
          switch (ast.type) {
            case AST.Literal:
              return this.value(ast.value, context);
            case AST.UnaryExpression:
              right = this.recurse(ast.argument);
              return this['unary' + ast.operator](right, context);
            case AST.BinaryExpression:
              left = this.recurse(ast.left);
              right = this.recurse(ast.right);
              return this['binary' + ast.operator](left, right, context);
            case AST.LogicalExpression:
              left = this.recurse(ast.left);
              right = this.recurse(ast.right);
              return this['binary' + ast.operator](left, right, context);
            case AST.ConditionalExpression:
              return this['ternary?:'](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context);
            case AST.Identifier:
              ensureSafeMemberName(ast.name, self.expression);
              return self.identifier(ast.name, self.expensiveChecks || isPossiblyDangerousMemberName(ast.name), context, create, self.expression);
            case AST.MemberExpression:
              left = this.recurse(ast.object, false, !!create);
              if (!ast.computed) {
                ensureSafeMemberName(ast.property.name, self.expression);
                right = ast.property.name;
              }
              if (ast.computed)
                right = this.recurse(ast.property);
              return ast.computed ? this.computedMember(left, right, context, create, self.expression) : this.nonComputedMember(left, right, self.expensiveChecks, context, create, self.expression);
            case AST.CallExpression:
              args = [];
              forEach(ast.arguments, function(expr) {
                args.push(self.recurse(expr));
              });
              if (ast.filter)
                right = this.$filter(ast.callee.name);
              if (!ast.filter)
                right = this.recurse(ast.callee, true);
              return ast.filter ? function(scope, locals, assign, inputs) {
                var values = [];
                for (var i = 0; i < args.length; ++i) {
                  values.push(args[i](scope, locals, assign, inputs));
                }
                var value = right.apply(undefined, values, inputs);
                return context ? {
                  context: undefined,
                  name: undefined,
                  value: value
                } : value;
              } : function(scope, locals, assign, inputs) {
                var rhs = right(scope, locals, assign, inputs);
                var value;
                if (rhs.value != null) {
                  ensureSafeObject(rhs.context, self.expression);
                  ensureSafeFunction(rhs.value, self.expression);
                  var values = [];
                  for (var i = 0; i < args.length; ++i) {
                    values.push(ensureSafeObject(args[i](scope, locals, assign, inputs), self.expression));
                  }
                  value = ensureSafeObject(rhs.value.apply(rhs.context, values), self.expression);
                }
                return context ? {value: value} : value;
              };
            case AST.AssignmentExpression:
              left = this.recurse(ast.left, true, 1);
              right = this.recurse(ast.right);
              return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs);
                var rhs = right(scope, locals, assign, inputs);
                ensureSafeObject(lhs.value, self.expression);
                ensureSafeAssignContext(lhs.context);
                lhs.context[lhs.name] = rhs;
                return context ? {value: rhs} : rhs;
              };
            case AST.ArrayExpression:
              args = [];
              forEach(ast.elements, function(expr) {
                args.push(self.recurse(expr));
              });
              return function(scope, locals, assign, inputs) {
                var value = [];
                for (var i = 0; i < args.length; ++i) {
                  value.push(args[i](scope, locals, assign, inputs));
                }
                return context ? {value: value} : value;
              };
            case AST.ObjectExpression:
              args = [];
              forEach(ast.properties, function(property) {
                if (property.computed) {
                  args.push({
                    key: self.recurse(property.key),
                    computed: true,
                    value: self.recurse(property.value)
                  });
                } else {
                  args.push({
                    key: property.key.type === AST.Identifier ? property.key.name : ('' + property.key.value),
                    computed: false,
                    value: self.recurse(property.value)
                  });
                }
              });
              return function(scope, locals, assign, inputs) {
                var value = {};
                for (var i = 0; i < args.length; ++i) {
                  if (args[i].computed) {
                    value[args[i].key(scope, locals, assign, inputs)] = args[i].value(scope, locals, assign, inputs);
                  } else {
                    value[args[i].key] = args[i].value(scope, locals, assign, inputs);
                  }
                }
                return context ? {value: value} : value;
              };
            case AST.ThisExpression:
              return function(scope) {
                return context ? {value: scope} : scope;
              };
            case AST.LocalsExpression:
              return function(scope, locals) {
                return context ? {value: locals} : locals;
              };
            case AST.NGValueParameter:
              return function(scope, locals, assign) {
                return context ? {value: assign} : assign;
              };
          }
        },
        'unary+': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = argument(scope, locals, assign, inputs);
            if (isDefined(arg)) {
              arg = +arg;
            } else {
              arg = 0;
            }
            return context ? {value: arg} : arg;
          };
        },
        'unary-': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = argument(scope, locals, assign, inputs);
            if (isDefined(arg)) {
              arg = -arg;
            } else {
              arg = 0;
            }
            return context ? {value: arg} : arg;
          };
        },
        'unary!': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = !argument(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary+': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs = right(scope, locals, assign, inputs);
            var arg = plusFn(lhs, rhs);
            return context ? {value: arg} : arg;
          };
        },
        'binary-': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs = right(scope, locals, assign, inputs);
            var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
            return context ? {value: arg} : arg;
          };
        },
        'binary*': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary/': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary%': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary===': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary!==': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary==': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary!=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary<': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary>': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary<=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary>=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary&&': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary||': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'ternary?:': function(test, alternate, consequent, context) {
          return function(scope, locals, assign, inputs) {
            var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        value: function(value, context) {
          return function() {
            return context ? {
              context: undefined,
              name: undefined,
              value: value
            } : value;
          };
        },
        identifier: function(name, expensiveChecks, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var base = locals && (name in locals) ? locals : scope;
            if (create && create !== 1 && base && !(base[name])) {
              base[name] = {};
            }
            var value = base ? base[name] : undefined;
            if (expensiveChecks) {
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: base,
                name: name,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        computedMember: function(left, right, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs;
            var value;
            if (lhs != null) {
              rhs = right(scope, locals, assign, inputs);
              rhs = getStringValue(rhs);
              ensureSafeMemberName(rhs, expression);
              if (create && create !== 1) {
                ensureSafeAssignContext(lhs);
                if (lhs && !(lhs[rhs])) {
                  lhs[rhs] = {};
                }
              }
              value = lhs[rhs];
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: lhs,
                name: rhs,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        nonComputedMember: function(left, right, expensiveChecks, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            if (create && create !== 1) {
              ensureSafeAssignContext(lhs);
              if (lhs && !(lhs[right])) {
                lhs[right] = {};
              }
            }
            var value = lhs != null ? lhs[right] : undefined;
            if (expensiveChecks || isPossiblyDangerousMemberName(right)) {
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: lhs,
                name: right,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        inputs: function(input, watchId) {
          return function(scope, value, locals, inputs) {
            if (inputs)
              return inputs[watchId];
            return input(scope, value, locals);
          };
        }
      };
      var Parser = function(lexer, $filter, options) {
        this.lexer = lexer;
        this.$filter = $filter;
        this.options = options;
        this.ast = new AST(lexer, options);
        this.astCompiler = options.csp ? new ASTInterpreter(this.ast, $filter) : new ASTCompiler(this.ast, $filter);
      };
      Parser.prototype = {
        constructor: Parser,
        parse: function(text) {
          return this.astCompiler.compile(text, this.options.expensiveChecks);
        }
      };
      function isPossiblyDangerousMemberName(name) {
        return name == 'constructor';
      }
      var objectValueOf = Object.prototype.valueOf;
      function getValueOf(value) {
        return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
      }
      function $ParseProvider() {
        var cacheDefault = createMap();
        var cacheExpensive = createMap();
        var literals = {
          'true': true,
          'false': false,
          'null': null,
          'undefined': undefined
        };
        var identStart,
            identContinue;
        this.addLiteral = function(literalName, literalValue) {
          literals[literalName] = literalValue;
        };
        this.setIdentifierFns = function(identifierStart, identifierContinue) {
          identStart = identifierStart;
          identContinue = identifierContinue;
          return this;
        };
        this.$get = ['$filter', function($filter) {
          var noUnsafeEval = csp().noUnsafeEval;
          var $parseOptions = {
            csp: noUnsafeEval,
            expensiveChecks: false,
            literals: copy(literals),
            isIdentifierStart: isFunction(identStart) && identStart,
            isIdentifierContinue: isFunction(identContinue) && identContinue
          },
              $parseOptionsExpensive = {
                csp: noUnsafeEval,
                expensiveChecks: true,
                literals: copy(literals),
                isIdentifierStart: isFunction(identStart) && identStart,
                isIdentifierContinue: isFunction(identContinue) && identContinue
              };
          var runningChecksEnabled = false;
          $parse.$$runningExpensiveChecks = function() {
            return runningChecksEnabled;
          };
          return $parse;
          function $parse(exp, interceptorFn, expensiveChecks) {
            var parsedExpression,
                oneTime,
                cacheKey;
            expensiveChecks = expensiveChecks || runningChecksEnabled;
            switch (typeof exp) {
              case 'string':
                exp = exp.trim();
                cacheKey = exp;
                var cache = (expensiveChecks ? cacheExpensive : cacheDefault);
                parsedExpression = cache[cacheKey];
                if (!parsedExpression) {
                  if (exp.charAt(0) === ':' && exp.charAt(1) === ':') {
                    oneTime = true;
                    exp = exp.substring(2);
                  }
                  var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions;
                  var lexer = new Lexer(parseOptions);
                  var parser = new Parser(lexer, $filter, parseOptions);
                  parsedExpression = parser.parse(exp);
                  if (parsedExpression.constant) {
                    parsedExpression.$$watchDelegate = constantWatchDelegate;
                  } else if (oneTime) {
                    parsedExpression.$$watchDelegate = parsedExpression.literal ? oneTimeLiteralWatchDelegate : oneTimeWatchDelegate;
                  } else if (parsedExpression.inputs) {
                    parsedExpression.$$watchDelegate = inputsWatchDelegate;
                  }
                  if (expensiveChecks) {
                    parsedExpression = expensiveChecksInterceptor(parsedExpression);
                  }
                  cache[cacheKey] = parsedExpression;
                }
                return addInterceptor(parsedExpression, interceptorFn);
              case 'function':
                return addInterceptor(exp, interceptorFn);
              default:
                return addInterceptor(noop, interceptorFn);
            }
          }
          function expensiveChecksInterceptor(fn) {
            if (!fn)
              return fn;
            expensiveCheckFn.$$watchDelegate = fn.$$watchDelegate;
            expensiveCheckFn.assign = expensiveChecksInterceptor(fn.assign);
            expensiveCheckFn.constant = fn.constant;
            expensiveCheckFn.literal = fn.literal;
            for (var i = 0; fn.inputs && i < fn.inputs.length; ++i) {
              fn.inputs[i] = expensiveChecksInterceptor(fn.inputs[i]);
            }
            expensiveCheckFn.inputs = fn.inputs;
            return expensiveCheckFn;
            function expensiveCheckFn(scope, locals, assign, inputs) {
              var expensiveCheckOldValue = runningChecksEnabled;
              runningChecksEnabled = true;
              try {
                return fn(scope, locals, assign, inputs);
              } finally {
                runningChecksEnabled = expensiveCheckOldValue;
              }
            }
          }
          function expressionInputDirtyCheck(newValue, oldValueOfValue) {
            if (newValue == null || oldValueOfValue == null) {
              return newValue === oldValueOfValue;
            }
            if (typeof newValue === 'object') {
              newValue = getValueOf(newValue);
              if (typeof newValue === 'object') {
                return false;
              }
            }
            return newValue === oldValueOfValue || (newValue !== newValue && oldValueOfValue !== oldValueOfValue);
          }
          function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
            var inputExpressions = parsedExpression.inputs;
            var lastResult;
            if (inputExpressions.length === 1) {
              var oldInputValueOf = expressionInputDirtyCheck;
              inputExpressions = inputExpressions[0];
              return scope.$watch(function expressionInputWatch(scope) {
                var newInputValue = inputExpressions(scope);
                if (!expressionInputDirtyCheck(newInputValue, oldInputValueOf)) {
                  lastResult = parsedExpression(scope, undefined, undefined, [newInputValue]);
                  oldInputValueOf = newInputValue && getValueOf(newInputValue);
                }
                return lastResult;
              }, listener, objectEquality, prettyPrintExpression);
            }
            var oldInputValueOfValues = [];
            var oldInputValues = [];
            for (var i = 0,
                ii = inputExpressions.length; i < ii; i++) {
              oldInputValueOfValues[i] = expressionInputDirtyCheck;
              oldInputValues[i] = null;
            }
            return scope.$watch(function expressionInputsWatch(scope) {
              var changed = false;
              for (var i = 0,
                  ii = inputExpressions.length; i < ii; i++) {
                var newInputValue = inputExpressions[i](scope);
                if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) {
                  oldInputValues[i] = newInputValue;
                  oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue);
                }
              }
              if (changed) {
                lastResult = parsedExpression(scope, undefined, undefined, oldInputValues);
              }
              return lastResult;
            }, listener, objectEquality, prettyPrintExpression);
          }
          function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch,
                lastValue;
            return unwatch = scope.$watch(function oneTimeWatch(scope) {
              return parsedExpression(scope);
            }, function oneTimeListener(value, old, scope) {
              lastValue = value;
              if (isFunction(listener)) {
                listener.apply(this, arguments);
              }
              if (isDefined(value)) {
                scope.$$postDigest(function() {
                  if (isDefined(lastValue)) {
                    unwatch();
                  }
                });
              }
            }, objectEquality);
          }
          function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch,
                lastValue;
            return unwatch = scope.$watch(function oneTimeWatch(scope) {
              return parsedExpression(scope);
            }, function oneTimeListener(value, old, scope) {
              lastValue = value;
              if (isFunction(listener)) {
                listener.call(this, value, old, scope);
              }
              if (isAllDefined(value)) {
                scope.$$postDigest(function() {
                  if (isAllDefined(lastValue))
                    unwatch();
                });
              }
            }, objectEquality);
            function isAllDefined(value) {
              var allDefined = true;
              forEach(value, function(val) {
                if (!isDefined(val))
                  allDefined = false;
              });
              return allDefined;
            }
          }
          function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch;
            return unwatch = scope.$watch(function constantWatch(scope) {
              unwatch();
              return parsedExpression(scope);
            }, listener, objectEquality);
          }
          function addInterceptor(parsedExpression, interceptorFn) {
            if (!interceptorFn)
              return parsedExpression;
            var watchDelegate = parsedExpression.$$watchDelegate;
            var useInputs = false;
            var regularWatch = watchDelegate !== oneTimeLiteralWatchDelegate && watchDelegate !== oneTimeWatchDelegate;
            var fn = regularWatch ? function regularInterceptedExpression(scope, locals, assign, inputs) {
              var value = useInputs && inputs ? inputs[0] : parsedExpression(scope, locals, assign, inputs);
              return interceptorFn(value, scope, locals);
            } : function oneTimeInterceptedExpression(scope, locals, assign, inputs) {
              var value = parsedExpression(scope, locals, assign, inputs);
              var result = interceptorFn(value, scope, locals);
              return isDefined(value) ? result : value;
            };
            if (parsedExpression.$$watchDelegate && parsedExpression.$$watchDelegate !== inputsWatchDelegate) {
              fn.$$watchDelegate = parsedExpression.$$watchDelegate;
            } else if (!interceptorFn.$stateful) {
              fn.$$watchDelegate = inputsWatchDelegate;
              useInputs = !parsedExpression.inputs;
              fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [parsedExpression];
            }
            return fn;
          }
        }];
      }
      function $QProvider() {
        this.$get = ['$rootScope', '$exceptionHandler', function($rootScope, $exceptionHandler) {
          return qFactory(function(callback) {
            $rootScope.$evalAsync(callback);
          }, $exceptionHandler);
        }];
      }
      function $$QProvider() {
        this.$get = ['$browser', '$exceptionHandler', function($browser, $exceptionHandler) {
          return qFactory(function(callback) {
            $browser.defer(callback);
          }, $exceptionHandler);
        }];
      }
      function qFactory(nextTick, exceptionHandler) {
        var $qMinErr = minErr('$q', TypeError);
        var defer = function() {
          var d = new Deferred();
          d.resolve = simpleBind(d, d.resolve);
          d.reject = simpleBind(d, d.reject);
          d.notify = simpleBind(d, d.notify);
          return d;
        };
        function Promise() {
          this.$$state = {status: 0};
        }
        extend(Promise.prototype, {
          then: function(onFulfilled, onRejected, progressBack) {
            if (isUndefined(onFulfilled) && isUndefined(onRejected) && isUndefined(progressBack)) {
              return this;
            }
            var result = new Deferred();
            this.$$state.pending = this.$$state.pending || [];
            this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]);
            if (this.$$state.status > 0)
              scheduleProcessQueue(this.$$state);
            return result.promise;
          },
          "catch": function(callback) {
            return this.then(null, callback);
          },
          "finally": function(callback, progressBack) {
            return this.then(function(value) {
              return handleCallback(value, true, callback);
            }, function(error) {
              return handleCallback(error, false, callback);
            }, progressBack);
          }
        });
        function simpleBind(context, fn) {
          return function(value) {
            fn.call(context, value);
          };
        }
        function processQueue(state) {
          var fn,
              deferred,
              pending;
          pending = state.pending;
          state.processScheduled = false;
          state.pending = undefined;
          for (var i = 0,
              ii = pending.length; i < ii; ++i) {
            deferred = pending[i][0];
            fn = pending[i][state.status];
            try {
              if (isFunction(fn)) {
                deferred.resolve(fn(state.value));
              } else if (state.status === 1) {
                deferred.resolve(state.value);
              } else {
                deferred.reject(state.value);
              }
            } catch (e) {
              deferred.reject(e);
              exceptionHandler(e);
            }
          }
        }
        function scheduleProcessQueue(state) {
          if (state.processScheduled || !state.pending)
            return;
          state.processScheduled = true;
          nextTick(function() {
            processQueue(state);
          });
        }
        function Deferred() {
          this.promise = new Promise();
        }
        extend(Deferred.prototype, {
          resolve: function(val) {
            if (this.promise.$$state.status)
              return;
            if (val === this.promise) {
              this.$$reject($qMinErr('qcycle', "Expected promise to be resolved with value other than itself '{0}'", val));
            } else {
              this.$$resolve(val);
            }
          },
          $$resolve: function(val) {
            var then;
            var that = this;
            var done = false;
            try {
              if ((isObject(val) || isFunction(val)))
                then = val && val.then;
              if (isFunction(then)) {
                this.promise.$$state.status = -1;
                then.call(val, resolvePromise, rejectPromise, simpleBind(this, this.notify));
              } else {
                this.promise.$$state.value = val;
                this.promise.$$state.status = 1;
                scheduleProcessQueue(this.promise.$$state);
              }
            } catch (e) {
              rejectPromise(e);
              exceptionHandler(e);
            }
            function resolvePromise(val) {
              if (done)
                return;
              done = true;
              that.$$resolve(val);
            }
            function rejectPromise(val) {
              if (done)
                return;
              done = true;
              that.$$reject(val);
            }
          },
          reject: function(reason) {
            if (this.promise.$$state.status)
              return;
            this.$$reject(reason);
          },
          $$reject: function(reason) {
            this.promise.$$state.value = reason;
            this.promise.$$state.status = 2;
            scheduleProcessQueue(this.promise.$$state);
          },
          notify: function(progress) {
            var callbacks = this.promise.$$state.pending;
            if ((this.promise.$$state.status <= 0) && callbacks && callbacks.length) {
              nextTick(function() {
                var callback,
                    result;
                for (var i = 0,
                    ii = callbacks.length; i < ii; i++) {
                  result = callbacks[i][0];
                  callback = callbacks[i][3];
                  try {
                    result.notify(isFunction(callback) ? callback(progress) : progress);
                  } catch (e) {
                    exceptionHandler(e);
                  }
                }
              });
            }
          }
        });
        var reject = function(reason) {
          var result = new Deferred();
          result.reject(reason);
          return result.promise;
        };
        var makePromise = function makePromise(value, resolved) {
          var result = new Deferred();
          if (resolved) {
            result.resolve(value);
          } else {
            result.reject(value);
          }
          return result.promise;
        };
        var handleCallback = function handleCallback(value, isResolved, callback) {
          var callbackOutput = null;
          try {
            if (isFunction(callback))
              callbackOutput = callback();
          } catch (e) {
            return makePromise(e, false);
          }
          if (isPromiseLike(callbackOutput)) {
            return callbackOutput.then(function() {
              return makePromise(value, isResolved);
            }, function(error) {
              return makePromise(error, false);
            });
          } else {
            return makePromise(value, isResolved);
          }
        };
        var when = function(value, callback, errback, progressBack) {
          var result = new Deferred();
          result.resolve(value);
          return result.promise.then(callback, errback, progressBack);
        };
        var resolve = when;
        function all(promises) {
          var deferred = new Deferred(),
              counter = 0,
              results = isArray(promises) ? [] : {};
          forEach(promises, function(promise, key) {
            counter++;
            when(promise).then(function(value) {
              if (results.hasOwnProperty(key))
                return;
              results[key] = value;
              if (!(--counter))
                deferred.resolve(results);
            }, function(reason) {
              if (results.hasOwnProperty(key))
                return;
              deferred.reject(reason);
            });
          });
          if (counter === 0) {
            deferred.resolve(results);
          }
          return deferred.promise;
        }
        function race(promises) {
          var deferred = defer();
          forEach(promises, function(promise) {
            when(promise).then(deferred.resolve, deferred.reject);
          });
          return deferred.promise;
        }
        var $Q = function Q(resolver) {
          if (!isFunction(resolver)) {
            throw $qMinErr('norslvr', "Expected resolverFn, got '{0}'", resolver);
          }
          var deferred = new Deferred();
          function resolveFn(value) {
            deferred.resolve(value);
          }
          function rejectFn(reason) {
            deferred.reject(reason);
          }
          resolver(resolveFn, rejectFn);
          return deferred.promise;
        };
        $Q.prototype = Promise.prototype;
        $Q.defer = defer;
        $Q.reject = reject;
        $Q.when = when;
        $Q.resolve = resolve;
        $Q.all = all;
        $Q.race = race;
        return $Q;
      }
      function $$RAFProvider() {
        this.$get = ['$window', '$timeout', function($window, $timeout) {
          var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame;
          var cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame;
          var rafSupported = !!requestAnimationFrame;
          var raf = rafSupported ? function(fn) {
            var id = requestAnimationFrame(fn);
            return function() {
              cancelAnimationFrame(id);
            };
          } : function(fn) {
            var timer = $timeout(fn, 16.66, false);
            return function() {
              $timeout.cancel(timer);
            };
          };
          raf.supported = rafSupported;
          return raf;
        }];
      }
      function $RootScopeProvider() {
        var TTL = 10;
        var $rootScopeMinErr = minErr('$rootScope');
        var lastDirtyWatch = null;
        var applyAsyncId = null;
        this.digestTtl = function(value) {
          if (arguments.length) {
            TTL = value;
          }
          return TTL;
        };
        function createChildScopeClass(parent) {
          function ChildScope() {
            this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null;
            this.$$listeners = {};
            this.$$listenerCount = {};
            this.$$watchersCount = 0;
            this.$id = nextUid();
            this.$$ChildScope = null;
          }
          ChildScope.prototype = parent;
          return ChildScope;
        }
        this.$get = ['$exceptionHandler', '$parse', '$browser', function($exceptionHandler, $parse, $browser) {
          function destroyChildScope($event) {
            $event.currentScope.$$destroyed = true;
          }
          function cleanUpScope($scope) {
            if (msie === 9) {
              $scope.$$childHead && cleanUpScope($scope.$$childHead);
              $scope.$$nextSibling && cleanUpScope($scope.$$nextSibling);
            }
            $scope.$parent = $scope.$$nextSibling = $scope.$$prevSibling = $scope.$$childHead = $scope.$$childTail = $scope.$root = $scope.$$watchers = null;
          }
          function Scope() {
            this.$id = nextUid();
            this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
            this.$root = this;
            this.$$destroyed = false;
            this.$$listeners = {};
            this.$$listenerCount = {};
            this.$$watchersCount = 0;
            this.$$isolateBindings = null;
          }
          Scope.prototype = {
            constructor: Scope,
            $new: function(isolate, parent) {
              var child;
              parent = parent || this;
              if (isolate) {
                child = new Scope();
                child.$root = this.$root;
              } else {
                if (!this.$$ChildScope) {
                  this.$$ChildScope = createChildScopeClass(this);
                }
                child = new this.$$ChildScope();
              }
              child.$parent = parent;
              child.$$prevSibling = parent.$$childTail;
              if (parent.$$childHead) {
                parent.$$childTail.$$nextSibling = child;
                parent.$$childTail = child;
              } else {
                parent.$$childHead = parent.$$childTail = child;
              }
              if (isolate || parent != this)
                child.$on('$destroy', destroyChildScope);
              return child;
            },
            $watch: function(watchExp, listener, objectEquality, prettyPrintExpression) {
              var get = $parse(watchExp);
              if (get.$$watchDelegate) {
                return get.$$watchDelegate(this, listener, objectEquality, get, watchExp);
              }
              var scope = this,
                  array = scope.$$watchers,
                  watcher = {
                    fn: listener,
                    last: initWatchVal,
                    get: get,
                    exp: prettyPrintExpression || watchExp,
                    eq: !!objectEquality
                  };
              lastDirtyWatch = null;
              if (!isFunction(listener)) {
                watcher.fn = noop;
              }
              if (!array) {
                array = scope.$$watchers = [];
              }
              array.unshift(watcher);
              incrementWatchersCount(this, 1);
              return function deregisterWatch() {
                if (arrayRemove(array, watcher) >= 0) {
                  incrementWatchersCount(scope, -1);
                }
                lastDirtyWatch = null;
              };
            },
            $watchGroup: function(watchExpressions, listener) {
              var oldValues = new Array(watchExpressions.length);
              var newValues = new Array(watchExpressions.length);
              var deregisterFns = [];
              var self = this;
              var changeReactionScheduled = false;
              var firstRun = true;
              if (!watchExpressions.length) {
                var shouldCall = true;
                self.$evalAsync(function() {
                  if (shouldCall)
                    listener(newValues, newValues, self);
                });
                return function deregisterWatchGroup() {
                  shouldCall = false;
                };
              }
              if (watchExpressions.length === 1) {
                return this.$watch(watchExpressions[0], function watchGroupAction(value, oldValue, scope) {
                  newValues[0] = value;
                  oldValues[0] = oldValue;
                  listener(newValues, (value === oldValue) ? newValues : oldValues, scope);
                });
              }
              forEach(watchExpressions, function(expr, i) {
                var unwatchFn = self.$watch(expr, function watchGroupSubAction(value, oldValue) {
                  newValues[i] = value;
                  oldValues[i] = oldValue;
                  if (!changeReactionScheduled) {
                    changeReactionScheduled = true;
                    self.$evalAsync(watchGroupAction);
                  }
                });
                deregisterFns.push(unwatchFn);
              });
              function watchGroupAction() {
                changeReactionScheduled = false;
                if (firstRun) {
                  firstRun = false;
                  listener(newValues, newValues, self);
                } else {
                  listener(newValues, oldValues, self);
                }
              }
              return function deregisterWatchGroup() {
                while (deregisterFns.length) {
                  deregisterFns.shift()();
                }
              };
            },
            $watchCollection: function(obj, listener) {
              $watchCollectionInterceptor.$stateful = true;
              var self = this;
              var newValue;
              var oldValue;
              var veryOldValue;
              var trackVeryOldValue = (listener.length > 1);
              var changeDetected = 0;
              var changeDetector = $parse(obj, $watchCollectionInterceptor);
              var internalArray = [];
              var internalObject = {};
              var initRun = true;
              var oldLength = 0;
              function $watchCollectionInterceptor(_value) {
                newValue = _value;
                var newLength,
                    key,
                    bothNaN,
                    newItem,
                    oldItem;
                if (isUndefined(newValue))
                  return;
                if (!isObject(newValue)) {
                  if (oldValue !== newValue) {
                    oldValue = newValue;
                    changeDetected++;
                  }
                } else if (isArrayLike(newValue)) {
                  if (oldValue !== internalArray) {
                    oldValue = internalArray;
                    oldLength = oldValue.length = 0;
                    changeDetected++;
                  }
                  newLength = newValue.length;
                  if (oldLength !== newLength) {
                    changeDetected++;
                    oldValue.length = oldLength = newLength;
                  }
                  for (var i = 0; i < newLength; i++) {
                    oldItem = oldValue[i];
                    newItem = newValue[i];
                    bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
                    if (!bothNaN && (oldItem !== newItem)) {
                      changeDetected++;
                      oldValue[i] = newItem;
                    }
                  }
                } else {
                  if (oldValue !== internalObject) {
                    oldValue = internalObject = {};
                    oldLength = 0;
                    changeDetected++;
                  }
                  newLength = 0;
                  for (key in newValue) {
                    if (hasOwnProperty.call(newValue, key)) {
                      newLength++;
                      newItem = newValue[key];
                      oldItem = oldValue[key];
                      if (key in oldValue) {
                        bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
                        if (!bothNaN && (oldItem !== newItem)) {
                          changeDetected++;
                          oldValue[key] = newItem;
                        }
                      } else {
                        oldLength++;
                        oldValue[key] = newItem;
                        changeDetected++;
                      }
                    }
                  }
                  if (oldLength > newLength) {
                    changeDetected++;
                    for (key in oldValue) {
                      if (!hasOwnProperty.call(newValue, key)) {
                        oldLength--;
                        delete oldValue[key];
                      }
                    }
                  }
                }
                return changeDetected;
              }
              function $watchCollectionAction() {
                if (initRun) {
                  initRun = false;
                  listener(newValue, newValue, self);
                } else {
                  listener(newValue, veryOldValue, self);
                }
                if (trackVeryOldValue) {
                  if (!isObject(newValue)) {
                    veryOldValue = newValue;
                  } else if (isArrayLike(newValue)) {
                    veryOldValue = new Array(newValue.length);
                    for (var i = 0; i < newValue.length; i++) {
                      veryOldValue[i] = newValue[i];
                    }
                  } else {
                    veryOldValue = {};
                    for (var key in newValue) {
                      if (hasOwnProperty.call(newValue, key)) {
                        veryOldValue[key] = newValue[key];
                      }
                    }
                  }
                }
              }
              return this.$watch(changeDetector, $watchCollectionAction);
            },
            $digest: function() {
              var watch,
                  value,
                  last,
                  fn,
                  get,
                  watchers,
                  length,
                  dirty,
                  ttl = TTL,
                  next,
                  current,
                  target = this,
                  watchLog = [],
                  logIdx,
                  asyncTask;
              beginPhase('$digest');
              $browser.$$checkUrlChange();
              if (this === $rootScope && applyAsyncId !== null) {
                $browser.defer.cancel(applyAsyncId);
                flushApplyAsync();
              }
              lastDirtyWatch = null;
              do {
                dirty = false;
                current = target;
                for (var asyncQueuePosition = 0; asyncQueuePosition < asyncQueue.length; asyncQueuePosition++) {
                  try {
                    asyncTask = asyncQueue[asyncQueuePosition];
                    asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                  lastDirtyWatch = null;
                }
                asyncQueue.length = 0;
                traverseScopesLoop: do {
                  if ((watchers = current.$$watchers)) {
                    length = watchers.length;
                    while (length--) {
                      try {
                        watch = watchers[length];
                        if (watch) {
                          get = watch.get;
                          if ((value = get(current)) !== (last = watch.last) && !(watch.eq ? equals(value, last) : (typeof value === 'number' && typeof last === 'number' && isNaN(value) && isNaN(last)))) {
                            dirty = true;
                            lastDirtyWatch = watch;
                            watch.last = watch.eq ? copy(value, null) : value;
                            fn = watch.fn;
                            fn(value, ((last === initWatchVal) ? value : last), current);
                            if (ttl < 5) {
                              logIdx = 4 - ttl;
                              if (!watchLog[logIdx])
                                watchLog[logIdx] = [];
                              watchLog[logIdx].push({
                                msg: isFunction(watch.exp) ? 'fn: ' + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                newVal: value,
                                oldVal: last
                              });
                            }
                          } else if (watch === lastDirtyWatch) {
                            dirty = false;
                            break traverseScopesLoop;
                          }
                        }
                      } catch (e) {
                        $exceptionHandler(e);
                      }
                    }
                  }
                  if (!(next = ((current.$$watchersCount && current.$$childHead) || (current !== target && current.$$nextSibling)))) {
                    while (current !== target && !(next = current.$$nextSibling)) {
                      current = current.$parent;
                    }
                  }
                } while ((current = next));
                if ((dirty || asyncQueue.length) && !(ttl--)) {
                  clearPhase();
                  throw $rootScopeMinErr('infdig', '{0} $digest() iterations reached. Aborting!\n' + 'Watchers fired in the last 5 iterations: {1}', TTL, watchLog);
                }
              } while (dirty || asyncQueue.length);
              clearPhase();
              while (postDigestQueuePosition < postDigestQueue.length) {
                try {
                  postDigestQueue[postDigestQueuePosition++]();
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
              postDigestQueue.length = postDigestQueuePosition = 0;
            },
            $destroy: function() {
              if (this.$$destroyed)
                return;
              var parent = this.$parent;
              this.$broadcast('$destroy');
              this.$$destroyed = true;
              if (this === $rootScope) {
                $browser.$$applicationDestroyed();
              }
              incrementWatchersCount(this, -this.$$watchersCount);
              for (var eventName in this.$$listenerCount) {
                decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
              }
              if (parent && parent.$$childHead == this)
                parent.$$childHead = this.$$nextSibling;
              if (parent && parent.$$childTail == this)
                parent.$$childTail = this.$$prevSibling;
              if (this.$$prevSibling)
                this.$$prevSibling.$$nextSibling = this.$$nextSibling;
              if (this.$$nextSibling)
                this.$$nextSibling.$$prevSibling = this.$$prevSibling;
              this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;
              this.$on = this.$watch = this.$watchGroup = function() {
                return noop;
              };
              this.$$listeners = {};
              this.$$nextSibling = null;
              cleanUpScope(this);
            },
            $eval: function(expr, locals) {
              return $parse(expr)(this, locals);
            },
            $evalAsync: function(expr, locals) {
              if (!$rootScope.$$phase && !asyncQueue.length) {
                $browser.defer(function() {
                  if (asyncQueue.length) {
                    $rootScope.$digest();
                  }
                });
              }
              asyncQueue.push({
                scope: this,
                expression: $parse(expr),
                locals: locals
              });
            },
            $$postDigest: function(fn) {
              postDigestQueue.push(fn);
            },
            $apply: function(expr) {
              try {
                beginPhase('$apply');
                try {
                  return this.$eval(expr);
                } finally {
                  clearPhase();
                }
              } catch (e) {
                $exceptionHandler(e);
              } finally {
                try {
                  $rootScope.$digest();
                } catch (e) {
                  $exceptionHandler(e);
                  throw e;
                }
              }
            },
            $applyAsync: function(expr) {
              var scope = this;
              expr && applyAsyncQueue.push($applyAsyncExpression);
              expr = $parse(expr);
              scheduleApplyAsync();
              function $applyAsyncExpression() {
                scope.$eval(expr);
              }
            },
            $on: function(name, listener) {
              var namedListeners = this.$$listeners[name];
              if (!namedListeners) {
                this.$$listeners[name] = namedListeners = [];
              }
              namedListeners.push(listener);
              var current = this;
              do {
                if (!current.$$listenerCount[name]) {
                  current.$$listenerCount[name] = 0;
                }
                current.$$listenerCount[name]++;
              } while ((current = current.$parent));
              var self = this;
              return function() {
                var indexOfListener = namedListeners.indexOf(listener);
                if (indexOfListener !== -1) {
                  namedListeners[indexOfListener] = null;
                  decrementListenerCount(self, 1, name);
                }
              };
            },
            $emit: function(name, args) {
              var empty = [],
                  namedListeners,
                  scope = this,
                  stopPropagation = false,
                  event = {
                    name: name,
                    targetScope: scope,
                    stopPropagation: function() {
                      stopPropagation = true;
                    },
                    preventDefault: function() {
                      event.defaultPrevented = true;
                    },
                    defaultPrevented: false
                  },
                  listenerArgs = concat([event], arguments, 1),
                  i,
                  length;
              do {
                namedListeners = scope.$$listeners[name] || empty;
                event.currentScope = scope;
                for (i = 0, length = namedListeners.length; i < length; i++) {
                  if (!namedListeners[i]) {
                    namedListeners.splice(i, 1);
                    i--;
                    length--;
                    continue;
                  }
                  try {
                    namedListeners[i].apply(null, listenerArgs);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (stopPropagation) {
                  event.currentScope = null;
                  return event;
                }
                scope = scope.$parent;
              } while (scope);
              event.currentScope = null;
              return event;
            },
            $broadcast: function(name, args) {
              var target = this,
                  current = target,
                  next = target,
                  event = {
                    name: name,
                    targetScope: target,
                    preventDefault: function() {
                      event.defaultPrevented = true;
                    },
                    defaultPrevented: false
                  };
              if (!target.$$listenerCount[name])
                return event;
              var listenerArgs = concat([event], arguments, 1),
                  listeners,
                  i,
                  length;
              while ((current = next)) {
                event.currentScope = current;
                listeners = current.$$listeners[name] || [];
                for (i = 0, length = listeners.length; i < length; i++) {
                  if (!listeners[i]) {
                    listeners.splice(i, 1);
                    i--;
                    length--;
                    continue;
                  }
                  try {
                    listeners[i].apply(null, listenerArgs);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (!(next = ((current.$$listenerCount[name] && current.$$childHead) || (current !== target && current.$$nextSibling)))) {
                  while (current !== target && !(next = current.$$nextSibling)) {
                    current = current.$parent;
                  }
                }
              }
              event.currentScope = null;
              return event;
            }
          };
          var $rootScope = new Scope();
          var asyncQueue = $rootScope.$$asyncQueue = [];
          var postDigestQueue = $rootScope.$$postDigestQueue = [];
          var applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];
          var postDigestQueuePosition = 0;
          return $rootScope;
          function beginPhase(phase) {
            if ($rootScope.$$phase) {
              throw $rootScopeMinErr('inprog', '{0} already in progress', $rootScope.$$phase);
            }
            $rootScope.$$phase = phase;
          }
          function clearPhase() {
            $rootScope.$$phase = null;
          }
          function incrementWatchersCount(current, count) {
            do {
              current.$$watchersCount += count;
            } while ((current = current.$parent));
          }
          function decrementListenerCount(current, count, name) {
            do {
              current.$$listenerCount[name] -= count;
              if (current.$$listenerCount[name] === 0) {
                delete current.$$listenerCount[name];
              }
            } while ((current = current.$parent));
          }
          function initWatchVal() {}
          function flushApplyAsync() {
            while (applyAsyncQueue.length) {
              try {
                applyAsyncQueue.shift()();
              } catch (e) {
                $exceptionHandler(e);
              }
            }
            applyAsyncId = null;
          }
          function scheduleApplyAsync() {
            if (applyAsyncId === null) {
              applyAsyncId = $browser.defer(function() {
                $rootScope.$apply(flushApplyAsync);
              });
            }
          }
        }];
      }
      function $$SanitizeUriProvider() {
        var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/,
            imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
        this.aHrefSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            aHrefSanitizationWhitelist = regexp;
            return this;
          }
          return aHrefSanitizationWhitelist;
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            imgSrcSanitizationWhitelist = regexp;
            return this;
          }
          return imgSrcSanitizationWhitelist;
        };
        this.$get = function() {
          return function sanitizeUri(uri, isImage) {
            var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
            var normalizedVal;
            normalizedVal = urlResolve(uri).href;
            if (normalizedVal !== '' && !normalizedVal.match(regex)) {
              return 'unsafe:' + normalizedVal;
            }
            return uri;
          };
        };
      }
      var $sceMinErr = minErr('$sce');
      var SCE_CONTEXTS = {
        HTML: 'html',
        CSS: 'css',
        URL: 'url',
        RESOURCE_URL: 'resourceUrl',
        JS: 'js'
      };
      function adjustMatcher(matcher) {
        if (matcher === 'self') {
          return matcher;
        } else if (isString(matcher)) {
          if (matcher.indexOf('***') > -1) {
            throw $sceMinErr('iwcard', 'Illegal sequence *** in string matcher.  String: {0}', matcher);
          }
          matcher = escapeForRegexp(matcher).replace('\\*\\*', '.*').replace('\\*', '[^:/.?&;]*');
          return new RegExp('^' + matcher + '$');
        } else if (isRegExp(matcher)) {
          return new RegExp('^' + matcher.source + '$');
        } else {
          throw $sceMinErr('imatcher', 'Matchers may only be "self", string patterns or RegExp objects');
        }
      }
      function adjustMatchers(matchers) {
        var adjustedMatchers = [];
        if (isDefined(matchers)) {
          forEach(matchers, function(matcher) {
            adjustedMatchers.push(adjustMatcher(matcher));
          });
        }
        return adjustedMatchers;
      }
      function $SceDelegateProvider() {
        this.SCE_CONTEXTS = SCE_CONTEXTS;
        var resourceUrlWhitelist = ['self'],
            resourceUrlBlacklist = [];
        this.resourceUrlWhitelist = function(value) {
          if (arguments.length) {
            resourceUrlWhitelist = adjustMatchers(value);
          }
          return resourceUrlWhitelist;
        };
        this.resourceUrlBlacklist = function(value) {
          if (arguments.length) {
            resourceUrlBlacklist = adjustMatchers(value);
          }
          return resourceUrlBlacklist;
        };
        this.$get = ['$injector', function($injector) {
          var htmlSanitizer = function htmlSanitizer(html) {
            throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
          };
          if ($injector.has('$sanitize')) {
            htmlSanitizer = $injector.get('$sanitize');
          }
          function matchUrl(matcher, parsedUrl) {
            if (matcher === 'self') {
              return urlIsSameOrigin(parsedUrl);
            } else {
              return !!matcher.exec(parsedUrl.href);
            }
          }
          function isResourceUrlAllowedByPolicy(url) {
            var parsedUrl = urlResolve(url.toString());
            var i,
                n,
                allowed = false;
            for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
              if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                allowed = true;
                break;
              }
            }
            if (allowed) {
              for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
                if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                  allowed = false;
                  break;
                }
              }
            }
            return allowed;
          }
          function generateHolderType(Base) {
            var holderType = function TrustedValueHolderType(trustedValue) {
              this.$$unwrapTrustedValue = function() {
                return trustedValue;
              };
            };
            if (Base) {
              holderType.prototype = new Base();
            }
            holderType.prototype.valueOf = function sceValueOf() {
              return this.$$unwrapTrustedValue();
            };
            holderType.prototype.toString = function sceToString() {
              return this.$$unwrapTrustedValue().toString();
            };
            return holderType;
          }
          var trustedValueHolderBase = generateHolderType(),
              byType = {};
          byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);
          function trustAs(type, trustedValue) {
            var Constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
            if (!Constructor) {
              throw $sceMinErr('icontext', 'Attempted to trust a value in invalid context. Context: {0}; Value: {1}', type, trustedValue);
            }
            if (trustedValue === null || isUndefined(trustedValue) || trustedValue === '') {
              return trustedValue;
            }
            if (typeof trustedValue !== 'string') {
              throw $sceMinErr('itype', 'Attempted to trust a non-string value in a content requiring a string: Context: {0}', type);
            }
            return new Constructor(trustedValue);
          }
          function valueOf(maybeTrusted) {
            if (maybeTrusted instanceof trustedValueHolderBase) {
              return maybeTrusted.$$unwrapTrustedValue();
            } else {
              return maybeTrusted;
            }
          }
          function getTrusted(type, maybeTrusted) {
            if (maybeTrusted === null || isUndefined(maybeTrusted) || maybeTrusted === '') {
              return maybeTrusted;
            }
            var constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
            if (constructor && maybeTrusted instanceof constructor) {
              return maybeTrusted.$$unwrapTrustedValue();
            }
            if (type === SCE_CONTEXTS.RESOURCE_URL) {
              if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
                return maybeTrusted;
              } else {
                throw $sceMinErr('insecurl', 'Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}', maybeTrusted.toString());
              }
            } else if (type === SCE_CONTEXTS.HTML) {
              return htmlSanitizer(maybeTrusted);
            }
            throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
          }
          return {
            trustAs: trustAs,
            getTrusted: getTrusted,
            valueOf: valueOf
          };
        }];
      }
      function $SceProvider() {
        var enabled = true;
        this.enabled = function(value) {
          if (arguments.length) {
            enabled = !!value;
          }
          return enabled;
        };
        this.$get = ['$parse', '$sceDelegate', function($parse, $sceDelegate) {
          if (enabled && msie < 8) {
            throw $sceMinErr('iequirks', 'Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks ' + 'mode.  You can fix this by adding the text <!doctype html> to the top of your HTML ' + 'document.  See http://docs.angularjs.org/api/ng.$sce for more information.');
          }
          var sce = shallowCopy(SCE_CONTEXTS);
          sce.isEnabled = function() {
            return enabled;
          };
          sce.trustAs = $sceDelegate.trustAs;
          sce.getTrusted = $sceDelegate.getTrusted;
          sce.valueOf = $sceDelegate.valueOf;
          if (!enabled) {
            sce.trustAs = sce.getTrusted = function(type, value) {
              return value;
            };
            sce.valueOf = identity;
          }
          sce.parseAs = function sceParseAs(type, expr) {
            var parsed = $parse(expr);
            if (parsed.literal && parsed.constant) {
              return parsed;
            } else {
              return $parse(expr, function(value) {
                return sce.getTrusted(type, value);
              });
            }
          };
          var parse = sce.parseAs,
              getTrusted = sce.getTrusted,
              trustAs = sce.trustAs;
          forEach(SCE_CONTEXTS, function(enumValue, name) {
            var lName = lowercase(name);
            sce[camelCase("parse_as_" + lName)] = function(expr) {
              return parse(enumValue, expr);
            };
            sce[camelCase("get_trusted_" + lName)] = function(value) {
              return getTrusted(enumValue, value);
            };
            sce[camelCase("trust_as_" + lName)] = function(value) {
              return trustAs(enumValue, value);
            };
          });
          return sce;
        }];
      }
      function $SnifferProvider() {
        this.$get = ['$window', '$document', function($window, $document) {
          var eventSupport = {},
              isChromePackagedApp = $window.chrome && $window.chrome.app && $window.chrome.app.runtime,
              hasHistoryPushState = !isChromePackagedApp && $window.history && $window.history.pushState,
              android = toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]),
              boxee = /Boxee/i.test(($window.navigator || {}).userAgent),
              document = $document[0] || {},
              vendorPrefix,
              vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/,
              bodyStyle = document.body && document.body.style,
              transitions = false,
              animations = false,
              match;
          if (bodyStyle) {
            for (var prop in bodyStyle) {
              if (match = vendorRegex.exec(prop)) {
                vendorPrefix = match[0];
                vendorPrefix = vendorPrefix[0].toUpperCase() + vendorPrefix.substr(1);
                break;
              }
            }
            if (!vendorPrefix) {
              vendorPrefix = ('WebkitOpacity' in bodyStyle) && 'webkit';
            }
            transitions = !!(('transition' in bodyStyle) || (vendorPrefix + 'Transition' in bodyStyle));
            animations = !!(('animation' in bodyStyle) || (vendorPrefix + 'Animation' in bodyStyle));
            if (android && (!transitions || !animations)) {
              transitions = isString(bodyStyle.webkitTransition);
              animations = isString(bodyStyle.webkitAnimation);
            }
          }
          return {
            history: !!(hasHistoryPushState && !(android < 4) && !boxee),
            hasEvent: function(event) {
              if (event === 'input' && msie <= 11)
                return false;
              if (isUndefined(eventSupport[event])) {
                var divElm = document.createElement('div');
                eventSupport[event] = 'on' + event in divElm;
              }
              return eventSupport[event];
            },
            csp: csp(),
            vendorPrefix: vendorPrefix,
            transitions: transitions,
            animations: animations,
            android: android
          };
        }];
      }
      var $templateRequestMinErr = minErr('$compile');
      function $TemplateRequestProvider() {
        var httpOptions;
        this.httpOptions = function(val) {
          if (val) {
            httpOptions = val;
            return this;
          }
          return httpOptions;
        };
        this.$get = ['$templateCache', '$http', '$q', '$sce', function($templateCache, $http, $q, $sce) {
          function handleRequestFn(tpl, ignoreRequestError) {
            handleRequestFn.totalPendingRequests++;
            if (!isString(tpl) || isUndefined($templateCache.get(tpl))) {
              tpl = $sce.getTrustedResourceUrl(tpl);
            }
            var transformResponse = $http.defaults && $http.defaults.transformResponse;
            if (isArray(transformResponse)) {
              transformResponse = transformResponse.filter(function(transformer) {
                return transformer !== defaultHttpResponseTransform;
              });
            } else if (transformResponse === defaultHttpResponseTransform) {
              transformResponse = null;
            }
            return $http.get(tpl, extend({
              cache: $templateCache,
              transformResponse: transformResponse
            }, httpOptions))['finally'](function() {
              handleRequestFn.totalPendingRequests--;
            }).then(function(response) {
              $templateCache.put(tpl, response.data);
              return response.data;
            }, handleError);
            function handleError(resp) {
              if (!ignoreRequestError) {
                throw $templateRequestMinErr('tpload', 'Failed to load template: {0} (HTTP status: {1} {2})', tpl, resp.status, resp.statusText);
              }
              return $q.reject(resp);
            }
          }
          handleRequestFn.totalPendingRequests = 0;
          return handleRequestFn;
        }];
      }
      function $$TestabilityProvider() {
        this.$get = ['$rootScope', '$browser', '$location', function($rootScope, $browser, $location) {
          var testability = {};
          testability.findBindings = function(element, expression, opt_exactMatch) {
            var bindings = element.getElementsByClassName('ng-binding');
            var matches = [];
            forEach(bindings, function(binding) {
              var dataBinding = angular.element(binding).data('$binding');
              if (dataBinding) {
                forEach(dataBinding, function(bindingName) {
                  if (opt_exactMatch) {
                    var matcher = new RegExp('(^|\\s)' + escapeForRegexp(expression) + '(\\s|\\||$)');
                    if (matcher.test(bindingName)) {
                      matches.push(binding);
                    }
                  } else {
                    if (bindingName.indexOf(expression) != -1) {
                      matches.push(binding);
                    }
                  }
                });
              }
            });
            return matches;
          };
          testability.findModels = function(element, expression, opt_exactMatch) {
            var prefixes = ['ng-', 'data-ng-', 'ng\\:'];
            for (var p = 0; p < prefixes.length; ++p) {
              var attributeEquals = opt_exactMatch ? '=' : '*=';
              var selector = '[' + prefixes[p] + 'model' + attributeEquals + '"' + expression + '"]';
              var elements = element.querySelectorAll(selector);
              if (elements.length) {
                return elements;
              }
            }
          };
          testability.getLocation = function() {
            return $location.url();
          };
          testability.setLocation = function(url) {
            if (url !== $location.url()) {
              $location.url(url);
              $rootScope.$digest();
            }
          };
          testability.whenStable = function(callback) {
            $browser.notifyWhenNoOutstandingRequests(callback);
          };
          return testability;
        }];
      }
      function $TimeoutProvider() {
        this.$get = ['$rootScope', '$browser', '$q', '$$q', '$exceptionHandler', function($rootScope, $browser, $q, $$q, $exceptionHandler) {
          var deferreds = {};
          function timeout(fn, delay, invokeApply) {
            if (!isFunction(fn)) {
              invokeApply = delay;
              delay = fn;
              fn = noop;
            }
            var args = sliceArgs(arguments, 3),
                skipApply = (isDefined(invokeApply) && !invokeApply),
                deferred = (skipApply ? $$q : $q).defer(),
                promise = deferred.promise,
                timeoutId;
            timeoutId = $browser.defer(function() {
              try {
                deferred.resolve(fn.apply(null, args));
              } catch (e) {
                deferred.reject(e);
                $exceptionHandler(e);
              } finally {
                delete deferreds[promise.$$timeoutId];
              }
              if (!skipApply)
                $rootScope.$apply();
            }, delay);
            promise.$$timeoutId = timeoutId;
            deferreds[timeoutId] = deferred;
            return promise;
          }
          timeout.cancel = function(promise) {
            if (promise && promise.$$timeoutId in deferreds) {
              deferreds[promise.$$timeoutId].reject('canceled');
              delete deferreds[promise.$$timeoutId];
              return $browser.defer.cancel(promise.$$timeoutId);
            }
            return false;
          };
          return timeout;
        }];
      }
      var urlParsingNode = window.document.createElement("a");
      var originUrl = urlResolve(window.location.href);
      function urlResolve(url) {
        var href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute('href', href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
        };
      }
      function urlIsSameOrigin(requestUrl) {
        var parsed = (isString(requestUrl)) ? urlResolve(requestUrl) : requestUrl;
        return (parsed.protocol === originUrl.protocol && parsed.host === originUrl.host);
      }
      function $WindowProvider() {
        this.$get = valueFn(window);
      }
      function $$CookieReader($document) {
        var rawDocument = $document[0] || {};
        var lastCookies = {};
        var lastCookieString = '';
        function safeDecodeURIComponent(str) {
          try {
            return decodeURIComponent(str);
          } catch (e) {
            return str;
          }
        }
        return function() {
          var cookieArray,
              cookie,
              i,
              index,
              name;
          var currentCookieString = rawDocument.cookie || '';
          if (currentCookieString !== lastCookieString) {
            lastCookieString = currentCookieString;
            cookieArray = lastCookieString.split('; ');
            lastCookies = {};
            for (i = 0; i < cookieArray.length; i++) {
              cookie = cookieArray[i];
              index = cookie.indexOf('=');
              if (index > 0) {
                name = safeDecodeURIComponent(cookie.substring(0, index));
                if (isUndefined(lastCookies[name])) {
                  lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));
                }
              }
            }
          }
          return lastCookies;
        };
      }
      $$CookieReader.$inject = ['$document'];
      function $$CookieReaderProvider() {
        this.$get = $$CookieReader;
      }
      $FilterProvider.$inject = ['$provide'];
      function $FilterProvider($provide) {
        var suffix = 'Filter';
        function register(name, factory) {
          if (isObject(name)) {
            var filters = {};
            forEach(name, function(filter, key) {
              filters[key] = register(key, filter);
            });
            return filters;
          } else {
            return $provide.factory(name + suffix, factory);
          }
        }
        this.register = register;
        this.$get = ['$injector', function($injector) {
          return function(name) {
            return $injector.get(name + suffix);
          };
        }];
        register('currency', currencyFilter);
        register('date', dateFilter);
        register('filter', filterFilter);
        register('json', jsonFilter);
        register('limitTo', limitToFilter);
        register('lowercase', lowercaseFilter);
        register('number', numberFilter);
        register('orderBy', orderByFilter);
        register('uppercase', uppercaseFilter);
      }
      function filterFilter() {
        return function(array, expression, comparator, anyPropertyKey) {
          if (!isArrayLike(array)) {
            if (array == null) {
              return array;
            } else {
              throw minErr('filter')('notarray', 'Expected array but received: {0}', array);
            }
          }
          anyPropertyKey = anyPropertyKey || '$';
          var expressionType = getTypeForFilter(expression);
          var predicateFn;
          var matchAgainstAnyProp;
          switch (expressionType) {
            case 'function':
              predicateFn = expression;
              break;
            case 'boolean':
            case 'null':
            case 'number':
            case 'string':
              matchAgainstAnyProp = true;
            case 'object':
              predicateFn = createPredicateFn(expression, comparator, anyPropertyKey, matchAgainstAnyProp);
              break;
            default:
              return array;
          }
          return Array.prototype.filter.call(array, predicateFn);
        };
      }
      function createPredicateFn(expression, comparator, anyPropertyKey, matchAgainstAnyProp) {
        var shouldMatchPrimitives = isObject(expression) && (anyPropertyKey in expression);
        var predicateFn;
        if (comparator === true) {
          comparator = equals;
        } else if (!isFunction(comparator)) {
          comparator = function(actual, expected) {
            if (isUndefined(actual)) {
              return false;
            }
            if ((actual === null) || (expected === null)) {
              return actual === expected;
            }
            if (isObject(expected) || (isObject(actual) && !hasCustomToString(actual))) {
              return false;
            }
            actual = lowercase('' + actual);
            expected = lowercase('' + expected);
            return actual.indexOf(expected) !== -1;
          };
        }
        predicateFn = function(item) {
          if (shouldMatchPrimitives && !isObject(item)) {
            return deepCompare(item, expression[anyPropertyKey], comparator, anyPropertyKey, false);
          }
          return deepCompare(item, expression, comparator, anyPropertyKey, matchAgainstAnyProp);
        };
        return predicateFn;
      }
      function deepCompare(actual, expected, comparator, anyPropertyKey, matchAgainstAnyProp, dontMatchWholeObject) {
        var actualType = getTypeForFilter(actual);
        var expectedType = getTypeForFilter(expected);
        if ((expectedType === 'string') && (expected.charAt(0) === '!')) {
          return !deepCompare(actual, expected.substring(1), comparator, anyPropertyKey, matchAgainstAnyProp);
        } else if (isArray(actual)) {
          return actual.some(function(item) {
            return deepCompare(item, expected, comparator, anyPropertyKey, matchAgainstAnyProp);
          });
        }
        switch (actualType) {
          case 'object':
            var key;
            if (matchAgainstAnyProp) {
              for (key in actual) {
                if ((key.charAt(0) !== '$') && deepCompare(actual[key], expected, comparator, anyPropertyKey, true)) {
                  return true;
                }
              }
              return dontMatchWholeObject ? false : deepCompare(actual, expected, comparator, anyPropertyKey, false);
            } else if (expectedType === 'object') {
              for (key in expected) {
                var expectedVal = expected[key];
                if (isFunction(expectedVal) || isUndefined(expectedVal)) {
                  continue;
                }
                var matchAnyProperty = key === anyPropertyKey;
                var actualVal = matchAnyProperty ? actual : actual[key];
                if (!deepCompare(actualVal, expectedVal, comparator, anyPropertyKey, matchAnyProperty, matchAnyProperty)) {
                  return false;
                }
              }
              return true;
            } else {
              return comparator(actual, expected);
            }
            break;
          case 'function':
            return false;
          default:
            return comparator(actual, expected);
        }
      }
      function getTypeForFilter(val) {
        return (val === null) ? 'null' : typeof val;
      }
      var MAX_DIGITS = 22;
      var DECIMAL_SEP = '.';
      var ZERO_CHAR = '0';
      currencyFilter.$inject = ['$locale'];
      function currencyFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(amount, currencySymbol, fractionSize) {
          if (isUndefined(currencySymbol)) {
            currencySymbol = formats.CURRENCY_SYM;
          }
          if (isUndefined(fractionSize)) {
            fractionSize = formats.PATTERNS[1].maxFrac;
          }
          return (amount == null) ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(/\u00A4/g, currencySymbol);
        };
      }
      numberFilter.$inject = ['$locale'];
      function numberFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(number, fractionSize) {
          return (number == null) ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
        };
      }
      function parse(numStr) {
        var exponent = 0,
            digits,
            numberOfIntegerDigits;
        var i,
            j,
            zeros;
        if ((numberOfIntegerDigits = numStr.indexOf(DECIMAL_SEP)) > -1) {
          numStr = numStr.replace(DECIMAL_SEP, '');
        }
        if ((i = numStr.search(/e/i)) > 0) {
          if (numberOfIntegerDigits < 0)
            numberOfIntegerDigits = i;
          numberOfIntegerDigits += +numStr.slice(i + 1);
          numStr = numStr.substring(0, i);
        } else if (numberOfIntegerDigits < 0) {
          numberOfIntegerDigits = numStr.length;
        }
        for (i = 0; numStr.charAt(i) == ZERO_CHAR; i++) {}
        if (i == (zeros = numStr.length)) {
          digits = [0];
          numberOfIntegerDigits = 1;
        } else {
          zeros--;
          while (numStr.charAt(zeros) == ZERO_CHAR)
            zeros--;
          numberOfIntegerDigits -= i;
          digits = [];
          for (j = 0; i <= zeros; i++, j++) {
            digits[j] = +numStr.charAt(i);
          }
        }
        if (numberOfIntegerDigits > MAX_DIGITS) {
          digits = digits.splice(0, MAX_DIGITS - 1);
          exponent = numberOfIntegerDigits - 1;
          numberOfIntegerDigits = 1;
        }
        return {
          d: digits,
          e: exponent,
          i: numberOfIntegerDigits
        };
      }
      function roundNumber(parsedNumber, fractionSize, minFrac, maxFrac) {
        var digits = parsedNumber.d;
        var fractionLen = digits.length - parsedNumber.i;
        fractionSize = (isUndefined(fractionSize)) ? Math.min(Math.max(minFrac, fractionLen), maxFrac) : +fractionSize;
        var roundAt = fractionSize + parsedNumber.i;
        var digit = digits[roundAt];
        if (roundAt > 0) {
          digits.splice(Math.max(parsedNumber.i, roundAt));
          for (var j = roundAt; j < digits.length; j++) {
            digits[j] = 0;
          }
        } else {
          fractionLen = Math.max(0, fractionLen);
          parsedNumber.i = 1;
          digits.length = Math.max(1, roundAt = fractionSize + 1);
          digits[0] = 0;
          for (var i = 1; i < roundAt; i++)
            digits[i] = 0;
        }
        if (digit >= 5) {
          if (roundAt - 1 < 0) {
            for (var k = 0; k > roundAt; k--) {
              digits.unshift(0);
              parsedNumber.i++;
            }
            digits.unshift(1);
            parsedNumber.i++;
          } else {
            digits[roundAt - 1]++;
          }
        }
        for (; fractionLen < Math.max(0, fractionSize); fractionLen++)
          digits.push(0);
        var carry = digits.reduceRight(function(carry, d, i, digits) {
          d = d + carry;
          digits[i] = d % 10;
          return Math.floor(d / 10);
        }, 0);
        if (carry) {
          digits.unshift(carry);
          parsedNumber.i++;
        }
      }
      function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
        if (!(isString(number) || isNumber(number)) || isNaN(number))
          return '';
        var isInfinity = !isFinite(number);
        var isZero = false;
        var numStr = Math.abs(number) + '',
            formattedText = '',
            parsedNumber;
        if (isInfinity) {
          formattedText = '\u221e';
        } else {
          parsedNumber = parse(numStr);
          roundNumber(parsedNumber, fractionSize, pattern.minFrac, pattern.maxFrac);
          var digits = parsedNumber.d;
          var integerLen = parsedNumber.i;
          var exponent = parsedNumber.e;
          var decimals = [];
          isZero = digits.reduce(function(isZero, d) {
            return isZero && !d;
          }, true);
          while (integerLen < 0) {
            digits.unshift(0);
            integerLen++;
          }
          if (integerLen > 0) {
            decimals = digits.splice(integerLen, digits.length);
          } else {
            decimals = digits;
            digits = [0];
          }
          var groups = [];
          if (digits.length >= pattern.lgSize) {
            groups.unshift(digits.splice(-pattern.lgSize, digits.length).join(''));
          }
          while (digits.length > pattern.gSize) {
            groups.unshift(digits.splice(-pattern.gSize, digits.length).join(''));
          }
          if (digits.length) {
            groups.unshift(digits.join(''));
          }
          formattedText = groups.join(groupSep);
          if (decimals.length) {
            formattedText += decimalSep + decimals.join('');
          }
          if (exponent) {
            formattedText += 'e+' + exponent;
          }
        }
        if (number < 0 && !isZero) {
          return pattern.negPre + formattedText + pattern.negSuf;
        } else {
          return pattern.posPre + formattedText + pattern.posSuf;
        }
      }
      function padNumber(num, digits, trim, negWrap) {
        var neg = '';
        if (num < 0 || (negWrap && num <= 0)) {
          if (negWrap) {
            num = -num + 1;
          } else {
            num = -num;
            neg = '-';
          }
        }
        num = '' + num;
        while (num.length < digits)
          num = ZERO_CHAR + num;
        if (trim) {
          num = num.substr(num.length - digits);
        }
        return neg + num;
      }
      function dateGetter(name, size, offset, trim, negWrap) {
        offset = offset || 0;
        return function(date) {
          var value = date['get' + name]();
          if (offset > 0 || value > -offset) {
            value += offset;
          }
          if (value === 0 && offset == -12)
            value = 12;
          return padNumber(value, size, trim, negWrap);
        };
      }
      function dateStrGetter(name, shortForm, standAlone) {
        return function(date, formats) {
          var value = date['get' + name]();
          var propPrefix = (standAlone ? 'STANDALONE' : '') + (shortForm ? 'SHORT' : '');
          var get = uppercase(propPrefix + name);
          return formats[get][value];
        };
      }
      function timeZoneGetter(date, formats, offset) {
        var zone = -1 * offset;
        var paddedZone = (zone >= 0) ? "+" : "";
        paddedZone += padNumber(Math[zone > 0 ? 'floor' : 'ceil'](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
        return paddedZone;
      }
      function getFirstThursdayOfYear(year) {
        var dayOfWeekOnFirst = (new Date(year, 0, 1)).getDay();
        return new Date(year, 0, ((dayOfWeekOnFirst <= 4) ? 5 : 12) - dayOfWeekOnFirst);
      }
      function getThursdayThisWeek(datetime) {
        return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()));
      }
      function weekGetter(size) {
        return function(date) {
          var firstThurs = getFirstThursdayOfYear(date.getFullYear()),
              thisThurs = getThursdayThisWeek(date);
          var diff = +thisThurs - +firstThurs,
              result = 1 + Math.round(diff / 6.048e8);
          return padNumber(result, size);
        };
      }
      function ampmGetter(date, formats) {
        return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
      }
      function eraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
      }
      function longEraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
      }
      var DATE_FORMATS = {
        yyyy: dateGetter('FullYear', 4, 0, false, true),
        yy: dateGetter('FullYear', 2, 0, true, true),
        y: dateGetter('FullYear', 1, 0, false, true),
        MMMM: dateStrGetter('Month'),
        MMM: dateStrGetter('Month', true),
        MM: dateGetter('Month', 2, 1),
        M: dateGetter('Month', 1, 1),
        LLLL: dateStrGetter('Month', false, true),
        dd: dateGetter('Date', 2),
        d: dateGetter('Date', 1),
        HH: dateGetter('Hours', 2),
        H: dateGetter('Hours', 1),
        hh: dateGetter('Hours', 2, -12),
        h: dateGetter('Hours', 1, -12),
        mm: dateGetter('Minutes', 2),
        m: dateGetter('Minutes', 1),
        ss: dateGetter('Seconds', 2),
        s: dateGetter('Seconds', 1),
        sss: dateGetter('Milliseconds', 3),
        EEEE: dateStrGetter('Day'),
        EEE: dateStrGetter('Day', true),
        a: ampmGetter,
        Z: timeZoneGetter,
        ww: weekGetter(2),
        w: weekGetter(1),
        G: eraGetter,
        GG: eraGetter,
        GGG: eraGetter,
        GGGG: longEraGetter
      };
      var DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/,
          NUMBER_STRING = /^\-?\d+$/;
      dateFilter.$inject = ['$locale'];
      function dateFilter($locale) {
        var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        function jsonStringToDate(string) {
          var match;
          if (match = string.match(R_ISO8601_STR)) {
            var date = new Date(0),
                tzHour = 0,
                tzMin = 0,
                dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,
                timeSetter = match[8] ? date.setUTCHours : date.setHours;
            if (match[9]) {
              tzHour = toInt(match[9] + match[10]);
              tzMin = toInt(match[9] + match[11]);
            }
            dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
            var h = toInt(match[4] || 0) - tzHour;
            var m = toInt(match[5] || 0) - tzMin;
            var s = toInt(match[6] || 0);
            var ms = Math.round(parseFloat('0.' + (match[7] || 0)) * 1000);
            timeSetter.call(date, h, m, s, ms);
            return date;
          }
          return string;
        }
        return function(date, format, timezone) {
          var text = '',
              parts = [],
              fn,
              match;
          format = format || 'mediumDate';
          format = $locale.DATETIME_FORMATS[format] || format;
          if (isString(date)) {
            date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date);
          }
          if (isNumber(date)) {
            date = new Date(date);
          }
          if (!isDate(date) || !isFinite(date.getTime())) {
            return date;
          }
          while (format) {
            match = DATE_FORMATS_SPLIT.exec(format);
            if (match) {
              parts = concat(parts, match, 1);
              format = parts.pop();
            } else {
              parts.push(format);
              format = null;
            }
          }
          var dateTimezoneOffset = date.getTimezoneOffset();
          if (timezone) {
            dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
            date = convertTimezoneToLocal(date, timezone, true);
          }
          forEach(parts, function(value) {
            fn = DATE_FORMATS[value];
            text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) : value === "''" ? "'" : value.replace(/(^'|'$)/g, '').replace(/''/g, "'");
          });
          return text;
        };
      }
      function jsonFilter() {
        return function(object, spacing) {
          if (isUndefined(spacing)) {
            spacing = 2;
          }
          return toJson(object, spacing);
        };
      }
      var lowercaseFilter = valueFn(lowercase);
      var uppercaseFilter = valueFn(uppercase);
      function limitToFilter() {
        return function(input, limit, begin) {
          if (Math.abs(Number(limit)) === Infinity) {
            limit = Number(limit);
          } else {
            limit = toInt(limit);
          }
          if (isNaN(limit))
            return input;
          if (isNumber(input))
            input = input.toString();
          if (!isArrayLike(input))
            return input;
          begin = (!begin || isNaN(begin)) ? 0 : toInt(begin);
          begin = (begin < 0) ? Math.max(0, input.length + begin) : begin;
          if (limit >= 0) {
            return sliceFn(input, begin, begin + limit);
          } else {
            if (begin === 0) {
              return sliceFn(input, limit, input.length);
            } else {
              return sliceFn(input, Math.max(0, begin + limit), begin);
            }
          }
        };
      }
      function sliceFn(input, begin, end) {
        if (isString(input))
          return input.slice(begin, end);
        return slice.call(input, begin, end);
      }
      orderByFilter.$inject = ['$parse'];
      function orderByFilter($parse) {
        return function(array, sortPredicate, reverseOrder, compareFn) {
          if (array == null)
            return array;
          if (!isArrayLike(array)) {
            throw minErr('orderBy')('notarray', 'Expected array but received: {0}', array);
          }
          if (!isArray(sortPredicate)) {
            sortPredicate = [sortPredicate];
          }
          if (sortPredicate.length === 0) {
            sortPredicate = ['+'];
          }
          var predicates = processPredicates(sortPredicate);
          var descending = reverseOrder ? -1 : 1;
          var compare = isFunction(compareFn) ? compareFn : defaultCompare;
          var compareValues = Array.prototype.map.call(array, getComparisonObject);
          compareValues.sort(doComparison);
          array = compareValues.map(function(item) {
            return item.value;
          });
          return array;
          function getComparisonObject(value, index) {
            return {
              value: value,
              tieBreaker: {
                value: index,
                type: 'number',
                index: index
              },
              predicateValues: predicates.map(function(predicate) {
                return getPredicateValue(predicate.get(value), index);
              })
            };
          }
          function doComparison(v1, v2) {
            for (var i = 0,
                ii = predicates.length; i < ii; i++) {
              var result = compare(v1.predicateValues[i], v2.predicateValues[i]);
              if (result) {
                return result * predicates[i].descending * descending;
              }
            }
            return compare(v1.tieBreaker, v2.tieBreaker) * descending;
          }
        };
        function processPredicates(sortPredicates) {
          return sortPredicates.map(function(predicate) {
            var descending = 1,
                get = identity;
            if (isFunction(predicate)) {
              get = predicate;
            } else if (isString(predicate)) {
              if ((predicate.charAt(0) == '+' || predicate.charAt(0) == '-')) {
                descending = predicate.charAt(0) == '-' ? -1 : 1;
                predicate = predicate.substring(1);
              }
              if (predicate !== '') {
                get = $parse(predicate);
                if (get.constant) {
                  var key = get();
                  get = function(value) {
                    return value[key];
                  };
                }
              }
            }
            return {
              get: get,
              descending: descending
            };
          });
        }
        function isPrimitive(value) {
          switch (typeof value) {
            case 'number':
            case 'boolean':
            case 'string':
              return true;
            default:
              return false;
          }
        }
        function objectValue(value) {
          if (isFunction(value.valueOf)) {
            value = value.valueOf();
            if (isPrimitive(value))
              return value;
          }
          if (hasCustomToString(value)) {
            value = value.toString();
            if (isPrimitive(value))
              return value;
          }
          return value;
        }
        function getPredicateValue(value, index) {
          var type = typeof value;
          if (value === null) {
            type = 'string';
            value = 'null';
          } else if (type === 'object') {
            value = objectValue(value);
          }
          return {
            value: value,
            type: type,
            index: index
          };
        }
        function defaultCompare(v1, v2) {
          var result = 0;
          var type1 = v1.type;
          var type2 = v2.type;
          if (type1 === type2) {
            var value1 = v1.value;
            var value2 = v2.value;
            if (type1 === 'string') {
              value1 = value1.toLowerCase();
              value2 = value2.toLowerCase();
            } else if (type1 === 'object') {
              if (isObject(value1))
                value1 = v1.index;
              if (isObject(value2))
                value2 = v2.index;
            }
            if (value1 !== value2) {
              result = value1 < value2 ? -1 : 1;
            }
          } else {
            result = type1 < type2 ? -1 : 1;
          }
          return result;
        }
      }
      function ngDirective(directive) {
        if (isFunction(directive)) {
          directive = {link: directive};
        }
        directive.restrict = directive.restrict || 'AC';
        return valueFn(directive);
      }
      var htmlAnchorDirective = valueFn({
        restrict: 'E',
        compile: function(element, attr) {
          if (!attr.href && !attr.xlinkHref) {
            return function(scope, element) {
              if (element[0].nodeName.toLowerCase() !== 'a')
                return;
              var href = toString.call(element.prop('href')) === '[object SVGAnimatedString]' ? 'xlink:href' : 'href';
              element.on('click', function(event) {
                if (!element.attr(href)) {
                  event.preventDefault();
                }
              });
            };
          }
        }
      });
      var ngAttributeAliasDirectives = {};
      forEach(BOOLEAN_ATTR, function(propName, attrName) {
        if (propName == "multiple")
          return;
        function defaultLinkFn(scope, element, attr) {
          scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
            attr.$set(attrName, !!value);
          });
        }
        var normalized = directiveNormalize('ng-' + attrName);
        var linkFn = defaultLinkFn;
        if (propName === 'checked') {
          linkFn = function(scope, element, attr) {
            if (attr.ngModel !== attr[normalized]) {
              defaultLinkFn(scope, element, attr);
            }
          };
        }
        ngAttributeAliasDirectives[normalized] = function() {
          return {
            restrict: 'A',
            priority: 100,
            link: linkFn
          };
        };
      });
      forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
        ngAttributeAliasDirectives[ngAttr] = function() {
          return {
            priority: 100,
            link: function(scope, element, attr) {
              if (ngAttr === "ngPattern" && attr.ngPattern.charAt(0) == "/") {
                var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                if (match) {
                  attr.$set("ngPattern", new RegExp(match[1], match[2]));
                  return;
                }
              }
              scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
                attr.$set(ngAttr, value);
              });
            }
          };
        };
      });
      forEach(['src', 'srcset', 'href'], function(attrName) {
        var normalized = directiveNormalize('ng-' + attrName);
        ngAttributeAliasDirectives[normalized] = function() {
          return {
            priority: 99,
            link: function(scope, element, attr) {
              var propName = attrName,
                  name = attrName;
              if (attrName === 'href' && toString.call(element.prop('href')) === '[object SVGAnimatedString]') {
                name = 'xlinkHref';
                attr.$attr[name] = 'xlink:href';
                propName = null;
              }
              attr.$observe(normalized, function(value) {
                if (!value) {
                  if (attrName === 'href') {
                    attr.$set(name, null);
                  }
                  return;
                }
                attr.$set(name, value);
                if (msie && propName)
                  element.prop(propName, attr[name]);
              });
            }
          };
        };
      });
      var nullFormCtrl = {
        $addControl: noop,
        $$renameControl: nullFormRenameControl,
        $removeControl: noop,
        $setValidity: noop,
        $setDirty: noop,
        $setPristine: noop,
        $setSubmitted: noop
      },
          SUBMITTED_CLASS = 'ng-submitted';
      function nullFormRenameControl(control, name) {
        control.$name = name;
      }
      FormController.$inject = ['$element', '$attrs', '$scope', '$animate', '$interpolate'];
      function FormController(element, attrs, $scope, $animate, $interpolate) {
        var form = this,
            controls = [];
        form.$error = {};
        form.$$success = {};
        form.$pending = undefined;
        form.$name = $interpolate(attrs.name || attrs.ngForm || '')($scope);
        form.$dirty = false;
        form.$pristine = true;
        form.$valid = true;
        form.$invalid = false;
        form.$submitted = false;
        form.$$parentForm = nullFormCtrl;
        form.$rollbackViewValue = function() {
          forEach(controls, function(control) {
            control.$rollbackViewValue();
          });
        };
        form.$commitViewValue = function() {
          forEach(controls, function(control) {
            control.$commitViewValue();
          });
        };
        form.$addControl = function(control) {
          assertNotHasOwnProperty(control.$name, 'input');
          controls.push(control);
          if (control.$name) {
            form[control.$name] = control;
          }
          control.$$parentForm = form;
        };
        form.$$renameControl = function(control, newName) {
          var oldName = control.$name;
          if (form[oldName] === control) {
            delete form[oldName];
          }
          form[newName] = control;
          control.$name = newName;
        };
        form.$removeControl = function(control) {
          if (control.$name && form[control.$name] === control) {
            delete form[control.$name];
          }
          forEach(form.$pending, function(value, name) {
            form.$setValidity(name, null, control);
          });
          forEach(form.$error, function(value, name) {
            form.$setValidity(name, null, control);
          });
          forEach(form.$$success, function(value, name) {
            form.$setValidity(name, null, control);
          });
          arrayRemove(controls, control);
          control.$$parentForm = nullFormCtrl;
        };
        addSetValidityMethod({
          ctrl: this,
          $element: element,
          set: function(object, property, controller) {
            var list = object[property];
            if (!list) {
              object[property] = [controller];
            } else {
              var index = list.indexOf(controller);
              if (index === -1) {
                list.push(controller);
              }
            }
          },
          unset: function(object, property, controller) {
            var list = object[property];
            if (!list) {
              return;
            }
            arrayRemove(list, controller);
            if (list.length === 0) {
              delete object[property];
            }
          },
          $animate: $animate
        });
        form.$setDirty = function() {
          $animate.removeClass(element, PRISTINE_CLASS);
          $animate.addClass(element, DIRTY_CLASS);
          form.$dirty = true;
          form.$pristine = false;
          form.$$parentForm.$setDirty();
        };
        form.$setPristine = function() {
          $animate.setClass(element, PRISTINE_CLASS, DIRTY_CLASS + ' ' + SUBMITTED_CLASS);
          form.$dirty = false;
          form.$pristine = true;
          form.$submitted = false;
          forEach(controls, function(control) {
            control.$setPristine();
          });
        };
        form.$setUntouched = function() {
          forEach(controls, function(control) {
            control.$setUntouched();
          });
        };
        form.$setSubmitted = function() {
          $animate.addClass(element, SUBMITTED_CLASS);
          form.$submitted = true;
          form.$$parentForm.$setSubmitted();
        };
      }
      var formDirectiveFactory = function(isNgForm) {
        return ['$timeout', '$parse', function($timeout, $parse) {
          var formDirective = {
            name: 'form',
            restrict: isNgForm ? 'EAC' : 'E',
            require: ['form', '^^?form'],
            controller: FormController,
            compile: function ngFormCompile(formElement, attr) {
              formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
              var nameAttr = attr.name ? 'name' : (isNgForm && attr.ngForm ? 'ngForm' : false);
              return {pre: function ngFormPreLink(scope, formElement, attr, ctrls) {
                  var controller = ctrls[0];
                  if (!('action' in attr)) {
                    var handleFormSubmission = function(event) {
                      scope.$apply(function() {
                        controller.$commitViewValue();
                        controller.$setSubmitted();
                      });
                      event.preventDefault();
                    };
                    addEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                    formElement.on('$destroy', function() {
                      $timeout(function() {
                        removeEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                      }, 0, false);
                    });
                  }
                  var parentFormCtrl = ctrls[1] || controller.$$parentForm;
                  parentFormCtrl.$addControl(controller);
                  var setter = nameAttr ? getSetter(controller.$name) : noop;
                  if (nameAttr) {
                    setter(scope, controller);
                    attr.$observe(nameAttr, function(newValue) {
                      if (controller.$name === newValue)
                        return;
                      setter(scope, undefined);
                      controller.$$parentForm.$$renameControl(controller, newValue);
                      setter = getSetter(controller.$name);
                      setter(scope, controller);
                    });
                  }
                  formElement.on('$destroy', function() {
                    controller.$$parentForm.$removeControl(controller);
                    setter(scope, undefined);
                    extend(controller, nullFormCtrl);
                  });
                }};
            }
          };
          return formDirective;
          function getSetter(expression) {
            if (expression === '') {
              return $parse('this[""]').assign;
            }
            return $parse(expression).assign || noop;
          }
        }];
      };
      var formDirective = formDirectiveFactory();
      var ngFormDirective = formDirectiveFactory(true);
      var ISO_DATE_REGEXP = /^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/;
      var URL_REGEXP = /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:/?#]+|\[[a-f\d:]+\])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i;
      var EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+\/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&'*+\/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/;
      var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/;
      var DATE_REGEXP = /^(\d{4,})-(\d{2})-(\d{2})$/;
      var DATETIMELOCAL_REGEXP = /^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
      var WEEK_REGEXP = /^(\d{4,})-W(\d\d)$/;
      var MONTH_REGEXP = /^(\d{4,})-(\d\d)$/;
      var TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
      var PARTIAL_VALIDATION_EVENTS = 'keydown wheel mousedown';
      var PARTIAL_VALIDATION_TYPES = createMap();
      forEach('date,datetime-local,month,time,week'.split(','), function(type) {
        PARTIAL_VALIDATION_TYPES[type] = true;
      });
      var inputType = {
        'text': textInputType,
        'date': createDateInputType('date', DATE_REGEXP, createDateParser(DATE_REGEXP, ['yyyy', 'MM', 'dd']), 'yyyy-MM-dd'),
        'datetime-local': createDateInputType('datetimelocal', DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, ['yyyy', 'MM', 'dd', 'HH', 'mm', 'ss', 'sss']), 'yyyy-MM-ddTHH:mm:ss.sss'),
        'time': createDateInputType('time', TIME_REGEXP, createDateParser(TIME_REGEXP, ['HH', 'mm', 'ss', 'sss']), 'HH:mm:ss.sss'),
        'week': createDateInputType('week', WEEK_REGEXP, weekParser, 'yyyy-Www'),
        'month': createDateInputType('month', MONTH_REGEXP, createDateParser(MONTH_REGEXP, ['yyyy', 'MM']), 'yyyy-MM'),
        'number': numberInputType,
        'url': urlInputType,
        'email': emailInputType,
        'radio': radioInputType,
        'checkbox': checkboxInputType,
        'hidden': noop,
        'button': noop,
        'submit': noop,
        'reset': noop,
        'file': noop
      };
      function stringBasedInputType(ctrl) {
        ctrl.$formatters.push(function(value) {
          return ctrl.$isEmpty(value) ? value : value.toString();
        });
      }
      function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
      }
      function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        var type = lowercase(element[0].type);
        if (!$sniffer.android) {
          var composing = false;
          element.on('compositionstart', function() {
            composing = true;
          });
          element.on('compositionend', function() {
            composing = false;
            listener();
          });
        }
        var timeout;
        var listener = function(ev) {
          if (timeout) {
            $browser.defer.cancel(timeout);
            timeout = null;
          }
          if (composing)
            return;
          var value = element.val(),
              event = ev && ev.type;
          if (type !== 'password' && (!attr.ngTrim || attr.ngTrim !== 'false')) {
            value = trim(value);
          }
          if (ctrl.$viewValue !== value || (value === '' && ctrl.$$hasNativeValidators)) {
            ctrl.$setViewValue(value, event);
          }
        };
        if ($sniffer.hasEvent('input')) {
          element.on('input', listener);
        } else {
          var deferListener = function(ev, input, origValue) {
            if (!timeout) {
              timeout = $browser.defer(function() {
                timeout = null;
                if (!input || input.value !== origValue) {
                  listener(ev);
                }
              });
            }
          };
          element.on('keydown', function(event) {
            var key = event.keyCode;
            if (key === 91 || (15 < key && key < 19) || (37 <= key && key <= 40))
              return;
            deferListener(event, this, this.value);
          });
          if ($sniffer.hasEvent('paste')) {
            element.on('paste cut', deferListener);
          }
        }
        element.on('change', listener);
        if (PARTIAL_VALIDATION_TYPES[type] && ctrl.$$hasNativeValidators && type === attr.type) {
          element.on(PARTIAL_VALIDATION_EVENTS, function(ev) {
            if (!timeout) {
              var validity = this[VALIDITY_STATE_PROPERTY];
              var origBadInput = validity.badInput;
              var origTypeMismatch = validity.typeMismatch;
              timeout = $browser.defer(function() {
                timeout = null;
                if (validity.badInput !== origBadInput || validity.typeMismatch !== origTypeMismatch) {
                  listener(ev);
                }
              });
            }
          });
        }
        ctrl.$render = function() {
          var value = ctrl.$isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue;
          if (element.val() !== value) {
            element.val(value);
          }
        };
      }
      function weekParser(isoWeek, existingDate) {
        if (isDate(isoWeek)) {
          return isoWeek;
        }
        if (isString(isoWeek)) {
          WEEK_REGEXP.lastIndex = 0;
          var parts = WEEK_REGEXP.exec(isoWeek);
          if (parts) {
            var year = +parts[1],
                week = +parts[2],
                hours = 0,
                minutes = 0,
                seconds = 0,
                milliseconds = 0,
                firstThurs = getFirstThursdayOfYear(year),
                addDays = (week - 1) * 7;
            if (existingDate) {
              hours = existingDate.getHours();
              minutes = existingDate.getMinutes();
              seconds = existingDate.getSeconds();
              milliseconds = existingDate.getMilliseconds();
            }
            return new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
          }
        }
        return NaN;
      }
      function createDateParser(regexp, mapping) {
        return function(iso, date) {
          var parts,
              map;
          if (isDate(iso)) {
            return iso;
          }
          if (isString(iso)) {
            if (iso.charAt(0) == '"' && iso.charAt(iso.length - 1) == '"') {
              iso = iso.substring(1, iso.length - 1);
            }
            if (ISO_DATE_REGEXP.test(iso)) {
              return new Date(iso);
            }
            regexp.lastIndex = 0;
            parts = regexp.exec(iso);
            if (parts) {
              parts.shift();
              if (date) {
                map = {
                  yyyy: date.getFullYear(),
                  MM: date.getMonth() + 1,
                  dd: date.getDate(),
                  HH: date.getHours(),
                  mm: date.getMinutes(),
                  ss: date.getSeconds(),
                  sss: date.getMilliseconds() / 1000
                };
              } else {
                map = {
                  yyyy: 1970,
                  MM: 1,
                  dd: 1,
                  HH: 0,
                  mm: 0,
                  ss: 0,
                  sss: 0
                };
              }
              forEach(parts, function(part, index) {
                if (index < mapping.length) {
                  map[mapping[index]] = +part;
                }
              });
              return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1000 || 0);
            }
          }
          return NaN;
        };
      }
      function createDateInputType(type, regexp, parseDate, format) {
        return function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
          badInputChecker(scope, element, attr, ctrl);
          baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
          var timezone = ctrl && ctrl.$options && ctrl.$options.timezone;
          var previousDate;
          ctrl.$$parserName = type;
          ctrl.$parsers.push(function(value) {
            if (ctrl.$isEmpty(value))
              return null;
            if (regexp.test(value)) {
              var parsedDate = parseDate(value, previousDate);
              if (timezone) {
                parsedDate = convertTimezoneToLocal(parsedDate, timezone);
              }
              return parsedDate;
            }
            return undefined;
          });
          ctrl.$formatters.push(function(value) {
            if (value && !isDate(value)) {
              throw ngModelMinErr('datefmt', 'Expected `{0}` to be a date', value);
            }
            if (isValidDate(value)) {
              previousDate = value;
              if (previousDate && timezone) {
                previousDate = convertTimezoneToLocal(previousDate, timezone, true);
              }
              return $filter('date')(value, format, timezone);
            } else {
              previousDate = null;
              return '';
            }
          });
          if (isDefined(attr.min) || attr.ngMin) {
            var minVal;
            ctrl.$validators.min = function(value) {
              return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
            };
            attr.$observe('min', function(val) {
              minVal = parseObservedDateValue(val);
              ctrl.$validate();
            });
          }
          if (isDefined(attr.max) || attr.ngMax) {
            var maxVal;
            ctrl.$validators.max = function(value) {
              return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
            };
            attr.$observe('max', function(val) {
              maxVal = parseObservedDateValue(val);
              ctrl.$validate();
            });
          }
          function isValidDate(value) {
            return value && !(value.getTime && value.getTime() !== value.getTime());
          }
          function parseObservedDateValue(val) {
            return isDefined(val) && !isDate(val) ? parseDate(val) || undefined : val;
          }
        };
      }
      function badInputChecker(scope, element, attr, ctrl) {
        var node = element[0];
        var nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
        if (nativeValidation) {
          ctrl.$parsers.push(function(value) {
            var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
            return validity.badInput || validity.typeMismatch ? undefined : value;
          });
        }
      }
      function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        badInputChecker(scope, element, attr, ctrl);
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        ctrl.$$parserName = 'number';
        ctrl.$parsers.push(function(value) {
          if (ctrl.$isEmpty(value))
            return null;
          if (NUMBER_REGEXP.test(value))
            return parseFloat(value);
          return undefined;
        });
        ctrl.$formatters.push(function(value) {
          if (!ctrl.$isEmpty(value)) {
            if (!isNumber(value)) {
              throw ngModelMinErr('numfmt', 'Expected `{0}` to be a number', value);
            }
            value = value.toString();
          }
          return value;
        });
        if (isDefined(attr.min) || attr.ngMin) {
          var minVal;
          ctrl.$validators.min = function(value) {
            return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
          };
          attr.$observe('min', function(val) {
            if (isDefined(val) && !isNumber(val)) {
              val = parseFloat(val);
            }
            minVal = isNumber(val) && !isNaN(val) ? val : undefined;
            ctrl.$validate();
          });
        }
        if (isDefined(attr.max) || attr.ngMax) {
          var maxVal;
          ctrl.$validators.max = function(value) {
            return ctrl.$isEmpty(value) || isUndefined(maxVal) || value <= maxVal;
          };
          attr.$observe('max', function(val) {
            if (isDefined(val) && !isNumber(val)) {
              val = parseFloat(val);
            }
            maxVal = isNumber(val) && !isNaN(val) ? val : undefined;
            ctrl.$validate();
          });
        }
      }
      function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$$parserName = 'url';
        ctrl.$validators.url = function(modelValue, viewValue) {
          var value = modelValue || viewValue;
          return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
        };
      }
      function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$$parserName = 'email';
        ctrl.$validators.email = function(modelValue, viewValue) {
          var value = modelValue || viewValue;
          return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
        };
      }
      function radioInputType(scope, element, attr, ctrl) {
        if (isUndefined(attr.name)) {
          element.attr('name', nextUid());
        }
        var listener = function(ev) {
          if (element[0].checked) {
            ctrl.$setViewValue(attr.value, ev && ev.type);
          }
        };
        element.on('click', listener);
        ctrl.$render = function() {
          var value = attr.value;
          element[0].checked = (value == ctrl.$viewValue);
        };
        attr.$observe('value', ctrl.$render);
      }
      function parseConstantExpr($parse, context, name, expression, fallback) {
        var parseFn;
        if (isDefined(expression)) {
          parseFn = $parse(expression);
          if (!parseFn.constant) {
            throw ngModelMinErr('constexpr', 'Expected constant expression for `{0}`, but saw ' + '`{1}`.', name, expression);
          }
          return parseFn(context);
        }
        return fallback;
      }
      function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
        var trueValue = parseConstantExpr($parse, scope, 'ngTrueValue', attr.ngTrueValue, true);
        var falseValue = parseConstantExpr($parse, scope, 'ngFalseValue', attr.ngFalseValue, false);
        var listener = function(ev) {
          ctrl.$setViewValue(element[0].checked, ev && ev.type);
        };
        element.on('click', listener);
        ctrl.$render = function() {
          element[0].checked = ctrl.$viewValue;
        };
        ctrl.$isEmpty = function(value) {
          return value === false;
        };
        ctrl.$formatters.push(function(value) {
          return equals(value, trueValue);
        });
        ctrl.$parsers.push(function(value) {
          return value ? trueValue : falseValue;
        });
      }
      var inputDirective = ['$browser', '$sniffer', '$filter', '$parse', function($browser, $sniffer, $filter, $parse) {
        return {
          restrict: 'E',
          require: ['?ngModel'],
          link: {pre: function(scope, element, attr, ctrls) {
              if (ctrls[0]) {
                (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse);
              }
            }}
        };
      }];
      var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
      var ngValueDirective = function() {
        return {
          restrict: 'A',
          priority: 100,
          compile: function(tpl, tplAttr) {
            if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
              return function ngValueConstantLink(scope, elm, attr) {
                attr.$set('value', scope.$eval(attr.ngValue));
              };
            } else {
              return function ngValueLink(scope, elm, attr) {
                scope.$watch(attr.ngValue, function valueWatchAction(value) {
                  attr.$set('value', value);
                });
              };
            }
          }
        };
      };
      var ngBindDirective = ['$compile', function($compile) {
        return {
          restrict: 'AC',
          compile: function ngBindCompile(templateElement) {
            $compile.$$addBindingClass(templateElement);
            return function ngBindLink(scope, element, attr) {
              $compile.$$addBindingInfo(element, attr.ngBind);
              element = element[0];
              scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
                element.textContent = isUndefined(value) ? '' : value;
              });
            };
          }
        };
      }];
      var ngBindTemplateDirective = ['$interpolate', '$compile', function($interpolate, $compile) {
        return {compile: function ngBindTemplateCompile(templateElement) {
            $compile.$$addBindingClass(templateElement);
            return function ngBindTemplateLink(scope, element, attr) {
              var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
              $compile.$$addBindingInfo(element, interpolateFn.expressions);
              element = element[0];
              attr.$observe('ngBindTemplate', function(value) {
                element.textContent = isUndefined(value) ? '' : value;
              });
            };
          }};
      }];
      var ngBindHtmlDirective = ['$sce', '$parse', '$compile', function($sce, $parse, $compile) {
        return {
          restrict: 'A',
          compile: function ngBindHtmlCompile(tElement, tAttrs) {
            var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);
            var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function sceValueOf(val) {
              return $sce.valueOf(val);
            });
            $compile.$$addBindingClass(tElement);
            return function ngBindHtmlLink(scope, element, attr) {
              $compile.$$addBindingInfo(element, attr.ngBindHtml);
              scope.$watch(ngBindHtmlWatch, function ngBindHtmlWatchAction() {
                var value = ngBindHtmlGetter(scope);
                element.html($sce.getTrustedHtml(value) || '');
              });
            };
          }
        };
      }];
      var ngChangeDirective = valueFn({
        restrict: 'A',
        require: 'ngModel',
        link: function(scope, element, attr, ctrl) {
          ctrl.$viewChangeListeners.push(function() {
            scope.$eval(attr.ngChange);
          });
        }
      });
      function classDirective(name, selector) {
        name = 'ngClass' + name;
        return ['$animate', function($animate) {
          return {
            restrict: 'AC',
            link: function(scope, element, attr) {
              var oldVal;
              scope.$watch(attr[name], ngClassWatchAction, true);
              attr.$observe('class', function(value) {
                ngClassWatchAction(scope.$eval(attr[name]));
              });
              if (name !== 'ngClass') {
                scope.$watch('$index', function($index, old$index) {
                  var mod = $index & 1;
                  if (mod !== (old$index & 1)) {
                    var classes = arrayClasses(scope.$eval(attr[name]));
                    mod === selector ? addClasses(classes) : removeClasses(classes);
                  }
                });
              }
              function addClasses(classes) {
                var newClasses = digestClassCounts(classes, 1);
                attr.$addClass(newClasses);
              }
              function removeClasses(classes) {
                var newClasses = digestClassCounts(classes, -1);
                attr.$removeClass(newClasses);
              }
              function digestClassCounts(classes, count) {
                var classCounts = element.data('$classCounts') || createMap();
                var classesToUpdate = [];
                forEach(classes, function(className) {
                  if (count > 0 || classCounts[className]) {
                    classCounts[className] = (classCounts[className] || 0) + count;
                    if (classCounts[className] === +(count > 0)) {
                      classesToUpdate.push(className);
                    }
                  }
                });
                element.data('$classCounts', classCounts);
                return classesToUpdate.join(' ');
              }
              function updateClasses(oldClasses, newClasses) {
                var toAdd = arrayDifference(newClasses, oldClasses);
                var toRemove = arrayDifference(oldClasses, newClasses);
                toAdd = digestClassCounts(toAdd, 1);
                toRemove = digestClassCounts(toRemove, -1);
                if (toAdd && toAdd.length) {
                  $animate.addClass(element, toAdd);
                }
                if (toRemove && toRemove.length) {
                  $animate.removeClass(element, toRemove);
                }
              }
              function ngClassWatchAction(newVal) {
                if (selector === true || (scope.$index & 1) === selector) {
                  var newClasses = arrayClasses(newVal || []);
                  if (!oldVal) {
                    addClasses(newClasses);
                  } else if (!equals(newVal, oldVal)) {
                    var oldClasses = arrayClasses(oldVal);
                    updateClasses(oldClasses, newClasses);
                  }
                }
                if (isArray(newVal)) {
                  oldVal = newVal.map(function(v) {
                    return shallowCopy(v);
                  });
                } else {
                  oldVal = shallowCopy(newVal);
                }
              }
            }
          };
          function arrayDifference(tokens1, tokens2) {
            var values = [];
            outer: for (var i = 0; i < tokens1.length; i++) {
              var token = tokens1[i];
              for (var j = 0; j < tokens2.length; j++) {
                if (token == tokens2[j])
                  continue outer;
              }
              values.push(token);
            }
            return values;
          }
          function arrayClasses(classVal) {
            var classes = [];
            if (isArray(classVal)) {
              forEach(classVal, function(v) {
                classes = classes.concat(arrayClasses(v));
              });
              return classes;
            } else if (isString(classVal)) {
              return classVal.split(' ');
            } else if (isObject(classVal)) {
              forEach(classVal, function(v, k) {
                if (v) {
                  classes = classes.concat(k.split(' '));
                }
              });
              return classes;
            }
            return classVal;
          }
        }];
      }
      var ngClassDirective = classDirective('', true);
      var ngClassOddDirective = classDirective('Odd', 0);
      var ngClassEvenDirective = classDirective('Even', 1);
      var ngCloakDirective = ngDirective({compile: function(element, attr) {
          attr.$set('ngCloak', undefined);
          element.removeClass('ng-cloak');
        }});
      var ngControllerDirective = [function() {
        return {
          restrict: 'A',
          scope: true,
          controller: '@',
          priority: 500
        };
      }];
      var ngEventDirectives = {};
      var forceAsyncEvents = {
        'blur': true,
        'focus': true
      };
      forEach('click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste'.split(' '), function(eventName) {
        var directiveName = directiveNormalize('ng-' + eventName);
        ngEventDirectives[directiveName] = ['$parse', '$rootScope', function($parse, $rootScope) {
          return {
            restrict: 'A',
            compile: function($element, attr) {
              var fn = $parse(attr[directiveName], null, true);
              return function ngEventHandler(scope, element) {
                element.on(eventName, function(event) {
                  var callback = function() {
                    fn(scope, {$event: event});
                  };
                  if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                    scope.$evalAsync(callback);
                  } else {
                    scope.$apply(callback);
                  }
                });
              };
            }
          };
        }];
      });
      var ngIfDirective = ['$animate', '$compile', function($animate, $compile) {
        return {
          multiElement: true,
          transclude: 'element',
          priority: 600,
          terminal: true,
          restrict: 'A',
          $$tlb: true,
          link: function($scope, $element, $attr, ctrl, $transclude) {
            var block,
                childScope,
                previousElements;
            $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
              if (value) {
                if (!childScope) {
                  $transclude(function(clone, newScope) {
                    childScope = newScope;
                    clone[clone.length++] = $compile.$$createComment('end ngIf', $attr.ngIf);
                    block = {clone: clone};
                    $animate.enter(clone, $element.parent(), $element);
                  });
                }
              } else {
                if (previousElements) {
                  previousElements.remove();
                  previousElements = null;
                }
                if (childScope) {
                  childScope.$destroy();
                  childScope = null;
                }
                if (block) {
                  previousElements = getBlockNodes(block.clone);
                  $animate.leave(previousElements).then(function() {
                    previousElements = null;
                  });
                  block = null;
                }
              }
            });
          }
        };
      }];
      var ngIncludeDirective = ['$templateRequest', '$anchorScroll', '$animate', function($templateRequest, $anchorScroll, $animate) {
        return {
          restrict: 'ECA',
          priority: 400,
          terminal: true,
          transclude: 'element',
          controller: angular.noop,
          compile: function(element, attr) {
            var srcExp = attr.ngInclude || attr.src,
                onloadExp = attr.onload || '',
                autoScrollExp = attr.autoscroll;
            return function(scope, $element, $attr, ctrl, $transclude) {
              var changeCounter = 0,
                  currentScope,
                  previousElement,
                  currentElement;
              var cleanupLastIncludeContent = function() {
                if (previousElement) {
                  previousElement.remove();
                  previousElement = null;
                }
                if (currentScope) {
                  currentScope.$destroy();
                  currentScope = null;
                }
                if (currentElement) {
                  $animate.leave(currentElement).then(function() {
                    previousElement = null;
                  });
                  previousElement = currentElement;
                  currentElement = null;
                }
              };
              scope.$watch(srcExp, function ngIncludeWatchAction(src) {
                var afterAnimation = function() {
                  if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                    $anchorScroll();
                  }
                };
                var thisChangeId = ++changeCounter;
                if (src) {
                  $templateRequest(src, true).then(function(response) {
                    if (scope.$$destroyed)
                      return;
                    if (thisChangeId !== changeCounter)
                      return;
                    var newScope = scope.$new();
                    ctrl.template = response;
                    var clone = $transclude(newScope, function(clone) {
                      cleanupLastIncludeContent();
                      $animate.enter(clone, null, $element).then(afterAnimation);
                    });
                    currentScope = newScope;
                    currentElement = clone;
                    currentScope.$emit('$includeContentLoaded', src);
                    scope.$eval(onloadExp);
                  }, function() {
                    if (scope.$$destroyed)
                      return;
                    if (thisChangeId === changeCounter) {
                      cleanupLastIncludeContent();
                      scope.$emit('$includeContentError', src);
                    }
                  });
                  scope.$emit('$includeContentRequested', src);
                } else {
                  cleanupLastIncludeContent();
                  ctrl.template = null;
                }
              });
            };
          }
        };
      }];
      var ngIncludeFillContentDirective = ['$compile', function($compile) {
        return {
          restrict: 'ECA',
          priority: -400,
          require: 'ngInclude',
          link: function(scope, $element, $attr, ctrl) {
            if (toString.call($element[0]).match(/SVG/)) {
              $element.empty();
              $compile(jqLiteBuildFragment(ctrl.template, window.document).childNodes)(scope, function namespaceAdaptedClone(clone) {
                $element.append(clone);
              }, {futureParentElement: $element});
              return;
            }
            $element.html(ctrl.template);
            $compile($element.contents())(scope);
          }
        };
      }];
      var ngInitDirective = ngDirective({
        priority: 450,
        compile: function() {
          return {pre: function(scope, element, attrs) {
              scope.$eval(attrs.ngInit);
            }};
        }
      });
      var ngListDirective = function() {
        return {
          restrict: 'A',
          priority: 100,
          require: 'ngModel',
          link: function(scope, element, attr, ctrl) {
            var ngList = element.attr(attr.$attr.ngList) || ', ';
            var trimValues = attr.ngTrim !== 'false';
            var separator = trimValues ? trim(ngList) : ngList;
            var parse = function(viewValue) {
              if (isUndefined(viewValue))
                return;
              var list = [];
              if (viewValue) {
                forEach(viewValue.split(separator), function(value) {
                  if (value)
                    list.push(trimValues ? trim(value) : value);
                });
              }
              return list;
            };
            ctrl.$parsers.push(parse);
            ctrl.$formatters.push(function(value) {
              if (isArray(value)) {
                return value.join(ngList);
              }
              return undefined;
            });
            ctrl.$isEmpty = function(value) {
              return !value || !value.length;
            };
          }
        };
      };
      var VALID_CLASS = 'ng-valid',
          INVALID_CLASS = 'ng-invalid',
          PRISTINE_CLASS = 'ng-pristine',
          DIRTY_CLASS = 'ng-dirty',
          UNTOUCHED_CLASS = 'ng-untouched',
          TOUCHED_CLASS = 'ng-touched',
          PENDING_CLASS = 'ng-pending',
          EMPTY_CLASS = 'ng-empty',
          NOT_EMPTY_CLASS = 'ng-not-empty';
      var ngModelMinErr = minErr('ngModel');
      var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$parse', '$animate', '$timeout', '$rootScope', '$q', '$interpolate', function($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $rootScope, $q, $interpolate) {
        this.$viewValue = Number.NaN;
        this.$modelValue = Number.NaN;
        this.$$rawModelValue = undefined;
        this.$validators = {};
        this.$asyncValidators = {};
        this.$parsers = [];
        this.$formatters = [];
        this.$viewChangeListeners = [];
        this.$untouched = true;
        this.$touched = false;
        this.$pristine = true;
        this.$dirty = false;
        this.$valid = true;
        this.$invalid = false;
        this.$error = {};
        this.$$success = {};
        this.$pending = undefined;
        this.$name = $interpolate($attr.name || '', false)($scope);
        this.$$parentForm = nullFormCtrl;
        var parsedNgModel = $parse($attr.ngModel),
            parsedNgModelAssign = parsedNgModel.assign,
            ngModelGet = parsedNgModel,
            ngModelSet = parsedNgModelAssign,
            pendingDebounce = null,
            parserValid,
            ctrl = this;
        this.$$setOptions = function(options) {
          ctrl.$options = options;
          if (options && options.getterSetter) {
            var invokeModelGetter = $parse($attr.ngModel + '()'),
                invokeModelSetter = $parse($attr.ngModel + '($$$p)');
            ngModelGet = function($scope) {
              var modelValue = parsedNgModel($scope);
              if (isFunction(modelValue)) {
                modelValue = invokeModelGetter($scope);
              }
              return modelValue;
            };
            ngModelSet = function($scope, newValue) {
              if (isFunction(parsedNgModel($scope))) {
                invokeModelSetter($scope, {$$$p: newValue});
              } else {
                parsedNgModelAssign($scope, newValue);
              }
            };
          } else if (!parsedNgModel.assign) {
            throw ngModelMinErr('nonassign', "Expression '{0}' is non-assignable. Element: {1}", $attr.ngModel, startingTag($element));
          }
        };
        this.$render = noop;
        this.$isEmpty = function(value) {
          return isUndefined(value) || value === '' || value === null || value !== value;
        };
        this.$$updateEmptyClasses = function(value) {
          if (ctrl.$isEmpty(value)) {
            $animate.removeClass($element, NOT_EMPTY_CLASS);
            $animate.addClass($element, EMPTY_CLASS);
          } else {
            $animate.removeClass($element, EMPTY_CLASS);
            $animate.addClass($element, NOT_EMPTY_CLASS);
          }
        };
        var currentValidationRunId = 0;
        addSetValidityMethod({
          ctrl: this,
          $element: $element,
          set: function(object, property) {
            object[property] = true;
          },
          unset: function(object, property) {
            delete object[property];
          },
          $animate: $animate
        });
        this.$setPristine = function() {
          ctrl.$dirty = false;
          ctrl.$pristine = true;
          $animate.removeClass($element, DIRTY_CLASS);
          $animate.addClass($element, PRISTINE_CLASS);
        };
        this.$setDirty = function() {
          ctrl.$dirty = true;
          ctrl.$pristine = false;
          $animate.removeClass($element, PRISTINE_CLASS);
          $animate.addClass($element, DIRTY_CLASS);
          ctrl.$$parentForm.$setDirty();
        };
        this.$setUntouched = function() {
          ctrl.$touched = false;
          ctrl.$untouched = true;
          $animate.setClass($element, UNTOUCHED_CLASS, TOUCHED_CLASS);
        };
        this.$setTouched = function() {
          ctrl.$touched = true;
          ctrl.$untouched = false;
          $animate.setClass($element, TOUCHED_CLASS, UNTOUCHED_CLASS);
        };
        this.$rollbackViewValue = function() {
          $timeout.cancel(pendingDebounce);
          ctrl.$viewValue = ctrl.$$lastCommittedViewValue;
          ctrl.$render();
        };
        this.$validate = function() {
          if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
            return;
          }
          var viewValue = ctrl.$$lastCommittedViewValue;
          var modelValue = ctrl.$$rawModelValue;
          var prevValid = ctrl.$valid;
          var prevModelValue = ctrl.$modelValue;
          var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
          ctrl.$$runValidators(modelValue, viewValue, function(allValid) {
            if (!allowInvalid && prevValid !== allValid) {
              ctrl.$modelValue = allValid ? modelValue : undefined;
              if (ctrl.$modelValue !== prevModelValue) {
                ctrl.$$writeModelToScope();
              }
            }
          });
        };
        this.$$runValidators = function(modelValue, viewValue, doneCallback) {
          currentValidationRunId++;
          var localValidationRunId = currentValidationRunId;
          if (!processParseErrors()) {
            validationDone(false);
            return;
          }
          if (!processSyncValidators()) {
            validationDone(false);
            return;
          }
          processAsyncValidators();
          function processParseErrors() {
            var errorKey = ctrl.$$parserName || 'parse';
            if (isUndefined(parserValid)) {
              setValidity(errorKey, null);
            } else {
              if (!parserValid) {
                forEach(ctrl.$validators, function(v, name) {
                  setValidity(name, null);
                });
                forEach(ctrl.$asyncValidators, function(v, name) {
                  setValidity(name, null);
                });
              }
              setValidity(errorKey, parserValid);
              return parserValid;
            }
            return true;
          }
          function processSyncValidators() {
            var syncValidatorsValid = true;
            forEach(ctrl.$validators, function(validator, name) {
              var result = validator(modelValue, viewValue);
              syncValidatorsValid = syncValidatorsValid && result;
              setValidity(name, result);
            });
            if (!syncValidatorsValid) {
              forEach(ctrl.$asyncValidators, function(v, name) {
                setValidity(name, null);
              });
              return false;
            }
            return true;
          }
          function processAsyncValidators() {
            var validatorPromises = [];
            var allValid = true;
            forEach(ctrl.$asyncValidators, function(validator, name) {
              var promise = validator(modelValue, viewValue);
              if (!isPromiseLike(promise)) {
                throw ngModelMinErr('nopromise', "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
              }
              setValidity(name, undefined);
              validatorPromises.push(promise.then(function() {
                setValidity(name, true);
              }, function() {
                allValid = false;
                setValidity(name, false);
              }));
            });
            if (!validatorPromises.length) {
              validationDone(true);
            } else {
              $q.all(validatorPromises).then(function() {
                validationDone(allValid);
              }, noop);
            }
          }
          function setValidity(name, isValid) {
            if (localValidationRunId === currentValidationRunId) {
              ctrl.$setValidity(name, isValid);
            }
          }
          function validationDone(allValid) {
            if (localValidationRunId === currentValidationRunId) {
              doneCallback(allValid);
            }
          }
        };
        this.$commitViewValue = function() {
          var viewValue = ctrl.$viewValue;
          $timeout.cancel(pendingDebounce);
          if (ctrl.$$lastCommittedViewValue === viewValue && (viewValue !== '' || !ctrl.$$hasNativeValidators)) {
            return;
          }
          ctrl.$$updateEmptyClasses(viewValue);
          ctrl.$$lastCommittedViewValue = viewValue;
          if (ctrl.$pristine) {
            this.$setDirty();
          }
          this.$$parseAndValidate();
        };
        this.$$parseAndValidate = function() {
          var viewValue = ctrl.$$lastCommittedViewValue;
          var modelValue = viewValue;
          parserValid = isUndefined(modelValue) ? undefined : true;
          if (parserValid) {
            for (var i = 0; i < ctrl.$parsers.length; i++) {
              modelValue = ctrl.$parsers[i](modelValue);
              if (isUndefined(modelValue)) {
                parserValid = false;
                break;
              }
            }
          }
          if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
            ctrl.$modelValue = ngModelGet($scope);
          }
          var prevModelValue = ctrl.$modelValue;
          var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
          ctrl.$$rawModelValue = modelValue;
          if (allowInvalid) {
            ctrl.$modelValue = modelValue;
            writeToModelIfNeeded();
          }
          ctrl.$$runValidators(modelValue, ctrl.$$lastCommittedViewValue, function(allValid) {
            if (!allowInvalid) {
              ctrl.$modelValue = allValid ? modelValue : undefined;
              writeToModelIfNeeded();
            }
          });
          function writeToModelIfNeeded() {
            if (ctrl.$modelValue !== prevModelValue) {
              ctrl.$$writeModelToScope();
            }
          }
        };
        this.$$writeModelToScope = function() {
          ngModelSet($scope, ctrl.$modelValue);
          forEach(ctrl.$viewChangeListeners, function(listener) {
            try {
              listener();
            } catch (e) {
              $exceptionHandler(e);
            }
          });
        };
        this.$setViewValue = function(value, trigger) {
          ctrl.$viewValue = value;
          if (!ctrl.$options || ctrl.$options.updateOnDefault) {
            ctrl.$$debounceViewValueCommit(trigger);
          }
        };
        this.$$debounceViewValueCommit = function(trigger) {
          var debounceDelay = 0,
              options = ctrl.$options,
              debounce;
          if (options && isDefined(options.debounce)) {
            debounce = options.debounce;
            if (isNumber(debounce)) {
              debounceDelay = debounce;
            } else if (isNumber(debounce[trigger])) {
              debounceDelay = debounce[trigger];
            } else if (isNumber(debounce['default'])) {
              debounceDelay = debounce['default'];
            }
          }
          $timeout.cancel(pendingDebounce);
          if (debounceDelay) {
            pendingDebounce = $timeout(function() {
              ctrl.$commitViewValue();
            }, debounceDelay);
          } else if ($rootScope.$$phase) {
            ctrl.$commitViewValue();
          } else {
            $scope.$apply(function() {
              ctrl.$commitViewValue();
            });
          }
        };
        $scope.$watch(function ngModelWatch() {
          var modelValue = ngModelGet($scope);
          if (modelValue !== ctrl.$modelValue && (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)) {
            ctrl.$modelValue = ctrl.$$rawModelValue = modelValue;
            parserValid = undefined;
            var formatters = ctrl.$formatters,
                idx = formatters.length;
            var viewValue = modelValue;
            while (idx--) {
              viewValue = formatters[idx](viewValue);
            }
            if (ctrl.$viewValue !== viewValue) {
              ctrl.$$updateEmptyClasses(viewValue);
              ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue;
              ctrl.$render();
              ctrl.$$runValidators(modelValue, viewValue, noop);
            }
          }
          return modelValue;
        });
      }];
      var ngModelDirective = ['$rootScope', function($rootScope) {
        return {
          restrict: 'A',
          require: ['ngModel', '^?form', '^?ngModelOptions'],
          controller: NgModelController,
          priority: 1,
          compile: function ngModelCompile(element) {
            element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS);
            return {
              pre: function ngModelPreLink(scope, element, attr, ctrls) {
                var modelCtrl = ctrls[0],
                    formCtrl = ctrls[1] || modelCtrl.$$parentForm;
                modelCtrl.$$setOptions(ctrls[2] && ctrls[2].$options);
                formCtrl.$addControl(modelCtrl);
                attr.$observe('name', function(newValue) {
                  if (modelCtrl.$name !== newValue) {
                    modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue);
                  }
                });
                scope.$on('$destroy', function() {
                  modelCtrl.$$parentForm.$removeControl(modelCtrl);
                });
              },
              post: function ngModelPostLink(scope, element, attr, ctrls) {
                var modelCtrl = ctrls[0];
                if (modelCtrl.$options && modelCtrl.$options.updateOn) {
                  element.on(modelCtrl.$options.updateOn, function(ev) {
                    modelCtrl.$$debounceViewValueCommit(ev && ev.type);
                  });
                }
                element.on('blur', function() {
                  if (modelCtrl.$touched)
                    return;
                  if ($rootScope.$$phase) {
                    scope.$evalAsync(modelCtrl.$setTouched);
                  } else {
                    scope.$apply(modelCtrl.$setTouched);
                  }
                });
              }
            };
          }
        };
      }];
      var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
      var ngModelOptionsDirective = function() {
        return {
          restrict: 'A',
          controller: ['$scope', '$attrs', function($scope, $attrs) {
            var that = this;
            this.$options = copy($scope.$eval($attrs.ngModelOptions));
            if (isDefined(this.$options.updateOn)) {
              this.$options.updateOnDefault = false;
              this.$options.updateOn = trim(this.$options.updateOn.replace(DEFAULT_REGEXP, function() {
                that.$options.updateOnDefault = true;
                return ' ';
              }));
            } else {
              this.$options.updateOnDefault = true;
            }
          }]
        };
      };
      function addSetValidityMethod(context) {
        var ctrl = context.ctrl,
            $element = context.$element,
            classCache = {},
            set = context.set,
            unset = context.unset,
            $animate = context.$animate;
        classCache[INVALID_CLASS] = !(classCache[VALID_CLASS] = $element.hasClass(VALID_CLASS));
        ctrl.$setValidity = setValidity;
        function setValidity(validationErrorKey, state, controller) {
          if (isUndefined(state)) {
            createAndSet('$pending', validationErrorKey, controller);
          } else {
            unsetAndCleanup('$pending', validationErrorKey, controller);
          }
          if (!isBoolean(state)) {
            unset(ctrl.$error, validationErrorKey, controller);
            unset(ctrl.$$success, validationErrorKey, controller);
          } else {
            if (state) {
              unset(ctrl.$error, validationErrorKey, controller);
              set(ctrl.$$success, validationErrorKey, controller);
            } else {
              set(ctrl.$error, validationErrorKey, controller);
              unset(ctrl.$$success, validationErrorKey, controller);
            }
          }
          if (ctrl.$pending) {
            cachedToggleClass(PENDING_CLASS, true);
            ctrl.$valid = ctrl.$invalid = undefined;
            toggleValidationCss('', null);
          } else {
            cachedToggleClass(PENDING_CLASS, false);
            ctrl.$valid = isObjectEmpty(ctrl.$error);
            ctrl.$invalid = !ctrl.$valid;
            toggleValidationCss('', ctrl.$valid);
          }
          var combinedState;
          if (ctrl.$pending && ctrl.$pending[validationErrorKey]) {
            combinedState = undefined;
          } else if (ctrl.$error[validationErrorKey]) {
            combinedState = false;
          } else if (ctrl.$$success[validationErrorKey]) {
            combinedState = true;
          } else {
            combinedState = null;
          }
          toggleValidationCss(validationErrorKey, combinedState);
          ctrl.$$parentForm.$setValidity(validationErrorKey, combinedState, ctrl);
        }
        function createAndSet(name, value, controller) {
          if (!ctrl[name]) {
            ctrl[name] = {};
          }
          set(ctrl[name], value, controller);
        }
        function unsetAndCleanup(name, value, controller) {
          if (ctrl[name]) {
            unset(ctrl[name], value, controller);
          }
          if (isObjectEmpty(ctrl[name])) {
            ctrl[name] = undefined;
          }
        }
        function cachedToggleClass(className, switchValue) {
          if (switchValue && !classCache[className]) {
            $animate.addClass($element, className);
            classCache[className] = true;
          } else if (!switchValue && classCache[className]) {
            $animate.removeClass($element, className);
            classCache[className] = false;
          }
        }
        function toggleValidationCss(validationErrorKey, isValid) {
          validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
          cachedToggleClass(VALID_CLASS + validationErrorKey, isValid === true);
          cachedToggleClass(INVALID_CLASS + validationErrorKey, isValid === false);
        }
      }
      function isObjectEmpty(obj) {
        if (obj) {
          for (var prop in obj) {
            if (obj.hasOwnProperty(prop)) {
              return false;
            }
          }
        }
        return true;
      }
      var ngNonBindableDirective = ngDirective({
        terminal: true,
        priority: 1000
      });
      var ngOptionsMinErr = minErr('ngOptions');
      var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;
      var ngOptionsDirective = ['$compile', '$document', '$parse', function($compile, $document, $parse) {
        function parseOptionsExpression(optionsExp, selectElement, scope) {
          var match = optionsExp.match(NG_OPTIONS_REGEXP);
          if (!(match)) {
            throw ngOptionsMinErr('iexp', "Expected expression in form of " + "'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" + " but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
          }
          var valueName = match[5] || match[7];
          var keyName = match[6];
          var selectAs = / as /.test(match[0]) && match[1];
          var trackBy = match[9];
          var valueFn = $parse(match[2] ? match[1] : valueName);
          var selectAsFn = selectAs && $parse(selectAs);
          var viewValueFn = selectAsFn || valueFn;
          var trackByFn = trackBy && $parse(trackBy);
          var getTrackByValueFn = trackBy ? function(value, locals) {
            return trackByFn(scope, locals);
          } : function getHashOfValue(value) {
            return hashKey(value);
          };
          var getTrackByValue = function(value, key) {
            return getTrackByValueFn(value, getLocals(value, key));
          };
          var displayFn = $parse(match[2] || match[1]);
          var groupByFn = $parse(match[3] || '');
          var disableWhenFn = $parse(match[4] || '');
          var valuesFn = $parse(match[8]);
          var locals = {};
          var getLocals = keyName ? function(value, key) {
            locals[keyName] = key;
            locals[valueName] = value;
            return locals;
          } : function(value) {
            locals[valueName] = value;
            return locals;
          };
          function Option(selectValue, viewValue, label, group, disabled) {
            this.selectValue = selectValue;
            this.viewValue = viewValue;
            this.label = label;
            this.group = group;
            this.disabled = disabled;
          }
          function getOptionValuesKeys(optionValues) {
            var optionValuesKeys;
            if (!keyName && isArrayLike(optionValues)) {
              optionValuesKeys = optionValues;
            } else {
              optionValuesKeys = [];
              for (var itemKey in optionValues) {
                if (optionValues.hasOwnProperty(itemKey) && itemKey.charAt(0) !== '$') {
                  optionValuesKeys.push(itemKey);
                }
              }
            }
            return optionValuesKeys;
          }
          return {
            trackBy: trackBy,
            getTrackByValue: getTrackByValue,
            getWatchables: $parse(valuesFn, function(optionValues) {
              var watchedArray = [];
              optionValues = optionValues || [];
              var optionValuesKeys = getOptionValuesKeys(optionValues);
              var optionValuesLength = optionValuesKeys.length;
              for (var index = 0; index < optionValuesLength; index++) {
                var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
                var value = optionValues[key];
                var locals = getLocals(value, key);
                var selectValue = getTrackByValueFn(value, locals);
                watchedArray.push(selectValue);
                if (match[2] || match[1]) {
                  var label = displayFn(scope, locals);
                  watchedArray.push(label);
                }
                if (match[4]) {
                  var disableWhen = disableWhenFn(scope, locals);
                  watchedArray.push(disableWhen);
                }
              }
              return watchedArray;
            }),
            getOptions: function() {
              var optionItems = [];
              var selectValueMap = {};
              var optionValues = valuesFn(scope) || [];
              var optionValuesKeys = getOptionValuesKeys(optionValues);
              var optionValuesLength = optionValuesKeys.length;
              for (var index = 0; index < optionValuesLength; index++) {
                var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
                var value = optionValues[key];
                var locals = getLocals(value, key);
                var viewValue = viewValueFn(scope, locals);
                var selectValue = getTrackByValueFn(viewValue, locals);
                var label = displayFn(scope, locals);
                var group = groupByFn(scope, locals);
                var disabled = disableWhenFn(scope, locals);
                var optionItem = new Option(selectValue, viewValue, label, group, disabled);
                optionItems.push(optionItem);
                selectValueMap[selectValue] = optionItem;
              }
              return {
                items: optionItems,
                selectValueMap: selectValueMap,
                getOptionFromViewValue: function(value) {
                  return selectValueMap[getTrackByValue(value)];
                },
                getViewValueFromOption: function(option) {
                  return trackBy ? angular.copy(option.viewValue) : option.viewValue;
                }
              };
            }
          };
        }
        var optionTemplate = window.document.createElement('option'),
            optGroupTemplate = window.document.createElement('optgroup');
        function ngOptionsPostLink(scope, selectElement, attr, ctrls) {
          var selectCtrl = ctrls[0];
          var ngModelCtrl = ctrls[1];
          var multiple = attr.multiple;
          var emptyOption;
          for (var i = 0,
              children = selectElement.children(),
              ii = children.length; i < ii; i++) {
            if (children[i].value === '') {
              emptyOption = children.eq(i);
              break;
            }
          }
          var providedEmptyOption = !!emptyOption;
          var unknownOption = jqLite(optionTemplate.cloneNode(false));
          unknownOption.val('?');
          var options;
          var ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope);
          var listFragment = $document[0].createDocumentFragment();
          var renderEmptyOption = function() {
            if (!providedEmptyOption) {
              selectElement.prepend(emptyOption);
            }
            selectElement.val('');
            emptyOption.prop('selected', true);
            emptyOption.attr('selected', true);
          };
          var removeEmptyOption = function() {
            if (!providedEmptyOption) {
              emptyOption.remove();
            }
          };
          var renderUnknownOption = function() {
            selectElement.prepend(unknownOption);
            selectElement.val('?');
            unknownOption.prop('selected', true);
            unknownOption.attr('selected', true);
          };
          var removeUnknownOption = function() {
            unknownOption.remove();
          };
          if (!multiple) {
            selectCtrl.writeValue = function writeNgOptionsValue(value) {
              var option = options.getOptionFromViewValue(value);
              if (option) {
                if (selectElement[0].value !== option.selectValue) {
                  removeUnknownOption();
                  removeEmptyOption();
                  selectElement[0].value = option.selectValue;
                  option.element.selected = true;
                }
                option.element.setAttribute('selected', 'selected');
              } else {
                if (value === null || providedEmptyOption) {
                  removeUnknownOption();
                  renderEmptyOption();
                } else {
                  removeEmptyOption();
                  renderUnknownOption();
                }
              }
            };
            selectCtrl.readValue = function readNgOptionsValue() {
              var selectedOption = options.selectValueMap[selectElement.val()];
              if (selectedOption && !selectedOption.disabled) {
                removeEmptyOption();
                removeUnknownOption();
                return options.getViewValueFromOption(selectedOption);
              }
              return null;
            };
            if (ngOptions.trackBy) {
              scope.$watch(function() {
                return ngOptions.getTrackByValue(ngModelCtrl.$viewValue);
              }, function() {
                ngModelCtrl.$render();
              });
            }
          } else {
            ngModelCtrl.$isEmpty = function(value) {
              return !value || value.length === 0;
            };
            selectCtrl.writeValue = function writeNgOptionsMultiple(value) {
              options.items.forEach(function(option) {
                option.element.selected = false;
              });
              if (value) {
                value.forEach(function(item) {
                  var option = options.getOptionFromViewValue(item);
                  if (option)
                    option.element.selected = true;
                });
              }
            };
            selectCtrl.readValue = function readNgOptionsMultiple() {
              var selectedValues = selectElement.val() || [],
                  selections = [];
              forEach(selectedValues, function(value) {
                var option = options.selectValueMap[value];
                if (option && !option.disabled)
                  selections.push(options.getViewValueFromOption(option));
              });
              return selections;
            };
            if (ngOptions.trackBy) {
              scope.$watchCollection(function() {
                if (isArray(ngModelCtrl.$viewValue)) {
                  return ngModelCtrl.$viewValue.map(function(value) {
                    return ngOptions.getTrackByValue(value);
                  });
                }
              }, function() {
                ngModelCtrl.$render();
              });
            }
          }
          if (providedEmptyOption) {
            emptyOption.remove();
            $compile(emptyOption)(scope);
            emptyOption.removeClass('ng-scope');
          } else {
            emptyOption = jqLite(optionTemplate.cloneNode(false));
          }
          selectElement.empty();
          updateOptions();
          scope.$watchCollection(ngOptions.getWatchables, updateOptions);
          function addOptionElement(option, parent) {
            var optionElement = optionTemplate.cloneNode(false);
            parent.appendChild(optionElement);
            updateOptionElement(option, optionElement);
          }
          function updateOptionElement(option, element) {
            option.element = element;
            element.disabled = option.disabled;
            if (option.label !== element.label) {
              element.label = option.label;
              element.textContent = option.label;
            }
            if (option.value !== element.value)
              element.value = option.selectValue;
          }
          function updateOptions() {
            var previousValue = options && selectCtrl.readValue();
            if (options) {
              for (var i = options.items.length - 1; i >= 0; i--) {
                var option = options.items[i];
                if (isDefined(option.group)) {
                  jqLiteRemove(option.element.parentNode);
                } else {
                  jqLiteRemove(option.element);
                }
              }
            }
            options = ngOptions.getOptions();
            var groupElementMap = {};
            if (providedEmptyOption) {
              selectElement.prepend(emptyOption);
            }
            options.items.forEach(function addOption(option) {
              var groupElement;
              if (isDefined(option.group)) {
                groupElement = groupElementMap[option.group];
                if (!groupElement) {
                  groupElement = optGroupTemplate.cloneNode(false);
                  listFragment.appendChild(groupElement);
                  groupElement.label = option.group === null ? 'null' : option.group;
                  groupElementMap[option.group] = groupElement;
                }
                addOptionElement(option, groupElement);
              } else {
                addOptionElement(option, listFragment);
              }
            });
            selectElement[0].appendChild(listFragment);
            ngModelCtrl.$render();
            if (!ngModelCtrl.$isEmpty(previousValue)) {
              var nextValue = selectCtrl.readValue();
              var isNotPrimitive = ngOptions.trackBy || multiple;
              if (isNotPrimitive ? !equals(previousValue, nextValue) : previousValue !== nextValue) {
                ngModelCtrl.$setViewValue(nextValue);
                ngModelCtrl.$render();
              }
            }
          }
        }
        return {
          restrict: 'A',
          terminal: true,
          require: ['select', 'ngModel'],
          link: {
            pre: function ngOptionsPreLink(scope, selectElement, attr, ctrls) {
              ctrls[0].registerOption = noop;
            },
            post: ngOptionsPostLink
          }
        };
      }];
      var ngPluralizeDirective = ['$locale', '$interpolate', '$log', function($locale, $interpolate, $log) {
        var BRACE = /{}/g,
            IS_WHEN = /^when(Minus)?(.+)$/;
        return {link: function(scope, element, attr) {
            var numberExp = attr.count,
                whenExp = attr.$attr.when && element.attr(attr.$attr.when),
                offset = attr.offset || 0,
                whens = scope.$eval(whenExp) || {},
                whensExpFns = {},
                startSymbol = $interpolate.startSymbol(),
                endSymbol = $interpolate.endSymbol(),
                braceReplacement = startSymbol + numberExp + '-' + offset + endSymbol,
                watchRemover = angular.noop,
                lastCount;
            forEach(attr, function(expression, attributeName) {
              var tmpMatch = IS_WHEN.exec(attributeName);
              if (tmpMatch) {
                var whenKey = (tmpMatch[1] ? '-' : '') + lowercase(tmpMatch[2]);
                whens[whenKey] = element.attr(attr.$attr[attributeName]);
              }
            });
            forEach(whens, function(expression, key) {
              whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
            });
            scope.$watch(numberExp, function ngPluralizeWatchAction(newVal) {
              var count = parseFloat(newVal);
              var countIsNaN = isNaN(count);
              if (!countIsNaN && !(count in whens)) {
                count = $locale.pluralCat(count - offset);
              }
              if ((count !== lastCount) && !(countIsNaN && isNumber(lastCount) && isNaN(lastCount))) {
                watchRemover();
                var whenExpFn = whensExpFns[count];
                if (isUndefined(whenExpFn)) {
                  if (newVal != null) {
                    $log.debug("ngPluralize: no rule defined for '" + count + "' in " + whenExp);
                  }
                  watchRemover = noop;
                  updateElementText();
                } else {
                  watchRemover = scope.$watch(whenExpFn, updateElementText);
                }
                lastCount = count;
              }
            });
            function updateElementText(newText) {
              element.text(newText || '');
            }
          }};
      }];
      var ngRepeatDirective = ['$parse', '$animate', '$compile', function($parse, $animate, $compile) {
        var NG_REMOVED = '$$NG_REMOVED';
        var ngRepeatMinErr = minErr('ngRepeat');
        var updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
          scope[valueIdentifier] = value;
          if (keyIdentifier)
            scope[keyIdentifier] = key;
          scope.$index = index;
          scope.$first = (index === 0);
          scope.$last = (index === (arrayLength - 1));
          scope.$middle = !(scope.$first || scope.$last);
          scope.$odd = !(scope.$even = (index & 1) === 0);
        };
        var getBlockStart = function(block) {
          return block.clone[0];
        };
        var getBlockEnd = function(block) {
          return block.clone[block.clone.length - 1];
        };
        return {
          restrict: 'A',
          multiElement: true,
          transclude: 'element',
          priority: 1000,
          terminal: true,
          $$tlb: true,
          compile: function ngRepeatCompile($element, $attr) {
            var expression = $attr.ngRepeat;
            var ngRepeatEndComment = $compile.$$createComment('end ngRepeat', expression);
            var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
            if (!match) {
              throw ngRepeatMinErr('iexp', "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
            }
            var lhs = match[1];
            var rhs = match[2];
            var aliasAs = match[3];
            var trackByExp = match[4];
            match = lhs.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/);
            if (!match) {
              throw ngRepeatMinErr('iidexp', "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
            }
            var valueIdentifier = match[3] || match[1];
            var keyIdentifier = match[2];
            if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) {
              throw ngRepeatMinErr('badident', "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", aliasAs);
            }
            var trackByExpGetter,
                trackByIdExpFn,
                trackByIdArrayFn,
                trackByIdObjFn;
            var hashFnLocals = {$id: hashKey};
            if (trackByExp) {
              trackByExpGetter = $parse(trackByExp);
            } else {
              trackByIdArrayFn = function(key, value) {
                return hashKey(value);
              };
              trackByIdObjFn = function(key) {
                return key;
              };
            }
            return function ngRepeatLink($scope, $element, $attr, ctrl, $transclude) {
              if (trackByExpGetter) {
                trackByIdExpFn = function(key, value, index) {
                  if (keyIdentifier)
                    hashFnLocals[keyIdentifier] = key;
                  hashFnLocals[valueIdentifier] = value;
                  hashFnLocals.$index = index;
                  return trackByExpGetter($scope, hashFnLocals);
                };
              }
              var lastBlockMap = createMap();
              $scope.$watchCollection(rhs, function ngRepeatAction(collection) {
                var index,
                    length,
                    previousNode = $element[0],
                    nextNode,
                    nextBlockMap = createMap(),
                    collectionLength,
                    key,
                    value,
                    trackById,
                    trackByIdFn,
                    collectionKeys,
                    block,
                    nextBlockOrder,
                    elementsToRemove;
                if (aliasAs) {
                  $scope[aliasAs] = collection;
                }
                if (isArrayLike(collection)) {
                  collectionKeys = collection;
                  trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
                } else {
                  trackByIdFn = trackByIdExpFn || trackByIdObjFn;
                  collectionKeys = [];
                  for (var itemKey in collection) {
                    if (hasOwnProperty.call(collection, itemKey) && itemKey.charAt(0) !== '$') {
                      collectionKeys.push(itemKey);
                    }
                  }
                }
                collectionLength = collectionKeys.length;
                nextBlockOrder = new Array(collectionLength);
                for (index = 0; index < collectionLength; index++) {
                  key = (collection === collectionKeys) ? index : collectionKeys[index];
                  value = collection[key];
                  trackById = trackByIdFn(key, value, index);
                  if (lastBlockMap[trackById]) {
                    block = lastBlockMap[trackById];
                    delete lastBlockMap[trackById];
                    nextBlockMap[trackById] = block;
                    nextBlockOrder[index] = block;
                  } else if (nextBlockMap[trackById]) {
                    forEach(nextBlockOrder, function(block) {
                      if (block && block.scope)
                        lastBlockMap[block.id] = block;
                    });
                    throw ngRepeatMinErr('dupes', "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, value);
                  } else {
                    nextBlockOrder[index] = {
                      id: trackById,
                      scope: undefined,
                      clone: undefined
                    };
                    nextBlockMap[trackById] = true;
                  }
                }
                for (var blockKey in lastBlockMap) {
                  block = lastBlockMap[blockKey];
                  elementsToRemove = getBlockNodes(block.clone);
                  $animate.leave(elementsToRemove);
                  if (elementsToRemove[0].parentNode) {
                    for (index = 0, length = elementsToRemove.length; index < length; index++) {
                      elementsToRemove[index][NG_REMOVED] = true;
                    }
                  }
                  block.scope.$destroy();
                }
                for (index = 0; index < collectionLength; index++) {
                  key = (collection === collectionKeys) ? index : collectionKeys[index];
                  value = collection[key];
                  block = nextBlockOrder[index];
                  if (block.scope) {
                    nextNode = previousNode;
                    do {
                      nextNode = nextNode.nextSibling;
                    } while (nextNode && nextNode[NG_REMOVED]);
                    if (getBlockStart(block) != nextNode) {
                      $animate.move(getBlockNodes(block.clone), null, previousNode);
                    }
                    previousNode = getBlockEnd(block);
                    updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                  } else {
                    $transclude(function ngRepeatTransclude(clone, scope) {
                      block.scope = scope;
                      var endNode = ngRepeatEndComment.cloneNode(false);
                      clone[clone.length++] = endNode;
                      $animate.enter(clone, null, previousNode);
                      previousNode = endNode;
                      block.clone = clone;
                      nextBlockMap[block.id] = block;
                      updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                    });
                  }
                }
                lastBlockMap = nextBlockMap;
              });
            };
          }
        };
      }];
      var NG_HIDE_CLASS = 'ng-hide';
      var NG_HIDE_IN_PROGRESS_CLASS = 'ng-hide-animate';
      var ngShowDirective = ['$animate', function($animate) {
        return {
          restrict: 'A',
          multiElement: true,
          link: function(scope, element, attr) {
            scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
              $animate[value ? 'removeClass' : 'addClass'](element, NG_HIDE_CLASS, {tempClasses: NG_HIDE_IN_PROGRESS_CLASS});
            });
          }
        };
      }];
      var ngHideDirective = ['$animate', function($animate) {
        return {
          restrict: 'A',
          multiElement: true,
          link: function(scope, element, attr) {
            scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
              $animate[value ? 'addClass' : 'removeClass'](element, NG_HIDE_CLASS, {tempClasses: NG_HIDE_IN_PROGRESS_CLASS});
            });
          }
        };
      }];
      var ngStyleDirective = ngDirective(function(scope, element, attr) {
        scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
          if (oldStyles && (newStyles !== oldStyles)) {
            forEach(oldStyles, function(val, style) {
              element.css(style, '');
            });
          }
          if (newStyles)
            element.css(newStyles);
        }, true);
      });
      var ngSwitchDirective = ['$animate', '$compile', function($animate, $compile) {
        return {
          require: 'ngSwitch',
          controller: ['$scope', function ngSwitchController() {
            this.cases = {};
          }],
          link: function(scope, element, attr, ngSwitchController) {
            var watchExpr = attr.ngSwitch || attr.on,
                selectedTranscludes = [],
                selectedElements = [],
                previousLeaveAnimations = [],
                selectedScopes = [];
            var spliceFactory = function(array, index) {
              return function() {
                array.splice(index, 1);
              };
            };
            scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
              var i,
                  ii;
              for (i = 0, ii = previousLeaveAnimations.length; i < ii; ++i) {
                $animate.cancel(previousLeaveAnimations[i]);
              }
              previousLeaveAnimations.length = 0;
              for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
                var selected = getBlockNodes(selectedElements[i].clone);
                selectedScopes[i].$destroy();
                var promise = previousLeaveAnimations[i] = $animate.leave(selected);
                promise.then(spliceFactory(previousLeaveAnimations, i));
              }
              selectedElements.length = 0;
              selectedScopes.length = 0;
              if ((selectedTranscludes = ngSwitchController.cases['!' + value] || ngSwitchController.cases['?'])) {
                forEach(selectedTranscludes, function(selectedTransclude) {
                  selectedTransclude.transclude(function(caseElement, selectedScope) {
                    selectedScopes.push(selectedScope);
                    var anchor = selectedTransclude.element;
                    caseElement[caseElement.length++] = $compile.$$createComment('end ngSwitchWhen');
                    var block = {clone: caseElement};
                    selectedElements.push(block);
                    $animate.enter(caseElement, anchor.parent(), anchor);
                  });
                });
              }
            });
          }
        };
      }];
      var ngSwitchWhenDirective = ngDirective({
        transclude: 'element',
        priority: 1200,
        require: '^ngSwitch',
        multiElement: true,
        link: function(scope, element, attrs, ctrl, $transclude) {
          ctrl.cases['!' + attrs.ngSwitchWhen] = (ctrl.cases['!' + attrs.ngSwitchWhen] || []);
          ctrl.cases['!' + attrs.ngSwitchWhen].push({
            transclude: $transclude,
            element: element
          });
        }
      });
      var ngSwitchDefaultDirective = ngDirective({
        transclude: 'element',
        priority: 1200,
        require: '^ngSwitch',
        multiElement: true,
        link: function(scope, element, attr, ctrl, $transclude) {
          ctrl.cases['?'] = (ctrl.cases['?'] || []);
          ctrl.cases['?'].push({
            transclude: $transclude,
            element: element
          });
        }
      });
      var ngTranscludeMinErr = minErr('ngTransclude');
      var ngTranscludeDirective = ['$compile', function($compile) {
        return {
          restrict: 'EAC',
          terminal: true,
          compile: function ngTranscludeCompile(tElement) {
            var fallbackLinkFn = $compile(tElement.contents());
            tElement.empty();
            return function ngTranscludePostLink($scope, $element, $attrs, controller, $transclude) {
              if (!$transclude) {
                throw ngTranscludeMinErr('orphan', 'Illegal use of ngTransclude directive in the template! ' + 'No parent directive that requires a transclusion found. ' + 'Element: {0}', startingTag($element));
              }
              if ($attrs.ngTransclude === $attrs.$attr.ngTransclude) {
                $attrs.ngTransclude = '';
              }
              var slotName = $attrs.ngTransclude || $attrs.ngTranscludeSlot;
              $transclude(ngTranscludeCloneAttachFn, null, slotName);
              if (slotName && !$transclude.isSlotFilled(slotName)) {
                useFallbackContent();
              }
              function ngTranscludeCloneAttachFn(clone, transcludedScope) {
                if (clone.length) {
                  $element.append(clone);
                } else {
                  useFallbackContent();
                  transcludedScope.$destroy();
                }
              }
              function useFallbackContent() {
                fallbackLinkFn($scope, function(clone) {
                  $element.append(clone);
                });
              }
            };
          }
        };
      }];
      var scriptDirective = ['$templateCache', function($templateCache) {
        return {
          restrict: 'E',
          terminal: true,
          compile: function(element, attr) {
            if (attr.type == 'text/ng-template') {
              var templateUrl = attr.id,
                  text = element[0].text;
              $templateCache.put(templateUrl, text);
            }
          }
        };
      }];
      var noopNgModelController = {
        $setViewValue: noop,
        $render: noop
      };
      function chromeHack(optionElement) {
        if (optionElement[0].hasAttribute('selected')) {
          optionElement[0].selected = true;
        }
      }
      var SelectController = ['$element', '$scope', function($element, $scope) {
        var self = this,
            optionsMap = new HashMap();
        self.ngModelCtrl = noopNgModelController;
        self.unknownOption = jqLite(window.document.createElement('option'));
        self.renderUnknownOption = function(val) {
          var unknownVal = '? ' + hashKey(val) + ' ?';
          self.unknownOption.val(unknownVal);
          $element.prepend(self.unknownOption);
          $element.val(unknownVal);
        };
        $scope.$on('$destroy', function() {
          self.renderUnknownOption = noop;
        });
        self.removeUnknownOption = function() {
          if (self.unknownOption.parent())
            self.unknownOption.remove();
        };
        self.readValue = function readSingleValue() {
          self.removeUnknownOption();
          return $element.val();
        };
        self.writeValue = function writeSingleValue(value) {
          if (self.hasOption(value)) {
            self.removeUnknownOption();
            $element.val(value);
            if (value === '')
              self.emptyOption.prop('selected', true);
          } else {
            if (value == null && self.emptyOption) {
              self.removeUnknownOption();
              $element.val('');
            } else {
              self.renderUnknownOption(value);
            }
          }
        };
        self.addOption = function(value, element) {
          if (element[0].nodeType === NODE_TYPE_COMMENT)
            return;
          assertNotHasOwnProperty(value, '"option value"');
          if (value === '') {
            self.emptyOption = element;
          }
          var count = optionsMap.get(value) || 0;
          optionsMap.put(value, count + 1);
          self.ngModelCtrl.$render();
          chromeHack(element);
        };
        self.removeOption = function(value) {
          var count = optionsMap.get(value);
          if (count) {
            if (count === 1) {
              optionsMap.remove(value);
              if (value === '') {
                self.emptyOption = undefined;
              }
            } else {
              optionsMap.put(value, count - 1);
            }
          }
        };
        self.hasOption = function(value) {
          return !!optionsMap.get(value);
        };
        self.registerOption = function(optionScope, optionElement, optionAttrs, interpolateValueFn, interpolateTextFn) {
          if (interpolateValueFn) {
            var oldVal;
            optionAttrs.$observe('value', function valueAttributeObserveAction(newVal) {
              if (isDefined(oldVal)) {
                self.removeOption(oldVal);
              }
              oldVal = newVal;
              self.addOption(newVal, optionElement);
            });
          } else if (interpolateTextFn) {
            optionScope.$watch(interpolateTextFn, function interpolateWatchAction(newVal, oldVal) {
              optionAttrs.$set('value', newVal);
              if (oldVal !== newVal) {
                self.removeOption(oldVal);
              }
              self.addOption(newVal, optionElement);
            });
          } else {
            self.addOption(optionAttrs.value, optionElement);
          }
          optionElement.on('$destroy', function() {
            self.removeOption(optionAttrs.value);
            self.ngModelCtrl.$render();
          });
        };
      }];
      var selectDirective = function() {
        return {
          restrict: 'E',
          require: ['select', '?ngModel'],
          controller: SelectController,
          priority: 1,
          link: {
            pre: selectPreLink,
            post: selectPostLink
          }
        };
        function selectPreLink(scope, element, attr, ctrls) {
          var ngModelCtrl = ctrls[1];
          if (!ngModelCtrl)
            return;
          var selectCtrl = ctrls[0];
          selectCtrl.ngModelCtrl = ngModelCtrl;
          element.on('change', function() {
            scope.$apply(function() {
              ngModelCtrl.$setViewValue(selectCtrl.readValue());
            });
          });
          if (attr.multiple) {
            selectCtrl.readValue = function readMultipleValue() {
              var array = [];
              forEach(element.find('option'), function(option) {
                if (option.selected) {
                  array.push(option.value);
                }
              });
              return array;
            };
            selectCtrl.writeValue = function writeMultipleValue(value) {
              var items = new HashMap(value);
              forEach(element.find('option'), function(option) {
                option.selected = isDefined(items.get(option.value));
              });
            };
            var lastView,
                lastViewRef = NaN;
            scope.$watch(function selectMultipleWatch() {
              if (lastViewRef === ngModelCtrl.$viewValue && !equals(lastView, ngModelCtrl.$viewValue)) {
                lastView = shallowCopy(ngModelCtrl.$viewValue);
                ngModelCtrl.$render();
              }
              lastViewRef = ngModelCtrl.$viewValue;
            });
            ngModelCtrl.$isEmpty = function(value) {
              return !value || value.length === 0;
            };
          }
        }
        function selectPostLink(scope, element, attrs, ctrls) {
          var ngModelCtrl = ctrls[1];
          if (!ngModelCtrl)
            return;
          var selectCtrl = ctrls[0];
          ngModelCtrl.$render = function() {
            selectCtrl.writeValue(ngModelCtrl.$viewValue);
          };
        }
      };
      var optionDirective = ['$interpolate', function($interpolate) {
        return {
          restrict: 'E',
          priority: 100,
          compile: function(element, attr) {
            if (isDefined(attr.value)) {
              var interpolateValueFn = $interpolate(attr.value, true);
            } else {
              var interpolateTextFn = $interpolate(element.text(), true);
              if (!interpolateTextFn) {
                attr.$set('value', element.text());
              }
            }
            return function(scope, element, attr) {
              var selectCtrlName = '$selectController',
                  parent = element.parent(),
                  selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
              if (selectCtrl) {
                selectCtrl.registerOption(scope, element, attr, interpolateValueFn, interpolateTextFn);
              }
            };
          }
        };
      }];
      var styleDirective = valueFn({
        restrict: 'E',
        terminal: false
      });
      var requiredDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            attr.required = true;
            ctrl.$validators.required = function(modelValue, viewValue) {
              return !attr.required || !ctrl.$isEmpty(viewValue);
            };
            attr.$observe('required', function() {
              ctrl.$validate();
            });
          }
        };
      };
      var patternDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            var regexp,
                patternExp = attr.ngPattern || attr.pattern;
            attr.$observe('pattern', function(regex) {
              if (isString(regex) && regex.length > 0) {
                regex = new RegExp('^' + regex + '$');
              }
              if (regex && !regex.test) {
                throw minErr('ngPattern')('noregexp', 'Expected {0} to be a RegExp but was {1}. Element: {2}', patternExp, regex, startingTag(elm));
              }
              regexp = regex || undefined;
              ctrl.$validate();
            });
            ctrl.$validators.pattern = function(modelValue, viewValue) {
              return ctrl.$isEmpty(viewValue) || isUndefined(regexp) || regexp.test(viewValue);
            };
          }
        };
      };
      var maxlengthDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            var maxlength = -1;
            attr.$observe('maxlength', function(value) {
              var intVal = toInt(value);
              maxlength = isNaN(intVal) ? -1 : intVal;
              ctrl.$validate();
            });
            ctrl.$validators.maxlength = function(modelValue, viewValue) {
              return (maxlength < 0) || ctrl.$isEmpty(viewValue) || (viewValue.length <= maxlength);
            };
          }
        };
      };
      var minlengthDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            var minlength = 0;
            attr.$observe('minlength', function(value) {
              minlength = toInt(value) || 0;
              ctrl.$validate();
            });
            ctrl.$validators.minlength = function(modelValue, viewValue) {
              return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
            };
          }
        };
      };
      if (window.angular.bootstrap) {
        if (window.console) {
          console.log('WARNING: Tried to load angular more than once.');
        }
        return;
      }
      bindJQuery();
      publishExternalAPI(angular);
      angular.module("ngLocale", [], ["$provide", function($provide) {
        var PLURAL_CATEGORY = {
          ZERO: "zero",
          ONE: "one",
          TWO: "two",
          FEW: "few",
          MANY: "many",
          OTHER: "other"
        };
        function getDecimals(n) {
          n = n + '';
          var i = n.indexOf('.');
          return (i == -1) ? 0 : n.length - i - 1;
        }
        function getVF(n, opt_precision) {
          var v = opt_precision;
          if (undefined === v) {
            v = Math.min(getDecimals(n), 3);
          }
          var base = Math.pow(10, v);
          var f = ((n * base) | 0) % base;
          return {
            v: v,
            f: f
          };
        }
        $provide.value("$locale", {
          "DATETIME_FORMATS": {
            "AMPMS": ["AM", "PM"],
            "DAY": ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            "ERANAMES": ["Before Christ", "Anno Domini"],
            "ERAS": ["BC", "AD"],
            "FIRSTDAYOFWEEK": 6,
            "MONTH": ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            "SHORTDAY": ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            "SHORTMONTH": ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            "STANDALONEMONTH": ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            "WEEKENDRANGE": [5, 6],
            "fullDate": "EEEE, MMMM d, y",
            "longDate": "MMMM d, y",
            "medium": "MMM d, y h:mm:ss a",
            "mediumDate": "MMM d, y",
            "mediumTime": "h:mm:ss a",
            "short": "M/d/yy h:mm a",
            "shortDate": "M/d/yy",
            "shortTime": "h:mm a"
          },
          "NUMBER_FORMATS": {
            "CURRENCY_SYM": "$",
            "DECIMAL_SEP": ".",
            "GROUP_SEP": ",",
            "PATTERNS": [{
              "gSize": 3,
              "lgSize": 3,
              "maxFrac": 3,
              "minFrac": 0,
              "minInt": 1,
              "negPre": "-",
              "negSuf": "",
              "posPre": "",
              "posSuf": ""
            }, {
              "gSize": 3,
              "lgSize": 3,
              "maxFrac": 2,
              "minFrac": 2,
              "minInt": 1,
              "negPre": "-\u00a4",
              "negSuf": "",
              "posPre": "\u00a4",
              "posSuf": ""
            }]
          },
          "id": "en-us",
          "localeID": "en_US",
          "pluralCat": function(n, opt_precision) {
            var i = n | 0;
            var vf = getVF(n, opt_precision);
            if (i == 1 && vf.v == 0) {
              return PLURAL_CATEGORY.ONE;
            }
            return PLURAL_CATEGORY.OTHER;
          }
        });
      }]);
      jqLite(window.document).ready(function() {
        angularInit(window.document, bootstrap);
      });
    })(window);
    !window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("14", ["8a"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('8a');
  return module.exports;
});

$__System.registerDynamic("8b", ["14"], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    "format global";
    "deps angular";
    (function(window, angular) {
      'use strict';
      angular.mock = {};
      angular.mock.$BrowserProvider = function() {
        this.$get = function() {
          return new angular.mock.$Browser();
        };
      };
      angular.mock.$Browser = function() {
        var self = this;
        this.isMock = true;
        self.$$url = "http://server/";
        self.$$lastUrl = self.$$url;
        self.pollFns = [];
        self.$$completeOutstandingRequest = angular.noop;
        self.$$incOutstandingRequestCount = angular.noop;
        self.onUrlChange = function(listener) {
          self.pollFns.push(function() {
            if (self.$$lastUrl !== self.$$url || self.$$state !== self.$$lastState) {
              self.$$lastUrl = self.$$url;
              self.$$lastState = self.$$state;
              listener(self.$$url, self.$$state);
            }
          });
          return listener;
        };
        self.$$applicationDestroyed = angular.noop;
        self.$$checkUrlChange = angular.noop;
        self.deferredFns = [];
        self.deferredNextId = 0;
        self.defer = function(fn, delay) {
          delay = delay || 0;
          self.deferredFns.push({
            time: (self.defer.now + delay),
            fn: fn,
            id: self.deferredNextId
          });
          self.deferredFns.sort(function(a, b) {
            return a.time - b.time;
          });
          return self.deferredNextId++;
        };
        self.defer.now = 0;
        self.defer.cancel = function(deferId) {
          var fnIndex;
          angular.forEach(self.deferredFns, function(fn, index) {
            if (fn.id === deferId)
              fnIndex = index;
          });
          if (angular.isDefined(fnIndex)) {
            self.deferredFns.splice(fnIndex, 1);
            return true;
          }
          return false;
        };
        self.defer.flush = function(delay) {
          if (angular.isDefined(delay)) {
            self.defer.now += delay;
          } else {
            if (self.deferredFns.length) {
              self.defer.now = self.deferredFns[self.deferredFns.length - 1].time;
            } else {
              throw new Error('No deferred tasks to be flushed');
            }
          }
          while (self.deferredFns.length && self.deferredFns[0].time <= self.defer.now) {
            self.deferredFns.shift().fn();
          }
        };
        self.$$baseHref = '/';
        self.baseHref = function() {
          return this.$$baseHref;
        };
      };
      angular.mock.$Browser.prototype = {
        poll: function poll() {
          angular.forEach(this.pollFns, function(pollFn) {
            pollFn();
          });
        },
        url: function(url, replace, state) {
          if (angular.isUndefined(state)) {
            state = null;
          }
          if (url) {
            this.$$url = url;
            this.$$state = angular.copy(state);
            return this;
          }
          return this.$$url;
        },
        state: function() {
          return this.$$state;
        },
        notifyWhenNoOutstandingRequests: function(fn) {
          fn();
        }
      };
      angular.mock.$ExceptionHandlerProvider = function() {
        var handler;
        this.mode = function(mode) {
          switch (mode) {
            case 'log':
            case 'rethrow':
              var errors = [];
              handler = function(e) {
                if (arguments.length == 1) {
                  errors.push(e);
                } else {
                  errors.push([].slice.call(arguments, 0));
                }
                if (mode === "rethrow") {
                  throw e;
                }
              };
              handler.errors = errors;
              break;
            default:
              throw new Error("Unknown mode '" + mode + "', only 'log'/'rethrow' modes are allowed!");
          }
        };
        this.$get = function() {
          return handler;
        };
        this.mode('rethrow');
      };
      angular.mock.$LogProvider = function() {
        var debug = true;
        function concat(array1, array2, index) {
          return array1.concat(Array.prototype.slice.call(array2, index));
        }
        this.debugEnabled = function(flag) {
          if (angular.isDefined(flag)) {
            debug = flag;
            return this;
          } else {
            return debug;
          }
        };
        this.$get = function() {
          var $log = {
            log: function() {
              $log.log.logs.push(concat([], arguments, 0));
            },
            warn: function() {
              $log.warn.logs.push(concat([], arguments, 0));
            },
            info: function() {
              $log.info.logs.push(concat([], arguments, 0));
            },
            error: function() {
              $log.error.logs.push(concat([], arguments, 0));
            },
            debug: function() {
              if (debug) {
                $log.debug.logs.push(concat([], arguments, 0));
              }
            }
          };
          $log.reset = function() {
            $log.log.logs = [];
            $log.info.logs = [];
            $log.warn.logs = [];
            $log.error.logs = [];
            $log.debug.logs = [];
          };
          $log.assertEmpty = function() {
            var errors = [];
            angular.forEach(['error', 'warn', 'info', 'log', 'debug'], function(logLevel) {
              angular.forEach($log[logLevel].logs, function(log) {
                angular.forEach(log, function(logItem) {
                  errors.push('MOCK $log (' + logLevel + '): ' + String(logItem) + '\n' + (logItem.stack || ''));
                });
              });
            });
            if (errors.length) {
              errors.unshift("Expected $log to be empty! Either a message was logged unexpectedly, or " + "an expected log message was not checked and removed:");
              errors.push('');
              throw new Error(errors.join('\n---------\n'));
            }
          };
          $log.reset();
          return $log;
        };
      };
      angular.mock.$IntervalProvider = function() {
        this.$get = ['$browser', '$rootScope', '$q', '$$q', function($browser, $rootScope, $q, $$q) {
          var repeatFns = [],
              nextRepeatId = 0,
              now = 0;
          var $interval = function(fn, delay, count, invokeApply) {
            var hasParams = arguments.length > 4,
                args = hasParams ? Array.prototype.slice.call(arguments, 4) : [],
                iteration = 0,
                skipApply = (angular.isDefined(invokeApply) && !invokeApply),
                deferred = (skipApply ? $$q : $q).defer(),
                promise = deferred.promise;
            count = (angular.isDefined(count)) ? count : 0;
            promise.then(null, null, (!hasParams) ? fn : function() {
              fn.apply(null, args);
            });
            promise.$$intervalId = nextRepeatId;
            function tick() {
              deferred.notify(iteration++);
              if (count > 0 && iteration >= count) {
                var fnIndex;
                deferred.resolve(iteration);
                angular.forEach(repeatFns, function(fn, index) {
                  if (fn.id === promise.$$intervalId)
                    fnIndex = index;
                });
                if (angular.isDefined(fnIndex)) {
                  repeatFns.splice(fnIndex, 1);
                }
              }
              if (skipApply) {
                $browser.defer.flush();
              } else {
                $rootScope.$apply();
              }
            }
            repeatFns.push({
              nextTime: (now + delay),
              delay: delay,
              fn: tick,
              id: nextRepeatId,
              deferred: deferred
            });
            repeatFns.sort(function(a, b) {
              return a.nextTime - b.nextTime;
            });
            nextRepeatId++;
            return promise;
          };
          $interval.cancel = function(promise) {
            if (!promise)
              return false;
            var fnIndex;
            angular.forEach(repeatFns, function(fn, index) {
              if (fn.id === promise.$$intervalId)
                fnIndex = index;
            });
            if (angular.isDefined(fnIndex)) {
              repeatFns[fnIndex].deferred.reject('canceled');
              repeatFns.splice(fnIndex, 1);
              return true;
            }
            return false;
          };
          $interval.flush = function(millis) {
            now += millis;
            while (repeatFns.length && repeatFns[0].nextTime <= now) {
              var task = repeatFns[0];
              task.fn();
              task.nextTime += task.delay;
              repeatFns.sort(function(a, b) {
                return a.nextTime - b.nextTime;
              });
            }
            return millis;
          };
          return $interval;
        }];
      };
      var R_ISO8061_STR = /^(-?\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?:\:?(\d\d)(?:\:?(\d\d)(?:\.(\d{3}))?)?)?(Z|([+-])(\d\d):?(\d\d)))?$/;
      function jsonStringToDate(string) {
        var match;
        if (match = string.match(R_ISO8061_STR)) {
          var date = new Date(0),
              tzHour = 0,
              tzMin = 0;
          if (match[9]) {
            tzHour = toInt(match[9] + match[10]);
            tzMin = toInt(match[9] + match[11]);
          }
          date.setUTCFullYear(toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
          date.setUTCHours(toInt(match[4] || 0) - tzHour, toInt(match[5] || 0) - tzMin, toInt(match[6] || 0), toInt(match[7] || 0));
          return date;
        }
        return string;
      }
      function toInt(str) {
        return parseInt(str, 10);
      }
      function padNumberInMock(num, digits, trim) {
        var neg = '';
        if (num < 0) {
          neg = '-';
          num = -num;
        }
        num = '' + num;
        while (num.length < digits)
          num = '0' + num;
        if (trim) {
          num = num.substr(num.length - digits);
        }
        return neg + num;
      }
      angular.mock.TzDate = function(offset, timestamp) {
        var self = new Date(0);
        if (angular.isString(timestamp)) {
          var tsStr = timestamp;
          self.origDate = jsonStringToDate(timestamp);
          timestamp = self.origDate.getTime();
          if (isNaN(timestamp)) {
            throw {
              name: "Illegal Argument",
              message: "Arg '" + tsStr + "' passed into TzDate constructor is not a valid date string"
            };
          }
        } else {
          self.origDate = new Date(timestamp);
        }
        var localOffset = new Date(timestamp).getTimezoneOffset();
        self.offsetDiff = localOffset * 60 * 1000 - offset * 1000 * 60 * 60;
        self.date = new Date(timestamp + self.offsetDiff);
        self.getTime = function() {
          return self.date.getTime() - self.offsetDiff;
        };
        self.toLocaleDateString = function() {
          return self.date.toLocaleDateString();
        };
        self.getFullYear = function() {
          return self.date.getFullYear();
        };
        self.getMonth = function() {
          return self.date.getMonth();
        };
        self.getDate = function() {
          return self.date.getDate();
        };
        self.getHours = function() {
          return self.date.getHours();
        };
        self.getMinutes = function() {
          return self.date.getMinutes();
        };
        self.getSeconds = function() {
          return self.date.getSeconds();
        };
        self.getMilliseconds = function() {
          return self.date.getMilliseconds();
        };
        self.getTimezoneOffset = function() {
          return offset * 60;
        };
        self.getUTCFullYear = function() {
          return self.origDate.getUTCFullYear();
        };
        self.getUTCMonth = function() {
          return self.origDate.getUTCMonth();
        };
        self.getUTCDate = function() {
          return self.origDate.getUTCDate();
        };
        self.getUTCHours = function() {
          return self.origDate.getUTCHours();
        };
        self.getUTCMinutes = function() {
          return self.origDate.getUTCMinutes();
        };
        self.getUTCSeconds = function() {
          return self.origDate.getUTCSeconds();
        };
        self.getUTCMilliseconds = function() {
          return self.origDate.getUTCMilliseconds();
        };
        self.getDay = function() {
          return self.date.getDay();
        };
        if (self.toISOString) {
          self.toISOString = function() {
            return padNumberInMock(self.origDate.getUTCFullYear(), 4) + '-' + padNumberInMock(self.origDate.getUTCMonth() + 1, 2) + '-' + padNumberInMock(self.origDate.getUTCDate(), 2) + 'T' + padNumberInMock(self.origDate.getUTCHours(), 2) + ':' + padNumberInMock(self.origDate.getUTCMinutes(), 2) + ':' + padNumberInMock(self.origDate.getUTCSeconds(), 2) + '.' + padNumberInMock(self.origDate.getUTCMilliseconds(), 3) + 'Z';
          };
        }
        var unimplementedMethods = ['getUTCDay', 'getYear', 'setDate', 'setFullYear', 'setHours', 'setMilliseconds', 'setMinutes', 'setMonth', 'setSeconds', 'setTime', 'setUTCDate', 'setUTCFullYear', 'setUTCHours', 'setUTCMilliseconds', 'setUTCMinutes', 'setUTCMonth', 'setUTCSeconds', 'setYear', 'toDateString', 'toGMTString', 'toJSON', 'toLocaleFormat', 'toLocaleString', 'toLocaleTimeString', 'toSource', 'toString', 'toTimeString', 'toUTCString', 'valueOf'];
        angular.forEach(unimplementedMethods, function(methodName) {
          self[methodName] = function() {
            throw new Error("Method '" + methodName + "' is not implemented in the TzDate mock");
          };
        });
        return self;
      };
      angular.mock.TzDate.prototype = Date.prototype;
      angular.mock.animate = angular.module('ngAnimateMock', ['ng']).config(['$provide', function($provide) {
        $provide.factory('$$forceReflow', function() {
          function reflowFn() {
            reflowFn.totalReflows++;
          }
          reflowFn.totalReflows = 0;
          return reflowFn;
        });
        $provide.factory('$$animateAsyncRun', function() {
          var queue = [];
          var queueFn = function() {
            return function(fn) {
              queue.push(fn);
            };
          };
          queueFn.flush = function() {
            if (queue.length === 0)
              return false;
            for (var i = 0; i < queue.length; i++) {
              queue[i]();
            }
            queue = [];
            return true;
          };
          return queueFn;
        });
        $provide.decorator('$$animateJs', ['$delegate', function($delegate) {
          var runners = [];
          var animateJsConstructor = function() {
            var animator = $delegate.apply($delegate, arguments);
            if (animator) {
              runners.push(animator);
            }
            return animator;
          };
          animateJsConstructor.$closeAndFlush = function() {
            runners.forEach(function(runner) {
              runner.end();
            });
            runners = [];
          };
          return animateJsConstructor;
        }]);
        $provide.decorator('$animateCss', ['$delegate', function($delegate) {
          var runners = [];
          var animateCssConstructor = function(element, options) {
            var animator = $delegate(element, options);
            runners.push(animator);
            return animator;
          };
          animateCssConstructor.$closeAndFlush = function() {
            runners.forEach(function(runner) {
              runner.end();
            });
            runners = [];
          };
          return animateCssConstructor;
        }]);
        $provide.decorator('$animate', ['$delegate', '$timeout', '$browser', '$$rAF', '$animateCss', '$$animateJs', '$$forceReflow', '$$animateAsyncRun', '$rootScope', function($delegate, $timeout, $browser, $$rAF, $animateCss, $$animateJs, $$forceReflow, $$animateAsyncRun, $rootScope) {
          var animate = {
            queue: [],
            cancel: $delegate.cancel,
            on: $delegate.on,
            off: $delegate.off,
            pin: $delegate.pin,
            get reflows() {
              return $$forceReflow.totalReflows;
            },
            enabled: $delegate.enabled,
            closeAndFlush: function() {
              this.flush(true);
              $animateCss.$closeAndFlush();
              $$animateJs.$closeAndFlush();
              this.flush();
            },
            flush: function(hideErrors) {
              $rootScope.$digest();
              var doNextRun,
                  somethingFlushed = false;
              do {
                doNextRun = false;
                if ($$rAF.queue.length) {
                  $$rAF.flush();
                  doNextRun = somethingFlushed = true;
                }
                if ($$animateAsyncRun.flush()) {
                  doNextRun = somethingFlushed = true;
                }
              } while (doNextRun);
              if (!somethingFlushed && !hideErrors) {
                throw new Error('No pending animations ready to be closed or flushed');
              }
              $rootScope.$digest();
            }
          };
          angular.forEach(['animate', 'enter', 'leave', 'move', 'addClass', 'removeClass', 'setClass'], function(method) {
            animate[method] = function() {
              animate.queue.push({
                event: method,
                element: arguments[0],
                options: arguments[arguments.length - 1],
                args: arguments
              });
              return $delegate[method].apply($delegate, arguments);
            };
          });
          return animate;
        }]);
      }]);
      angular.mock.dump = function(object) {
        return serialize(object);
        function serialize(object) {
          var out;
          if (angular.isElement(object)) {
            object = angular.element(object);
            out = angular.element('<div></div>');
            angular.forEach(object, function(element) {
              out.append(angular.element(element).clone());
            });
            out = out.html();
          } else if (angular.isArray(object)) {
            out = [];
            angular.forEach(object, function(o) {
              out.push(serialize(o));
            });
            out = '[ ' + out.join(', ') + ' ]';
          } else if (angular.isObject(object)) {
            if (angular.isFunction(object.$eval) && angular.isFunction(object.$apply)) {
              out = serializeScope(object);
            } else if (object instanceof Error) {
              out = object.stack || ('' + object.name + ': ' + object.message);
            } else {
              out = angular.toJson(object, true);
            }
          } else {
            out = String(object);
          }
          return out;
        }
        function serializeScope(scope, offset) {
          offset = offset || '  ';
          var log = [offset + 'Scope(' + scope.$id + '): {'];
          for (var key in scope) {
            if (Object.prototype.hasOwnProperty.call(scope, key) && !key.match(/^(\$|this)/)) {
              log.push('  ' + key + ': ' + angular.toJson(scope[key]));
            }
          }
          var child = scope.$$childHead;
          while (child) {
            log.push(serializeScope(child, offset + '  '));
            child = child.$$nextSibling;
          }
          log.push('}');
          return log.join('\n' + offset);
        }
      };
      angular.mock.$HttpBackendProvider = function() {
        this.$get = ['$rootScope', '$timeout', createHttpBackendMock];
      };
      function createHttpBackendMock($rootScope, $timeout, $delegate, $browser) {
        var definitions = [],
            expectations = [],
            responses = [],
            responsesPush = angular.bind(responses, responses.push),
            copy = angular.copy;
        function createResponse(status, data, headers, statusText) {
          if (angular.isFunction(status))
            return status;
          return function() {
            return angular.isNumber(status) ? [status, data, headers, statusText] : [200, status, data, headers];
          };
        }
        function $httpBackend(method, url, data, callback, headers, timeout, withCredentials, responseType, eventHandlers, uploadEventHandlers) {
          var xhr = new MockXhr(),
              expectation = expectations[0],
              wasExpected = false;
          xhr.$$events = eventHandlers;
          xhr.upload.$$events = uploadEventHandlers;
          function prettyPrint(data) {
            return (angular.isString(data) || angular.isFunction(data) || data instanceof RegExp) ? data : angular.toJson(data);
          }
          function wrapResponse(wrapped) {
            if (!$browser && timeout) {
              timeout.then ? timeout.then(handleTimeout) : $timeout(handleTimeout, timeout);
            }
            return handleResponse;
            function handleResponse() {
              var response = wrapped.response(method, url, data, headers, wrapped.params(url));
              xhr.$$respHeaders = response[2];
              callback(copy(response[0]), copy(response[1]), xhr.getAllResponseHeaders(), copy(response[3] || ''));
            }
            function handleTimeout() {
              for (var i = 0,
                  ii = responses.length; i < ii; i++) {
                if (responses[i] === handleResponse) {
                  responses.splice(i, 1);
                  callback(-1, undefined, '');
                  break;
                }
              }
            }
          }
          if (expectation && expectation.match(method, url)) {
            if (!expectation.matchData(data)) {
              throw new Error('Expected ' + expectation + ' with different data\n' + 'EXPECTED: ' + prettyPrint(expectation.data) + '\nGOT:      ' + data);
            }
            if (!expectation.matchHeaders(headers)) {
              throw new Error('Expected ' + expectation + ' with different headers\n' + 'EXPECTED: ' + prettyPrint(expectation.headers) + '\nGOT:      ' + prettyPrint(headers));
            }
            expectations.shift();
            if (expectation.response) {
              responses.push(wrapResponse(expectation));
              return;
            }
            wasExpected = true;
          }
          var i = -1,
              definition;
          while ((definition = definitions[++i])) {
            if (definition.match(method, url, data, headers || {})) {
              if (definition.response) {
                ($browser ? $browser.defer : responsesPush)(wrapResponse(definition));
              } else if (definition.passThrough) {
                $delegate(method, url, data, callback, headers, timeout, withCredentials, responseType, eventHandlers, uploadEventHandlers);
              } else
                throw new Error('No response defined !');
              return;
            }
          }
          throw wasExpected ? new Error('No response defined !') : new Error('Unexpected request: ' + method + ' ' + url + '\n' + (expectation ? 'Expected ' + expectation : 'No more request expected'));
        }
        $httpBackend.when = function(method, url, data, headers, keys) {
          var definition = new MockHttpExpectation(method, url, data, headers, keys),
              chain = {respond: function(status, data, headers, statusText) {
                  definition.passThrough = undefined;
                  definition.response = createResponse(status, data, headers, statusText);
                  return chain;
                }};
          if ($browser) {
            chain.passThrough = function() {
              definition.response = undefined;
              definition.passThrough = true;
              return chain;
            };
          }
          definitions.push(definition);
          return chain;
        };
        createShortMethods('when');
        $httpBackend.whenRoute = function(method, url) {
          var pathObj = parseRoute(url);
          return $httpBackend.when(method, pathObj.regexp, undefined, undefined, pathObj.keys);
        };
        function parseRoute(url) {
          var ret = {regexp: url},
              keys = ret.keys = [];
          if (!url || !angular.isString(url))
            return ret;
          url = url.replace(/([().])/g, '\\$1').replace(/(\/)?:(\w+)([\?\*])?/g, function(_, slash, key, option) {
            var optional = option === '?' ? option : null;
            var star = option === '*' ? option : null;
            keys.push({
              name: key,
              optional: !!optional
            });
            slash = slash || '';
            return '' + (optional ? '' : slash) + '(?:' + (optional ? slash : '') + (star && '(.+?)' || '([^/]+)') + (optional || '') + ')' + (optional || '');
          }).replace(/([\/$\*])/g, '\\$1');
          ret.regexp = new RegExp('^' + url, 'i');
          return ret;
        }
        $httpBackend.expect = function(method, url, data, headers, keys) {
          var expectation = new MockHttpExpectation(method, url, data, headers, keys),
              chain = {respond: function(status, data, headers, statusText) {
                  expectation.response = createResponse(status, data, headers, statusText);
                  return chain;
                }};
          expectations.push(expectation);
          return chain;
        };
        createShortMethods('expect');
        $httpBackend.expectRoute = function(method, url) {
          var pathObj = parseRoute(url);
          return $httpBackend.expect(method, pathObj.regexp, undefined, undefined, pathObj.keys);
        };
        $httpBackend.flush = function(count, digest) {
          if (digest !== false)
            $rootScope.$digest();
          if (!responses.length)
            throw new Error('No pending request to flush !');
          if (angular.isDefined(count) && count !== null) {
            while (count--) {
              if (!responses.length)
                throw new Error('No more pending request to flush !');
              responses.shift()();
            }
          } else {
            while (responses.length) {
              responses.shift()();
            }
          }
          $httpBackend.verifyNoOutstandingExpectation(digest);
        };
        $httpBackend.verifyNoOutstandingExpectation = function(digest) {
          if (digest !== false)
            $rootScope.$digest();
          if (expectations.length) {
            throw new Error('Unsatisfied requests: ' + expectations.join(', '));
          }
        };
        $httpBackend.verifyNoOutstandingRequest = function() {
          if (responses.length) {
            throw new Error('Unflushed requests: ' + responses.length);
          }
        };
        $httpBackend.resetExpectations = function() {
          expectations.length = 0;
          responses.length = 0;
        };
        return $httpBackend;
        function createShortMethods(prefix) {
          angular.forEach(['GET', 'DELETE', 'JSONP', 'HEAD'], function(method) {
            $httpBackend[prefix + method] = function(url, headers, keys) {
              return $httpBackend[prefix](method, url, undefined, headers, keys);
            };
          });
          angular.forEach(['PUT', 'POST', 'PATCH'], function(method) {
            $httpBackend[prefix + method] = function(url, data, headers, keys) {
              return $httpBackend[prefix](method, url, data, headers, keys);
            };
          });
        }
      }
      function MockHttpExpectation(method, url, data, headers, keys) {
        function getUrlParams(u) {
          var params = u.slice(u.indexOf('?') + 1).split('&');
          return params.sort();
        }
        function compareUrl(u) {
          return (url.slice(0, url.indexOf('?')) == u.slice(0, u.indexOf('?')) && getUrlParams(url).join() == getUrlParams(u).join());
        }
        this.data = data;
        this.headers = headers;
        this.match = function(m, u, d, h) {
          if (method != m)
            return false;
          if (!this.matchUrl(u))
            return false;
          if (angular.isDefined(d) && !this.matchData(d))
            return false;
          if (angular.isDefined(h) && !this.matchHeaders(h))
            return false;
          return true;
        };
        this.matchUrl = function(u) {
          if (!url)
            return true;
          if (angular.isFunction(url.test))
            return url.test(u);
          if (angular.isFunction(url))
            return url(u);
          return (url == u || compareUrl(u));
        };
        this.matchHeaders = function(h) {
          if (angular.isUndefined(headers))
            return true;
          if (angular.isFunction(headers))
            return headers(h);
          return angular.equals(headers, h);
        };
        this.matchData = function(d) {
          if (angular.isUndefined(data))
            return true;
          if (data && angular.isFunction(data.test))
            return data.test(d);
          if (data && angular.isFunction(data))
            return data(d);
          if (data && !angular.isString(data)) {
            return angular.equals(angular.fromJson(angular.toJson(data)), angular.fromJson(d));
          }
          return data == d;
        };
        this.toString = function() {
          return method + ' ' + url;
        };
        this.params = function(u) {
          return angular.extend(parseQuery(), pathParams());
          function pathParams() {
            var keyObj = {};
            if (!url || !angular.isFunction(url.test) || !keys || keys.length === 0)
              return keyObj;
            var m = url.exec(u);
            if (!m)
              return keyObj;
            for (var i = 1,
                len = m.length; i < len; ++i) {
              var key = keys[i - 1];
              var val = m[i];
              if (key && val) {
                keyObj[key.name || key] = val;
              }
            }
            return keyObj;
          }
          function parseQuery() {
            var obj = {},
                key_value,
                key,
                queryStr = u.indexOf('?') > -1 ? u.substring(u.indexOf('?') + 1) : "";
            angular.forEach(queryStr.split('&'), function(keyValue) {
              if (keyValue) {
                key_value = keyValue.replace(/\+/g, '%20').split('=');
                key = tryDecodeURIComponent(key_value[0]);
                if (angular.isDefined(key)) {
                  var val = angular.isDefined(key_value[1]) ? tryDecodeURIComponent(key_value[1]) : true;
                  if (!hasOwnProperty.call(obj, key)) {
                    obj[key] = val;
                  } else if (angular.isArray(obj[key])) {
                    obj[key].push(val);
                  } else {
                    obj[key] = [obj[key], val];
                  }
                }
              }
            });
            return obj;
          }
          function tryDecodeURIComponent(value) {
            try {
              return decodeURIComponent(value);
            } catch (e) {}
          }
        };
      }
      function createMockXhr() {
        return new MockXhr();
      }
      function MockXhr() {
        MockXhr.$$lastInstance = this;
        this.open = function(method, url, async) {
          this.$$method = method;
          this.$$url = url;
          this.$$async = async;
          this.$$reqHeaders = {};
          this.$$respHeaders = {};
        };
        this.send = function(data) {
          this.$$data = data;
        };
        this.setRequestHeader = function(key, value) {
          this.$$reqHeaders[key] = value;
        };
        this.getResponseHeader = function(name) {
          var header = this.$$respHeaders[name];
          if (header)
            return header;
          name = angular.lowercase(name);
          header = this.$$respHeaders[name];
          if (header)
            return header;
          header = undefined;
          angular.forEach(this.$$respHeaders, function(headerVal, headerName) {
            if (!header && angular.lowercase(headerName) == name)
              header = headerVal;
          });
          return header;
        };
        this.getAllResponseHeaders = function() {
          var lines = [];
          angular.forEach(this.$$respHeaders, function(value, key) {
            lines.push(key + ': ' + value);
          });
          return lines.join('\n');
        };
        this.abort = angular.noop;
        this.$$events = {};
        this.addEventListener = function(name, listener) {
          if (angular.isUndefined(this.$$events[name]))
            this.$$events[name] = [];
          this.$$events[name].push(listener);
        };
        this.upload = {
          $$events: {},
          addEventListener: this.addEventListener
        };
      }
      angular.mock.$TimeoutDecorator = ['$delegate', '$browser', function($delegate, $browser) {
        $delegate.flush = function(delay) {
          $browser.defer.flush(delay);
        };
        $delegate.verifyNoPendingTasks = function() {
          if ($browser.deferredFns.length) {
            throw new Error('Deferred tasks to flush (' + $browser.deferredFns.length + '): ' + formatPendingTasksAsString($browser.deferredFns));
          }
        };
        function formatPendingTasksAsString(tasks) {
          var result = [];
          angular.forEach(tasks, function(task) {
            result.push('{id: ' + task.id + ', ' + 'time: ' + task.time + '}');
          });
          return result.join(', ');
        }
        return $delegate;
      }];
      angular.mock.$RAFDecorator = ['$delegate', function($delegate) {
        var rafFn = function(fn) {
          var index = rafFn.queue.length;
          rafFn.queue.push(fn);
          return function() {
            rafFn.queue.splice(index, 1);
          };
        };
        rafFn.queue = [];
        rafFn.supported = $delegate.supported;
        rafFn.flush = function() {
          if (rafFn.queue.length === 0) {
            throw new Error('No rAF callbacks present');
          }
          var length = rafFn.queue.length;
          for (var i = 0; i < length; i++) {
            rafFn.queue[i]();
          }
          rafFn.queue = rafFn.queue.slice(i);
        };
        return rafFn;
      }];
      var originalRootElement;
      angular.mock.$RootElementProvider = function() {
        this.$get = ['$injector', function($injector) {
          originalRootElement = angular.element('<div ng-app></div>').data('$injector', $injector);
          return originalRootElement;
        }];
      };
      angular.mock.$ControllerDecorator = ['$delegate', function($delegate) {
        return function(expression, locals, later, ident) {
          if (later && typeof later === 'object') {
            var instantiate = $delegate(expression, locals, true, ident);
            angular.extend(instantiate.instance, later);
            var instance = instantiate();
            if (instance !== instantiate.instance) {
              angular.extend(instance, later);
            }
            return instance;
          }
          return $delegate(expression, locals, later, ident);
        };
      }];
      angular.mock.$ComponentControllerProvider = ['$compileProvider', function($compileProvider) {
        this.$get = ['$controller', '$injector', '$rootScope', function($controller, $injector, $rootScope) {
          return function $componentController(componentName, locals, bindings, ident) {
            var directives = $injector.get(componentName + 'Directive');
            var candidateDirectives = directives.filter(function(directiveInfo) {
              return directiveInfo.controller && directiveInfo.controllerAs && directiveInfo.restrict === 'E';
            });
            if (candidateDirectives.length === 0) {
              throw new Error('No component found');
            }
            if (candidateDirectives.length > 1) {
              throw new Error('Too many components found');
            }
            var directiveInfo = candidateDirectives[0];
            locals = locals || {};
            locals.$scope = locals.$scope || $rootScope.$new(true);
            return $controller(directiveInfo.controller, locals, bindings, ident || directiveInfo.controllerAs);
          };
        }];
      }];
      angular.module('ngMock', ['ng']).provider({
        $browser: angular.mock.$BrowserProvider,
        $exceptionHandler: angular.mock.$ExceptionHandlerProvider,
        $log: angular.mock.$LogProvider,
        $interval: angular.mock.$IntervalProvider,
        $httpBackend: angular.mock.$HttpBackendProvider,
        $rootElement: angular.mock.$RootElementProvider,
        $componentController: angular.mock.$ComponentControllerProvider
      }).config(['$provide', function($provide) {
        $provide.decorator('$timeout', angular.mock.$TimeoutDecorator);
        $provide.decorator('$$rAF', angular.mock.$RAFDecorator);
        $provide.decorator('$rootScope', angular.mock.$RootScopeDecorator);
        $provide.decorator('$controller', angular.mock.$ControllerDecorator);
      }]);
      angular.module('ngMockE2E', ['ng']).config(['$provide', function($provide) {
        $provide.value('$httpBackend', angular.injector(['ng']).get('$httpBackend'));
        $provide.decorator('$httpBackend', angular.mock.e2e.$httpBackendDecorator);
      }]);
      angular.mock.e2e = {};
      angular.mock.e2e.$httpBackendDecorator = ['$rootScope', '$timeout', '$delegate', '$browser', createHttpBackendMock];
      angular.mock.$RootScopeDecorator = ['$delegate', function($delegate) {
        var $rootScopePrototype = Object.getPrototypeOf($delegate);
        $rootScopePrototype.$countChildScopes = countChildScopes;
        $rootScopePrototype.$countWatchers = countWatchers;
        return $delegate;
        function countChildScopes() {
          var count = 0;
          var pendingChildHeads = [this.$$childHead];
          var currentScope;
          while (pendingChildHeads.length) {
            currentScope = pendingChildHeads.shift();
            while (currentScope) {
              count += 1;
              pendingChildHeads.push(currentScope.$$childHead);
              currentScope = currentScope.$$nextSibling;
            }
          }
          return count;
        }
        function countWatchers() {
          var count = this.$$watchers ? this.$$watchers.length : 0;
          var pendingChildHeads = [this.$$childHead];
          var currentScope;
          while (pendingChildHeads.length) {
            currentScope = pendingChildHeads.shift();
            while (currentScope) {
              count += currentScope.$$watchers ? currentScope.$$watchers.length : 0;
              pendingChildHeads.push(currentScope.$$childHead);
              currentScope = currentScope.$$nextSibling;
            }
          }
          return count;
        }
      }];
      !(function(jasmineOrMocha) {
        if (!jasmineOrMocha) {
          return;
        }
        var currentSpec = null,
            injectorState = new InjectorState(),
            annotatedFunctions = [],
            wasInjectorCreated = function() {
              return !!currentSpec;
            };
        angular.mock.$$annotate = angular.injector.$$annotate;
        angular.injector.$$annotate = function(fn) {
          if (typeof fn === 'function' && !fn.$inject) {
            annotatedFunctions.push(fn);
          }
          return angular.mock.$$annotate.apply(this, arguments);
        };
        var module = window.module = angular.mock.module = function() {
          var moduleFns = Array.prototype.slice.call(arguments, 0);
          return wasInjectorCreated() ? workFn() : workFn;
          function workFn() {
            if (currentSpec.$injector) {
              throw new Error('Injector already created, can not register a module!');
            } else {
              var fn,
                  modules = currentSpec.$modules || (currentSpec.$modules = []);
              angular.forEach(moduleFns, function(module) {
                if (angular.isObject(module) && !angular.isArray(module)) {
                  fn = ['$provide', function($provide) {
                    angular.forEach(module, function(value, key) {
                      $provide.value(key, value);
                    });
                  }];
                } else {
                  fn = module;
                }
                if (currentSpec.$providerInjector) {
                  currentSpec.$providerInjector.invoke(fn);
                } else {
                  modules.push(fn);
                }
              });
            }
          }
        };
        module.$$beforeAllHook = (window.before || window.beforeAll);
        module.$$afterAllHook = (window.after || window.afterAll);
        module.$$currentSpec = function(to) {
          if (arguments.length === 0)
            return to;
          currentSpec = to;
        };
        module.sharedInjector = function() {
          if (!(module.$$beforeAllHook && module.$$afterAllHook)) {
            throw Error("sharedInjector() cannot be used unless your test runner defines beforeAll/afterAll");
          }
          var initialized = false;
          module.$$beforeAllHook(function() {
            if (injectorState.shared) {
              injectorState.sharedError = Error("sharedInjector() cannot be called inside a context that has already called sharedInjector()");
              throw injectorState.sharedError;
            }
            initialized = true;
            currentSpec = this;
            injectorState.shared = true;
          });
          module.$$afterAllHook(function() {
            if (initialized) {
              injectorState = new InjectorState();
              module.$$cleanup();
            } else {
              injectorState.sharedError = null;
            }
          });
        };
        module.$$beforeEach = function() {
          if (injectorState.shared && currentSpec && currentSpec != this) {
            var state = currentSpec;
            currentSpec = this;
            angular.forEach(["$injector", "$modules", "$providerInjector", "$injectorStrict"], function(k) {
              currentSpec[k] = state[k];
              state[k] = null;
            });
          } else {
            currentSpec = this;
            originalRootElement = null;
            annotatedFunctions = [];
          }
        };
        module.$$afterEach = function() {
          if (injectorState.cleanupAfterEach()) {
            module.$$cleanup();
          }
        };
        module.$$cleanup = function() {
          var injector = currentSpec.$injector;
          annotatedFunctions.forEach(function(fn) {
            delete fn.$inject;
          });
          angular.forEach(currentSpec.$modules, function(module) {
            if (module && module.$$hashKey) {
              module.$$hashKey = undefined;
            }
          });
          currentSpec.$injector = null;
          currentSpec.$modules = null;
          currentSpec.$providerInjector = null;
          currentSpec = null;
          if (injector) {
            var $rootElement = injector.get('$rootElement');
            var rootNode = $rootElement && $rootElement[0];
            var cleanUpNodes = !originalRootElement ? [] : [originalRootElement[0]];
            if (rootNode && (!originalRootElement || rootNode !== originalRootElement[0])) {
              cleanUpNodes.push(rootNode);
            }
            angular.element.cleanData(cleanUpNodes);
            var $rootScope = injector.get('$rootScope');
            if ($rootScope && $rootScope.$destroy)
              $rootScope.$destroy();
          }
          angular.forEach(angular.element.fragments, function(val, key) {
            delete angular.element.fragments[key];
          });
          MockXhr.$$lastInstance = null;
          angular.forEach(angular.callbacks, function(val, key) {
            delete angular.callbacks[key];
          });
          angular.callbacks.counter = 0;
        };
        (window.beforeEach || window.setup)(module.$$beforeEach);
        (window.afterEach || window.teardown)(module.$$afterEach);
        var ErrorAddingDeclarationLocationStack = function(e, errorForStack) {
          this.message = e.message;
          this.name = e.name;
          if (e.line)
            this.line = e.line;
          if (e.sourceId)
            this.sourceId = e.sourceId;
          if (e.stack && errorForStack)
            this.stack = e.stack + '\n' + errorForStack.stack;
          if (e.stackArray)
            this.stackArray = e.stackArray;
        };
        ErrorAddingDeclarationLocationStack.prototype.toString = Error.prototype.toString;
        window.inject = angular.mock.inject = function() {
          var blockFns = Array.prototype.slice.call(arguments, 0);
          var errorForStack = new Error('Declaration Location');
          if (!errorForStack.stack) {
            try {
              throw errorForStack;
            } catch (e) {}
          }
          return wasInjectorCreated() ? workFn.call(currentSpec) : workFn;
          function workFn() {
            var modules = currentSpec.$modules || [];
            var strictDi = !!currentSpec.$injectorStrict;
            modules.unshift(['$injector', function($injector) {
              currentSpec.$providerInjector = $injector;
            }]);
            modules.unshift('ngMock');
            modules.unshift('ng');
            var injector = currentSpec.$injector;
            if (!injector) {
              if (strictDi) {
                angular.forEach(modules, function(moduleFn) {
                  if (typeof moduleFn === "function") {
                    angular.injector.$$annotate(moduleFn);
                  }
                });
              }
              injector = currentSpec.$injector = angular.injector(modules, strictDi);
              currentSpec.$injectorStrict = strictDi;
            }
            for (var i = 0,
                ii = blockFns.length; i < ii; i++) {
              if (currentSpec.$injectorStrict) {
                injector.annotate(blockFns[i]);
              }
              try {
                injector.invoke(blockFns[i] || angular.noop, this);
              } catch (e) {
                if (e.stack && errorForStack) {
                  throw new ErrorAddingDeclarationLocationStack(e, errorForStack);
                }
                throw e;
              } finally {
                errorForStack = null;
              }
            }
          }
        };
        angular.mock.inject.strictDi = function(value) {
          value = arguments.length ? !!value : true;
          return wasInjectorCreated() ? workFn() : workFn;
          function workFn() {
            if (value !== currentSpec.$injectorStrict) {
              if (currentSpec.$injector) {
                throw new Error('Injector already created, can not modify strict annotations');
              } else {
                currentSpec.$injectorStrict = value;
              }
            }
          }
        };
        function InjectorState() {
          this.shared = false;
          this.sharedError = null;
          this.cleanupAfterEach = function() {
            return !this.shared || this.sharedError;
          };
        }
      })(window.jasmine || window.mocha);
    })(window, window.angular);
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("87", ["8b"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('8b');
  return module.exports;
});

$__System.registerDynamic("8c", ["37", "4d", "4e", "87", "88", "56", "4f"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var _getOwnPropertyDescriptor = $__require('37');
  var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);
  var _classCallCheck2 = $__require('4d');
  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
  var _createClass2 = $__require('4e');
  var _createClass3 = _interopRequireDefault(_createClass2);
  var _dec,
      _desc,
      _value,
      _class,
      _dec2,
      _desc2,
      _value2,
      _class2;
  $__require('87');
  var _angular = $__require('88');
  var _angular2 = _interopRequireDefault(_angular);
  var _ngDecorators = $__require('56');
  var _index = $__require('4f');
  var _index2 = _interopRequireDefault(_index);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object['ke' + 'ys'](descriptor).forEach(function(key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function(desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
      Object['define' + 'Property'](target, property, desc);
      desc = null;
    }
    return desc;
  }
  var OnConfigTest = (_dec = (0, _ngDecorators.Config)(), (_class = function() {
    function OnConfigTest() {
      (0, _classCallCheck3.default)(this, OnConfigTest);
    }
    (0, _createClass3.default)(OnConfigTest, null, [{
      key: 'configFactory',
      value: function configFactory($provide) {
        if (_index2.default.config.isQaMode()) {
          console.log("config test");
        }
      }
    }]);
    return OnConfigTest;
  }(), (_applyDecoratedDescriptor(_class, 'configFactory', [_dec], (0, _getOwnPropertyDescriptor2.default)(_class, 'configFactory'), _class)), _class));
  var OnRunTest = (_dec2 = (0, _ngDecorators.Run)(), (_class2 = function() {
    function OnRunTest() {
      (0, _classCallCheck3.default)(this, OnRunTest);
    }
    (0, _createClass3.default)(OnRunTest, null, [{
      key: 'runFactory',
      value: function runFactory($rootScope) {}
    }]);
    return OnRunTest;
  }(), (_applyDecoratedDescriptor(_class2, 'runFactory', [_dec2], (0, _getOwnPropertyDescriptor2.default)(_class2, 'runFactory'), _class2)), _class2));
  return module.exports;
});

$__System.registerDynamic("8d", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var process = module.exports = {};
  var cachedSetTimeout;
  var cachedClearTimeout;
  (function() {
    try {
      cachedSetTimeout = setTimeout;
    } catch (e) {
      cachedSetTimeout = function() {
        throw new Error('setTimeout is not defined');
      };
    }
    try {
      cachedClearTimeout = clearTimeout;
    } catch (e) {
      cachedClearTimeout = function() {
        throw new Error('clearTimeout is not defined');
      };
    }
  }());
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  function cleanUpNextTick() {
    if (!draining || !currentQueue) {
      return;
    }
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = cachedSetTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    cachedClearTimeout(timeout);
  }
  process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
      cachedSetTimeout(drainQueue, 0);
    }
  };
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  Item.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = '';
  process.versions = {};
  function noop() {}
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.binding = function(name) {
    throw new Error('process.binding is not supported');
  };
  process.cwd = function() {
    return '/';
  };
  process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
  };
  process.umask = function() {
    return 0;
  };
  return module.exports;
});

$__System.registerDynamic("8e", ["8d"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('8d');
  return module.exports;
});

$__System.registerDynamic("8f", ["8e"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__System._nodeRequire ? process : $__require('8e');
  return module.exports;
});

$__System.registerDynamic("28", ["8f"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('8f');
  return module.exports;
});

$__System.registerDynamic("90", ["37", "4d", "4e", "56", "4f", "28"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  (function(process) {
    'use strict';
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.OnRunProd = exports.OnConfigProd = undefined;
    var _getOwnPropertyDescriptor = $__require('37');
    var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);
    var _classCallCheck2 = $__require('4d');
    var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
    var _createClass2 = $__require('4e');
    var _createClass3 = _interopRequireDefault(_createClass2);
    var _dec,
        _dec2,
        _desc,
        _value,
        _class,
        _dec3,
        _dec4,
        _desc2,
        _value2,
        _class2;
    var _ngDecorators = $__require('56');
    var _index = $__require('4f');
    var _index2 = _interopRequireDefault(_index);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {default: obj};
    }
    function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
      var desc = {};
      Object['ke' + 'ys'](descriptor).forEach(function(key) {
        desc[key] = descriptor[key];
      });
      desc.enumerable = !!desc.enumerable;
      desc.configurable = !!desc.configurable;
      if ('value' in desc || desc.initializer) {
        desc.writable = true;
      }
      desc = decorators.slice().reverse().reduce(function(desc, decorator) {
        return decorator(target, property, desc) || desc;
      }, desc);
      if (context && desc.initializer !== void 0) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = undefined;
      }
      if (desc.initializer === void 0) {
        Object['define' + 'Property'](target, property, desc);
        desc = null;
      }
      return desc;
    }
    var OnConfigProd = (_dec = (0, _ngDecorators.Config)(), _dec2 = (0, _ngDecorators.Inject)('$compileProvider', '$httpProvider'), (_class = function() {
      function OnConfigProd() {
        (0, _classCallCheck3.default)(this, OnConfigProd);
      }
      (0, _createClass3.default)(OnConfigProd, null, [{
        key: 'configFactory',
        value: function configFactory($compileProvider, $httpProvider) {
          if (_index2.default.config.isProductionMode()) {
            $compileProvider.debugInfoEnabled(false);
            $httpProvider.useApplyAsync(true);
          }
        }
      }]);
      return OnConfigProd;
    }(), (_applyDecoratedDescriptor(_class, 'configFactory', [_dec, _dec2], (0, _getOwnPropertyDescriptor2.default)(_class, 'configFactory'), _class)), _class));
    var OnRunProd = (_dec3 = (0, _ngDecorators.Run)(), _dec4 = (0, _ngDecorators.Inject)('$rootScope'), (_class2 = function() {
      function OnRunProd() {
        (0, _classCallCheck3.default)(this, OnRunProd);
      }
      (0, _createClass3.default)(OnRunProd, null, [{
        key: 'runFactory',
        value: function runFactory($rootScope) {}
      }]);
      return OnRunProd;
    }(), (_applyDecoratedDescriptor(_class2, 'runFactory', [_dec3, _dec4], (0, _getOwnPropertyDescriptor2.default)(_class2, 'runFactory'), _class2)), _class2));
    exports.OnConfigProd = OnConfigProd;
    exports.OnRunProd = OnRunProd;
  })($__require('28'));
  return module.exports;
});

$__System.registerDynamic("63", ["6f", "65", "71"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('6f'),
      core = $__require('65'),
      fails = $__require('71');
  module.exports = function(KEY, exec) {
    var fn = (core.Object || {})[KEY] || Object[KEY],
        exp = {};
    exp[KEY] = exec(fn);
    $export($export.S + $export.F * fails(function() {
      fn(1);
    }), 'Object', exp);
  };
  return module.exports;
});

$__System.registerDynamic("91", ["68", "63"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var toIObject = $__require('68');
  $__require('63')('getOwnPropertyDescriptor', function($getOwnPropertyDescriptor) {
    return function getOwnPropertyDescriptor(it, key) {
      return $getOwnPropertyDescriptor(toIObject(it), key);
    };
  });
  return module.exports;
});

$__System.registerDynamic("92", ["67", "91"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('67');
  $__require('91');
  module.exports = function getOwnPropertyDescriptor(it, key) {
    return $.getDesc(it, key);
  };
  return module.exports;
});

$__System.registerDynamic("37", ["92"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = {
    "default": $__require('92'),
    __esModule: true
  };
  return module.exports;
});

$__System.registerDynamic("93", ["37", "4d", "4e", "56", "48"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.OnRun = exports.OnConfig = undefined;
  var _getOwnPropertyDescriptor = $__require('37');
  var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);
  var _classCallCheck2 = $__require('4d');
  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
  var _createClass2 = $__require('4e');
  var _createClass3 = _interopRequireDefault(_createClass2);
  var _dec,
      _dec2,
      _desc,
      _value,
      _class,
      _dec3,
      _dec4,
      _desc2,
      _value2,
      _class2;
  var _ngDecorators = $__require('56');
  var _lodash = $__require('48');
  var _lodash2 = _interopRequireDefault(_lodash);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object['ke' + 'ys'](descriptor).forEach(function(key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function(desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
      Object['define' + 'Property'](target, property, desc);
      desc = null;
    }
    return desc;
  }
  var OnConfig = (_dec = (0, _ngDecorators.Config)(), _dec2 = (0, _ngDecorators.Inject)('$locationProvider', '$provide', '$urlRouterProvider'), (_class = function() {
    function OnConfig() {
      (0, _classCallCheck3.default)(this, OnConfig);
    }
    (0, _createClass3.default)(OnConfig, null, [{
      key: 'configFactory',
      value: function configFactory($locationProvider, $provide, $urlRouterProvider) {
        $provide.decorator('$uiViewScroll', ['$delegate', '$window', function($delegate, $window) {
          return function() {
            $window.scrollTo(0, 0);
          };
        }]);
        0;
        $locationProvider.html5Mode({
          enabled: true,
          requireBase: false
        });
        $urlRouterProvider.otherwise('/404');
      }
    }]);
    return OnConfig;
  }(), (_applyDecoratedDescriptor(_class, 'configFactory', [_dec, _dec2], (0, _getOwnPropertyDescriptor2.default)(_class, 'configFactory'), _class)), _class));
  var OnRun = (_dec3 = (0, _ngDecorators.Run)(), _dec4 = (0, _ngDecorators.Inject)('$rootScope', '$state', '$log'), (_class2 = function() {
    function OnRun() {
      (0, _classCallCheck3.default)(this, OnRun);
    }
    (0, _createClass3.default)(OnRun, null, [{
      key: 'runFactory',
      value: function runFactory($rootScope, $state, $log, StateStore) {
        console.log(StateStore);
        $rootScope.$on('$stateChangeStart', function(event, toState) {});
        $rootScope.$on('$stateChangeError', function(event, toState, toParams, fromState, fromParams, error) {});
        $rootScope.$on('$stateChangeSuccess', function(event, toState, toParams, fromState, fromParams) {});
        $rootScope.$on('$viewContentLoaded', function(event) {
          event.preventDefault();
        });
        $rootScope.$on('$stateNotFound', function(event, unfoundState, fromState, fromParams) {});
        $rootScope.$on('$stateChangeError', function(event, toState, toParams, fromState, fromParams, error) {
          event.preventDefault();
          $log.error(error.stack);
          $state.go('500');
        });
      }
    }]);
    return OnRun;
  }(), (_applyDecoratedDescriptor(_class2, 'runFactory', [_dec3, _dec4], (0, _getOwnPropertyDescriptor2.default)(_class2, 'runFactory'), _class2)), _class2));
  exports.OnConfig = OnConfig;
  exports.OnRun = OnRun;
  return module.exports;
});

$__System.registerDynamic("94", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = "<div id=\"test-ui-harness\" style=\"position: fixed; bottom: 0; left: 0; right: 0; max-height: 200px; overflow-y: scroll;\" ng-class=\"{hidden: vm.isTesting === false}\">\n    <div class=\"request {{'type-' + response.type}}\" ng-class=\"{error: response.error}\" ng-repeat=\"response in vm.responses\">\n        <span class=\"type\">{{response.type}}</span>\n        <span class=\"request-url\">{{response.url}}</span>\n        <span class=\"response\">{{response.data}}</span>\n    </div>\n    <button id=\"start-test-exchange-recording\" ng-click=\"vm.startWatching()\">Record</button>\n    <button id=\"stop-test-exchange-recording\" ng-click=\"vm.stopWatching()\">Stop</button>\n</div>";
  return module.exports;
});

$__System.registerDynamic("95", ["5c", "4d", "4e", "48", "56", "4f", "94"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _stringify = $__require('5c');
  var _stringify2 = _interopRequireDefault(_stringify);
  var _classCallCheck2 = $__require('4d');
  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
  var _createClass2 = $__require('4e');
  var _createClass3 = _interopRequireDefault(_createClass2);
  var _dec,
      _dec2,
      _class;
  var _lodash = $__require('48');
  var _lodash2 = _interopRequireDefault(_lodash);
  var _ngDecorators = $__require('56');
  var _index = $__require('4f');
  var _index2 = _interopRequireDefault(_index);
  var _testUiHarness = $__require('94');
  var _testUiHarness2 = _interopRequireDefault(_testUiHarness);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var API_BASE;
  var TestUiHarness = (_dec = (0, _ngDecorators.Component)({selector: 'test-ui-harness'}), _dec2 = (0, _ngDecorators.View)({template: _testUiHarness2.default}), _dec(_class = _dec2(_class = function() {
    function TestUiHarness($rootScope) {
      (0, _classCallCheck3.default)(this, TestUiHarness);
      var that = this;
      API_BASE = _index2.default.config.getApiBase();
      this.responses = null;
      this.isTesting = false;
      if (_index2.default.config.isCliMode()) {
        this.isTesting = true;
      }
      $rootScope.addTestUIHarnessResponse = function(response) {
        that.addResponse(response);
      };
    }
    (0, _createClass3.default)(TestUiHarness, [{
      key: 'addResponse',
      value: function addResponse(response) {
        if (this.isTesting && this.watching) {
          var setResp = {};
          if (response.config) {
            setResp.type = response.config.method;
            setResp.url = _lodash2.default.isString(response.config.url) ? response.config.url.substr(API_BASE.length) : "";
          }
          if (response.status < 200 || response.status > 299) {
            setResp.error = true;
          }
          if (response.data) {
            setResp.data = response.data;
            try {
              setResp.data = (0, _stringify2.default)(response.data);
            } catch (e) {}
          }
          this.responses.push(setResp);
        }
        if (this.isTesting) {
          if (response.status < 200 || response.status > 299) {
            var message = 'Server Error. StatusCode: ' + response.status;
            if (response.status === -1) {
              message += ". Is the backend server enabled?";
            }
            throw new Error(message);
          }
        }
      }
    }, {
      key: 'startWatching',
      value: function startWatching() {
        this.responses = [];
        this.watching = true;
      }
    }, {
      key: 'stopWatching',
      value: function stopWatching() {
        this.watching = false;
      }
    }]);
    return TestUiHarness;
  }()) || _class) || _class);
  exports.default = TestUiHarness;
  return module.exports;
});

$__System.registerDynamic("96", ["95"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('95');
  return module.exports;
});

$__System.registerDynamic("97", ["4d", "4e", "48", "56"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _classCallCheck2 = $__require('4d');
  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
  var _createClass2 = $__require('4e');
  var _createClass3 = _interopRequireDefault(_createClass2);
  var _dec,
      _class;
  var _lodash = $__require('48');
  var _lodash2 = _interopRequireDefault(_lodash);
  var _ngDecorators = $__require('56');
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var AttachDataState = (_dec = (0, _ngDecorators.Directive)({selector: 'attach-data-state'}), _dec(_class = function() {
    function AttachDataState($rootScope, $state) {
      (0, _classCallCheck3.default)(this, AttachDataState);
      this.restrict = 'A';
      this.require = 'ngModel';
      this.scope = false;
    }
    (0, _createClass3.default)(AttachDataState, [{
      key: 'link',
      value: function link(scope, element, attrs, ngModel) {
        var setClasses = [];
        var modelBits = attrs["ngModel"].split(".");
        if (modelBits[0] == "vm") {
          modelBits.shift();
        }
        if (!modelBits.length) {
          return;
        }
        if (!_lodash2.default.has(scope.$parent, modelBits[0])) {
          console.log(scope.$parent, modelBits[0]);
          throw new Error("Can't find ngModel base node in scope");
        }
        scope.$parent[modelBits[0]].onStateChange(function(newState) {
          var states = newState.split(":");
          var parent = states[0];
          var remove = [];
          _lodash2.default.each(setClasses, function(name) {
            if (_lodash2.default.startsWith(name, parent)) {
              remove.push(name);
            }
          });
          if (remove.length) {
            _lodash2.default.each(remove, function(name) {
              element.removeClass(name.replace(":", "-"));
              setClasses.splice(setClasses.indexOf(name), 1);
            }, this);
          }
          setClasses.push(newState);
          element.addClass(newState.replace(":", "-"));
        });
      }
    }], [{
      key: 'directiveFactory',
      value: function directiveFactory($rootScope, $state) {
        AttachDataState.instance = new AttachDataState($rootScope, $state);
        return AttachDataState.instance;
      }
    }]);
    return AttachDataState;
  }()) || _class);
  exports.default = AttachDataState;
  return module.exports;
});

$__System.registerDynamic("98", ["4d", "4e", "56"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _classCallCheck2 = $__require('4d');
  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
  var _createClass2 = $__require('4e');
  var _createClass3 = _interopRequireDefault(_createClass2);
  var _dec,
      _class;
  var _ngDecorators = $__require('56');
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var Form = (_dec = (0, _ngDecorators.Directive)({selector: 'form'}), _dec(_class = function() {
    function Form($rootScope, $state) {
      (0, _classCallCheck3.default)(this, Form);
      this.restrict = 'E';
      this.scope = false;
    }
    (0, _createClass3.default)(Form, [{
      key: 'compile',
      value: function compile(element, attrs) {
        if (!attrs.name) {
          throw new Error("Your form must have a 'name' attribute.");
        }
        if (attrs.name.indexOf("-") !== -1) {
          throw new Error("Your form name cannot contain -. Use Camel Case.");
        }
        if (attrs.name != "form") {
          angular.element(element).attr("name", "_form");
          console.log("I had to change your form name to 'form' in order for the ng-message validators to work.");
        }
        element.attr("novalidate", true);
        return {pre: function pre(scope, element, attrs, ngModel) {
            element.bind("submit", function(e) {
              e.preventDefault();
              if (scope[attrs.name].$valid) {
                scope.$eval(attrs.onSubmit);
                return true;
              }
              return false;
            });
          }};
      }
    }], [{
      key: 'directiveFactory',
      value: function directiveFactory($rootScope, $state) {
        Form.instance = new Form($rootScope, $state);
        return Form.instance;
      }
    }]);
    return Form;
  }()) || _class);
  exports.default = Form;
  return module.exports;
});

$__System.registerDynamic("99", ["4d", "4e", "48", "56"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _classCallCheck2 = $__require('4d');
  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
  var _createClass2 = $__require('4e');
  var _createClass3 = _interopRequireDefault(_createClass2);
  var _dec,
      _class;
  var _lodash = $__require('48');
  var _lodash2 = _interopRequireDefault(_lodash);
  var _ngDecorators = $__require('56');
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var Input = (_dec = (0, _ngDecorators.Directive)({selector: 'input'}), _dec(_class = function() {
    function Input($rootScope, $state) {
      (0, _classCallCheck3.default)(this, Input);
      this.restrict = 'E';
      this.scope = false;
    }
    (0, _createClass3.default)(Input, [{
      key: 'compile',
      value: function compile(element, attrs) {
        if (!attrs) {
          attrs = {};
        }
        if (attrs.class && attrs.class.indexOf("md-datepicker-input") !== -1) {
          attrs.type = 'date';
        }
        return {pre: function pre(scope, element, attrs, ngModel) {}};
      }
    }], [{
      key: 'directiveFactory',
      value: function directiveFactory($rootScope, $state) {
        Input.instance = new Input($rootScope, $state);
        return Input.instance;
      }
    }]);
    return Input;
  }()) || _class);
  exports.default = Input;
  return module.exports;
});

$__System.registerDynamic("9a", ["4d", "4e", "48", "56"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _classCallCheck2 = $__require('4d');
  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
  var _createClass2 = $__require('4e');
  var _createClass3 = _interopRequireDefault(_createClass2);
  var _dec,
      _class;
  var _lodash = $__require('48');
  var _lodash2 = _interopRequireDefault(_lodash);
  var _ngDecorators = $__require('56');
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var LiveEditView = (_dec = (0, _ngDecorators.Directive)({selector: 'live-edit-view'}), _dec(_class = function() {
    function LiveEditView($rootScope, $state) {
      (0, _classCallCheck3.default)(this, LiveEditView);
      this.restrict = 'E';
      this.require = 'ngModel';
      this.scope = false;
    }
    (0, _createClass3.default)(LiveEditView, [{
      key: 'link',
      value: function link(scope, element, attrs, ngModel) {
        element.on("click", function() {
          _lodash2.default.each(element.parent().children(), function(item) {
            if (!_lodash2.default.isUndefined(angular.element(item).attr('live-edit'))) {
              item.click();
            }
          });
        });
        element.on("hide", function() {
          element.addClass("ng-hide");
        });
        element.on("show", function() {
          element.removeClass("ng-hide");
        });
        scope.$watch(function() {
          return ngModel.$modelValue;
        }, function(newValue) {
          element.text(newValue);
        }, true);
      }
    }], [{
      key: 'directiveFactory',
      value: function directiveFactory($rootScope, $state) {
        LiveEditView.instance = new LiveEditView($rootScope, $state);
        return LiveEditView.instance;
      }
    }]);
    return LiveEditView;
  }()) || _class);
  exports.default = LiveEditView;
  return module.exports;
});

$__System.registerDynamic("9b", ["4d", "4e", "48", "4f", "56"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _classCallCheck2 = $__require('4d');
  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
  var _createClass2 = $__require('4e');
  var _createClass3 = _interopRequireDefault(_createClass2);
  var _dec,
      _class;
  var _lodash = $__require('48');
  var _lodash2 = _interopRequireDefault(_lodash);
  var _index = $__require('4f');
  var _index2 = _interopRequireDefault(_index);
  var _ngDecorators = $__require('56');
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var ID_PROP;
  var LiveEdit = (_dec = (0, _ngDecorators.Directive)({selector: 'live-edit'}), _dec(_class = function() {
    function LiveEdit($rootScope, $state, $timeout) {
      (0, _classCallCheck3.default)(this, LiveEdit);
      ID_PROP = _index2.default.config.getIdPropertyName();
      this.restrict = 'A';
      this.require = 'ngModel';
      this.scope = {};
      this.$timeout = $timeout;
    }
    (0, _createClass3.default)(LiveEdit, [{
      key: 'compile',
      value: function compile(element, attrs) {
        if (_index.EnvironmentHelper.isLiveEditEnabled()) {
          element.after('<live-edit-view ng-model="' + attrs['ngModel'] + '"></live-edit-view>');
          var that = this;
          return {
            pre: function pre(scope, element, attrs, ngModel) {
              scope.editMode = function() {
                element.removeClass('ng-hide');
                element[0].focus();
                var setElem = angular.element(element.parent().find('live-edit-view'));
                setElem.triggerHandler("hide");
              };
              scope.displayMode = function() {
                element.addClass('ng-hide');
                var setElem = angular.element(element.parent().find('live-edit-view'));
                setElem.triggerHandler("show");
              };
              element.on("click", function() {
                scope.editMode();
              });
              var loading = true;
              if (ngModel) {
                var modelBits = attrs["ngModel"].split(".");
                var propName = modelBits.pop();
                var parentName = modelBits.pop();
                var inputScope = scope.$parent;
                var isEditable = function isEditable() {
                  return inputScope[parentName][ID_PROP];
                };
                var syncValue = function syncValue() {
                  var hasChanged = scope.originalValue != ngModel.$modelValue;
                  if (isEditable()) {
                    scope.displayMode(ngModel.$modelValue);
                  }
                  if (loading)
                    return true;
                  if (element.hasClass("ng-valid") && isEditable() && hasChanged) {
                    scope.originalValue = ngModel.$modelValue;
                    inputScope[parentName].pushChanges(propName);
                    scope.displayMode();
                    return true;
                  }
                  return false;
                };
                if (!_lodash2.default.has(inputScope, parentName)) {
                  throw new Error('Can\'t find ' + parentName + ' in element scope.');
                }
                if (!(inputScope[parentName] instanceof _index.DataModel)) {
                  throw new Error("You're trying to use live edit mode but the model attached is not an instance of a DataModel. Is it created?");
                  return false;
                }
                if (element[0].tagName == "INPUT") {
                  element.on("blur", function() {
                    return syncValue();
                  });
                } else {
                  scope.$watch(function() {
                    return ngModel.$modelValue;
                  }, function(newValue, oldValue) {
                    syncValue();
                  });
                }
                that.$timeout(function() {
                  loading = false;
                  if (ngModel.$modelValue == null || _lodash2.default.isUndefined(ngModel.$modelValue) || _lodash2.default.isString(ngModel.$modelValue) && ngModel.$modelValue.length == 0) {
                    scope.editMode();
                  } else {
                    scope.displayMode(ngModel.$modelValue);
                  }
                  scope.originalValue = ngModel.$modelValue;
                });
              }
            },
            post: function post(scope, element, attrs, ngModel) {}
          };
        }
      }
    }], [{
      key: 'directiveFactory',
      value: function directiveFactory($rootScope, $state, $timeout) {
        LiveEdit.instance = new LiveEdit($rootScope, $state, $timeout);
        return LiveEdit.instance;
      }
    }]);
    return LiveEdit;
  }()) || _class);
  exports.default = LiveEdit;
  return module.exports;
});

$__System.registerDynamic("9c", ["4d", "4e", "48", "56", "4f"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _classCallCheck2 = $__require('4d');
  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
  var _createClass2 = $__require('4e');
  var _createClass3 = _interopRequireDefault(_createClass2);
  var _dec,
      _class;
  var _lodash = $__require('48');
  var _lodash2 = _interopRequireDefault(_lodash);
  var _ngDecorators = $__require('56');
  var _index = $__require('4f');
  var _index2 = _interopRequireDefault(_index);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var ID_PROP;
  var LiveEditBlurSubmit = (_dec = (0, _ngDecorators.Directive)({selector: 'live-edit-blur-submit'}), _dec(_class = function() {
    function LiveEditBlurSubmit($rootScope, $state, $timeout) {
      (0, _classCallCheck3.default)(this, LiveEditBlurSubmit);
      ID_PROP = _index2.default.config.getIdPropertyName();
      this.restrict = 'A';
      this.require = 'ngModel';
      this.scope = false;
    }
    (0, _createClass3.default)(LiveEditBlurSubmit, [{
      key: 'link',
      value: function link(scope, element, attrs, ngModel) {
        var modelBits = attrs["ngModel"].split(".");
        var propName = modelBits.pop();
        var parentName = modelBits.pop();
        if (!_lodash2.default.has(scope, parentName)) {
          throw new Error('Can\'t find ' + parentName + ' in element scope.');
        }
        if (!(scope[parentName] instanceof _index.DataModel)) {
          throw new Error("You're trying to use live edit mode but the model attached is not an instance of a DataModel. Is it created?");
          return false;
        }
        var loading = true;
        if (!scope[parentName][ID_PROP]) {
          scope.displayMode = function() {
            element.addClass('ng-hide');
            var setElem = angular.element(element.parent().find('live-edit-view'));
            setElem.triggerHandler("show");
          };
          if (element[0].tagName == "INPUT") {
            element.on("blur", function() {
              if (loading)
                return true;
              if (element.hasClass("ng-valid") && !scope[parentName][ID_PROP]) {
                scope[parentName].save();
                scope.displayMode();
              }
            });
          } else {
            scope.$watch(function() {
              return ngModel.$valid;
            }, function(newValue, oldValue) {
              if (loading)
                return true;
              if (newValue) {
                if (!scope[parentName][ID_PROP]) {
                  scope[parentName].save();
                  scope.displayMode();
                }
              }
            });
          }
        }
        setTimeout(function() {
          loading = false;
        });
      }
    }], [{
      key: 'directiveFactory',
      value: function directiveFactory($rootScope, $state, $timeout) {
        LiveEditBlurSubmit.instance = new LiveEditBlurSubmit($rootScope, $state, $timeout);
        return LiveEditBlurSubmit.instance;
      }
    }]);
    return LiveEditBlurSubmit;
  }()) || _class);
  exports.default = LiveEditBlurSubmit;
  return module.exports;
});

$__System.registerDynamic("9d", ["4d", "4e", "48", "56"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _classCallCheck2 = $__require('4d');
  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
  var _createClass2 = $__require('4e');
  var _createClass3 = _interopRequireDefault(_createClass2);
  var _dec,
      _class;
  var _lodash = $__require('48');
  var _lodash2 = _interopRequireDefault(_lodash);
  var _ngDecorators = $__require('56');
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var MdSelect = (_dec = (0, _ngDecorators.Directive)({selector: 'md-select'}), _dec(_class = function() {
    function MdSelect($rootScope, $state) {
      (0, _classCallCheck3.default)(this, MdSelect);
      this.restrict = 'E';
      this.scope = false;
    }
    (0, _createClass3.default)(MdSelect, [{
      key: 'compile',
      value: function compile(element, attrs) {
        return {pre: function pre(scope, element, attrs, ngModel) {}};
      }
    }], [{
      key: 'directiveFactory',
      value: function directiveFactory($rootScope, $state) {
        MdSelect.instance = new MdSelect($rootScope, $state);
        return MdSelect.instance;
      }
    }]);
    return MdSelect;
  }()) || _class);
  exports.default = MdSelect;
  return module.exports;
});

$__System.registerDynamic("7b", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  "format cjs";
  return module.exports;
});

$__System.registerDynamic("9e", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = function() {};
  return module.exports;
});

$__System.registerDynamic("9f", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = function(done, value) {
    return {
      value: value,
      done: !!done
    };
  };
  return module.exports;
});

$__System.registerDynamic("68", ["a0", "a1"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var IObject = $__require('a0'),
      defined = $__require('a1');
  module.exports = function(it) {
    return IObject(defined(it));
  };
  return module.exports;
});

$__System.registerDynamic("79", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = true;
  return module.exports;
});

$__System.registerDynamic("a2", ["67", "78", "73", "a3", "75"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('67'),
      descriptor = $__require('78'),
      setToStringTag = $__require('73'),
      IteratorPrototype = {};
  $__require('a3')(IteratorPrototype, $__require('75')('iterator'), function() {
    return this;
  });
  module.exports = function(Constructor, NAME, next) {
    Constructor.prototype = $.create(IteratorPrototype, {next: descriptor(1, next)});
    setToStringTag(Constructor, NAME + ' Iterator');
  };
  return module.exports;
});

$__System.registerDynamic("a4", ["79", "6f", "70", "a3", "6d", "a5", "a2", "73", "67", "75"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var LIBRARY = $__require('79'),
      $export = $__require('6f'),
      redefine = $__require('70'),
      hide = $__require('a3'),
      has = $__require('6d'),
      Iterators = $__require('a5'),
      $iterCreate = $__require('a2'),
      setToStringTag = $__require('73'),
      getProto = $__require('67').getProto,
      ITERATOR = $__require('75')('iterator'),
      BUGGY = !([].keys && 'next' in [].keys()),
      FF_ITERATOR = '@@iterator',
      KEYS = 'keys',
      VALUES = 'values';
  var returnThis = function() {
    return this;
  };
  module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
    $iterCreate(Constructor, NAME, next);
    var getMethod = function(kind) {
      if (!BUGGY && kind in proto)
        return proto[kind];
      switch (kind) {
        case KEYS:
          return function keys() {
            return new Constructor(this, kind);
          };
        case VALUES:
          return function values() {
            return new Constructor(this, kind);
          };
      }
      return function entries() {
        return new Constructor(this, kind);
      };
    };
    var TAG = NAME + ' Iterator',
        DEF_VALUES = DEFAULT == VALUES,
        VALUES_BUG = false,
        proto = Base.prototype,
        $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT],
        $default = $native || getMethod(DEFAULT),
        methods,
        key;
    if ($native) {
      var IteratorPrototype = getProto($default.call(new Base));
      setToStringTag(IteratorPrototype, TAG, true);
      if (!LIBRARY && has(proto, FF_ITERATOR))
        hide(IteratorPrototype, ITERATOR, returnThis);
      if (DEF_VALUES && $native.name !== VALUES) {
        VALUES_BUG = true;
        $default = function values() {
          return $native.call(this);
        };
      }
    }
    if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
      hide(proto, ITERATOR, $default);
    }
    Iterators[NAME] = $default;
    Iterators[TAG] = returnThis;
    if (DEFAULT) {
      methods = {
        values: DEF_VALUES ? $default : getMethod(VALUES),
        keys: IS_SET ? $default : getMethod(KEYS),
        entries: !DEF_VALUES ? $default : getMethod('entries')
      };
      if (FORCED)
        for (key in methods) {
          if (!(key in proto))
            redefine(proto, key, methods[key]);
        }
      else
        $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
    }
    return methods;
  };
  return module.exports;
});

$__System.registerDynamic("a6", ["9e", "9f", "a5", "68", "a4"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var addToUnscopables = $__require('9e'),
      step = $__require('9f'),
      Iterators = $__require('a5'),
      toIObject = $__require('68');
  module.exports = $__require('a4')(Array, 'Array', function(iterated, kind) {
    this._t = toIObject(iterated);
    this._i = 0;
    this._k = kind;
  }, function() {
    var O = this._t,
        kind = this._k,
        index = this._i++;
    if (!O || index >= O.length) {
      this._t = undefined;
      return step(1);
    }
    if (kind == 'keys')
      return step(0, index);
    if (kind == 'values')
      return step(0, O[index]);
    return step(0, [index, O[index]]);
  }, 'values');
  Iterators.Arguments = Iterators.Array;
  addToUnscopables('keys');
  addToUnscopables('values');
  addToUnscopables('entries');
  return module.exports;
});

$__System.registerDynamic("a7", ["a6", "a5"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('a6');
  var Iterators = $__require('a5');
  Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;
  return module.exports;
});

$__System.registerDynamic("76", ["a8"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var cof = $__require('a8');
  module.exports = Array.isArray || function(arg) {
    return cof(arg) == 'Array';
  };
  return module.exports;
});

$__System.registerDynamic("a9", ["7f", "76", "75"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var isObject = $__require('7f'),
      isArray = $__require('76'),
      SPECIES = $__require('75')('species');
  module.exports = function(original, length) {
    var C;
    if (isArray(original)) {
      C = original.constructor;
      if (typeof C == 'function' && (C === Array || isArray(C.prototype)))
        C = undefined;
      if (isObject(C)) {
        C = C[SPECIES];
        if (C === null)
          C = undefined;
      }
    }
    return new (C === undefined ? Array : C)(length);
  };
  return module.exports;
});

$__System.registerDynamic("aa", ["80", "a0", "62", "ab", "a9"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var ctx = $__require('80'),
      IObject = $__require('a0'),
      toObject = $__require('62'),
      toLength = $__require('ab'),
      asc = $__require('a9');
  module.exports = function(TYPE) {
    var IS_MAP = TYPE == 1,
        IS_FILTER = TYPE == 2,
        IS_SOME = TYPE == 3,
        IS_EVERY = TYPE == 4,
        IS_FIND_INDEX = TYPE == 6,
        NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
    return function($this, callbackfn, that) {
      var O = toObject($this),
          self = IObject(O),
          f = ctx(callbackfn, that, 3),
          length = toLength(self.length),
          index = 0,
          result = IS_MAP ? asc($this, length) : IS_FILTER ? asc($this, 0) : undefined,
          val,
          res;
      for (; length > index; index++)
        if (NO_HOLES || index in self) {
          val = self[index];
          res = f(val, index, O);
          if (TYPE) {
            if (IS_MAP)
              result[index] = res;
            else if (res)
              switch (TYPE) {
                case 3:
                  return true;
                case 5:
                  return val;
                case 6:
                  return index;
                case 2:
                  result.push(val);
              }
            else if (IS_EVERY)
              return false;
          }
        }
      return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
    };
  };
  return module.exports;
});

$__System.registerDynamic("ac", ["a3", "ad", "77", "7f", "ae", "af", "aa", "6d", "74"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var hide = $__require('a3'),
      redefineAll = $__require('ad'),
      anObject = $__require('77'),
      isObject = $__require('7f'),
      strictNew = $__require('ae'),
      forOf = $__require('af'),
      createArrayMethod = $__require('aa'),
      $has = $__require('6d'),
      WEAK = $__require('74')('weak'),
      isExtensible = Object.isExtensible || isObject,
      arrayFind = createArrayMethod(5),
      arrayFindIndex = createArrayMethod(6),
      id = 0;
  var frozenStore = function(that) {
    return that._l || (that._l = new FrozenStore);
  };
  var FrozenStore = function() {
    this.a = [];
  };
  var findFrozen = function(store, key) {
    return arrayFind(store.a, function(it) {
      return it[0] === key;
    });
  };
  FrozenStore.prototype = {
    get: function(key) {
      var entry = findFrozen(this, key);
      if (entry)
        return entry[1];
    },
    has: function(key) {
      return !!findFrozen(this, key);
    },
    set: function(key, value) {
      var entry = findFrozen(this, key);
      if (entry)
        entry[1] = value;
      else
        this.a.push([key, value]);
    },
    'delete': function(key) {
      var index = arrayFindIndex(this.a, function(it) {
        return it[0] === key;
      });
      if (~index)
        this.a.splice(index, 1);
      return !!~index;
    }
  };
  module.exports = {
    getConstructor: function(wrapper, NAME, IS_MAP, ADDER) {
      var C = wrapper(function(that, iterable) {
        strictNew(that, C, NAME);
        that._i = id++;
        that._l = undefined;
        if (iterable != undefined)
          forOf(iterable, IS_MAP, that[ADDER], that);
      });
      redefineAll(C.prototype, {
        'delete': function(key) {
          if (!isObject(key))
            return false;
          if (!isExtensible(key))
            return frozenStore(this)['delete'](key);
          return $has(key, WEAK) && $has(key[WEAK], this._i) && delete key[WEAK][this._i];
        },
        has: function has(key) {
          if (!isObject(key))
            return false;
          if (!isExtensible(key))
            return frozenStore(this).has(key);
          return $has(key, WEAK) && $has(key[WEAK], this._i);
        }
      });
      return C;
    },
    def: function(that, key, value) {
      if (!isExtensible(anObject(key))) {
        frozenStore(that).set(key, value);
      } else {
        $has(key, WEAK) || hide(key, WEAK, {});
        key[WEAK][that._i] = value;
      }
      return that;
    },
    frozenStore: frozenStore,
    WEAK: WEAK
  };
  return module.exports;
});

$__System.registerDynamic("78", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = function(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };
  return module.exports;
});

$__System.registerDynamic("a3", ["67", "78", "6e"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('67'),
      createDesc = $__require('78');
  module.exports = $__require('6e') ? function(object, key, value) {
    return $.setDesc(object, key, createDesc(1, value));
  } : function(object, key, value) {
    object[key] = value;
    return object;
  };
  return module.exports;
});

$__System.registerDynamic("70", ["a3"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('a3');
  return module.exports;
});

$__System.registerDynamic("ad", ["70"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var redefine = $__require('70');
  module.exports = function(target, src) {
    for (var key in src)
      redefine(target, key, src[key]);
    return target;
  };
  return module.exports;
});

$__System.registerDynamic("b0", ["77"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var anObject = $__require('77');
  module.exports = function(iterator, fn, value, entries) {
    try {
      return entries ? fn(anObject(value)[0], value[1]) : fn(value);
    } catch (e) {
      var ret = iterator['return'];
      if (ret !== undefined)
        anObject(ret.call(iterator));
      throw e;
    }
  };
  return module.exports;
});

$__System.registerDynamic("b1", ["a5", "75"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var Iterators = $__require('a5'),
      ITERATOR = $__require('75')('iterator'),
      ArrayProto = Array.prototype;
  module.exports = function(it) {
    return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
  };
  return module.exports;
});

$__System.registerDynamic("77", ["7f"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var isObject = $__require('7f');
  module.exports = function(it) {
    if (!isObject(it))
      throw TypeError(it + ' is not an object!');
    return it;
  };
  return module.exports;
});

$__System.registerDynamic("b2", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var ceil = Math.ceil,
      floor = Math.floor;
  module.exports = function(it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  };
  return module.exports;
});

$__System.registerDynamic("ab", ["b2"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var toInteger = $__require('b2'),
      min = Math.min;
  module.exports = function(it) {
    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0;
  };
  return module.exports;
});

$__System.registerDynamic("b3", ["a8", "75"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var cof = $__require('a8'),
      TAG = $__require('75')('toStringTag'),
      ARG = cof(function() {
        return arguments;
      }()) == 'Arguments';
  module.exports = function(it) {
    var O,
        T,
        B;
    return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof(T = (O = Object(it))[TAG]) == 'string' ? T : ARG ? cof(O) : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
  };
  return module.exports;
});

$__System.registerDynamic("a5", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = {};
  return module.exports;
});

$__System.registerDynamic("b4", ["b3", "75", "a5", "65"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var classof = $__require('b3'),
      ITERATOR = $__require('75')('iterator'),
      Iterators = $__require('a5');
  module.exports = $__require('65').getIteratorMethod = function(it) {
    if (it != undefined)
      return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
  };
  return module.exports;
});

$__System.registerDynamic("af", ["80", "b0", "b1", "77", "ab", "b4"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var ctx = $__require('80'),
      call = $__require('b0'),
      isArrayIter = $__require('b1'),
      anObject = $__require('77'),
      toLength = $__require('ab'),
      getIterFn = $__require('b4');
  module.exports = function(iterable, entries, fn, that) {
    var iterFn = getIterFn(iterable),
        f = ctx(fn, that, entries ? 2 : 1),
        index = 0,
        length,
        step,
        iterator;
    if (typeof iterFn != 'function')
      throw TypeError(iterable + ' is not iterable!');
    if (isArrayIter(iterFn))
      for (length = toLength(iterable.length); length > index; index++) {
        entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
      }
    else
      for (iterator = iterFn.call(iterable); !(step = iterator.next()).done; ) {
        call(iterator, f, step.value, entries);
      }
  };
  return module.exports;
});

$__System.registerDynamic("ae", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = function(it, Constructor, name) {
    if (!(it instanceof Constructor))
      throw TypeError(name + ": use the 'new' operator!");
    return it;
  };
  return module.exports;
});

$__System.registerDynamic("7f", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = function(it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };
  return module.exports;
});

$__System.registerDynamic("6d", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var hasOwnProperty = {}.hasOwnProperty;
  module.exports = function(it, key) {
    return hasOwnProperty.call(it, key);
  };
  return module.exports;
});

$__System.registerDynamic("72", ["6c"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var global = $__require('6c'),
      SHARED = '__core-js_shared__',
      store = global[SHARED] || (global[SHARED] = {});
  module.exports = function(key) {
    return store[key] || (store[key] = {});
  };
  return module.exports;
});

$__System.registerDynamic("74", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var id = 0,
      px = Math.random();
  module.exports = function(key) {
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
  };
  return module.exports;
});

$__System.registerDynamic("75", ["72", "74", "6c"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var store = $__require('72')('wks'),
      uid = $__require('74'),
      Symbol = $__require('6c').Symbol;
  module.exports = function(name) {
    return store[name] || (store[name] = Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));
  };
  return module.exports;
});

$__System.registerDynamic("73", ["67", "6d", "75"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var def = $__require('67').setDesc,
      has = $__require('6d'),
      TAG = $__require('75')('toStringTag');
  module.exports = function(it, tag, stat) {
    if (it && !has(it = stat ? it : it.prototype, TAG))
      def(it, TAG, {
        configurable: true,
        value: tag
      });
  };
  return module.exports;
});

$__System.registerDynamic("6e", ["71"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = !$__require('71')(function() {
    return Object.defineProperty({}, 'a', {get: function() {
        return 7;
      }}).a != 7;
  });
  return module.exports;
});

$__System.registerDynamic("b5", ["67", "6c", "6f", "71", "a3", "ad", "af", "ae", "7f", "73", "6e"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('67'),
      global = $__require('6c'),
      $export = $__require('6f'),
      fails = $__require('71'),
      hide = $__require('a3'),
      redefineAll = $__require('ad'),
      forOf = $__require('af'),
      strictNew = $__require('ae'),
      isObject = $__require('7f'),
      setToStringTag = $__require('73'),
      DESCRIPTORS = $__require('6e');
  module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
    var Base = global[NAME],
        C = Base,
        ADDER = IS_MAP ? 'set' : 'add',
        proto = C && C.prototype,
        O = {};
    if (!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function() {
      new C().entries().next();
    }))) {
      C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
      redefineAll(C.prototype, methods);
    } else {
      C = wrapper(function(target, iterable) {
        strictNew(target, C, NAME);
        target._c = new Base;
        if (iterable != undefined)
          forOf(iterable, IS_MAP, target[ADDER], target);
      });
      $.each.call('add,clear,delete,forEach,get,has,set,keys,values,entries'.split(','), function(KEY) {
        var IS_ADDER = KEY == 'add' || KEY == 'set';
        if (KEY in proto && !(IS_WEAK && KEY == 'clear'))
          hide(C.prototype, KEY, function(a, b) {
            if (!IS_ADDER && IS_WEAK && !isObject(a))
              return KEY == 'get' ? undefined : false;
            var result = this._c[KEY](a === 0 ? 0 : a, b);
            return IS_ADDER ? this : result;
          });
      });
      if ('size' in proto)
        $.setDesc(C.prototype, 'size', {get: function() {
            return this._c.size;
          }});
    }
    setToStringTag(C, NAME);
    O[NAME] = C;
    $export($export.G + $export.W + $export.F, O);
    if (!IS_WEAK)
      common.setStrong(C, NAME, IS_MAP);
    return C;
  };
  return module.exports;
});

$__System.registerDynamic("b6", ["67", "70", "ac", "7f", "6d", "b5"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('67'),
      redefine = $__require('70'),
      weak = $__require('ac'),
      isObject = $__require('7f'),
      has = $__require('6d'),
      frozenStore = weak.frozenStore,
      WEAK = weak.WEAK,
      isExtensible = Object.isExtensible || isObject,
      tmp = {};
  var $WeakMap = $__require('b5')('WeakMap', function(get) {
    return function WeakMap() {
      return get(this, arguments.length > 0 ? arguments[0] : undefined);
    };
  }, {
    get: function get(key) {
      if (isObject(key)) {
        if (!isExtensible(key))
          return frozenStore(this).get(key);
        if (has(key, WEAK))
          return key[WEAK][this._i];
      }
    },
    set: function set(key, value) {
      return weak.def(this, key, value);
    }
  }, weak, true, true);
  if (new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7) {
    $.each.call(['delete', 'has', 'get', 'set'], function(key) {
      var proto = $WeakMap.prototype,
          method = proto[key];
      redefine(proto, key, function(a, b) {
        if (isObject(a) && !isExtensible(a)) {
          var result = frozenStore(this)[key](a, b);
          return key == 'set' ? this : result;
        }
        return method.call(this, a, b);
      });
    });
  }
  return module.exports;
});

$__System.registerDynamic("b7", ["7b", "a7", "b6", "65"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('7b');
  $__require('a7');
  $__require('b6');
  module.exports = $__require('65').WeakMap;
  return module.exports;
});

$__System.registerDynamic("b8", ["b7"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = {
    "default": $__require('b7'),
    __esModule: true
  };
  return module.exports;
});

$__System.registerDynamic("b9", ["4d", "4e", "b8", "56", "48"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _classCallCheck2 = $__require('4d');
  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
  var _createClass2 = $__require('4e');
  var _createClass3 = _interopRequireDefault(_createClass2);
  var _weakMap = $__require('b8');
  var _weakMap2 = _interopRequireDefault(_weakMap);
  var _dec,
      _class;
  var _ngDecorators = $__require('56');
  var _lodash = $__require('48');
  var _lodash2 = _interopRequireDefault(_lodash);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var COMPILE = new _weakMap2.default();
  var Name = (_dec = (0, _ngDecorators.Directive)({selector: 'name'}), _dec(_class = function() {
    function Name($rootScope, $state, $compile) {
      (0, _classCallCheck3.default)(this, Name);
      this.restrict = 'A';
      this.scope = false;
      COMPILE.set(this, $compile);
    }
    (0, _createClass3.default)(Name, [{
      key: 'compile',
      value: function compile() {
        var _this = this;
        return {post: function post(scope, element, attrs, formCtrl) {
            if (!attrs.name) {
              throw new Error("You've referenced the name property without filling one in. Shame shame shame.");
            }
            if (attrs.ngModel && !_lodash2.default.startsWith(attrs.name, ".")) {
              var tagName = element[0].tagName.toLowerCase();
              var ngAttrs = {
                ngRequired: "required",
                ngPattern: "pattern",
                mdMinlength: "minlength",
                mdMaxlength: "maxlength"
              };
              var messageTypes = {
                required: 'Required',
                min: 'Value too small',
                max: 'Value too big',
                minlength: 'Too short',
                maxlength: 'Too long',
                pattern: null,
                validate: null
              };
              var messagesToGenerate = {};
              var formElemName = "formCtrl." + attrs.name;
              var messages = '<div class="validation-messages">';
              _lodash2.default.forEach(messageTypes, function(value, name) {
                if (!_lodash2.default.has(attrs, name)) {
                  return true;
                }
                if (_lodash2.default.has(attrs, name + "Message")) {
                  value = attrs[name + "Message"];
                }
                if (!value) {
                  throw new Error('You must provide a ' + _lodash2.default.kebabCase(name) + '-message attribute if you want to validate on it');
                  return false;
                }
                messagesToGenerate[name] = value;
              }, _this);
              _lodash2.default.forEach(attrs, function(value, name) {
                if (_lodash2.default.startsWith(name, "ng") && _lodash2.default.has(ngAttrs, name)) {
                  var preChopName = name;
                  name = _lodash2.default.camelCase(name.substr(2));
                  var messageValue;
                  if (_lodash2.default.has(messageTypes, name)) {
                    messageValue = messageTypes[name];
                  }
                  if (_lodash2.default.has(attrs, preChopName + "Message")) {
                    messageValue = attrs[preChopName + "Message"];
                  }
                  if (!messageValue) {
                    throw new Error('You must provide a ' + _lodash2.default.kebabCase(preChopName) + '-message attribute if you want to validate on it');
                    return false;
                  }
                  messagesToGenerate[name] = messageValue;
                }
              });
              _lodash2.default.forEach(messagesToGenerate, function(value, name) {
                var showLogic = formElemName + '.$error.' + name + ' && (formCtrl.$submitted || (' + formElemName + '.$touched && ' + formElemName + '.$invalid))';
                if (tagName == "div" || tagName == "span") {
                  showLogic = formElemName + '.$error.' + name + ' && (formCtrl.$submitted || ' + formElemName + '.$invalid)';
                }
                messages += '<div class="message" role="alert" ng-show="' + showLogic + '">' + value + '</div>';
              });
              messages += "</div>";
              var div = COMPILE.get(_this)(messages)(scope);
              element.after(div);
            }
          }};
      }
    }], [{
      key: 'directiveFactory',
      value: function directiveFactory($rootScope, $state, $compile) {
        Name.instance = new Name($rootScope, $state, $compile);
        return Name.instance;
      }
    }]);
    return Name;
  }()) || _class);
  exports.default = Name;
  return module.exports;
});

$__System.registerDynamic("ba", ["4d", "4e", "48", "56"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _classCallCheck2 = $__require('4d');
  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
  var _createClass2 = $__require('4e');
  var _createClass3 = _interopRequireDefault(_createClass2);
  var _dec,
      _class;
  var _lodash = $__require('48');
  var _lodash2 = _interopRequireDefault(_lodash);
  var _ngDecorators = $__require('56');
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var Select = (_dec = (0, _ngDecorators.Directive)({selector: 'select'}), _dec(_class = function() {
    function Select($rootScope, $state) {
      (0, _classCallCheck3.default)(this, Select);
      this.restrict = 'E';
      this.scope = false;
    }
    (0, _createClass3.default)(Select, [{
      key: 'link',
      value: function link(scope, element, attrs, ngModel) {}
    }], [{
      key: 'directiveFactory',
      value: function directiveFactory($rootScope, $state) {
        Select.instance = new Select($rootScope, $state);
        return Select.instance;
      }
    }]);
    return Select;
  }()) || _class);
  exports.default = Select;
  return module.exports;
});

$__System.registerDynamic("bb", ["4d", "4e", "56"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _classCallCheck2 = $__require('4d');
  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
  var _createClass2 = $__require('4e');
  var _createClass3 = _interopRequireDefault(_createClass2);
  var _dec,
      _class;
  var _ngDecorators = $__require('56');
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var StateChange = (_dec = (0, _ngDecorators.Directive)({selector: 'state-change'}), _dec(_class = function() {
    function StateChange($rootScope, $state) {
      (0, _classCallCheck3.default)(this, StateChange);
      this.restrict = 'A';
      this.scope = {stateChange: "&"};
    }
    (0, _createClass3.default)(StateChange, [{
      key: 'link',
      value: function link(scope, element, attrs, ngModel) {
        var that = this;
        var stateChangFn = scope.stateChange();
        var rootListener = scope.$root.$on('$stateChangeStart', function(event, toState, toParams, fromState, fromParams) {
          stateChangFn(toState.name);
        });
        scope.$on("$destroy", function() {
          rootListener();
        });
      }
    }], [{
      key: 'directiveFactory',
      value: function directiveFactory($rootScope, $state) {
        StateChange.instance = new StateChange($rootScope, $state);
        return StateChange.instance;
      }
    }]);
    return StateChange;
  }()) || _class);
  exports.default = StateChange;
  return module.exports;
});

$__System.registerDynamic("bc", ["4d", "4e", "48", "56"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _classCallCheck2 = $__require('4d');
  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
  var _createClass2 = $__require('4e');
  var _createClass3 = _interopRequireDefault(_createClass2);
  var _dec,
      _class;
  var _lodash = $__require('48');
  var _lodash2 = _interopRequireDefault(_lodash);
  var _ngDecorators = $__require('56');
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var Textarea = (_dec = (0, _ngDecorators.Directive)({selector: 'textarea'}), _dec(_class = function() {
    function Textarea($rootScope, $state) {
      (0, _classCallCheck3.default)(this, Textarea);
      this.restrict = 'E';
      this.scope = false;
    }
    (0, _createClass3.default)(Textarea, [{
      key: 'compile',
      value: function compile(element, attrs) {
        return {pre: function pre(scope, element, attrs, ngModel) {}};
      }
    }], [{
      key: 'directiveFactory',
      value: function directiveFactory($rootScope, $state) {
        Textarea.instance = new Textarea($rootScope, $state);
        return Textarea.instance;
      }
    }]);
    return Textarea;
  }()) || _class);
  exports.default = Textarea;
  return module.exports;
});

$__System.registerDynamic("bd", ["4d", "4e", "56"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _classCallCheck2 = $__require('4d');
  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
  var _createClass2 = $__require('4e');
  var _createClass3 = _interopRequireDefault(_createClass2);
  var _dec,
      _class;
  var _ngDecorators = $__require('56');
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var Validate = (_dec = (0, _ngDecorators.Directive)({selector: 'validate'}), _dec(_class = function() {
    function Validate($rootScope, $state) {
      (0, _classCallCheck3.default)(this, Validate);
      this.require = 'ngModel';
      this.restrict = 'A';
      this.scope = false;
    }
    (0, _createClass3.default)(Validate, [{
      key: 'link',
      value: function link(scope, element, attrs, ngModel) {
        ngModel.$validators.validate = function(modelValue, viewValue) {
          return scope.$eval(attrs.validate);
        };
        scope.$watch(function() {
          return scope.$eval(attrs.validate);
        }, function() {
          ngModel.$validate();
        });
      }
    }], [{
      key: 'directiveFactory',
      value: function directiveFactory($rootScope, $state) {
        Validate.instance = new Validate($rootScope, $state);
        return Validate.instance;
      }
    }]);
    return Validate;
  }()) || _class);
  exports.default = Validate;
  return module.exports;
});

$__System.registerDynamic("be", ["97", "98", "99", "9a", "9b", "9c", "9d", "b9", "ba", "bb", "bc", "bd"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('97');
  $__require('98');
  $__require('99');
  $__require('9a');
  $__require('9b');
  $__require('9c');
  $__require('9d');
  $__require('b9');
  $__require('ba');
  $__require('bb');
  $__require('bc');
  $__require('bd');
  return module.exports;
});

(function() {
var define = $__System.amdDefine;
"format amd";
;
(function(global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define("bf", [], factory) : global.moment = factory();
}(this, function() {
  'use strict';
  var hookCallback;
  function utils_hooks__hooks() {
    return hookCallback.apply(null, arguments);
  }
  function setHookCallback(callback) {
    hookCallback = callback;
  }
  function isArray(input) {
    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
  }
  function isObject(input) {
    return Object.prototype.toString.call(input) === '[object Object]';
  }
  function isObjectEmpty(obj) {
    var k;
    for (k in obj) {
      return false;
    }
    return true;
  }
  function isDate(input) {
    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
  }
  function map(arr, fn) {
    var res = [],
        i;
    for (i = 0; i < arr.length; ++i) {
      res.push(fn(arr[i], i));
    }
    return res;
  }
  function hasOwnProp(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
  }
  function extend(a, b) {
    for (var i in b) {
      if (hasOwnProp(b, i)) {
        a[i] = b[i];
      }
    }
    if (hasOwnProp(b, 'toString')) {
      a.toString = b.toString;
    }
    if (hasOwnProp(b, 'valueOf')) {
      a.valueOf = b.valueOf;
    }
    return a;
  }
  function create_utc__createUTC(input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, true).utc();
  }
  function defaultParsingFlags() {
    return {
      empty: false,
      unusedTokens: [],
      unusedInput: [],
      overflow: -2,
      charsLeftOver: 0,
      nullInput: false,
      invalidMonth: null,
      invalidFormat: false,
      userInvalidated: false,
      iso: false,
      parsedDateParts: [],
      meridiem: null
    };
  }
  function getParsingFlags(m) {
    if (m._pf == null) {
      m._pf = defaultParsingFlags();
    }
    return m._pf;
  }
  var some;
  if (Array.prototype.some) {
    some = Array.prototype.some;
  } else {
    some = function(fun) {
      var t = Object(this);
      var len = t.length >>> 0;
      for (var i = 0; i < len; i++) {
        if (i in t && fun.call(this, t[i], i, t)) {
          return true;
        }
      }
      return false;
    };
  }
  function valid__isValid(m) {
    if (m._isValid == null) {
      var flags = getParsingFlags(m);
      var parsedParts = some.call(flags.parsedDateParts, function(i) {
        return i != null;
      });
      m._isValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || (flags.meridiem && parsedParts));
      if (m._strict) {
        m._isValid = m._isValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
      }
    }
    return m._isValid;
  }
  function valid__createInvalid(flags) {
    var m = create_utc__createUTC(NaN);
    if (flags != null) {
      extend(getParsingFlags(m), flags);
    } else {
      getParsingFlags(m).userInvalidated = true;
    }
    return m;
  }
  function isUndefined(input) {
    return input === void 0;
  }
  var momentProperties = utils_hooks__hooks.momentProperties = [];
  function copyConfig(to, from) {
    var i,
        prop,
        val;
    if (!isUndefined(from._isAMomentObject)) {
      to._isAMomentObject = from._isAMomentObject;
    }
    if (!isUndefined(from._i)) {
      to._i = from._i;
    }
    if (!isUndefined(from._f)) {
      to._f = from._f;
    }
    if (!isUndefined(from._l)) {
      to._l = from._l;
    }
    if (!isUndefined(from._strict)) {
      to._strict = from._strict;
    }
    if (!isUndefined(from._tzm)) {
      to._tzm = from._tzm;
    }
    if (!isUndefined(from._isUTC)) {
      to._isUTC = from._isUTC;
    }
    if (!isUndefined(from._offset)) {
      to._offset = from._offset;
    }
    if (!isUndefined(from._pf)) {
      to._pf = getParsingFlags(from);
    }
    if (!isUndefined(from._locale)) {
      to._locale = from._locale;
    }
    if (momentProperties.length > 0) {
      for (i in momentProperties) {
        prop = momentProperties[i];
        val = from[prop];
        if (!isUndefined(val)) {
          to[prop] = val;
        }
      }
    }
    return to;
  }
  var updateInProgress = false;
  function Moment(config) {
    copyConfig(this, config);
    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
    if (updateInProgress === false) {
      updateInProgress = true;
      utils_hooks__hooks.updateOffset(this);
      updateInProgress = false;
    }
  }
  function isMoment(obj) {
    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
  }
  function absFloor(number) {
    if (number < 0) {
      return Math.ceil(number) || 0;
    } else {
      return Math.floor(number);
    }
  }
  function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion,
        value = 0;
    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
      value = absFloor(coercedNumber);
    }
    return value;
  }
  function compareArrays(array1, array2, dontConvert) {
    var len = Math.min(array1.length, array2.length),
        lengthDiff = Math.abs(array1.length - array2.length),
        diffs = 0,
        i;
    for (i = 0; i < len; i++) {
      if ((dontConvert && array1[i] !== array2[i]) || (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
        diffs++;
      }
    }
    return diffs + lengthDiff;
  }
  function warn(msg) {
    if (utils_hooks__hooks.suppressDeprecationWarnings === false && (typeof console !== 'undefined') && console.warn) {
      console.warn('Deprecation warning: ' + msg);
    }
  }
  function deprecate(msg, fn) {
    var firstTime = true;
    return extend(function() {
      if (utils_hooks__hooks.deprecationHandler != null) {
        utils_hooks__hooks.deprecationHandler(null, msg);
      }
      if (firstTime) {
        warn(msg + '\nArguments: ' + Array.prototype.slice.call(arguments).join(', ') + '\n' + (new Error()).stack);
        firstTime = false;
      }
      return fn.apply(this, arguments);
    }, fn);
  }
  var deprecations = {};
  function deprecateSimple(name, msg) {
    if (utils_hooks__hooks.deprecationHandler != null) {
      utils_hooks__hooks.deprecationHandler(name, msg);
    }
    if (!deprecations[name]) {
      warn(msg);
      deprecations[name] = true;
    }
  }
  utils_hooks__hooks.suppressDeprecationWarnings = false;
  utils_hooks__hooks.deprecationHandler = null;
  function isFunction(input) {
    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
  }
  function locale_set__set(config) {
    var prop,
        i;
    for (i in config) {
      prop = config[i];
      if (isFunction(prop)) {
        this[i] = prop;
      } else {
        this['_' + i] = prop;
      }
    }
    this._config = config;
    this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
  }
  function mergeConfigs(parentConfig, childConfig) {
    var res = extend({}, parentConfig),
        prop;
    for (prop in childConfig) {
      if (hasOwnProp(childConfig, prop)) {
        if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
          res[prop] = {};
          extend(res[prop], parentConfig[prop]);
          extend(res[prop], childConfig[prop]);
        } else if (childConfig[prop] != null) {
          res[prop] = childConfig[prop];
        } else {
          delete res[prop];
        }
      }
    }
    for (prop in parentConfig) {
      if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
        res[prop] = extend({}, res[prop]);
      }
    }
    return res;
  }
  function Locale(config) {
    if (config != null) {
      this.set(config);
    }
  }
  var keys;
  if (Object.keys) {
    keys = Object.keys;
  } else {
    keys = function(obj) {
      var i,
          res = [];
      for (i in obj) {
        if (hasOwnProp(obj, i)) {
          res.push(i);
        }
      }
      return res;
    };
  }
  var defaultCalendar = {
    sameDay: '[Today at] LT',
    nextDay: '[Tomorrow at] LT',
    nextWeek: 'dddd [at] LT',
    lastDay: '[Yesterday at] LT',
    lastWeek: '[Last] dddd [at] LT',
    sameElse: 'L'
  };
  function locale_calendar__calendar(key, mom, now) {
    var output = this._calendar[key] || this._calendar['sameElse'];
    return isFunction(output) ? output.call(mom, now) : output;
  }
  var defaultLongDateFormat = {
    LTS: 'h:mm:ss A',
    LT: 'h:mm A',
    L: 'MM/DD/YYYY',
    LL: 'MMMM D, YYYY',
    LLL: 'MMMM D, YYYY h:mm A',
    LLLL: 'dddd, MMMM D, YYYY h:mm A'
  };
  function longDateFormat(key) {
    var format = this._longDateFormat[key],
        formatUpper = this._longDateFormat[key.toUpperCase()];
    if (format || !formatUpper) {
      return format;
    }
    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function(val) {
      return val.slice(1);
    });
    return this._longDateFormat[key];
  }
  var defaultInvalidDate = 'Invalid date';
  function invalidDate() {
    return this._invalidDate;
  }
  var defaultOrdinal = '%d';
  var defaultOrdinalParse = /\d{1,2}/;
  function ordinal(number) {
    return this._ordinal.replace('%d', number);
  }
  var defaultRelativeTime = {
    future: 'in %s',
    past: '%s ago',
    s: 'a few seconds',
    m: 'a minute',
    mm: '%d minutes',
    h: 'an hour',
    hh: '%d hours',
    d: 'a day',
    dd: '%d days',
    M: 'a month',
    MM: '%d months',
    y: 'a year',
    yy: '%d years'
  };
  function relative__relativeTime(number, withoutSuffix, string, isFuture) {
    var output = this._relativeTime[string];
    return (isFunction(output)) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
  }
  function pastFuture(diff, output) {
    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
  }
  var aliases = {};
  function addUnitAlias(unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
  }
  function normalizeUnits(units) {
    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
  }
  function normalizeObjectUnits(inputObject) {
    var normalizedInput = {},
        normalizedProp,
        prop;
    for (prop in inputObject) {
      if (hasOwnProp(inputObject, prop)) {
        normalizedProp = normalizeUnits(prop);
        if (normalizedProp) {
          normalizedInput[normalizedProp] = inputObject[prop];
        }
      }
    }
    return normalizedInput;
  }
  var priorities = {};
  function addUnitPriority(unit, priority) {
    priorities[unit] = priority;
  }
  function getPrioritizedUnits(unitsObj) {
    var units = [];
    for (var u in unitsObj) {
      units.push({
        unit: u,
        priority: priorities[u]
      });
    }
    units.sort(function(a, b) {
      return a.priority - b.priority;
    });
    return units;
  }
  function makeGetSet(unit, keepTime) {
    return function(value) {
      if (value != null) {
        get_set__set(this, unit, value);
        utils_hooks__hooks.updateOffset(this, keepTime);
        return this;
      } else {
        return get_set__get(this, unit);
      }
    };
  }
  function get_set__get(mom, unit) {
    return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
  }
  function get_set__set(mom, unit, value) {
    if (mom.isValid()) {
      mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
    }
  }
  function stringGet(units) {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
      return this[units]();
    }
    return this;
  }
  function stringSet(units, value) {
    if (typeof units === 'object') {
      units = normalizeObjectUnits(units);
      var prioritized = getPrioritizedUnits(units);
      for (var i = 0; i < prioritized.length; i++) {
        this[prioritized[i].unit](units[prioritized[i].unit]);
      }
    } else {
      units = normalizeUnits(units);
      if (isFunction(this[units])) {
        return this[units](value);
      }
    }
    return this;
  }
  function zeroFill(number, targetLength, forceSign) {
    var absNumber = '' + Math.abs(number),
        zerosToFill = targetLength - absNumber.length,
        sign = number >= 0;
    return (sign ? (forceSign ? '+' : '') : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
  }
  var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
  var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
  var formatFunctions = {};
  var formatTokenFunctions = {};
  function addFormatToken(token, padded, ordinal, callback) {
    var func = callback;
    if (typeof callback === 'string') {
      func = function() {
        return this[callback]();
      };
    }
    if (token) {
      formatTokenFunctions[token] = func;
    }
    if (padded) {
      formatTokenFunctions[padded[0]] = function() {
        return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
      };
    }
    if (ordinal) {
      formatTokenFunctions[ordinal] = function() {
        return this.localeData().ordinal(func.apply(this, arguments), token);
      };
    }
  }
  function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
      return input.replace(/^\[|\]$/g, '');
    }
    return input.replace(/\\/g, '');
  }
  function makeFormatFunction(format) {
    var array = format.match(formattingTokens),
        i,
        length;
    for (i = 0, length = array.length; i < length; i++) {
      if (formatTokenFunctions[array[i]]) {
        array[i] = formatTokenFunctions[array[i]];
      } else {
        array[i] = removeFormattingTokens(array[i]);
      }
    }
    return function(mom) {
      var output = '',
          i;
      for (i = 0; i < length; i++) {
        output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
      }
      return output;
    };
  }
  function formatMoment(m, format) {
    if (!m.isValid()) {
      return m.localeData().invalidDate();
    }
    format = expandFormat(format, m.localeData());
    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
    return formatFunctions[format](m);
  }
  function expandFormat(format, locale) {
    var i = 5;
    function replaceLongDateFormatTokens(input) {
      return locale.longDateFormat(input) || input;
    }
    localFormattingTokens.lastIndex = 0;
    while (i >= 0 && localFormattingTokens.test(format)) {
      format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
      localFormattingTokens.lastIndex = 0;
      i -= 1;
    }
    return format;
  }
  var match1 = /\d/;
  var match2 = /\d\d/;
  var match3 = /\d{3}/;
  var match4 = /\d{4}/;
  var match6 = /[+-]?\d{6}/;
  var match1to2 = /\d\d?/;
  var match3to4 = /\d\d\d\d?/;
  var match5to6 = /\d\d\d\d\d\d?/;
  var match1to3 = /\d{1,3}/;
  var match1to4 = /\d{1,4}/;
  var match1to6 = /[+-]?\d{1,6}/;
  var matchUnsigned = /\d+/;
  var matchSigned = /[+-]?\d+/;
  var matchOffset = /Z|[+-]\d\d:?\d\d/gi;
  var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi;
  var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/;
  var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
  var regexes = {};
  function addRegexToken(token, regex, strictRegex) {
    regexes[token] = isFunction(regex) ? regex : function(isStrict, localeData) {
      return (isStrict && strictRegex) ? strictRegex : regex;
    };
  }
  function getParseRegexForToken(token, config) {
    if (!hasOwnProp(regexes, token)) {
      return new RegExp(unescapeFormat(token));
    }
    return regexes[token](config._strict, config._locale);
  }
  function unescapeFormat(s) {
    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
      return p1 || p2 || p3 || p4;
    }));
  }
  function regexEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
  }
  var tokens = {};
  function addParseToken(token, callback) {
    var i,
        func = callback;
    if (typeof token === 'string') {
      token = [token];
    }
    if (typeof callback === 'number') {
      func = function(input, array) {
        array[callback] = toInt(input);
      };
    }
    for (i = 0; i < token.length; i++) {
      tokens[token[i]] = func;
    }
  }
  function addWeekParseToken(token, callback) {
    addParseToken(token, function(input, array, config, token) {
      config._w = config._w || {};
      callback(input, config._w, config, token);
    });
  }
  function addTimeToArrayFromToken(token, input, config) {
    if (input != null && hasOwnProp(tokens, token)) {
      tokens[token](input, config._a, config, token);
    }
  }
  var YEAR = 0;
  var MONTH = 1;
  var DATE = 2;
  var HOUR = 3;
  var MINUTE = 4;
  var SECOND = 5;
  var MILLISECOND = 6;
  var WEEK = 7;
  var WEEKDAY = 8;
  var indexOf;
  if (Array.prototype.indexOf) {
    indexOf = Array.prototype.indexOf;
  } else {
    indexOf = function(o) {
      var i;
      for (i = 0; i < this.length; ++i) {
        if (this[i] === o) {
          return i;
        }
      }
      return -1;
    };
  }
  function daysInMonth(year, month) {
    return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
  }
  addFormatToken('M', ['MM', 2], 'Mo', function() {
    return this.month() + 1;
  });
  addFormatToken('MMM', 0, 0, function(format) {
    return this.localeData().monthsShort(this, format);
  });
  addFormatToken('MMMM', 0, 0, function(format) {
    return this.localeData().months(this, format);
  });
  addUnitAlias('month', 'M');
  addUnitPriority('month', 8);
  addRegexToken('M', match1to2);
  addRegexToken('MM', match1to2, match2);
  addRegexToken('MMM', function(isStrict, locale) {
    return locale.monthsShortRegex(isStrict);
  });
  addRegexToken('MMMM', function(isStrict, locale) {
    return locale.monthsRegex(isStrict);
  });
  addParseToken(['M', 'MM'], function(input, array) {
    array[MONTH] = toInt(input) - 1;
  });
  addParseToken(['MMM', 'MMMM'], function(input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict);
    if (month != null) {
      array[MONTH] = month;
    } else {
      getParsingFlags(config).invalidMonth = input;
    }
  });
  var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/;
  var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
  function localeMonths(m, format) {
    return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
  }
  var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
  function localeMonthsShort(m, format) {
    return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
  }
  function units_month__handleStrictParse(monthName, format, strict) {
    var i,
        ii,
        mom,
        llc = monthName.toLocaleLowerCase();
    if (!this._monthsParse) {
      this._monthsParse = [];
      this._longMonthsParse = [];
      this._shortMonthsParse = [];
      for (i = 0; i < 12; ++i) {
        mom = create_utc__createUTC([2000, i]);
        this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
        this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
      }
    }
    if (strict) {
      if (format === 'MMM') {
        ii = indexOf.call(this._shortMonthsParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._longMonthsParse, llc);
        return ii !== -1 ? ii : null;
      }
    } else {
      if (format === 'MMM') {
        ii = indexOf.call(this._shortMonthsParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._longMonthsParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._longMonthsParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._shortMonthsParse, llc);
        return ii !== -1 ? ii : null;
      }
    }
  }
  function localeMonthsParse(monthName, format, strict) {
    var i,
        mom,
        regex;
    if (this._monthsParseExact) {
      return units_month__handleStrictParse.call(this, monthName, format, strict);
    }
    if (!this._monthsParse) {
      this._monthsParse = [];
      this._longMonthsParse = [];
      this._shortMonthsParse = [];
    }
    for (i = 0; i < 12; i++) {
      mom = create_utc__createUTC([2000, i]);
      if (strict && !this._longMonthsParse[i]) {
        this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
        this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
      }
      if (!strict && !this._monthsParse[i]) {
        regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
        this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
      }
      if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
        return i;
      } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
        return i;
      } else if (!strict && this._monthsParse[i].test(monthName)) {
        return i;
      }
    }
  }
  function setMonth(mom, value) {
    var dayOfMonth;
    if (!mom.isValid()) {
      return mom;
    }
    if (typeof value === 'string') {
      if (/^\d+$/.test(value)) {
        value = toInt(value);
      } else {
        value = mom.localeData().monthsParse(value);
        if (typeof value !== 'number') {
          return mom;
        }
      }
    }
    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
    return mom;
  }
  function getSetMonth(value) {
    if (value != null) {
      setMonth(this, value);
      utils_hooks__hooks.updateOffset(this, true);
      return this;
    } else {
      return get_set__get(this, 'Month');
    }
  }
  function getDaysInMonth() {
    return daysInMonth(this.year(), this.month());
  }
  var defaultMonthsShortRegex = matchWord;
  function monthsShortRegex(isStrict) {
    if (this._monthsParseExact) {
      if (!hasOwnProp(this, '_monthsRegex')) {
        computeMonthsParse.call(this);
      }
      if (isStrict) {
        return this._monthsShortStrictRegex;
      } else {
        return this._monthsShortRegex;
      }
    } else {
      if (!hasOwnProp(this, '_monthsShortRegex')) {
        this._monthsShortRegex = defaultMonthsShortRegex;
      }
      return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
    }
  }
  var defaultMonthsRegex = matchWord;
  function monthsRegex(isStrict) {
    if (this._monthsParseExact) {
      if (!hasOwnProp(this, '_monthsRegex')) {
        computeMonthsParse.call(this);
      }
      if (isStrict) {
        return this._monthsStrictRegex;
      } else {
        return this._monthsRegex;
      }
    } else {
      if (!hasOwnProp(this, '_monthsRegex')) {
        this._monthsRegex = defaultMonthsRegex;
      }
      return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
    }
  }
  function computeMonthsParse() {
    function cmpLenRev(a, b) {
      return b.length - a.length;
    }
    var shortPieces = [],
        longPieces = [],
        mixedPieces = [],
        i,
        mom;
    for (i = 0; i < 12; i++) {
      mom = create_utc__createUTC([2000, i]);
      shortPieces.push(this.monthsShort(mom, ''));
      longPieces.push(this.months(mom, ''));
      mixedPieces.push(this.months(mom, ''));
      mixedPieces.push(this.monthsShort(mom, ''));
    }
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 12; i++) {
      shortPieces[i] = regexEscape(shortPieces[i]);
      longPieces[i] = regexEscape(longPieces[i]);
    }
    for (i = 0; i < 24; i++) {
      mixedPieces[i] = regexEscape(mixedPieces[i]);
    }
    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._monthsShortRegex = this._monthsRegex;
    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
  }
  addFormatToken('Y', 0, 0, function() {
    var y = this.year();
    return y <= 9999 ? '' + y : '+' + y;
  });
  addFormatToken(0, ['YY', 2], 0, function() {
    return this.year() % 100;
  });
  addFormatToken(0, ['YYYY', 4], 0, 'year');
  addFormatToken(0, ['YYYYY', 5], 0, 'year');
  addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');
  addUnitAlias('year', 'y');
  addUnitPriority('year', 1);
  addRegexToken('Y', matchSigned);
  addRegexToken('YY', match1to2, match2);
  addRegexToken('YYYY', match1to4, match4);
  addRegexToken('YYYYY', match1to6, match6);
  addRegexToken('YYYYYY', match1to6, match6);
  addParseToken(['YYYYY', 'YYYYYY'], YEAR);
  addParseToken('YYYY', function(input, array) {
    array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
  });
  addParseToken('YY', function(input, array) {
    array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
  });
  addParseToken('Y', function(input, array) {
    array[YEAR] = parseInt(input, 10);
  });
  function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
  }
  function isLeapYear(year) {
    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
  }
  utils_hooks__hooks.parseTwoDigitYear = function(input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
  };
  var getSetYear = makeGetSet('FullYear', true);
  function getIsLeapYear() {
    return isLeapYear(this.year());
  }
  function createDate(y, m, d, h, M, s, ms) {
    var date = new Date(y, m, d, h, M, s, ms);
    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
      date.setFullYear(y);
    }
    return date;
  }
  function createUTCDate(y) {
    var date = new Date(Date.UTC.apply(null, arguments));
    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
      date.setUTCFullYear(y);
    }
    return date;
  }
  function firstWeekOffset(year, dow, doy) {
    var fwd = 7 + dow - doy,
        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
    return -fwdlw + fwd - 1;
  }
  function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
    var localWeekday = (7 + weekday - dow) % 7,
        weekOffset = firstWeekOffset(year, dow, doy),
        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
        resYear,
        resDayOfYear;
    if (dayOfYear <= 0) {
      resYear = year - 1;
      resDayOfYear = daysInYear(resYear) + dayOfYear;
    } else if (dayOfYear > daysInYear(year)) {
      resYear = year + 1;
      resDayOfYear = dayOfYear - daysInYear(year);
    } else {
      resYear = year;
      resDayOfYear = dayOfYear;
    }
    return {
      year: resYear,
      dayOfYear: resDayOfYear
    };
  }
  function weekOfYear(mom, dow, doy) {
    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
        resWeek,
        resYear;
    if (week < 1) {
      resYear = mom.year() - 1;
      resWeek = week + weeksInYear(resYear, dow, doy);
    } else if (week > weeksInYear(mom.year(), dow, doy)) {
      resWeek = week - weeksInYear(mom.year(), dow, doy);
      resYear = mom.year() + 1;
    } else {
      resYear = mom.year();
      resWeek = week;
    }
    return {
      week: resWeek,
      year: resYear
    };
  }
  function weeksInYear(year, dow, doy) {
    var weekOffset = firstWeekOffset(year, dow, doy),
        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
  }
  addFormatToken('w', ['ww', 2], 'wo', 'week');
  addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');
  addUnitAlias('week', 'w');
  addUnitAlias('isoWeek', 'W');
  addUnitPriority('week', 5);
  addUnitPriority('isoWeek', 5);
  addRegexToken('w', match1to2);
  addRegexToken('ww', match1to2, match2);
  addRegexToken('W', match1to2);
  addRegexToken('WW', match1to2, match2);
  addWeekParseToken(['w', 'ww', 'W', 'WW'], function(input, week, config, token) {
    week[token.substr(0, 1)] = toInt(input);
  });
  function localeWeek(mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
  }
  var defaultLocaleWeek = {
    dow: 0,
    doy: 6
  };
  function localeFirstDayOfWeek() {
    return this._week.dow;
  }
  function localeFirstDayOfYear() {
    return this._week.doy;
  }
  function getSetWeek(input) {
    var week = this.localeData().week(this);
    return input == null ? week : this.add((input - week) * 7, 'd');
  }
  function getSetISOWeek(input) {
    var week = weekOfYear(this, 1, 4).week;
    return input == null ? week : this.add((input - week) * 7, 'd');
  }
  addFormatToken('d', 0, 'do', 'day');
  addFormatToken('dd', 0, 0, function(format) {
    return this.localeData().weekdaysMin(this, format);
  });
  addFormatToken('ddd', 0, 0, function(format) {
    return this.localeData().weekdaysShort(this, format);
  });
  addFormatToken('dddd', 0, 0, function(format) {
    return this.localeData().weekdays(this, format);
  });
  addFormatToken('e', 0, 0, 'weekday');
  addFormatToken('E', 0, 0, 'isoWeekday');
  addUnitAlias('day', 'd');
  addUnitAlias('weekday', 'e');
  addUnitAlias('isoWeekday', 'E');
  addUnitPriority('day', 11);
  addUnitPriority('weekday', 11);
  addUnitPriority('isoWeekday', 11);
  addRegexToken('d', match1to2);
  addRegexToken('e', match1to2);
  addRegexToken('E', match1to2);
  addRegexToken('dd', function(isStrict, locale) {
    return locale.weekdaysMinRegex(isStrict);
  });
  addRegexToken('ddd', function(isStrict, locale) {
    return locale.weekdaysShortRegex(isStrict);
  });
  addRegexToken('dddd', function(isStrict, locale) {
    return locale.weekdaysRegex(isStrict);
  });
  addWeekParseToken(['dd', 'ddd', 'dddd'], function(input, week, config, token) {
    var weekday = config._locale.weekdaysParse(input, token, config._strict);
    if (weekday != null) {
      week.d = weekday;
    } else {
      getParsingFlags(config).invalidWeekday = input;
    }
  });
  addWeekParseToken(['d', 'e', 'E'], function(input, week, config, token) {
    week[token] = toInt(input);
  });
  function parseWeekday(input, locale) {
    if (typeof input !== 'string') {
      return input;
    }
    if (!isNaN(input)) {
      return parseInt(input, 10);
    }
    input = locale.weekdaysParse(input);
    if (typeof input === 'number') {
      return input;
    }
    return null;
  }
  function parseIsoWeekday(input, locale) {
    if (typeof input === 'string') {
      return locale.weekdaysParse(input) % 7 || 7;
    }
    return isNaN(input) ? null : input;
  }
  var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
  function localeWeekdays(m, format) {
    return isArray(this._weekdays) ? this._weekdays[m.day()] : this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
  }
  var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
  function localeWeekdaysShort(m) {
    return this._weekdaysShort[m.day()];
  }
  var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
  function localeWeekdaysMin(m) {
    return this._weekdaysMin[m.day()];
  }
  function day_of_week__handleStrictParse(weekdayName, format, strict) {
    var i,
        ii,
        mom,
        llc = weekdayName.toLocaleLowerCase();
    if (!this._weekdaysParse) {
      this._weekdaysParse = [];
      this._shortWeekdaysParse = [];
      this._minWeekdaysParse = [];
      for (i = 0; i < 7; ++i) {
        mom = create_utc__createUTC([2000, 1]).day(i);
        this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
        this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
        this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
      }
    }
    if (strict) {
      if (format === 'dddd') {
        ii = indexOf.call(this._weekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else if (format === 'ddd') {
        ii = indexOf.call(this._shortWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._minWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      }
    } else {
      if (format === 'dddd') {
        ii = indexOf.call(this._weekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._shortWeekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._minWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else if (format === 'ddd') {
        ii = indexOf.call(this._shortWeekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._weekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._minWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._minWeekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._weekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._shortWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      }
    }
  }
  function localeWeekdaysParse(weekdayName, format, strict) {
    var i,
        mom,
        regex;
    if (this._weekdaysParseExact) {
      return day_of_week__handleStrictParse.call(this, weekdayName, format, strict);
    }
    if (!this._weekdaysParse) {
      this._weekdaysParse = [];
      this._minWeekdaysParse = [];
      this._shortWeekdaysParse = [];
      this._fullWeekdaysParse = [];
    }
    for (i = 0; i < 7; i++) {
      mom = create_utc__createUTC([2000, 1]).day(i);
      if (strict && !this._fullWeekdaysParse[i]) {
        this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
        this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
        this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
      }
      if (!this._weekdaysParse[i]) {
        regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
        this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
      }
      if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
        return i;
      } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
        return i;
      } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
        return i;
      } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
        return i;
      }
    }
  }
  function getSetDayOfWeek(input) {
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }
    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    if (input != null) {
      input = parseWeekday(input, this.localeData());
      return this.add(input - day, 'd');
    } else {
      return day;
    }
  }
  function getSetLocaleDayOfWeek(input) {
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }
    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return input == null ? weekday : this.add(input - weekday, 'd');
  }
  function getSetISODayOfWeek(input) {
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }
    if (input != null) {
      var weekday = parseIsoWeekday(input, this.localeData());
      return this.day(this.day() % 7 ? weekday : weekday - 7);
    } else {
      return this.day() || 7;
    }
  }
  var defaultWeekdaysRegex = matchWord;
  function weekdaysRegex(isStrict) {
    if (this._weekdaysParseExact) {
      if (!hasOwnProp(this, '_weekdaysRegex')) {
        computeWeekdaysParse.call(this);
      }
      if (isStrict) {
        return this._weekdaysStrictRegex;
      } else {
        return this._weekdaysRegex;
      }
    } else {
      if (!hasOwnProp(this, '_weekdaysRegex')) {
        this._weekdaysRegex = defaultWeekdaysRegex;
      }
      return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
    }
  }
  var defaultWeekdaysShortRegex = matchWord;
  function weekdaysShortRegex(isStrict) {
    if (this._weekdaysParseExact) {
      if (!hasOwnProp(this, '_weekdaysRegex')) {
        computeWeekdaysParse.call(this);
      }
      if (isStrict) {
        return this._weekdaysShortStrictRegex;
      } else {
        return this._weekdaysShortRegex;
      }
    } else {
      if (!hasOwnProp(this, '_weekdaysShortRegex')) {
        this._weekdaysShortRegex = defaultWeekdaysShortRegex;
      }
      return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
    }
  }
  var defaultWeekdaysMinRegex = matchWord;
  function weekdaysMinRegex(isStrict) {
    if (this._weekdaysParseExact) {
      if (!hasOwnProp(this, '_weekdaysRegex')) {
        computeWeekdaysParse.call(this);
      }
      if (isStrict) {
        return this._weekdaysMinStrictRegex;
      } else {
        return this._weekdaysMinRegex;
      }
    } else {
      if (!hasOwnProp(this, '_weekdaysMinRegex')) {
        this._weekdaysMinRegex = defaultWeekdaysMinRegex;
      }
      return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
    }
  }
  function computeWeekdaysParse() {
    function cmpLenRev(a, b) {
      return b.length - a.length;
    }
    var minPieces = [],
        shortPieces = [],
        longPieces = [],
        mixedPieces = [],
        i,
        mom,
        minp,
        shortp,
        longp;
    for (i = 0; i < 7; i++) {
      mom = create_utc__createUTC([2000, 1]).day(i);
      minp = this.weekdaysMin(mom, '');
      shortp = this.weekdaysShort(mom, '');
      longp = this.weekdays(mom, '');
      minPieces.push(minp);
      shortPieces.push(shortp);
      longPieces.push(longp);
      mixedPieces.push(minp);
      mixedPieces.push(shortp);
      mixedPieces.push(longp);
    }
    minPieces.sort(cmpLenRev);
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 7; i++) {
      shortPieces[i] = regexEscape(shortPieces[i]);
      longPieces[i] = regexEscape(longPieces[i]);
      mixedPieces[i] = regexEscape(mixedPieces[i]);
    }
    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._weekdaysShortRegex = this._weekdaysRegex;
    this._weekdaysMinRegex = this._weekdaysRegex;
    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
  }
  function hFormat() {
    return this.hours() % 12 || 12;
  }
  function kFormat() {
    return this.hours() || 24;
  }
  addFormatToken('H', ['HH', 2], 0, 'hour');
  addFormatToken('h', ['hh', 2], 0, hFormat);
  addFormatToken('k', ['kk', 2], 0, kFormat);
  addFormatToken('hmm', 0, 0, function() {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
  });
  addFormatToken('hmmss', 0, 0, function() {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
  });
  addFormatToken('Hmm', 0, 0, function() {
    return '' + this.hours() + zeroFill(this.minutes(), 2);
  });
  addFormatToken('Hmmss', 0, 0, function() {
    return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
  });
  function meridiem(token, lowercase) {
    addFormatToken(token, 0, 0, function() {
      return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
    });
  }
  meridiem('a', true);
  meridiem('A', false);
  addUnitAlias('hour', 'h');
  addUnitPriority('hour', 13);
  function matchMeridiem(isStrict, locale) {
    return locale._meridiemParse;
  }
  addRegexToken('a', matchMeridiem);
  addRegexToken('A', matchMeridiem);
  addRegexToken('H', match1to2);
  addRegexToken('h', match1to2);
  addRegexToken('HH', match1to2, match2);
  addRegexToken('hh', match1to2, match2);
  addRegexToken('hmm', match3to4);
  addRegexToken('hmmss', match5to6);
  addRegexToken('Hmm', match3to4);
  addRegexToken('Hmmss', match5to6);
  addParseToken(['H', 'HH'], HOUR);
  addParseToken(['a', 'A'], function(input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
  });
  addParseToken(['h', 'hh'], function(input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
  });
  addParseToken('hmm', function(input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config).bigHour = true;
  });
  addParseToken('hmmss', function(input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config).bigHour = true;
  });
  addParseToken('Hmm', function(input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
  });
  addParseToken('Hmmss', function(input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
  });
  function localeIsPM(input) {
    return ((input + '').toLowerCase().charAt(0) === 'p');
  }
  var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
  function localeMeridiem(hours, minutes, isLower) {
    if (hours > 11) {
      return isLower ? 'pm' : 'PM';
    } else {
      return isLower ? 'am' : 'AM';
    }
  }
  var getSetHour = makeGetSet('Hours', true);
  var baseConfig = {
    calendar: defaultCalendar,
    longDateFormat: defaultLongDateFormat,
    invalidDate: defaultInvalidDate,
    ordinal: defaultOrdinal,
    ordinalParse: defaultOrdinalParse,
    relativeTime: defaultRelativeTime,
    months: defaultLocaleMonths,
    monthsShort: defaultLocaleMonthsShort,
    week: defaultLocaleWeek,
    weekdays: defaultLocaleWeekdays,
    weekdaysMin: defaultLocaleWeekdaysMin,
    weekdaysShort: defaultLocaleWeekdaysShort,
    meridiemParse: defaultLocaleMeridiemParse
  };
  var locales = {};
  var globalLocale;
  function normalizeLocale(key) {
    return key ? key.toLowerCase().replace('_', '-') : key;
  }
  function chooseLocale(names) {
    var i = 0,
        j,
        next,
        locale,
        split;
    while (i < names.length) {
      split = normalizeLocale(names[i]).split('-');
      j = split.length;
      next = normalizeLocale(names[i + 1]);
      next = next ? next.split('-') : null;
      while (j > 0) {
        locale = loadLocale(split.slice(0, j).join('-'));
        if (locale) {
          return locale;
        }
        if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
          break;
        }
        j--;
      }
      i++;
    }
    return null;
  }
  function loadLocale(name) {
    var oldLocale = null;
    if (!locales[name] && (typeof module !== 'undefined') && module && module.exports) {
      try {
        oldLocale = globalLocale._abbr;
        require('./locale/' + name);
        locale_locales__getSetGlobalLocale(oldLocale);
      } catch (e) {}
    }
    return locales[name];
  }
  function locale_locales__getSetGlobalLocale(key, values) {
    var data;
    if (key) {
      if (isUndefined(values)) {
        data = locale_locales__getLocale(key);
      } else {
        data = defineLocale(key, values);
      }
      if (data) {
        globalLocale = data;
      }
    }
    return globalLocale._abbr;
  }
  function defineLocale(name, config) {
    if (config !== null) {
      var parentConfig = baseConfig;
      config.abbr = name;
      if (locales[name] != null) {
        deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale ' + 'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
        parentConfig = locales[name]._config;
      } else if (config.parentLocale != null) {
        if (locales[config.parentLocale] != null) {
          parentConfig = locales[config.parentLocale]._config;
        } else {
          deprecateSimple('parentLocaleUndefined', 'specified parentLocale is not defined yet. See http://momentjs.com/guides/#/warnings/parent-locale/');
        }
      }
      locales[name] = new Locale(mergeConfigs(parentConfig, config));
      locale_locales__getSetGlobalLocale(name);
      return locales[name];
    } else {
      delete locales[name];
      return null;
    }
  }
  function updateLocale(name, config) {
    if (config != null) {
      var locale,
          parentConfig = baseConfig;
      if (locales[name] != null) {
        parentConfig = locales[name]._config;
      }
      config = mergeConfigs(parentConfig, config);
      locale = new Locale(config);
      locale.parentLocale = locales[name];
      locales[name] = locale;
      locale_locales__getSetGlobalLocale(name);
    } else {
      if (locales[name] != null) {
        if (locales[name].parentLocale != null) {
          locales[name] = locales[name].parentLocale;
        } else if (locales[name] != null) {
          delete locales[name];
        }
      }
    }
    return locales[name];
  }
  function locale_locales__getLocale(key) {
    var locale;
    if (key && key._locale && key._locale._abbr) {
      key = key._locale._abbr;
    }
    if (!key) {
      return globalLocale;
    }
    if (!isArray(key)) {
      locale = loadLocale(key);
      if (locale) {
        return locale;
      }
      key = [key];
    }
    return chooseLocale(key);
  }
  function locale_locales__listLocales() {
    return keys(locales);
  }
  function checkOverflow(m) {
    var overflow;
    var a = m._a;
    if (a && getParsingFlags(m).overflow === -2) {
      overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
      if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
        overflow = DATE;
      }
      if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
        overflow = WEEK;
      }
      if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
        overflow = WEEKDAY;
      }
      getParsingFlags(m).overflow = overflow;
    }
    return m;
  }
  var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
  var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
  var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
  var isoDates = [['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/], ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/], ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/], ['GGGG-[W]WW', /\d{4}-W\d\d/, false], ['YYYY-DDD', /\d{4}-\d{3}/], ['YYYY-MM', /\d{4}-\d\d/, false], ['YYYYYYMMDD', /[+-]\d{10}/], ['YYYYMMDD', /\d{8}/], ['GGGG[W]WWE', /\d{4}W\d{3}/], ['GGGG[W]WW', /\d{4}W\d{2}/, false], ['YYYYDDD', /\d{7}/]];
  var isoTimes = [['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/], ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/], ['HH:mm:ss', /\d\d:\d\d:\d\d/], ['HH:mm', /\d\d:\d\d/], ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/], ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/], ['HHmmss', /\d\d\d\d\d\d/], ['HHmm', /\d\d\d\d/], ['HH', /\d\d/]];
  var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;
  function configFromISO(config) {
    var i,
        l,
        string = config._i,
        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
        allowTime,
        dateFormat,
        timeFormat,
        tzFormat;
    if (match) {
      getParsingFlags(config).iso = true;
      for (i = 0, l = isoDates.length; i < l; i++) {
        if (isoDates[i][1].exec(match[1])) {
          dateFormat = isoDates[i][0];
          allowTime = isoDates[i][2] !== false;
          break;
        }
      }
      if (dateFormat == null) {
        config._isValid = false;
        return;
      }
      if (match[3]) {
        for (i = 0, l = isoTimes.length; i < l; i++) {
          if (isoTimes[i][1].exec(match[3])) {
            timeFormat = (match[2] || ' ') + isoTimes[i][0];
            break;
          }
        }
        if (timeFormat == null) {
          config._isValid = false;
          return;
        }
      }
      if (!allowTime && timeFormat != null) {
        config._isValid = false;
        return;
      }
      if (match[4]) {
        if (tzRegex.exec(match[4])) {
          tzFormat = 'Z';
        } else {
          config._isValid = false;
          return;
        }
      }
      config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
      configFromStringAndFormat(config);
    } else {
      config._isValid = false;
    }
  }
  function configFromString(config) {
    var matched = aspNetJsonRegex.exec(config._i);
    if (matched !== null) {
      config._d = new Date(+matched[1]);
      return;
    }
    configFromISO(config);
    if (config._isValid === false) {
      delete config._isValid;
      utils_hooks__hooks.createFromInputFallback(config);
    }
  }
  utils_hooks__hooks.createFromInputFallback = deprecate('moment construction falls back to js Date. This is ' + 'discouraged and will be removed in upcoming major ' + 'release. Please refer to ' + 'http://momentjs.com/guides/#/warnings/js-date/ for more info.', function(config) {
    config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
  });
  function defaults(a, b, c) {
    if (a != null) {
      return a;
    }
    if (b != null) {
      return b;
    }
    return c;
  }
  function currentDateArray(config) {
    var nowValue = new Date(utils_hooks__hooks.now());
    if (config._useUTC) {
      return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
    }
    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
  }
  function configFromArray(config) {
    var i,
        date,
        input = [],
        currentDate,
        yearToUse;
    if (config._d) {
      return;
    }
    currentDate = currentDateArray(config);
    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
      dayOfYearFromWeekInfo(config);
    }
    if (config._dayOfYear) {
      yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
      if (config._dayOfYear > daysInYear(yearToUse)) {
        getParsingFlags(config)._overflowDayOfYear = true;
      }
      date = createUTCDate(yearToUse, 0, config._dayOfYear);
      config._a[MONTH] = date.getUTCMonth();
      config._a[DATE] = date.getUTCDate();
    }
    for (i = 0; i < 3 && config._a[i] == null; ++i) {
      config._a[i] = input[i] = currentDate[i];
    }
    for (; i < 7; i++) {
      config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
    }
    if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
      config._nextDay = true;
      config._a[HOUR] = 0;
    }
    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
    if (config._tzm != null) {
      config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }
    if (config._nextDay) {
      config._a[HOUR] = 24;
    }
  }
  function dayOfYearFromWeekInfo(config) {
    var w,
        weekYear,
        week,
        weekday,
        dow,
        doy,
        temp,
        weekdayOverflow;
    w = config._w;
    if (w.GG != null || w.W != null || w.E != null) {
      dow = 1;
      doy = 4;
      weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
      week = defaults(w.W, 1);
      weekday = defaults(w.E, 1);
      if (weekday < 1 || weekday > 7) {
        weekdayOverflow = true;
      }
    } else {
      dow = config._locale._week.dow;
      doy = config._locale._week.doy;
      weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
      week = defaults(w.w, 1);
      if (w.d != null) {
        weekday = w.d;
        if (weekday < 0 || weekday > 6) {
          weekdayOverflow = true;
        }
      } else if (w.e != null) {
        weekday = w.e + dow;
        if (w.e < 0 || w.e > 6) {
          weekdayOverflow = true;
        }
      } else {
        weekday = dow;
      }
    }
    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
      getParsingFlags(config)._overflowWeeks = true;
    } else if (weekdayOverflow != null) {
      getParsingFlags(config)._overflowWeekday = true;
    } else {
      temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
      config._a[YEAR] = temp.year;
      config._dayOfYear = temp.dayOfYear;
    }
  }
  utils_hooks__hooks.ISO_8601 = function() {};
  function configFromStringAndFormat(config) {
    if (config._f === utils_hooks__hooks.ISO_8601) {
      configFromISO(config);
      return;
    }
    config._a = [];
    getParsingFlags(config).empty = true;
    var string = '' + config._i,
        i,
        parsedInput,
        tokens,
        token,
        skipped,
        stringLength = string.length,
        totalParsedInputLength = 0;
    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
    for (i = 0; i < tokens.length; i++) {
      token = tokens[i];
      parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
      if (parsedInput) {
        skipped = string.substr(0, string.indexOf(parsedInput));
        if (skipped.length > 0) {
          getParsingFlags(config).unusedInput.push(skipped);
        }
        string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
        totalParsedInputLength += parsedInput.length;
      }
      if (formatTokenFunctions[token]) {
        if (parsedInput) {
          getParsingFlags(config).empty = false;
        } else {
          getParsingFlags(config).unusedTokens.push(token);
        }
        addTimeToArrayFromToken(token, parsedInput, config);
      } else if (config._strict && !parsedInput) {
        getParsingFlags(config).unusedTokens.push(token);
      }
    }
    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
    if (string.length > 0) {
      getParsingFlags(config).unusedInput.push(string);
    }
    if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
      getParsingFlags(config).bigHour = undefined;
    }
    getParsingFlags(config).parsedDateParts = config._a.slice(0);
    getParsingFlags(config).meridiem = config._meridiem;
    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
    configFromArray(config);
    checkOverflow(config);
  }
  function meridiemFixWrap(locale, hour, meridiem) {
    var isPm;
    if (meridiem == null) {
      return hour;
    }
    if (locale.meridiemHour != null) {
      return locale.meridiemHour(hour, meridiem);
    } else if (locale.isPM != null) {
      isPm = locale.isPM(meridiem);
      if (isPm && hour < 12) {
        hour += 12;
      }
      if (!isPm && hour === 12) {
        hour = 0;
      }
      return hour;
    } else {
      return hour;
    }
  }
  function configFromStringAndArray(config) {
    var tempConfig,
        bestMoment,
        scoreToBeat,
        i,
        currentScore;
    if (config._f.length === 0) {
      getParsingFlags(config).invalidFormat = true;
      config._d = new Date(NaN);
      return;
    }
    for (i = 0; i < config._f.length; i++) {
      currentScore = 0;
      tempConfig = copyConfig({}, config);
      if (config._useUTC != null) {
        tempConfig._useUTC = config._useUTC;
      }
      tempConfig._f = config._f[i];
      configFromStringAndFormat(tempConfig);
      if (!valid__isValid(tempConfig)) {
        continue;
      }
      currentScore += getParsingFlags(tempConfig).charsLeftOver;
      currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
      getParsingFlags(tempConfig).score = currentScore;
      if (scoreToBeat == null || currentScore < scoreToBeat) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
      }
    }
    extend(config, bestMoment || tempConfig);
  }
  function configFromObject(config) {
    if (config._d) {
      return;
    }
    var i = normalizeObjectUnits(config._i);
    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function(obj) {
      return obj && parseInt(obj, 10);
    });
    configFromArray(config);
  }
  function createFromConfig(config) {
    var res = new Moment(checkOverflow(prepareConfig(config)));
    if (res._nextDay) {
      res.add(1, 'd');
      res._nextDay = undefined;
    }
    return res;
  }
  function prepareConfig(config) {
    var input = config._i,
        format = config._f;
    config._locale = config._locale || locale_locales__getLocale(config._l);
    if (input === null || (format === undefined && input === '')) {
      return valid__createInvalid({nullInput: true});
    }
    if (typeof input === 'string') {
      config._i = input = config._locale.preparse(input);
    }
    if (isMoment(input)) {
      return new Moment(checkOverflow(input));
    } else if (isArray(format)) {
      configFromStringAndArray(config);
    } else if (isDate(input)) {
      config._d = input;
    } else if (format) {
      configFromStringAndFormat(config);
    } else {
      configFromInput(config);
    }
    if (!valid__isValid(config)) {
      config._d = null;
    }
    return config;
  }
  function configFromInput(config) {
    var input = config._i;
    if (input === undefined) {
      config._d = new Date(utils_hooks__hooks.now());
    } else if (isDate(input)) {
      config._d = new Date(input.valueOf());
    } else if (typeof input === 'string') {
      configFromString(config);
    } else if (isArray(input)) {
      config._a = map(input.slice(0), function(obj) {
        return parseInt(obj, 10);
      });
      configFromArray(config);
    } else if (typeof(input) === 'object') {
      configFromObject(config);
    } else if (typeof(input) === 'number') {
      config._d = new Date(input);
    } else {
      utils_hooks__hooks.createFromInputFallback(config);
    }
  }
  function createLocalOrUTC(input, format, locale, strict, isUTC) {
    var c = {};
    if (typeof(locale) === 'boolean') {
      strict = locale;
      locale = undefined;
    }
    if ((isObject(input) && isObjectEmpty(input)) || (isArray(input) && input.length === 0)) {
      input = undefined;
    }
    c._isAMomentObject = true;
    c._useUTC = c._isUTC = isUTC;
    c._l = locale;
    c._i = input;
    c._f = format;
    c._strict = strict;
    return createFromConfig(c);
  }
  function local__createLocal(input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, false);
  }
  var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function() {
    var other = local__createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
      return other < this ? this : other;
    } else {
      return valid__createInvalid();
    }
  });
  var prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function() {
    var other = local__createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
      return other > this ? this : other;
    } else {
      return valid__createInvalid();
    }
  });
  function pickBy(fn, moments) {
    var res,
        i;
    if (moments.length === 1 && isArray(moments[0])) {
      moments = moments[0];
    }
    if (!moments.length) {
      return local__createLocal();
    }
    res = moments[0];
    for (i = 1; i < moments.length; ++i) {
      if (!moments[i].isValid() || moments[i][fn](res)) {
        res = moments[i];
      }
    }
    return res;
  }
  function min() {
    var args = [].slice.call(arguments, 0);
    return pickBy('isBefore', args);
  }
  function max() {
    var args = [].slice.call(arguments, 0);
    return pickBy('isAfter', args);
  }
  var now = function() {
    return Date.now ? Date.now() : +(new Date());
  };
  function Duration(duration) {
    var normalizedInput = normalizeObjectUnits(duration),
        years = normalizedInput.year || 0,
        quarters = normalizedInput.quarter || 0,
        months = normalizedInput.month || 0,
        weeks = normalizedInput.week || 0,
        days = normalizedInput.day || 0,
        hours = normalizedInput.hour || 0,
        minutes = normalizedInput.minute || 0,
        seconds = normalizedInput.second || 0,
        milliseconds = normalizedInput.millisecond || 0;
    this._milliseconds = +milliseconds + seconds * 1e3 + minutes * 6e4 + hours * 1000 * 60 * 60;
    this._days = +days + weeks * 7;
    this._months = +months + quarters * 3 + years * 12;
    this._data = {};
    this._locale = locale_locales__getLocale();
    this._bubble();
  }
  function isDuration(obj) {
    return obj instanceof Duration;
  }
  function offset(token, separator) {
    addFormatToken(token, 0, 0, function() {
      var offset = this.utcOffset();
      var sign = '+';
      if (offset < 0) {
        offset = -offset;
        sign = '-';
      }
      return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
    });
  }
  offset('Z', ':');
  offset('ZZ', '');
  addRegexToken('Z', matchShortOffset);
  addRegexToken('ZZ', matchShortOffset);
  addParseToken(['Z', 'ZZ'], function(input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
  });
  var chunkOffset = /([\+\-]|\d\d)/gi;
  function offsetFromString(matcher, string) {
    var matches = ((string || '').match(matcher) || []);
    var chunk = matches[matches.length - 1] || [];
    var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
    var minutes = +(parts[1] * 60) + toInt(parts[2]);
    return parts[0] === '+' ? minutes : -minutes;
  }
  function cloneWithOffset(input, model) {
    var res,
        diff;
    if (model._isUTC) {
      res = model.clone();
      diff = (isMoment(input) || isDate(input) ? input.valueOf() : local__createLocal(input).valueOf()) - res.valueOf();
      res._d.setTime(res._d.valueOf() + diff);
      utils_hooks__hooks.updateOffset(res, false);
      return res;
    } else {
      return local__createLocal(input).local();
    }
  }
  function getDateOffset(m) {
    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
  }
  utils_hooks__hooks.updateOffset = function() {};
  function getSetOffset(input, keepLocalTime) {
    var offset = this._offset || 0,
        localAdjust;
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }
    if (input != null) {
      if (typeof input === 'string') {
        input = offsetFromString(matchShortOffset, input);
      } else if (Math.abs(input) < 16) {
        input = input * 60;
      }
      if (!this._isUTC && keepLocalTime) {
        localAdjust = getDateOffset(this);
      }
      this._offset = input;
      this._isUTC = true;
      if (localAdjust != null) {
        this.add(localAdjust, 'm');
      }
      if (offset !== input) {
        if (!keepLocalTime || this._changeInProgress) {
          add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
        } else if (!this._changeInProgress) {
          this._changeInProgress = true;
          utils_hooks__hooks.updateOffset(this, true);
          this._changeInProgress = null;
        }
      }
      return this;
    } else {
      return this._isUTC ? offset : getDateOffset(this);
    }
  }
  function getSetZone(input, keepLocalTime) {
    if (input != null) {
      if (typeof input !== 'string') {
        input = -input;
      }
      this.utcOffset(input, keepLocalTime);
      return this;
    } else {
      return -this.utcOffset();
    }
  }
  function setOffsetToUTC(keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
  }
  function setOffsetToLocal(keepLocalTime) {
    if (this._isUTC) {
      this.utcOffset(0, keepLocalTime);
      this._isUTC = false;
      if (keepLocalTime) {
        this.subtract(getDateOffset(this), 'm');
      }
    }
    return this;
  }
  function setOffsetToParsedOffset() {
    if (this._tzm) {
      this.utcOffset(this._tzm);
    } else if (typeof this._i === 'string') {
      this.utcOffset(offsetFromString(matchOffset, this._i));
    }
    return this;
  }
  function hasAlignedHourOffset(input) {
    if (!this.isValid()) {
      return false;
    }
    input = input ? local__createLocal(input).utcOffset() : 0;
    return (this.utcOffset() - input) % 60 === 0;
  }
  function isDaylightSavingTime() {
    return (this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset());
  }
  function isDaylightSavingTimeShifted() {
    if (!isUndefined(this._isDSTShifted)) {
      return this._isDSTShifted;
    }
    var c = {};
    copyConfig(c, this);
    c = prepareConfig(c);
    if (c._a) {
      var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
      this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
    } else {
      this._isDSTShifted = false;
    }
    return this._isDSTShifted;
  }
  function isLocal() {
    return this.isValid() ? !this._isUTC : false;
  }
  function isUtcOffset() {
    return this.isValid() ? this._isUTC : false;
  }
  function isUtc() {
    return this.isValid() ? this._isUTC && this._offset === 0 : false;
  }
  var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?\d*)?$/;
  var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;
  function create__createDuration(input, key) {
    var duration = input,
        match = null,
        sign,
        ret,
        diffRes;
    if (isDuration(input)) {
      duration = {
        ms: input._milliseconds,
        d: input._days,
        M: input._months
      };
    } else if (typeof input === 'number') {
      duration = {};
      if (key) {
        duration[key] = input;
      } else {
        duration.milliseconds = input;
      }
    } else if (!!(match = aspNetRegex.exec(input))) {
      sign = (match[1] === '-') ? -1 : 1;
      duration = {
        y: 0,
        d: toInt(match[DATE]) * sign,
        h: toInt(match[HOUR]) * sign,
        m: toInt(match[MINUTE]) * sign,
        s: toInt(match[SECOND]) * sign,
        ms: toInt(match[MILLISECOND]) * sign
      };
    } else if (!!(match = isoRegex.exec(input))) {
      sign = (match[1] === '-') ? -1 : 1;
      duration = {
        y: parseIso(match[2], sign),
        M: parseIso(match[3], sign),
        w: parseIso(match[4], sign),
        d: parseIso(match[5], sign),
        h: parseIso(match[6], sign),
        m: parseIso(match[7], sign),
        s: parseIso(match[8], sign)
      };
    } else if (duration == null) {
      duration = {};
    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
      diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));
      duration = {};
      duration.ms = diffRes.milliseconds;
      duration.M = diffRes.months;
    }
    ret = new Duration(duration);
    if (isDuration(input) && hasOwnProp(input, '_locale')) {
      ret._locale = input._locale;
    }
    return ret;
  }
  create__createDuration.fn = Duration.prototype;
  function parseIso(inp, sign) {
    var res = inp && parseFloat(inp.replace(',', '.'));
    return (isNaN(res) ? 0 : res) * sign;
  }
  function positiveMomentsDifference(base, other) {
    var res = {
      milliseconds: 0,
      months: 0
    };
    res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
    if (base.clone().add(res.months, 'M').isAfter(other)) {
      --res.months;
    }
    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));
    return res;
  }
  function momentsDifference(base, other) {
    var res;
    if (!(base.isValid() && other.isValid())) {
      return {
        milliseconds: 0,
        months: 0
      };
    }
    other = cloneWithOffset(other, base);
    if (base.isBefore(other)) {
      res = positiveMomentsDifference(base, other);
    } else {
      res = positiveMomentsDifference(other, base);
      res.milliseconds = -res.milliseconds;
      res.months = -res.months;
    }
    return res;
  }
  function absRound(number) {
    if (number < 0) {
      return Math.round(-1 * number) * -1;
    } else {
      return Math.round(number);
    }
  }
  function createAdder(direction, name) {
    return function(val, period) {
      var dur,
          tmp;
      if (period !== null && !isNaN(+period)) {
        deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' + 'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
        tmp = val;
        val = period;
        period = tmp;
      }
      val = typeof val === 'string' ? +val : val;
      dur = create__createDuration(val, period);
      add_subtract__addSubtract(this, dur, direction);
      return this;
    };
  }
  function add_subtract__addSubtract(mom, duration, isAdding, updateOffset) {
    var milliseconds = duration._milliseconds,
        days = absRound(duration._days),
        months = absRound(duration._months);
    if (!mom.isValid()) {
      return;
    }
    updateOffset = updateOffset == null ? true : updateOffset;
    if (milliseconds) {
      mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
    }
    if (days) {
      get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
    }
    if (months) {
      setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
    }
    if (updateOffset) {
      utils_hooks__hooks.updateOffset(mom, days || months);
    }
  }
  var add_subtract__add = createAdder(1, 'add');
  var add_subtract__subtract = createAdder(-1, 'subtract');
  function getCalendarFormat(myMoment, now) {
    var diff = myMoment.diff(now, 'days', true);
    return diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
  }
  function moment_calendar__calendar(time, formats) {
    var now = time || local__createLocal(),
        sod = cloneWithOffset(now, this).startOf('day'),
        format = utils_hooks__hooks.calendarFormat(this, sod) || 'sameElse';
    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
    return this.format(output || this.localeData().calendar(format, this, local__createLocal(now)));
  }
  function clone() {
    return new Moment(this);
  }
  function isAfter(input, units) {
    var localInput = isMoment(input) ? input : local__createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
      return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
      return this.valueOf() > localInput.valueOf();
    } else {
      return localInput.valueOf() < this.clone().startOf(units).valueOf();
    }
  }
  function isBefore(input, units) {
    var localInput = isMoment(input) ? input : local__createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
      return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
      return this.valueOf() < localInput.valueOf();
    } else {
      return this.clone().endOf(units).valueOf() < localInput.valueOf();
    }
  }
  function isBetween(from, to, units, inclusivity) {
    inclusivity = inclusivity || '()';
    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) && (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
  }
  function isSame(input, units) {
    var localInput = isMoment(input) ? input : local__createLocal(input),
        inputMs;
    if (!(this.isValid() && localInput.isValid())) {
      return false;
    }
    units = normalizeUnits(units || 'millisecond');
    if (units === 'millisecond') {
      return this.valueOf() === localInput.valueOf();
    } else {
      inputMs = localInput.valueOf();
      return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
    }
  }
  function isSameOrAfter(input, units) {
    return this.isSame(input, units) || this.isAfter(input, units);
  }
  function isSameOrBefore(input, units) {
    return this.isSame(input, units) || this.isBefore(input, units);
  }
  function diff(input, units, asFloat) {
    var that,
        zoneDelta,
        delta,
        output;
    if (!this.isValid()) {
      return NaN;
    }
    that = cloneWithOffset(input, this);
    if (!that.isValid()) {
      return NaN;
    }
    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
    units = normalizeUnits(units);
    if (units === 'year' || units === 'month' || units === 'quarter') {
      output = monthDiff(this, that);
      if (units === 'quarter') {
        output = output / 3;
      } else if (units === 'year') {
        output = output / 12;
      }
    } else {
      delta = this - that;
      output = units === 'second' ? delta / 1e3 : units === 'minute' ? delta / 6e4 : units === 'hour' ? delta / 36e5 : units === 'day' ? (delta - zoneDelta) / 864e5 : units === 'week' ? (delta - zoneDelta) / 6048e5 : delta;
    }
    return asFloat ? output : absFloor(output);
  }
  function monthDiff(a, b) {
    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
        anchor = a.clone().add(wholeMonthDiff, 'months'),
        anchor2,
        adjust;
    if (b - anchor < 0) {
      anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
      adjust = (b - anchor) / (anchor - anchor2);
    } else {
      anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
      adjust = (b - anchor) / (anchor2 - anchor);
    }
    return -(wholeMonthDiff + adjust) || 0;
  }
  utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
  utils_hooks__hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';
  function toString() {
    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
  }
  function moment_format__toISOString() {
    var m = this.clone().utc();
    if (0 < m.year() && m.year() <= 9999) {
      if (isFunction(Date.prototype.toISOString)) {
        return this.toDate().toISOString();
      } else {
        return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
      }
    } else {
      return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
    }
  }
  function format(inputString) {
    if (!inputString) {
      inputString = this.isUtc() ? utils_hooks__hooks.defaultFormatUtc : utils_hooks__hooks.defaultFormat;
    }
    var output = formatMoment(this, inputString);
    return this.localeData().postformat(output);
  }
  function from(time, withoutSuffix) {
    if (this.isValid() && ((isMoment(time) && time.isValid()) || local__createLocal(time).isValid())) {
      return create__createDuration({
        to: this,
        from: time
      }).locale(this.locale()).humanize(!withoutSuffix);
    } else {
      return this.localeData().invalidDate();
    }
  }
  function fromNow(withoutSuffix) {
    return this.from(local__createLocal(), withoutSuffix);
  }
  function to(time, withoutSuffix) {
    if (this.isValid() && ((isMoment(time) && time.isValid()) || local__createLocal(time).isValid())) {
      return create__createDuration({
        from: this,
        to: time
      }).locale(this.locale()).humanize(!withoutSuffix);
    } else {
      return this.localeData().invalidDate();
    }
  }
  function toNow(withoutSuffix) {
    return this.to(local__createLocal(), withoutSuffix);
  }
  function locale(key) {
    var newLocaleData;
    if (key === undefined) {
      return this._locale._abbr;
    } else {
      newLocaleData = locale_locales__getLocale(key);
      if (newLocaleData != null) {
        this._locale = newLocaleData;
      }
      return this;
    }
  }
  var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function(key) {
    if (key === undefined) {
      return this.localeData();
    } else {
      return this.locale(key);
    }
  });
  function localeData() {
    return this._locale;
  }
  function startOf(units) {
    units = normalizeUnits(units);
    switch (units) {
      case 'year':
        this.month(0);
      case 'quarter':
      case 'month':
        this.date(1);
      case 'week':
      case 'isoWeek':
      case 'day':
      case 'date':
        this.hours(0);
      case 'hour':
        this.minutes(0);
      case 'minute':
        this.seconds(0);
      case 'second':
        this.milliseconds(0);
    }
    if (units === 'week') {
      this.weekday(0);
    }
    if (units === 'isoWeek') {
      this.isoWeekday(1);
    }
    if (units === 'quarter') {
      this.month(Math.floor(this.month() / 3) * 3);
    }
    return this;
  }
  function endOf(units) {
    units = normalizeUnits(units);
    if (units === undefined || units === 'millisecond') {
      return this;
    }
    if (units === 'date') {
      units = 'day';
    }
    return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
  }
  function to_type__valueOf() {
    return this._d.valueOf() - ((this._offset || 0) * 60000);
  }
  function unix() {
    return Math.floor(this.valueOf() / 1000);
  }
  function toDate() {
    return new Date(this.valueOf());
  }
  function toArray() {
    var m = this;
    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
  }
  function toObject() {
    var m = this;
    return {
      years: m.year(),
      months: m.month(),
      date: m.date(),
      hours: m.hours(),
      minutes: m.minutes(),
      seconds: m.seconds(),
      milliseconds: m.milliseconds()
    };
  }
  function toJSON() {
    return this.isValid() ? this.toISOString() : null;
  }
  function moment_valid__isValid() {
    return valid__isValid(this);
  }
  function parsingFlags() {
    return extend({}, getParsingFlags(this));
  }
  function invalidAt() {
    return getParsingFlags(this).overflow;
  }
  function creationData() {
    return {
      input: this._i,
      format: this._f,
      locale: this._locale,
      isUTC: this._isUTC,
      strict: this._strict
    };
  }
  addFormatToken(0, ['gg', 2], 0, function() {
    return this.weekYear() % 100;
  });
  addFormatToken(0, ['GG', 2], 0, function() {
    return this.isoWeekYear() % 100;
  });
  function addWeekYearFormatToken(token, getter) {
    addFormatToken(0, [token, token.length], 0, getter);
  }
  addWeekYearFormatToken('gggg', 'weekYear');
  addWeekYearFormatToken('ggggg', 'weekYear');
  addWeekYearFormatToken('GGGG', 'isoWeekYear');
  addWeekYearFormatToken('GGGGG', 'isoWeekYear');
  addUnitAlias('weekYear', 'gg');
  addUnitAlias('isoWeekYear', 'GG');
  addUnitPriority('weekYear', 1);
  addUnitPriority('isoWeekYear', 1);
  addRegexToken('G', matchSigned);
  addRegexToken('g', matchSigned);
  addRegexToken('GG', match1to2, match2);
  addRegexToken('gg', match1to2, match2);
  addRegexToken('GGGG', match1to4, match4);
  addRegexToken('gggg', match1to4, match4);
  addRegexToken('GGGGG', match1to6, match6);
  addRegexToken('ggggg', match1to6, match6);
  addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function(input, week, config, token) {
    week[token.substr(0, 2)] = toInt(input);
  });
  addWeekParseToken(['gg', 'GG'], function(input, week, config, token) {
    week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
  });
  function getSetWeekYear(input) {
    return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
  }
  function getSetISOWeekYear(input) {
    return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
  }
  function getISOWeeksInYear() {
    return weeksInYear(this.year(), 1, 4);
  }
  function getWeeksInYear() {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
  }
  function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var weeksTarget;
    if (input == null) {
      return weekOfYear(this, dow, doy).year;
    } else {
      weeksTarget = weeksInYear(input, dow, doy);
      if (week > weeksTarget) {
        week = weeksTarget;
      }
      return setWeekAll.call(this, input, week, weekday, dow, doy);
    }
  }
  function setWeekAll(weekYear, week, weekday, dow, doy) {
    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
    this.year(date.getUTCFullYear());
    this.month(date.getUTCMonth());
    this.date(date.getUTCDate());
    return this;
  }
  addFormatToken('Q', 0, 'Qo', 'quarter');
  addUnitAlias('quarter', 'Q');
  addUnitPriority('quarter', 7);
  addRegexToken('Q', match1);
  addParseToken('Q', function(input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
  });
  function getSetQuarter(input) {
    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
  }
  addFormatToken('D', ['DD', 2], 'Do', 'date');
  addUnitAlias('date', 'D');
  addUnitPriority('date', 9);
  addRegexToken('D', match1to2);
  addRegexToken('DD', match1to2, match2);
  addRegexToken('Do', function(isStrict, locale) {
    return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
  });
  addParseToken(['D', 'DD'], DATE);
  addParseToken('Do', function(input, array) {
    array[DATE] = toInt(input.match(match1to2)[0], 10);
  });
  var getSetDayOfMonth = makeGetSet('Date', true);
  addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');
  addUnitAlias('dayOfYear', 'DDD');
  addUnitPriority('dayOfYear', 4);
  addRegexToken('DDD', match1to3);
  addRegexToken('DDDD', match3);
  addParseToken(['DDD', 'DDDD'], function(input, array, config) {
    config._dayOfYear = toInt(input);
  });
  function getSetDayOfYear(input) {
    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
  }
  addFormatToken('m', ['mm', 2], 0, 'minute');
  addUnitAlias('minute', 'm');
  addUnitPriority('minute', 14);
  addRegexToken('m', match1to2);
  addRegexToken('mm', match1to2, match2);
  addParseToken(['m', 'mm'], MINUTE);
  var getSetMinute = makeGetSet('Minutes', false);
  addFormatToken('s', ['ss', 2], 0, 'second');
  addUnitAlias('second', 's');
  addUnitPriority('second', 15);
  addRegexToken('s', match1to2);
  addRegexToken('ss', match1to2, match2);
  addParseToken(['s', 'ss'], SECOND);
  var getSetSecond = makeGetSet('Seconds', false);
  addFormatToken('S', 0, 0, function() {
    return ~~(this.millisecond() / 100);
  });
  addFormatToken(0, ['SS', 2], 0, function() {
    return ~~(this.millisecond() / 10);
  });
  addFormatToken(0, ['SSS', 3], 0, 'millisecond');
  addFormatToken(0, ['SSSS', 4], 0, function() {
    return this.millisecond() * 10;
  });
  addFormatToken(0, ['SSSSS', 5], 0, function() {
    return this.millisecond() * 100;
  });
  addFormatToken(0, ['SSSSSS', 6], 0, function() {
    return this.millisecond() * 1000;
  });
  addFormatToken(0, ['SSSSSSS', 7], 0, function() {
    return this.millisecond() * 10000;
  });
  addFormatToken(0, ['SSSSSSSS', 8], 0, function() {
    return this.millisecond() * 100000;
  });
  addFormatToken(0, ['SSSSSSSSS', 9], 0, function() {
    return this.millisecond() * 1000000;
  });
  addUnitAlias('millisecond', 'ms');
  addUnitPriority('millisecond', 16);
  addRegexToken('S', match1to3, match1);
  addRegexToken('SS', match1to3, match2);
  addRegexToken('SSS', match1to3, match3);
  var token;
  for (token = 'SSSS'; token.length <= 9; token += 'S') {
    addRegexToken(token, matchUnsigned);
  }
  function parseMs(input, array) {
    array[MILLISECOND] = toInt(('0.' + input) * 1000);
  }
  for (token = 'S'; token.length <= 9; token += 'S') {
    addParseToken(token, parseMs);
  }
  var getSetMillisecond = makeGetSet('Milliseconds', false);
  addFormatToken('z', 0, 0, 'zoneAbbr');
  addFormatToken('zz', 0, 0, 'zoneName');
  function getZoneAbbr() {
    return this._isUTC ? 'UTC' : '';
  }
  function getZoneName() {
    return this._isUTC ? 'Coordinated Universal Time' : '';
  }
  var momentPrototype__proto = Moment.prototype;
  momentPrototype__proto.add = add_subtract__add;
  momentPrototype__proto.calendar = moment_calendar__calendar;
  momentPrototype__proto.clone = clone;
  momentPrototype__proto.diff = diff;
  momentPrototype__proto.endOf = endOf;
  momentPrototype__proto.format = format;
  momentPrototype__proto.from = from;
  momentPrototype__proto.fromNow = fromNow;
  momentPrototype__proto.to = to;
  momentPrototype__proto.toNow = toNow;
  momentPrototype__proto.get = stringGet;
  momentPrototype__proto.invalidAt = invalidAt;
  momentPrototype__proto.isAfter = isAfter;
  momentPrototype__proto.isBefore = isBefore;
  momentPrototype__proto.isBetween = isBetween;
  momentPrototype__proto.isSame = isSame;
  momentPrototype__proto.isSameOrAfter = isSameOrAfter;
  momentPrototype__proto.isSameOrBefore = isSameOrBefore;
  momentPrototype__proto.isValid = moment_valid__isValid;
  momentPrototype__proto.lang = lang;
  momentPrototype__proto.locale = locale;
  momentPrototype__proto.localeData = localeData;
  momentPrototype__proto.max = prototypeMax;
  momentPrototype__proto.min = prototypeMin;
  momentPrototype__proto.parsingFlags = parsingFlags;
  momentPrototype__proto.set = stringSet;
  momentPrototype__proto.startOf = startOf;
  momentPrototype__proto.subtract = add_subtract__subtract;
  momentPrototype__proto.toArray = toArray;
  momentPrototype__proto.toObject = toObject;
  momentPrototype__proto.toDate = toDate;
  momentPrototype__proto.toISOString = moment_format__toISOString;
  momentPrototype__proto.toJSON = toJSON;
  momentPrototype__proto.toString = toString;
  momentPrototype__proto.unix = unix;
  momentPrototype__proto.valueOf = to_type__valueOf;
  momentPrototype__proto.creationData = creationData;
  momentPrototype__proto.year = getSetYear;
  momentPrototype__proto.isLeapYear = getIsLeapYear;
  momentPrototype__proto.weekYear = getSetWeekYear;
  momentPrototype__proto.isoWeekYear = getSetISOWeekYear;
  momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;
  momentPrototype__proto.month = getSetMonth;
  momentPrototype__proto.daysInMonth = getDaysInMonth;
  momentPrototype__proto.week = momentPrototype__proto.weeks = getSetWeek;
  momentPrototype__proto.isoWeek = momentPrototype__proto.isoWeeks = getSetISOWeek;
  momentPrototype__proto.weeksInYear = getWeeksInYear;
  momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;
  momentPrototype__proto.date = getSetDayOfMonth;
  momentPrototype__proto.day = momentPrototype__proto.days = getSetDayOfWeek;
  momentPrototype__proto.weekday = getSetLocaleDayOfWeek;
  momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
  momentPrototype__proto.dayOfYear = getSetDayOfYear;
  momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;
  momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;
  momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;
  momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;
  momentPrototype__proto.utcOffset = getSetOffset;
  momentPrototype__proto.utc = setOffsetToUTC;
  momentPrototype__proto.local = setOffsetToLocal;
  momentPrototype__proto.parseZone = setOffsetToParsedOffset;
  momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
  momentPrototype__proto.isDST = isDaylightSavingTime;
  momentPrototype__proto.isLocal = isLocal;
  momentPrototype__proto.isUtcOffset = isUtcOffset;
  momentPrototype__proto.isUtc = isUtc;
  momentPrototype__proto.isUTC = isUtc;
  momentPrototype__proto.zoneAbbr = getZoneAbbr;
  momentPrototype__proto.zoneName = getZoneName;
  momentPrototype__proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
  momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
  momentPrototype__proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
  momentPrototype__proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
  momentPrototype__proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);
  var momentPrototype = momentPrototype__proto;
  function moment__createUnix(input) {
    return local__createLocal(input * 1000);
  }
  function moment__createInZone() {
    return local__createLocal.apply(null, arguments).parseZone();
  }
  function preParsePostFormat(string) {
    return string;
  }
  var prototype__proto = Locale.prototype;
  prototype__proto.calendar = locale_calendar__calendar;
  prototype__proto.longDateFormat = longDateFormat;
  prototype__proto.invalidDate = invalidDate;
  prototype__proto.ordinal = ordinal;
  prototype__proto.preparse = preParsePostFormat;
  prototype__proto.postformat = preParsePostFormat;
  prototype__proto.relativeTime = relative__relativeTime;
  prototype__proto.pastFuture = pastFuture;
  prototype__proto.set = locale_set__set;
  prototype__proto.months = localeMonths;
  prototype__proto.monthsShort = localeMonthsShort;
  prototype__proto.monthsParse = localeMonthsParse;
  prototype__proto.monthsRegex = monthsRegex;
  prototype__proto.monthsShortRegex = monthsShortRegex;
  prototype__proto.week = localeWeek;
  prototype__proto.firstDayOfYear = localeFirstDayOfYear;
  prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;
  prototype__proto.weekdays = localeWeekdays;
  prototype__proto.weekdaysMin = localeWeekdaysMin;
  prototype__proto.weekdaysShort = localeWeekdaysShort;
  prototype__proto.weekdaysParse = localeWeekdaysParse;
  prototype__proto.weekdaysRegex = weekdaysRegex;
  prototype__proto.weekdaysShortRegex = weekdaysShortRegex;
  prototype__proto.weekdaysMinRegex = weekdaysMinRegex;
  prototype__proto.isPM = localeIsPM;
  prototype__proto.meridiem = localeMeridiem;
  function lists__get(format, index, field, setter) {
    var locale = locale_locales__getLocale();
    var utc = create_utc__createUTC().set(setter, index);
    return locale[field](utc, format);
  }
  function listMonthsImpl(format, index, field) {
    if (typeof format === 'number') {
      index = format;
      format = undefined;
    }
    format = format || '';
    if (index != null) {
      return lists__get(format, index, field, 'month');
    }
    var i;
    var out = [];
    for (i = 0; i < 12; i++) {
      out[i] = lists__get(format, i, field, 'month');
    }
    return out;
  }
  function listWeekdaysImpl(localeSorted, format, index, field) {
    if (typeof localeSorted === 'boolean') {
      if (typeof format === 'number') {
        index = format;
        format = undefined;
      }
      format = format || '';
    } else {
      format = localeSorted;
      index = format;
      localeSorted = false;
      if (typeof format === 'number') {
        index = format;
        format = undefined;
      }
      format = format || '';
    }
    var locale = locale_locales__getLocale(),
        shift = localeSorted ? locale._week.dow : 0;
    if (index != null) {
      return lists__get(format, (index + shift) % 7, field, 'day');
    }
    var i;
    var out = [];
    for (i = 0; i < 7; i++) {
      out[i] = lists__get(format, (i + shift) % 7, field, 'day');
    }
    return out;
  }
  function lists__listMonths(format, index) {
    return listMonthsImpl(format, index, 'months');
  }
  function lists__listMonthsShort(format, index) {
    return listMonthsImpl(format, index, 'monthsShort');
  }
  function lists__listWeekdays(localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
  }
  function lists__listWeekdaysShort(localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
  }
  function lists__listWeekdaysMin(localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
  }
  locale_locales__getSetGlobalLocale('en', {
    ordinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal: function(number) {
      var b = number % 10,
          output = (toInt(number % 100 / 10) === 1) ? 'th' : (b === 1) ? 'st' : (b === 2) ? 'nd' : (b === 3) ? 'rd' : 'th';
      return number + output;
    }
  });
  utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
  utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);
  var mathAbs = Math.abs;
  function duration_abs__abs() {
    var data = this._data;
    this._milliseconds = mathAbs(this._milliseconds);
    this._days = mathAbs(this._days);
    this._months = mathAbs(this._months);
    data.milliseconds = mathAbs(data.milliseconds);
    data.seconds = mathAbs(data.seconds);
    data.minutes = mathAbs(data.minutes);
    data.hours = mathAbs(data.hours);
    data.months = mathAbs(data.months);
    data.years = mathAbs(data.years);
    return this;
  }
  function duration_add_subtract__addSubtract(duration, input, value, direction) {
    var other = create__createDuration(input, value);
    duration._milliseconds += direction * other._milliseconds;
    duration._days += direction * other._days;
    duration._months += direction * other._months;
    return duration._bubble();
  }
  function duration_add_subtract__add(input, value) {
    return duration_add_subtract__addSubtract(this, input, value, 1);
  }
  function duration_add_subtract__subtract(input, value) {
    return duration_add_subtract__addSubtract(this, input, value, -1);
  }
  function absCeil(number) {
    if (number < 0) {
      return Math.floor(number);
    } else {
      return Math.ceil(number);
    }
  }
  function bubble() {
    var milliseconds = this._milliseconds;
    var days = this._days;
    var months = this._months;
    var data = this._data;
    var seconds,
        minutes,
        hours,
        years,
        monthsFromDays;
    if (!((milliseconds >= 0 && days >= 0 && months >= 0) || (milliseconds <= 0 && days <= 0 && months <= 0))) {
      milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
      days = 0;
      months = 0;
    }
    data.milliseconds = milliseconds % 1000;
    seconds = absFloor(milliseconds / 1000);
    data.seconds = seconds % 60;
    minutes = absFloor(seconds / 60);
    data.minutes = minutes % 60;
    hours = absFloor(minutes / 60);
    data.hours = hours % 24;
    days += absFloor(hours / 24);
    monthsFromDays = absFloor(daysToMonths(days));
    months += monthsFromDays;
    days -= absCeil(monthsToDays(monthsFromDays));
    years = absFloor(months / 12);
    months %= 12;
    data.days = days;
    data.months = months;
    data.years = years;
    return this;
  }
  function daysToMonths(days) {
    return days * 4800 / 146097;
  }
  function monthsToDays(months) {
    return months * 146097 / 4800;
  }
  function as(units) {
    var days;
    var months;
    var milliseconds = this._milliseconds;
    units = normalizeUnits(units);
    if (units === 'month' || units === 'year') {
      days = this._days + milliseconds / 864e5;
      months = this._months + daysToMonths(days);
      return units === 'month' ? months : months / 12;
    } else {
      days = this._days + Math.round(monthsToDays(this._months));
      switch (units) {
        case 'week':
          return days / 7 + milliseconds / 6048e5;
        case 'day':
          return days + milliseconds / 864e5;
        case 'hour':
          return days * 24 + milliseconds / 36e5;
        case 'minute':
          return days * 1440 + milliseconds / 6e4;
        case 'second':
          return days * 86400 + milliseconds / 1000;
        case 'millisecond':
          return Math.floor(days * 864e5) + milliseconds;
        default:
          throw new Error('Unknown unit ' + units);
      }
    }
  }
  function duration_as__valueOf() {
    return (this._milliseconds + this._days * 864e5 + (this._months % 12) * 2592e6 + toInt(this._months / 12) * 31536e6);
  }
  function makeAs(alias) {
    return function() {
      return this.as(alias);
    };
  }
  var asMilliseconds = makeAs('ms');
  var asSeconds = makeAs('s');
  var asMinutes = makeAs('m');
  var asHours = makeAs('h');
  var asDays = makeAs('d');
  var asWeeks = makeAs('w');
  var asMonths = makeAs('M');
  var asYears = makeAs('y');
  function duration_get__get(units) {
    units = normalizeUnits(units);
    return this[units + 's']();
  }
  function makeGetter(name) {
    return function() {
      return this._data[name];
    };
  }
  var milliseconds = makeGetter('milliseconds');
  var seconds = makeGetter('seconds');
  var minutes = makeGetter('minutes');
  var hours = makeGetter('hours');
  var days = makeGetter('days');
  var months = makeGetter('months');
  var years = makeGetter('years');
  function weeks() {
    return absFloor(this.days() / 7);
  }
  var round = Math.round;
  var thresholds = {
    s: 45,
    m: 45,
    h: 22,
    d: 26,
    M: 11
  };
  function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
  }
  function duration_humanize__relativeTime(posNegDuration, withoutSuffix, locale) {
    var duration = create__createDuration(posNegDuration).abs();
    var seconds = round(duration.as('s'));
    var minutes = round(duration.as('m'));
    var hours = round(duration.as('h'));
    var days = round(duration.as('d'));
    var months = round(duration.as('M'));
    var years = round(duration.as('y'));
    var a = seconds < thresholds.s && ['s', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days] || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years];
    a[2] = withoutSuffix;
    a[3] = +posNegDuration > 0;
    a[4] = locale;
    return substituteTimeAgo.apply(null, a);
  }
  function duration_humanize__getSetRelativeTimeRounding(roundingFunction) {
    if (roundingFunction === undefined) {
      return round;
    }
    if (typeof(roundingFunction) === 'function') {
      round = roundingFunction;
      return true;
    }
    return false;
  }
  function duration_humanize__getSetRelativeTimeThreshold(threshold, limit) {
    if (thresholds[threshold] === undefined) {
      return false;
    }
    if (limit === undefined) {
      return thresholds[threshold];
    }
    thresholds[threshold] = limit;
    return true;
  }
  function humanize(withSuffix) {
    var locale = this.localeData();
    var output = duration_humanize__relativeTime(this, !withSuffix, locale);
    if (withSuffix) {
      output = locale.pastFuture(+this, output);
    }
    return locale.postformat(output);
  }
  var iso_string__abs = Math.abs;
  function iso_string__toISOString() {
    var seconds = iso_string__abs(this._milliseconds) / 1000;
    var days = iso_string__abs(this._days);
    var months = iso_string__abs(this._months);
    var minutes,
        hours,
        years;
    minutes = absFloor(seconds / 60);
    hours = absFloor(minutes / 60);
    seconds %= 60;
    minutes %= 60;
    years = absFloor(months / 12);
    months %= 12;
    var Y = years;
    var M = months;
    var D = days;
    var h = hours;
    var m = minutes;
    var s = seconds;
    var total = this.asSeconds();
    if (!total) {
      return 'P0D';
    }
    return (total < 0 ? '-' : '') + 'P' + (Y ? Y + 'Y' : '') + (M ? M + 'M' : '') + (D ? D + 'D' : '') + ((h || m || s) ? 'T' : '') + (h ? h + 'H' : '') + (m ? m + 'M' : '') + (s ? s + 'S' : '');
  }
  var duration_prototype__proto = Duration.prototype;
  duration_prototype__proto.abs = duration_abs__abs;
  duration_prototype__proto.add = duration_add_subtract__add;
  duration_prototype__proto.subtract = duration_add_subtract__subtract;
  duration_prototype__proto.as = as;
  duration_prototype__proto.asMilliseconds = asMilliseconds;
  duration_prototype__proto.asSeconds = asSeconds;
  duration_prototype__proto.asMinutes = asMinutes;
  duration_prototype__proto.asHours = asHours;
  duration_prototype__proto.asDays = asDays;
  duration_prototype__proto.asWeeks = asWeeks;
  duration_prototype__proto.asMonths = asMonths;
  duration_prototype__proto.asYears = asYears;
  duration_prototype__proto.valueOf = duration_as__valueOf;
  duration_prototype__proto._bubble = bubble;
  duration_prototype__proto.get = duration_get__get;
  duration_prototype__proto.milliseconds = milliseconds;
  duration_prototype__proto.seconds = seconds;
  duration_prototype__proto.minutes = minutes;
  duration_prototype__proto.hours = hours;
  duration_prototype__proto.days = days;
  duration_prototype__proto.weeks = weeks;
  duration_prototype__proto.months = months;
  duration_prototype__proto.years = years;
  duration_prototype__proto.humanize = humanize;
  duration_prototype__proto.toISOString = iso_string__toISOString;
  duration_prototype__proto.toString = iso_string__toISOString;
  duration_prototype__proto.toJSON = iso_string__toISOString;
  duration_prototype__proto.locale = locale;
  duration_prototype__proto.localeData = localeData;
  duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
  duration_prototype__proto.lang = lang;
  addFormatToken('X', 0, 0, 'unix');
  addFormatToken('x', 0, 0, 'valueOf');
  addRegexToken('x', matchSigned);
  addRegexToken('X', matchTimestamp);
  addParseToken('X', function(input, array, config) {
    config._d = new Date(parseFloat(input, 10) * 1000);
  });
  addParseToken('x', function(input, array, config) {
    config._d = new Date(toInt(input));
  });
  utils_hooks__hooks.version = '2.14.1';
  setHookCallback(local__createLocal);
  utils_hooks__hooks.fn = momentPrototype;
  utils_hooks__hooks.min = min;
  utils_hooks__hooks.max = max;
  utils_hooks__hooks.now = now;
  utils_hooks__hooks.utc = create_utc__createUTC;
  utils_hooks__hooks.unix = moment__createUnix;
  utils_hooks__hooks.months = lists__listMonths;
  utils_hooks__hooks.isDate = isDate;
  utils_hooks__hooks.locale = locale_locales__getSetGlobalLocale;
  utils_hooks__hooks.invalid = valid__createInvalid;
  utils_hooks__hooks.duration = create__createDuration;
  utils_hooks__hooks.isMoment = isMoment;
  utils_hooks__hooks.weekdays = lists__listWeekdays;
  utils_hooks__hooks.parseZone = moment__createInZone;
  utils_hooks__hooks.localeData = locale_locales__getLocale;
  utils_hooks__hooks.isDuration = isDuration;
  utils_hooks__hooks.monthsShort = lists__listMonthsShort;
  utils_hooks__hooks.weekdaysMin = lists__listWeekdaysMin;
  utils_hooks__hooks.defineLocale = defineLocale;
  utils_hooks__hooks.updateLocale = updateLocale;
  utils_hooks__hooks.locales = locale_locales__listLocales;
  utils_hooks__hooks.weekdaysShort = lists__listWeekdaysShort;
  utils_hooks__hooks.normalizeUnits = normalizeUnits;
  utils_hooks__hooks.relativeTimeRounding = duration_humanize__getSetRelativeTimeRounding;
  utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
  utils_hooks__hooks.calendarFormat = getCalendarFormat;
  utils_hooks__hooks.prototype = momentPrototype;
  var _moment = utils_hooks__hooks;
  return _moment;
}));

})();
(function() {
var define = $__System.amdDefine;
define("50", ["bf"], function(main) {
  return main;
});

})();
$__System.registerDynamic("47", ["48", "50"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _lodash = $__require('48');
  var _lodash2 = _interopRequireDefault(_lodash);
  var _moment = $__require('50');
  var _moment2 = _interopRequireDefault(_moment);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var ParserHelper = {};
  ParserHelper = {
    isContainer: function isContainer(value) {
      return _lodash2.default.isArray(value) || _lodash2.default.isObject(value) && Object.prototype.toString.call(value) == "[object Object]";
    },
    isObject: function isObject(value) {
      return Object.prototype.toString.call(value) == "[object Object]";
    },
    isDate: function isDate(value) {
      return Object.prototype.toString.call(value) == "[object Date]";
    },
    isNumberString: function isNumberString(value) {
      if (_lodash2.default.isString(value) && !isNaN(value)) {
        return true;
      }
      return false;
    },
    isDateString: function isDateString(date) {
      if (!date) {
        return false;
      }
      if (!isNaN(Number(date))) {
        return false;
      }
      if (!_lodash2.default.isNumber(date) && new Date(date) !== "Invalid Date" && !isNaN(new Date(date)) && ((0, _moment2.default)(date).format().indexOf(date) !== -1 || date.match(/^\d+-\d+-\d+T\d+:\d+:\d+/))) {
        return true;
      }
      return false;
    },
    isFormController: function isFormController(item, name) {
      return (_lodash2.default.endsWith(name.toLowerCase(), "form") || name.toLowerCase() == "form") && _lodash2.default.has(item, "$submitted");
    },
    getFormController: function getFormController($scope) {
      var _this = this;
      var form;
      _lodash2.default.each($scope, function(value, name) {
        if (_this.isFormController(value, name)) {
          form = $scope[name];
        }
      }, this);
      if (form) {
        return form;
      }
      if ($scope.$parent) {
        return this.getFormController($scope.$parent);
      }
      return null;
    },
    setFormInChildScope: function setFormInChildScope($scope, $parent) {
      var _this2 = this;
      if ($scope && $parent) {
        var setForm = false;
        _lodash2.default.each($parent, function(value, name) {
          if (_this2.isFormController(value, name)) {
            $scope[name] = value;
            if (name !== "formCtrl") {
              name = "formCtrl";
              $parent[name] = value;
            }
            $scope[name] = value;
            setForm = true;
          }
        }, this);
        if (setForm) {
          return true;
        }
        if ($parent.$parent) {
          this.setFormInChildScope($scope, $parent.$parent);
        }
      }
      return false;
    },
    convertToNumber: function convertToNumber(value) {
      if (ParserHelper.isNumberString(value)) {
        if (value.indexOf('.') !== -1) {
          return parseFloat(value);
        } else {
          return parseInt(value, 10);
        }
      }
      return value;
    },
    isDateTimeString: function isDateTimeString(value) {
      if (!value) {
        return false;
      }
      if (!isNaN(Number(value))) {
        return false;
      }
      return value.match(/^\d+-\d+-\d+T\d+:\d+:\d+/) ? true : false;
    },
    getValueWithNestedKey: function getValueWithNestedKey(obj, key) {
      if (key.indexOf(".")) {
        var keys = key.split(".");
        var lastHash = keys.pop();
        while (key = keys.shift()) {
          if (_lodash2.default.isString(key) && key.indexOf("[") === 0) {
            key = key.replace("[", "").replace("]", "");
            key = parseInt(key, 10);
          }
          if (!_lodash2.default.has(obj, key)) {
            return null;
          }
          obj = obj[key];
        }
        key = lastHash;
      }
      if (_lodash2.default.has(obj, key)) {
        return obj[key];
      }
      return null;
    },
    setObjectWithNestedKey: function setObjectWithNestedKey(obj, key, value) {
      if (key.indexOf(".")) {
        var keys = key.split(".");
        var lastHash = keys.pop();
        for (var i = 0; i < keys.length; i++) {
          var keyPointer = keys[i];
          if (_lodash2.default.isString(keyPointer) && keyPointer.indexOf("[") === 0) {
            keyPointer = keyPointer.replace("[", "").replace("]", "");
            keyPointer = parseInt(keyPointer, 10);
          }
          if (!_lodash2.default.has(obj, keyPointer) || !_lodash2.default.isObject(obj[keyPointer])) {
            var newObj = {};
            var nextKey = i + 1;
            if (keys.length > nextKey && _lodash2.default.isString(keys[nextKey]) && keys[nextKey].indexOf("[") === 0) {
              newObj = [];
            }
            obj[keyPointer] = newObj;
          }
          obj = obj[keyPointer];
        }
        key = lastHash;
      }
      obj[key] = value;
      return true;
    },
    convertToDateStrings: function convertToDateStrings(obj) {
      if (!ParserHelper.isContainer(obj)) {
        return obj;
      }
      _lodash2.default.each(obj, function(value, key) {
        if (ParserHelper.isContainer(value)) {
          ParserHelper.convertToDateStrings(value);
        }
        if (_lodash2.default.isDate(value)) {
          obj[key] = (0, _moment2.default)(value).format('YYYY-MM-DD');
        }
      }, this);
    },
    convertToDateString: function convertToDateString(datevalue) {
      var date = datevalue;
      if (date instanceof _moment2.default) {
        return date.format("YYYY-MM-DD");
      }
      return (0, _moment2.default)(date).format("YYYY-MM-DD");
    },
    convertToDB: function convertToDB(structure) {
      if (!ParserHelper.isContainer(structure)) {
        return structure;
      }
      _lodash2.default.each(structure, function(value, key) {
        switch (true) {
          case ParserHelper.isContainer(value):
            ParserHelper.convertToDB(value);
            break;
          case ParserHelper.isDate(value):
            structure[key] = (0, _moment2.default)(value).format();
            break;
          case !_lodash2.default.isObject(value):
            break;
          default:
            console.log("Couldn't convert " + Object.prototype.toString.call(value), value);
            throw new Error("Couldn't convert " + Object.prototype.toString.call(value) + " in your api send!");
        }
      }, this);
      return structure;
    },
    convertToApp: function convertToApp(structure) {
      if (!ParserHelper.isContainer(structure)) {
        return structure;
      }
      _lodash2.default.each(structure, function(value, key) {
        if (ParserHelper.isContainer(value)) {
          ParserHelper.convertToApp(value);
        } else {
          switch (true) {
            case ParserHelper.isNumberString(value):
              structure[key] = ParserHelper.convertToNumber(value);
              break;
            case ParserHelper.isDateString(value):
              structure[key] = new Date(value);
              break;
          }
        }
      }, this);
      return structure;
    }
  };
  exports.default = ParserHelper;
  return module.exports;
});

$__System.registerDynamic("c0", ["4d", "4e", "56", "47", "48"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _classCallCheck2 = $__require('4d');
  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
  var _createClass2 = $__require('4e');
  var _createClass3 = _interopRequireDefault(_createClass2);
  var _dec,
      _class;
  var _ngDecorators = $__require('56');
  var _parserHelper = $__require('47');
  var _parserHelper2 = _interopRequireDefault(_parserHelper);
  var _lodash = $__require('48');
  var _lodash2 = _interopRequireDefault(_lodash);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var LIVE_EDITS = false;
  var SocketIO = (_dec = (0, _ngDecorators.Factory)({factoryName: 'socketIO'}), _dec(_class = function() {
    function SocketIO($rootScope) {
      (0, _classCallCheck3.default)(this, SocketIO);
      if (LIVE_EDITS) {
        var url = window.location.hostname + ":3000";
        this.socket = io.connect(url);
        this.$rootScope = $rootScope;
      }
    }
    (0, _createClass3.default)(SocketIO, [{
      key: 'on',
      value: function on(eventName, callback) {
        if (!LIVE_EDITS) {
          return false;
        }
        var that = this;
        var socket = this.socket;
        socket.on(eventName, function() {
          var args = [];
          _lodash2.default.each(arguments, function(value) {
            args.push(value);
          });
          _parserHelper2.default.convertToApp(args);
          that.$rootScope.$apply(function() {
            callback.apply(socket, args);
          });
        });
      }
    }, {
      key: 'emit',
      value: function emit(eventName, data, callback) {
        if (!LIVE_EDITS) {
          return false;
        }
        var that = this;
        var socket = this.socket;
        socket.emit(eventName, data, function() {
          var args = arguments;
          that.$rootScope.$apply(function() {
            if (callback) {
              callback.apply(socket, args);
            }
          });
        });
      }
    }], [{
      key: 'factory',
      value: function factory($rootScope) {
        SocketIO.instance = new SocketIO($rootScope);
        return SocketIO.instance;
      }
    }]);
    return SocketIO;
  }()) || _class);
  exports.default = SocketIO;
  return module.exports;
});

$__System.registerDynamic("c1", ["4d", "4e", "54", "48", "c2"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _classCallCheck2 = $__require('4d');
  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
  var _createClass2 = $__require('4e');
  var _createClass3 = _interopRequireDefault(_createClass2);
  var _dataModel = $__require('54');
  var _dataModel2 = _interopRequireDefault(_dataModel);
  var _lodash = $__require('48');
  var _lodash2 = _interopRequireDefault(_lodash);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var DataCollection = $__require('c2');
  var StateModel = function() {
    function StateModel(url, service, data, socketIO) {
      (0, _classCallCheck3.default)(this, StateModel);
      this.url = url;
      this.service = service;
      this.socketIO = socketIO;
      this.parseData(data);
    }
    (0, _createClass3.default)(StateModel, [{
      key: 'parseData',
      value: function parseData(data) {
        if (!data) {
          return null;
        }
        var inlineCount = null;
        if (_lodash2.default.has(data, 'inlineCount')) {
          inlineCount = data.inlineCount;
          data = data.results || [];
        }
        if (_lodash2.default.isArray(data)) {
          this.data = new DataCollection();
          this.data.init(this.service, data, this);
          if (inlineCount) {
            this.data.setServerTotal(inlineCount);
          }
        } else {
          this.data = new _dataModel2.default(this.service, data, this);
        }
      }
    }, {
      key: 'hasBaseLevel',
      value: function hasBaseLevel() {
        return this.baselevel ? true : false;
      }
    }, {
      key: 'getBaseLevel',
      value: function getBaseLevel() {
        return this.baselevel;
      }
    }, {
      key: 'setBaseLevel',
      value: function setBaseLevel(baseLevel) {
        this.baselevel = baseLevel;
      }
    }, {
      key: 'getUpdateCallback',
      value: function getUpdateCallback(listener) {
        var that = this;
        return function() {
          that.service.call(that.url).then(function(data) {
            that.data.updateData(listener, data);
          });
        };
      }
    }, {
      key: 'getSocket',
      value: function getSocket() {
        return this.socketIO;
      }
    }, {
      key: 'getRest',
      value: function getRest() {
        return this.data;
      }
    }]);
    return StateModel;
  }();
  exports.default = StateModel;
  return module.exports;
});

$__System.registerDynamic("c3", ["4d", "4e", "56", "48", "c1"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _classCallCheck2 = $__require('4d');
  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
  var _createClass2 = $__require('4e');
  var _createClass3 = _interopRequireDefault(_createClass2);
  var _dec,
      _class;
  var _ngDecorators = $__require('56');
  var _lodash = $__require('48');
  var _lodash2 = _interopRequireDefault(_lodash);
  var _stateModel = $__require('c1');
  var _stateModel2 = _interopRequireDefault(_stateModel);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var StateStore = (_dec = (0, _ngDecorators.Factory)({factoryName: 'stateStore'}), _dec(_class = function() {
    function StateStore($rootScope, socketIO) {
      (0, _classCallCheck3.default)(this, StateStore);
      this.$rootScope = $rootScope;
      this.socketIO = socketIO;
      this.requestStore = [];
      this.queue = [];
      this.transitionState = null;
      this.currentState = null;
      var that = this;
      $rootScope.$on('$stateChangeStart', function(event, toState) {
        that.transitionState = toState.name;
        that.currentState = null;
      });
      $rootScope.$on('$stateChangeSuccess', function(event, toState, toParams, fromState, fromParams) {
        that.currentState = toState.name;
        console.log(that.requestStore);
      });
    }
    (0, _createClass3.default)(StateStore, [{
      key: 'registerRequest',
      value: function registerRequest(service, url, data) {
        var request = {
          url: url,
          service: service
        };
        var returnData;
        returnData = new _stateModel2.default(url, service, data, this.socketIO);
        request.data = returnData;
        this.addToStore(request);
        return returnData.getRest();
      }
    }, {
      key: 'addToStore',
      value: function addToStore(request) {
        this.requestStore = _lodash2.default.filter(this.requestStore, function(item) {
          return item.url !== request.url;
        });
        this.requestStore.push(request);
      }
    }], [{
      key: 'factory',
      value: function factory($rootScope, socketIO) {
        StateStore.instance = new StateStore($rootScope, socketIO);
        return StateStore.instance;
      }
    }]);
    return StateStore;
  }()) || _class);
  exports.default = StateStore;
  return module.exports;
});

$__System.registerDynamic("6c", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
  if (typeof __g == 'number')
    __g = global;
  return module.exports;
});

$__System.registerDynamic("c4", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = function(it) {
    if (typeof it != 'function')
      throw TypeError(it + ' is not a function!');
    return it;
  };
  return module.exports;
});

$__System.registerDynamic("80", ["c4"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var aFunction = $__require('c4');
  module.exports = function(fn, that, length) {
    aFunction(fn);
    if (that === undefined)
      return fn;
    switch (length) {
      case 1:
        return function(a) {
          return fn.call(that, a);
        };
      case 2:
        return function(a, b) {
          return fn.call(that, a, b);
        };
      case 3:
        return function(a, b, c) {
          return fn.call(that, a, b, c);
        };
    }
    return function() {
      return fn.apply(that, arguments);
    };
  };
  return module.exports;
});

$__System.registerDynamic("6f", ["6c", "65", "80"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var global = $__require('6c'),
      core = $__require('65'),
      ctx = $__require('80'),
      PROTOTYPE = 'prototype';
  var $export = function(type, name, source) {
    var IS_FORCED = type & $export.F,
        IS_GLOBAL = type & $export.G,
        IS_STATIC = type & $export.S,
        IS_PROTO = type & $export.P,
        IS_BIND = type & $export.B,
        IS_WRAP = type & $export.W,
        exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
        target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE],
        key,
        own,
        out;
    if (IS_GLOBAL)
      source = name;
    for (key in source) {
      own = !IS_FORCED && target && key in target;
      if (own && key in exports)
        continue;
      out = own ? target[key] : source[key];
      exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key] : IS_BIND && own ? ctx(out, global) : IS_WRAP && target[key] == out ? (function(C) {
        var F = function(param) {
          return this instanceof C ? new C(param) : C(param);
        };
        F[PROTOTYPE] = C[PROTOTYPE];
        return F;
      })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
      if (IS_PROTO)
        (exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
    }
  };
  $export.F = 1;
  $export.G = 2;
  $export.S = 4;
  $export.P = 8;
  $export.B = 16;
  $export.W = 32;
  module.exports = $export;
  return module.exports;
});

$__System.registerDynamic("a1", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = function(it) {
    if (it == undefined)
      throw TypeError("Can't call method on  " + it);
    return it;
  };
  return module.exports;
});

$__System.registerDynamic("62", ["a1"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var defined = $__require('a1');
  module.exports = function(it) {
    return Object(defined(it));
  };
  return module.exports;
});

$__System.registerDynamic("a8", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var toString = {}.toString;
  module.exports = function(it) {
    return toString.call(it).slice(8, -1);
  };
  return module.exports;
});

$__System.registerDynamic("a0", ["a8"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var cof = $__require('a8');
  module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it) {
    return cof(it) == 'String' ? it.split('') : Object(it);
  };
  return module.exports;
});

$__System.registerDynamic("71", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = function(exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };
  return module.exports;
});

$__System.registerDynamic("c5", ["67", "62", "a0", "71"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('67'),
      toObject = $__require('62'),
      IObject = $__require('a0');
  module.exports = $__require('71')(function() {
    var a = Object.assign,
        A = {},
        B = {},
        S = Symbol(),
        K = 'abcdefghijklmnopqrst';
    A[S] = 7;
    K.split('').forEach(function(k) {
      B[k] = k;
    });
    return a({}, A)[S] != 7 || Object.keys(a({}, B)).join('') != K;
  }) ? function assign(target, source) {
    var T = toObject(target),
        $$ = arguments,
        $$len = $$.length,
        index = 1,
        getKeys = $.getKeys,
        getSymbols = $.getSymbols,
        isEnum = $.isEnum;
    while ($$len > index) {
      var S = IObject($$[index++]),
          keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S),
          length = keys.length,
          j = 0,
          key;
      while (length > j)
        if (isEnum.call(S, key = keys[j++]))
          T[key] = S[key];
    }
    return T;
  } : Object.assign;
  return module.exports;
});

$__System.registerDynamic("c6", ["6f", "c5"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('6f');
  $export($export.S + $export.F, 'Object', {assign: $__require('c5')});
  return module.exports;
});

$__System.registerDynamic("c7", ["c6", "65"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('c6');
  module.exports = $__require('65').Object.assign;
  return module.exports;
});

$__System.registerDynamic("c8", ["c7"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = {
    "default": $__require('c7'),
    __esModule: true
  };
  return module.exports;
});

$__System.registerDynamic("c9", ["c8"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var _Object$assign = $__require('c8')["default"];
  exports["default"] = _Object$assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  exports.__esModule = true;
  return module.exports;
});

$__System.registerDynamic("ca", [], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, "angular", null);
  (function() {
    "format global";
    "exports angular";
    (function(window) {
      'use strict';
      function minErr(module, ErrorConstructor) {
        ErrorConstructor = ErrorConstructor || Error;
        return function() {
          var SKIP_INDEXES = 2;
          var templateArgs = arguments,
              code = templateArgs[0],
              message = '[' + (module ? module + ':' : '') + code + '] ',
              template = templateArgs[1],
              paramPrefix,
              i;
          message += template.replace(/\{\d+\}/g, function(match) {
            var index = +match.slice(1, -1),
                shiftedIndex = index + SKIP_INDEXES;
            if (shiftedIndex < templateArgs.length) {
              return toDebugString(templateArgs[shiftedIndex]);
            }
            return match;
          });
          message += '\nhttp://errors.angularjs.org/1.5.7/' + (module ? module + '/' : '') + code;
          for (i = SKIP_INDEXES, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {
            message += paramPrefix + 'p' + (i - SKIP_INDEXES) + '=' + encodeURIComponent(toDebugString(templateArgs[i]));
          }
          return new ErrorConstructor(message);
        };
      }
      var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
      var VALIDITY_STATE_PROPERTY = 'validity';
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var lowercase = function(string) {
        return isString(string) ? string.toLowerCase() : string;
      };
      var uppercase = function(string) {
        return isString(string) ? string.toUpperCase() : string;
      };
      var manualLowercase = function(s) {
        return isString(s) ? s.replace(/[A-Z]/g, function(ch) {
          return String.fromCharCode(ch.charCodeAt(0) | 32);
        }) : s;
      };
      var manualUppercase = function(s) {
        return isString(s) ? s.replace(/[a-z]/g, function(ch) {
          return String.fromCharCode(ch.charCodeAt(0) & ~32);
        }) : s;
      };
      if ('i' !== 'I'.toLowerCase()) {
        lowercase = manualLowercase;
        uppercase = manualUppercase;
      }
      var msie,
          jqLite,
          jQuery,
          slice = [].slice,
          splice = [].splice,
          push = [].push,
          toString = Object.prototype.toString,
          getPrototypeOf = Object.getPrototypeOf,
          ngMinErr = minErr('ng'),
          angular = window.angular || (window.angular = {}),
          angularModule,
          uid = 0;
      msie = window.document.documentMode;
      function isArrayLike(obj) {
        if (obj == null || isWindow(obj))
          return false;
        if (isArray(obj) || isString(obj) || (jqLite && obj instanceof jqLite))
          return true;
        var length = "length" in Object(obj) && obj.length;
        return isNumber(length) && (length >= 0 && ((length - 1) in obj || obj instanceof Array) || typeof obj.item == 'function');
      }
      function forEach(obj, iterator, context) {
        var key,
            length;
        if (obj) {
          if (isFunction(obj)) {
            for (key in obj) {
              if (key != 'prototype' && key != 'length' && key != 'name' && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else if (isArray(obj) || isArrayLike(obj)) {
            var isPrimitive = typeof obj !== 'object';
            for (key = 0, length = obj.length; key < length; key++) {
              if (isPrimitive || key in obj) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else if (obj.forEach && obj.forEach !== forEach) {
            obj.forEach(iterator, context, obj);
          } else if (isBlankObject(obj)) {
            for (key in obj) {
              iterator.call(context, obj[key], key, obj);
            }
          } else if (typeof obj.hasOwnProperty === 'function') {
            for (key in obj) {
              if (obj.hasOwnProperty(key)) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else {
            for (key in obj) {
              if (hasOwnProperty.call(obj, key)) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          }
        }
        return obj;
      }
      function forEachSorted(obj, iterator, context) {
        var keys = Object.keys(obj).sort();
        for (var i = 0; i < keys.length; i++) {
          iterator.call(context, obj[keys[i]], keys[i]);
        }
        return keys;
      }
      function reverseParams(iteratorFn) {
        return function(value, key) {
          iteratorFn(key, value);
        };
      }
      function nextUid() {
        return ++uid;
      }
      function setHashKey(obj, h) {
        if (h) {
          obj.$$hashKey = h;
        } else {
          delete obj.$$hashKey;
        }
      }
      function baseExtend(dst, objs, deep) {
        var h = dst.$$hashKey;
        for (var i = 0,
            ii = objs.length; i < ii; ++i) {
          var obj = objs[i];
          if (!isObject(obj) && !isFunction(obj))
            continue;
          var keys = Object.keys(obj);
          for (var j = 0,
              jj = keys.length; j < jj; j++) {
            var key = keys[j];
            var src = obj[key];
            if (deep && isObject(src)) {
              if (isDate(src)) {
                dst[key] = new Date(src.valueOf());
              } else if (isRegExp(src)) {
                dst[key] = new RegExp(src);
              } else if (src.nodeName) {
                dst[key] = src.cloneNode(true);
              } else if (isElement(src)) {
                dst[key] = src.clone();
              } else {
                if (!isObject(dst[key]))
                  dst[key] = isArray(src) ? [] : {};
                baseExtend(dst[key], [src], true);
              }
            } else {
              dst[key] = src;
            }
          }
        }
        setHashKey(dst, h);
        return dst;
      }
      function extend(dst) {
        return baseExtend(dst, slice.call(arguments, 1), false);
      }
      function merge(dst) {
        return baseExtend(dst, slice.call(arguments, 1), true);
      }
      function toInt(str) {
        return parseInt(str, 10);
      }
      function inherit(parent, extra) {
        return extend(Object.create(parent), extra);
      }
      function noop() {}
      noop.$inject = [];
      function identity($) {
        return $;
      }
      identity.$inject = [];
      function valueFn(value) {
        return function valueRef() {
          return value;
        };
      }
      function hasCustomToString(obj) {
        return isFunction(obj.toString) && obj.toString !== toString;
      }
      function isUndefined(value) {
        return typeof value === 'undefined';
      }
      function isDefined(value) {
        return typeof value !== 'undefined';
      }
      function isObject(value) {
        return value !== null && typeof value === 'object';
      }
      function isBlankObject(value) {
        return value !== null && typeof value === 'object' && !getPrototypeOf(value);
      }
      function isString(value) {
        return typeof value === 'string';
      }
      function isNumber(value) {
        return typeof value === 'number';
      }
      function isDate(value) {
        return toString.call(value) === '[object Date]';
      }
      var isArray = Array.isArray;
      function isFunction(value) {
        return typeof value === 'function';
      }
      function isRegExp(value) {
        return toString.call(value) === '[object RegExp]';
      }
      function isWindow(obj) {
        return obj && obj.window === obj;
      }
      function isScope(obj) {
        return obj && obj.$evalAsync && obj.$watch;
      }
      function isFile(obj) {
        return toString.call(obj) === '[object File]';
      }
      function isFormData(obj) {
        return toString.call(obj) === '[object FormData]';
      }
      function isBlob(obj) {
        return toString.call(obj) === '[object Blob]';
      }
      function isBoolean(value) {
        return typeof value === 'boolean';
      }
      function isPromiseLike(obj) {
        return obj && isFunction(obj.then);
      }
      var TYPED_ARRAY_REGEXP = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array\]$/;
      function isTypedArray(value) {
        return value && isNumber(value.length) && TYPED_ARRAY_REGEXP.test(toString.call(value));
      }
      function isArrayBuffer(obj) {
        return toString.call(obj) === '[object ArrayBuffer]';
      }
      var trim = function(value) {
        return isString(value) ? value.trim() : value;
      };
      var escapeForRegexp = function(s) {
        return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
      };
      function isElement(node) {
        return !!(node && (node.nodeName || (node.prop && node.attr && node.find)));
      }
      function makeMap(str) {
        var obj = {},
            items = str.split(','),
            i;
        for (i = 0; i < items.length; i++) {
          obj[items[i]] = true;
        }
        return obj;
      }
      function nodeName_(element) {
        return lowercase(element.nodeName || (element[0] && element[0].nodeName));
      }
      function includes(array, obj) {
        return Array.prototype.indexOf.call(array, obj) != -1;
      }
      function arrayRemove(array, value) {
        var index = array.indexOf(value);
        if (index >= 0) {
          array.splice(index, 1);
        }
        return index;
      }
      function copy(source, destination) {
        var stackSource = [];
        var stackDest = [];
        if (destination) {
          if (isTypedArray(destination) || isArrayBuffer(destination)) {
            throw ngMinErr('cpta', "Can't copy! TypedArray destination cannot be mutated.");
          }
          if (source === destination) {
            throw ngMinErr('cpi', "Can't copy! Source and destination are identical.");
          }
          if (isArray(destination)) {
            destination.length = 0;
          } else {
            forEach(destination, function(value, key) {
              if (key !== '$$hashKey') {
                delete destination[key];
              }
            });
          }
          stackSource.push(source);
          stackDest.push(destination);
          return copyRecurse(source, destination);
        }
        return copyElement(source);
        function copyRecurse(source, destination) {
          var h = destination.$$hashKey;
          var key;
          if (isArray(source)) {
            for (var i = 0,
                ii = source.length; i < ii; i++) {
              destination.push(copyElement(source[i]));
            }
          } else if (isBlankObject(source)) {
            for (key in source) {
              destination[key] = copyElement(source[key]);
            }
          } else if (source && typeof source.hasOwnProperty === 'function') {
            for (key in source) {
              if (source.hasOwnProperty(key)) {
                destination[key] = copyElement(source[key]);
              }
            }
          } else {
            for (key in source) {
              if (hasOwnProperty.call(source, key)) {
                destination[key] = copyElement(source[key]);
              }
            }
          }
          setHashKey(destination, h);
          return destination;
        }
        function copyElement(source) {
          if (!isObject(source)) {
            return source;
          }
          var index = stackSource.indexOf(source);
          if (index !== -1) {
            return stackDest[index];
          }
          if (isWindow(source) || isScope(source)) {
            throw ngMinErr('cpws', "Can't copy! Making copies of Window or Scope instances is not supported.");
          }
          var needsRecurse = false;
          var destination = copyType(source);
          if (destination === undefined) {
            destination = isArray(source) ? [] : Object.create(getPrototypeOf(source));
            needsRecurse = true;
          }
          stackSource.push(source);
          stackDest.push(destination);
          return needsRecurse ? copyRecurse(source, destination) : destination;
        }
        function copyType(source) {
          switch (toString.call(source)) {
            case '[object Int8Array]':
            case '[object Int16Array]':
            case '[object Int32Array]':
            case '[object Float32Array]':
            case '[object Float64Array]':
            case '[object Uint8Array]':
            case '[object Uint8ClampedArray]':
            case '[object Uint16Array]':
            case '[object Uint32Array]':
              return new source.constructor(copyElement(source.buffer));
            case '[object ArrayBuffer]':
              if (!source.slice) {
                var copied = new ArrayBuffer(source.byteLength);
                new Uint8Array(copied).set(new Uint8Array(source));
                return copied;
              }
              return source.slice(0);
            case '[object Boolean]':
            case '[object Number]':
            case '[object String]':
            case '[object Date]':
              return new source.constructor(source.valueOf());
            case '[object RegExp]':
              var re = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
              re.lastIndex = source.lastIndex;
              return re;
            case '[object Blob]':
              return new source.constructor([source], {type: source.type});
          }
          if (isFunction(source.cloneNode)) {
            return source.cloneNode(true);
          }
        }
      }
      function equals(o1, o2) {
        if (o1 === o2)
          return true;
        if (o1 === null || o2 === null)
          return false;
        if (o1 !== o1 && o2 !== o2)
          return true;
        var t1 = typeof o1,
            t2 = typeof o2,
            length,
            key,
            keySet;
        if (t1 == t2 && t1 == 'object') {
          if (isArray(o1)) {
            if (!isArray(o2))
              return false;
            if ((length = o1.length) == o2.length) {
              for (key = 0; key < length; key++) {
                if (!equals(o1[key], o2[key]))
                  return false;
              }
              return true;
            }
          } else if (isDate(o1)) {
            if (!isDate(o2))
              return false;
            return equals(o1.getTime(), o2.getTime());
          } else if (isRegExp(o1)) {
            if (!isRegExp(o2))
              return false;
            return o1.toString() == o2.toString();
          } else {
            if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2) || isDate(o2) || isRegExp(o2))
              return false;
            keySet = createMap();
            for (key in o1) {
              if (key.charAt(0) === '$' || isFunction(o1[key]))
                continue;
              if (!equals(o1[key], o2[key]))
                return false;
              keySet[key] = true;
            }
            for (key in o2) {
              if (!(key in keySet) && key.charAt(0) !== '$' && isDefined(o2[key]) && !isFunction(o2[key]))
                return false;
            }
            return true;
          }
        }
        return false;
      }
      var csp = function() {
        if (!isDefined(csp.rules)) {
          var ngCspElement = (window.document.querySelector('[ng-csp]') || window.document.querySelector('[data-ng-csp]'));
          if (ngCspElement) {
            var ngCspAttribute = ngCspElement.getAttribute('ng-csp') || ngCspElement.getAttribute('data-ng-csp');
            csp.rules = {
              noUnsafeEval: !ngCspAttribute || (ngCspAttribute.indexOf('no-unsafe-eval') !== -1),
              noInlineStyle: !ngCspAttribute || (ngCspAttribute.indexOf('no-inline-style') !== -1)
            };
          } else {
            csp.rules = {
              noUnsafeEval: noUnsafeEval(),
              noInlineStyle: false
            };
          }
        }
        return csp.rules;
        function noUnsafeEval() {
          try {
            new Function('');
            return false;
          } catch (e) {
            return true;
          }
        }
      };
      var jq = function() {
        if (isDefined(jq.name_))
          return jq.name_;
        var el;
        var i,
            ii = ngAttrPrefixes.length,
            prefix,
            name;
        for (i = 0; i < ii; ++i) {
          prefix = ngAttrPrefixes[i];
          if (el = window.document.querySelector('[' + prefix.replace(':', '\\:') + 'jq]')) {
            name = el.getAttribute(prefix + 'jq');
            break;
          }
        }
        return (jq.name_ = name);
      };
      function concat(array1, array2, index) {
        return array1.concat(slice.call(array2, index));
      }
      function sliceArgs(args, startIndex) {
        return slice.call(args, startIndex || 0);
      }
      function bind(self, fn) {
        var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
        if (isFunction(fn) && !(fn instanceof RegExp)) {
          return curryArgs.length ? function() {
            return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs);
          } : function() {
            return arguments.length ? fn.apply(self, arguments) : fn.call(self);
          };
        } else {
          return fn;
        }
      }
      function toJsonReplacer(key, value) {
        var val = value;
        if (typeof key === 'string' && key.charAt(0) === '$' && key.charAt(1) === '$') {
          val = undefined;
        } else if (isWindow(value)) {
          val = '$WINDOW';
        } else if (value && window.document === value) {
          val = '$DOCUMENT';
        } else if (isScope(value)) {
          val = '$SCOPE';
        }
        return val;
      }
      function toJson(obj, pretty) {
        if (isUndefined(obj))
          return undefined;
        if (!isNumber(pretty)) {
          pretty = pretty ? 2 : null;
        }
        return JSON.stringify(obj, toJsonReplacer, pretty);
      }
      function fromJson(json) {
        return isString(json) ? JSON.parse(json) : json;
      }
      var ALL_COLONS = /:/g;
      function timezoneToOffset(timezone, fallback) {
        timezone = timezone.replace(ALL_COLONS, '');
        var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
        return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
      }
      function addDateMinutes(date, minutes) {
        date = new Date(date.getTime());
        date.setMinutes(date.getMinutes() + minutes);
        return date;
      }
      function convertTimezoneToLocal(date, timezone, reverse) {
        reverse = reverse ? -1 : 1;
        var dateTimezoneOffset = date.getTimezoneOffset();
        var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
        return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));
      }
      function startingTag(element) {
        element = jqLite(element).clone();
        try {
          element.empty();
        } catch (e) {}
        var elemHtml = jqLite('<div>').append(element).html();
        try {
          return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function(match, nodeName) {
            return '<' + lowercase(nodeName);
          });
        } catch (e) {
          return lowercase(elemHtml);
        }
      }
      function tryDecodeURIComponent(value) {
        try {
          return decodeURIComponent(value);
        } catch (e) {}
      }
      function parseKeyValue(keyValue) {
        var obj = {};
        forEach((keyValue || "").split('&'), function(keyValue) {
          var splitPoint,
              key,
              val;
          if (keyValue) {
            key = keyValue = keyValue.replace(/\+/g, '%20');
            splitPoint = keyValue.indexOf('=');
            if (splitPoint !== -1) {
              key = keyValue.substring(0, splitPoint);
              val = keyValue.substring(splitPoint + 1);
            }
            key = tryDecodeURIComponent(key);
            if (isDefined(key)) {
              val = isDefined(val) ? tryDecodeURIComponent(val) : true;
              if (!hasOwnProperty.call(obj, key)) {
                obj[key] = val;
              } else if (isArray(obj[key])) {
                obj[key].push(val);
              } else {
                obj[key] = [obj[key], val];
              }
            }
          }
        });
        return obj;
      }
      function toKeyValue(obj) {
        var parts = [];
        forEach(obj, function(value, key) {
          if (isArray(value)) {
            forEach(value, function(arrayValue) {
              parts.push(encodeUriQuery(key, true) + (arrayValue === true ? '' : '=' + encodeUriQuery(arrayValue, true)));
            });
          } else {
            parts.push(encodeUriQuery(key, true) + (value === true ? '' : '=' + encodeUriQuery(value, true)));
          }
        });
        return parts.length ? parts.join('&') : '';
      }
      function encodeUriSegment(val) {
        return encodeUriQuery(val, true).replace(/%26/gi, '&').replace(/%3D/gi, '=').replace(/%2B/gi, '+');
      }
      function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%3B/gi, ';').replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));
      }
      var ngAttrPrefixes = ['ng-', 'data-ng-', 'ng:', 'x-ng-'];
      function getNgAttribute(element, ngAttr) {
        var attr,
            i,
            ii = ngAttrPrefixes.length;
        for (i = 0; i < ii; ++i) {
          attr = ngAttrPrefixes[i] + ngAttr;
          if (isString(attr = element.getAttribute(attr))) {
            return attr;
          }
        }
        return null;
      }
      function angularInit(element, bootstrap) {
        var appElement,
            module,
            config = {};
        forEach(ngAttrPrefixes, function(prefix) {
          var name = prefix + 'app';
          if (!appElement && element.hasAttribute && element.hasAttribute(name)) {
            appElement = element;
            module = element.getAttribute(name);
          }
        });
        forEach(ngAttrPrefixes, function(prefix) {
          var name = prefix + 'app';
          var candidate;
          if (!appElement && (candidate = element.querySelector('[' + name.replace(':', '\\:') + ']'))) {
            appElement = candidate;
            module = candidate.getAttribute(name);
          }
        });
        if (appElement) {
          config.strictDi = getNgAttribute(appElement, "strict-di") !== null;
          bootstrap(appElement, module ? [module] : [], config);
        }
      }
      function bootstrap(element, modules, config) {
        if (!isObject(config))
          config = {};
        var defaultConfig = {strictDi: false};
        config = extend(defaultConfig, config);
        var doBootstrap = function() {
          element = jqLite(element);
          if (element.injector()) {
            var tag = (element[0] === window.document) ? 'document' : startingTag(element);
            throw ngMinErr('btstrpd', "App already bootstrapped with this element '{0}'", tag.replace(/</, '&lt;').replace(/>/, '&gt;'));
          }
          modules = modules || [];
          modules.unshift(['$provide', function($provide) {
            $provide.value('$rootElement', element);
          }]);
          if (config.debugInfoEnabled) {
            modules.push(['$compileProvider', function($compileProvider) {
              $compileProvider.debugInfoEnabled(true);
            }]);
          }
          modules.unshift('ng');
          var injector = createInjector(modules, config.strictDi);
          injector.invoke(['$rootScope', '$rootElement', '$compile', '$injector', function bootstrapApply(scope, element, compile, injector) {
            scope.$apply(function() {
              element.data('$injector', injector);
              compile(element)(scope);
            });
          }]);
          return injector;
        };
        var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;
        var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
        if (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {
          config.debugInfoEnabled = true;
          window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, '');
        }
        if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
          return doBootstrap();
        }
        window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');
        angular.resumeBootstrap = function(extraModules) {
          forEach(extraModules, function(module) {
            modules.push(module);
          });
          return doBootstrap();
        };
        if (isFunction(angular.resumeDeferredBootstrap)) {
          angular.resumeDeferredBootstrap();
        }
      }
      function reloadWithDebugInfo() {
        window.name = 'NG_ENABLE_DEBUG_INFO!' + window.name;
        window.location.reload();
      }
      function getTestability(rootElement) {
        var injector = angular.element(rootElement).injector();
        if (!injector) {
          throw ngMinErr('test', 'no injector found for element argument to getTestability');
        }
        return injector.get('$$testability');
      }
      var SNAKE_CASE_REGEXP = /[A-Z]/g;
      function snake_case(name, separator) {
        separator = separator || '_';
        return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
          return (pos ? separator : '') + letter.toLowerCase();
        });
      }
      var bindJQueryFired = false;
      function bindJQuery() {
        var originalCleanData;
        if (bindJQueryFired) {
          return;
        }
        var jqName = jq();
        jQuery = isUndefined(jqName) ? window.jQuery : !jqName ? undefined : window[jqName];
        if (jQuery && jQuery.fn.on) {
          jqLite = jQuery;
          extend(jQuery.fn, {
            scope: JQLitePrototype.scope,
            isolateScope: JQLitePrototype.isolateScope,
            controller: JQLitePrototype.controller,
            injector: JQLitePrototype.injector,
            inheritedData: JQLitePrototype.inheritedData
          });
          originalCleanData = jQuery.cleanData;
          jQuery.cleanData = function(elems) {
            var events;
            for (var i = 0,
                elem; (elem = elems[i]) != null; i++) {
              events = jQuery._data(elem, "events");
              if (events && events.$destroy) {
                jQuery(elem).triggerHandler('$destroy');
              }
            }
            originalCleanData(elems);
          };
        } else {
          jqLite = JQLite;
        }
        angular.element = jqLite;
        bindJQueryFired = true;
      }
      function assertArg(arg, name, reason) {
        if (!arg) {
          throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
        }
        return arg;
      }
      function assertArgFn(arg, name, acceptArrayAnnotation) {
        if (acceptArrayAnnotation && isArray(arg)) {
          arg = arg[arg.length - 1];
        }
        assertArg(isFunction(arg), name, 'not a function, got ' + (arg && typeof arg === 'object' ? arg.constructor.name || 'Object' : typeof arg));
        return arg;
      }
      function assertNotHasOwnProperty(name, context) {
        if (name === 'hasOwnProperty') {
          throw ngMinErr('badname', "hasOwnProperty is not a valid {0} name", context);
        }
      }
      function getter(obj, path, bindFnToScope) {
        if (!path)
          return obj;
        var keys = path.split('.');
        var key;
        var lastInstance = obj;
        var len = keys.length;
        for (var i = 0; i < len; i++) {
          key = keys[i];
          if (obj) {
            obj = (lastInstance = obj)[key];
          }
        }
        if (!bindFnToScope && isFunction(obj)) {
          return bind(lastInstance, obj);
        }
        return obj;
      }
      function getBlockNodes(nodes) {
        var node = nodes[0];
        var endNode = nodes[nodes.length - 1];
        var blockNodes;
        for (var i = 1; node !== endNode && (node = node.nextSibling); i++) {
          if (blockNodes || nodes[i] !== node) {
            if (!blockNodes) {
              blockNodes = jqLite(slice.call(nodes, 0, i));
            }
            blockNodes.push(node);
          }
        }
        return blockNodes || nodes;
      }
      function createMap() {
        return Object.create(null);
      }
      var NODE_TYPE_ELEMENT = 1;
      var NODE_TYPE_ATTRIBUTE = 2;
      var NODE_TYPE_TEXT = 3;
      var NODE_TYPE_COMMENT = 8;
      var NODE_TYPE_DOCUMENT = 9;
      var NODE_TYPE_DOCUMENT_FRAGMENT = 11;
      function setupModuleLoader(window) {
        var $injectorMinErr = minErr('$injector');
        var ngMinErr = minErr('ng');
        function ensure(obj, name, factory) {
          return obj[name] || (obj[name] = factory());
        }
        var angular = ensure(window, 'angular', Object);
        angular.$$minErr = angular.$$minErr || minErr;
        return ensure(angular, 'module', function() {
          var modules = {};
          return function module(name, requires, configFn) {
            var assertNotHasOwnProperty = function(name, context) {
              if (name === 'hasOwnProperty') {
                throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);
              }
            };
            assertNotHasOwnProperty(name, 'module');
            if (requires && modules.hasOwnProperty(name)) {
              modules[name] = null;
            }
            return ensure(modules, name, function() {
              if (!requires) {
                throw $injectorMinErr('nomod', "Module '{0}' is not available! You either misspelled " + "the module name or forgot to load it. If registering a module ensure that you " + "specify the dependencies as the second argument.", name);
              }
              var invokeQueue = [];
              var configBlocks = [];
              var runBlocks = [];
              var config = invokeLater('$injector', 'invoke', 'push', configBlocks);
              var moduleInstance = {
                _invokeQueue: invokeQueue,
                _configBlocks: configBlocks,
                _runBlocks: runBlocks,
                requires: requires,
                name: name,
                provider: invokeLaterAndSetModuleName('$provide', 'provider'),
                factory: invokeLaterAndSetModuleName('$provide', 'factory'),
                service: invokeLaterAndSetModuleName('$provide', 'service'),
                value: invokeLater('$provide', 'value'),
                constant: invokeLater('$provide', 'constant', 'unshift'),
                decorator: invokeLaterAndSetModuleName('$provide', 'decorator'),
                animation: invokeLaterAndSetModuleName('$animateProvider', 'register'),
                filter: invokeLaterAndSetModuleName('$filterProvider', 'register'),
                controller: invokeLaterAndSetModuleName('$controllerProvider', 'register'),
                directive: invokeLaterAndSetModuleName('$compileProvider', 'directive'),
                component: invokeLaterAndSetModuleName('$compileProvider', 'component'),
                config: config,
                run: function(block) {
                  runBlocks.push(block);
                  return this;
                }
              };
              if (configFn) {
                config(configFn);
              }
              return moduleInstance;
              function invokeLater(provider, method, insertMethod, queue) {
                if (!queue)
                  queue = invokeQueue;
                return function() {
                  queue[insertMethod || 'push']([provider, method, arguments]);
                  return moduleInstance;
                };
              }
              function invokeLaterAndSetModuleName(provider, method) {
                return function(recipeName, factoryFunction) {
                  if (factoryFunction && isFunction(factoryFunction))
                    factoryFunction.$$moduleName = name;
                  invokeQueue.push([provider, method, arguments]);
                  return moduleInstance;
                };
              }
            });
          };
        });
      }
      function shallowCopy(src, dst) {
        if (isArray(src)) {
          dst = dst || [];
          for (var i = 0,
              ii = src.length; i < ii; i++) {
            dst[i] = src[i];
          }
        } else if (isObject(src)) {
          dst = dst || {};
          for (var key in src) {
            if (!(key.charAt(0) === '$' && key.charAt(1) === '$')) {
              dst[key] = src[key];
            }
          }
        }
        return dst || src;
      }
      function serializeObject(obj) {
        var seen = [];
        return JSON.stringify(obj, function(key, val) {
          val = toJsonReplacer(key, val);
          if (isObject(val)) {
            if (seen.indexOf(val) >= 0)
              return '...';
            seen.push(val);
          }
          return val;
        });
      }
      function toDebugString(obj) {
        if (typeof obj === 'function') {
          return obj.toString().replace(/ \{[\s\S]*$/, '');
        } else if (isUndefined(obj)) {
          return 'undefined';
        } else if (typeof obj !== 'string') {
          return serializeObject(obj);
        }
        return obj;
      }
      var version = {
        full: '1.5.7',
        major: 1,
        minor: 5,
        dot: 7,
        codeName: 'hexagonal-circumvolution'
      };
      function publishExternalAPI(angular) {
        extend(angular, {
          'bootstrap': bootstrap,
          'copy': copy,
          'extend': extend,
          'merge': merge,
          'equals': equals,
          'element': jqLite,
          'forEach': forEach,
          'injector': createInjector,
          'noop': noop,
          'bind': bind,
          'toJson': toJson,
          'fromJson': fromJson,
          'identity': identity,
          'isUndefined': isUndefined,
          'isDefined': isDefined,
          'isString': isString,
          'isFunction': isFunction,
          'isObject': isObject,
          'isNumber': isNumber,
          'isElement': isElement,
          'isArray': isArray,
          'version': version,
          'isDate': isDate,
          'lowercase': lowercase,
          'uppercase': uppercase,
          'callbacks': {counter: 0},
          'getTestability': getTestability,
          '$$minErr': minErr,
          '$$csp': csp,
          'reloadWithDebugInfo': reloadWithDebugInfo
        });
        angularModule = setupModuleLoader(window);
        angularModule('ng', ['ngLocale'], ['$provide', function ngModule($provide) {
          $provide.provider({$$sanitizeUri: $$SanitizeUriProvider});
          $provide.provider('$compile', $CompileProvider).directive({
            a: htmlAnchorDirective,
            input: inputDirective,
            textarea: inputDirective,
            form: formDirective,
            script: scriptDirective,
            select: selectDirective,
            style: styleDirective,
            option: optionDirective,
            ngBind: ngBindDirective,
            ngBindHtml: ngBindHtmlDirective,
            ngBindTemplate: ngBindTemplateDirective,
            ngClass: ngClassDirective,
            ngClassEven: ngClassEvenDirective,
            ngClassOdd: ngClassOddDirective,
            ngCloak: ngCloakDirective,
            ngController: ngControllerDirective,
            ngForm: ngFormDirective,
            ngHide: ngHideDirective,
            ngIf: ngIfDirective,
            ngInclude: ngIncludeDirective,
            ngInit: ngInitDirective,
            ngNonBindable: ngNonBindableDirective,
            ngPluralize: ngPluralizeDirective,
            ngRepeat: ngRepeatDirective,
            ngShow: ngShowDirective,
            ngStyle: ngStyleDirective,
            ngSwitch: ngSwitchDirective,
            ngSwitchWhen: ngSwitchWhenDirective,
            ngSwitchDefault: ngSwitchDefaultDirective,
            ngOptions: ngOptionsDirective,
            ngTransclude: ngTranscludeDirective,
            ngModel: ngModelDirective,
            ngList: ngListDirective,
            ngChange: ngChangeDirective,
            pattern: patternDirective,
            ngPattern: patternDirective,
            required: requiredDirective,
            ngRequired: requiredDirective,
            minlength: minlengthDirective,
            ngMinlength: minlengthDirective,
            maxlength: maxlengthDirective,
            ngMaxlength: maxlengthDirective,
            ngValue: ngValueDirective,
            ngModelOptions: ngModelOptionsDirective
          }).directive({ngInclude: ngIncludeFillContentDirective}).directive(ngAttributeAliasDirectives).directive(ngEventDirectives);
          $provide.provider({
            $anchorScroll: $AnchorScrollProvider,
            $animate: $AnimateProvider,
            $animateCss: $CoreAnimateCssProvider,
            $$animateJs: $$CoreAnimateJsProvider,
            $$animateQueue: $$CoreAnimateQueueProvider,
            $$AnimateRunner: $$AnimateRunnerFactoryProvider,
            $$animateAsyncRun: $$AnimateAsyncRunFactoryProvider,
            $browser: $BrowserProvider,
            $cacheFactory: $CacheFactoryProvider,
            $controller: $ControllerProvider,
            $document: $DocumentProvider,
            $exceptionHandler: $ExceptionHandlerProvider,
            $filter: $FilterProvider,
            $$forceReflow: $$ForceReflowProvider,
            $interpolate: $InterpolateProvider,
            $interval: $IntervalProvider,
            $http: $HttpProvider,
            $httpParamSerializer: $HttpParamSerializerProvider,
            $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
            $httpBackend: $HttpBackendProvider,
            $xhrFactory: $xhrFactoryProvider,
            $location: $LocationProvider,
            $log: $LogProvider,
            $parse: $ParseProvider,
            $rootScope: $RootScopeProvider,
            $q: $QProvider,
            $$q: $$QProvider,
            $sce: $SceProvider,
            $sceDelegate: $SceDelegateProvider,
            $sniffer: $SnifferProvider,
            $templateCache: $TemplateCacheProvider,
            $templateRequest: $TemplateRequestProvider,
            $$testability: $$TestabilityProvider,
            $timeout: $TimeoutProvider,
            $window: $WindowProvider,
            $$rAF: $$RAFProvider,
            $$jqLite: $$jqLiteProvider,
            $$HashMap: $$HashMapProvider,
            $$cookieReader: $$CookieReaderProvider
          });
        }]);
      }
      JQLite.expando = 'ng339';
      var jqCache = JQLite.cache = {},
          jqId = 1,
          addEventListenerFn = function(element, type, fn) {
            element.addEventListener(type, fn, false);
          },
          removeEventListenerFn = function(element, type, fn) {
            element.removeEventListener(type, fn, false);
          };
      JQLite._data = function(node) {
        return this.cache[node[this.expando]] || {};
      };
      function jqNextId() {
        return ++jqId;
      }
      var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
      var MOZ_HACK_REGEXP = /^moz([A-Z])/;
      var MOUSE_EVENT_MAP = {
        mouseleave: "mouseout",
        mouseenter: "mouseover"
      };
      var jqLiteMinErr = minErr('jqLite');
      function camelCase(name) {
        return name.replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
          return offset ? letter.toUpperCase() : letter;
        }).replace(MOZ_HACK_REGEXP, 'Moz$1');
      }
      var SINGLE_TAG_REGEXP = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/;
      var HTML_REGEXP = /<|&#?\w+;/;
      var TAG_NAME_REGEXP = /<([\w:-]+)/;
      var XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi;
      var wrapMap = {
        'option': [1, '<select multiple="multiple">', '</select>'],
        'thead': [1, '<table>', '</table>'],
        'col': [2, '<table><colgroup>', '</colgroup></table>'],
        'tr': [2, '<table><tbody>', '</tbody></table>'],
        'td': [3, '<table><tbody><tr>', '</tr></tbody></table>'],
        '_default': [0, "", ""]
      };
      wrapMap.optgroup = wrapMap.option;
      wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
      wrapMap.th = wrapMap.td;
      function jqLiteIsTextNode(html) {
        return !HTML_REGEXP.test(html);
      }
      function jqLiteAcceptsData(node) {
        var nodeType = node.nodeType;
        return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
      }
      function jqLiteHasData(node) {
        for (var key in jqCache[node.ng339]) {
          return true;
        }
        return false;
      }
      function jqLiteCleanData(nodes) {
        for (var i = 0,
            ii = nodes.length; i < ii; i++) {
          jqLiteRemoveData(nodes[i]);
        }
      }
      function jqLiteBuildFragment(html, context) {
        var tmp,
            tag,
            wrap,
            fragment = context.createDocumentFragment(),
            nodes = [],
            i;
        if (jqLiteIsTextNode(html)) {
          nodes.push(context.createTextNode(html));
        } else {
          tmp = tmp || fragment.appendChild(context.createElement("div"));
          tag = (TAG_NAME_REGEXP.exec(html) || ["", ""])[1].toLowerCase();
          wrap = wrapMap[tag] || wrapMap._default;
          tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2];
          i = wrap[0];
          while (i--) {
            tmp = tmp.lastChild;
          }
          nodes = concat(nodes, tmp.childNodes);
          tmp = fragment.firstChild;
          tmp.textContent = "";
        }
        fragment.textContent = "";
        fragment.innerHTML = "";
        forEach(nodes, function(node) {
          fragment.appendChild(node);
        });
        return fragment;
      }
      function jqLiteParseHTML(html, context) {
        context = context || window.document;
        var parsed;
        if ((parsed = SINGLE_TAG_REGEXP.exec(html))) {
          return [context.createElement(parsed[1])];
        }
        if ((parsed = jqLiteBuildFragment(html, context))) {
          return parsed.childNodes;
        }
        return [];
      }
      function jqLiteWrapNode(node, wrapper) {
        var parent = node.parentNode;
        if (parent) {
          parent.replaceChild(wrapper, node);
        }
        wrapper.appendChild(node);
      }
      var jqLiteContains = window.Node.prototype.contains || function(arg) {
        return !!(this.compareDocumentPosition(arg) & 16);
      };
      function JQLite(element) {
        if (element instanceof JQLite) {
          return element;
        }
        var argIsString;
        if (isString(element)) {
          element = trim(element);
          argIsString = true;
        }
        if (!(this instanceof JQLite)) {
          if (argIsString && element.charAt(0) != '<') {
            throw jqLiteMinErr('nosel', 'Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element');
          }
          return new JQLite(element);
        }
        if (argIsString) {
          jqLiteAddNodes(this, jqLiteParseHTML(element));
        } else {
          jqLiteAddNodes(this, element);
        }
      }
      function jqLiteClone(element) {
        return element.cloneNode(true);
      }
      function jqLiteDealoc(element, onlyDescendants) {
        if (!onlyDescendants)
          jqLiteRemoveData(element);
        if (element.querySelectorAll) {
          var descendants = element.querySelectorAll('*');
          for (var i = 0,
              l = descendants.length; i < l; i++) {
            jqLiteRemoveData(descendants[i]);
          }
        }
      }
      function jqLiteOff(element, type, fn, unsupported) {
        if (isDefined(unsupported))
          throw jqLiteMinErr('offargs', 'jqLite#off() does not support the `selector` argument');
        var expandoStore = jqLiteExpandoStore(element);
        var events = expandoStore && expandoStore.events;
        var handle = expandoStore && expandoStore.handle;
        if (!handle)
          return;
        if (!type) {
          for (type in events) {
            if (type !== '$destroy') {
              removeEventListenerFn(element, type, handle);
            }
            delete events[type];
          }
        } else {
          var removeHandler = function(type) {
            var listenerFns = events[type];
            if (isDefined(fn)) {
              arrayRemove(listenerFns || [], fn);
            }
            if (!(isDefined(fn) && listenerFns && listenerFns.length > 0)) {
              removeEventListenerFn(element, type, handle);
              delete events[type];
            }
          };
          forEach(type.split(' '), function(type) {
            removeHandler(type);
            if (MOUSE_EVENT_MAP[type]) {
              removeHandler(MOUSE_EVENT_MAP[type]);
            }
          });
        }
      }
      function jqLiteRemoveData(element, name) {
        var expandoId = element.ng339;
        var expandoStore = expandoId && jqCache[expandoId];
        if (expandoStore) {
          if (name) {
            delete expandoStore.data[name];
            return;
          }
          if (expandoStore.handle) {
            if (expandoStore.events.$destroy) {
              expandoStore.handle({}, '$destroy');
            }
            jqLiteOff(element);
          }
          delete jqCache[expandoId];
          element.ng339 = undefined;
        }
      }
      function jqLiteExpandoStore(element, createIfNecessary) {
        var expandoId = element.ng339,
            expandoStore = expandoId && jqCache[expandoId];
        if (createIfNecessary && !expandoStore) {
          element.ng339 = expandoId = jqNextId();
          expandoStore = jqCache[expandoId] = {
            events: {},
            data: {},
            handle: undefined
          };
        }
        return expandoStore;
      }
      function jqLiteData(element, key, value) {
        if (jqLiteAcceptsData(element)) {
          var isSimpleSetter = isDefined(value);
          var isSimpleGetter = !isSimpleSetter && key && !isObject(key);
          var massGetter = !key;
          var expandoStore = jqLiteExpandoStore(element, !isSimpleGetter);
          var data = expandoStore && expandoStore.data;
          if (isSimpleSetter) {
            data[key] = value;
          } else {
            if (massGetter) {
              return data;
            } else {
              if (isSimpleGetter) {
                return data && data[key];
              } else {
                extend(data, key);
              }
            }
          }
        }
      }
      function jqLiteHasClass(element, selector) {
        if (!element.getAttribute)
          return false;
        return ((" " + (element.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1);
      }
      function jqLiteRemoveClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
          forEach(cssClasses.split(' '), function(cssClass) {
            element.setAttribute('class', trim((" " + (element.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").replace(" " + trim(cssClass) + " ", " ")));
          });
        }
      }
      function jqLiteAddClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
          var existingClasses = (' ' + (element.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, " ");
          forEach(cssClasses.split(' '), function(cssClass) {
            cssClass = trim(cssClass);
            if (existingClasses.indexOf(' ' + cssClass + ' ') === -1) {
              existingClasses += cssClass + ' ';
            }
          });
          element.setAttribute('class', trim(existingClasses));
        }
      }
      function jqLiteAddNodes(root, elements) {
        if (elements) {
          if (elements.nodeType) {
            root[root.length++] = elements;
          } else {
            var length = elements.length;
            if (typeof length === 'number' && elements.window !== elements) {
              if (length) {
                for (var i = 0; i < length; i++) {
                  root[root.length++] = elements[i];
                }
              }
            } else {
              root[root.length++] = elements;
            }
          }
        }
      }
      function jqLiteController(element, name) {
        return jqLiteInheritedData(element, '$' + (name || 'ngController') + 'Controller');
      }
      function jqLiteInheritedData(element, name, value) {
        if (element.nodeType == NODE_TYPE_DOCUMENT) {
          element = element.documentElement;
        }
        var names = isArray(name) ? name : [name];
        while (element) {
          for (var i = 0,
              ii = names.length; i < ii; i++) {
            if (isDefined(value = jqLite.data(element, names[i])))
              return value;
          }
          element = element.parentNode || (element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host);
        }
      }
      function jqLiteEmpty(element) {
        jqLiteDealoc(element, true);
        while (element.firstChild) {
          element.removeChild(element.firstChild);
        }
      }
      function jqLiteRemove(element, keepData) {
        if (!keepData)
          jqLiteDealoc(element);
        var parent = element.parentNode;
        if (parent)
          parent.removeChild(element);
      }
      function jqLiteDocumentLoaded(action, win) {
        win = win || window;
        if (win.document.readyState === 'complete') {
          win.setTimeout(action);
        } else {
          jqLite(win).on('load', action);
        }
      }
      var JQLitePrototype = JQLite.prototype = {
        ready: function(fn) {
          var fired = false;
          function trigger() {
            if (fired)
              return;
            fired = true;
            fn();
          }
          if (window.document.readyState === 'complete') {
            window.setTimeout(trigger);
          } else {
            this.on('DOMContentLoaded', trigger);
            JQLite(window).on('load', trigger);
          }
        },
        toString: function() {
          var value = [];
          forEach(this, function(e) {
            value.push('' + e);
          });
          return '[' + value.join(', ') + ']';
        },
        eq: function(index) {
          return (index >= 0) ? jqLite(this[index]) : jqLite(this[this.length + index]);
        },
        length: 0,
        push: push,
        sort: [].sort,
        splice: [].splice
      };
      var BOOLEAN_ATTR = {};
      forEach('multiple,selected,checked,disabled,readOnly,required,open'.split(','), function(value) {
        BOOLEAN_ATTR[lowercase(value)] = value;
      });
      var BOOLEAN_ELEMENTS = {};
      forEach('input,select,option,textarea,button,form,details'.split(','), function(value) {
        BOOLEAN_ELEMENTS[value] = true;
      });
      var ALIASED_ATTR = {
        'ngMinlength': 'minlength',
        'ngMaxlength': 'maxlength',
        'ngMin': 'min',
        'ngMax': 'max',
        'ngPattern': 'pattern'
      };
      function getBooleanAttrName(element, name) {
        var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
        return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
      }
      function getAliasedAttrName(name) {
        return ALIASED_ATTR[name];
      }
      forEach({
        data: jqLiteData,
        removeData: jqLiteRemoveData,
        hasData: jqLiteHasData,
        cleanData: jqLiteCleanData
      }, function(fn, name) {
        JQLite[name] = fn;
      });
      forEach({
        data: jqLiteData,
        inheritedData: jqLiteInheritedData,
        scope: function(element) {
          return jqLite.data(element, '$scope') || jqLiteInheritedData(element.parentNode || element, ['$isolateScope', '$scope']);
        },
        isolateScope: function(element) {
          return jqLite.data(element, '$isolateScope') || jqLite.data(element, '$isolateScopeNoTemplate');
        },
        controller: jqLiteController,
        injector: function(element) {
          return jqLiteInheritedData(element, '$injector');
        },
        removeAttr: function(element, name) {
          element.removeAttribute(name);
        },
        hasClass: jqLiteHasClass,
        css: function(element, name, value) {
          name = camelCase(name);
          if (isDefined(value)) {
            element.style[name] = value;
          } else {
            return element.style[name];
          }
        },
        attr: function(element, name, value) {
          var nodeType = element.nodeType;
          if (nodeType === NODE_TYPE_TEXT || nodeType === NODE_TYPE_ATTRIBUTE || nodeType === NODE_TYPE_COMMENT) {
            return;
          }
          var lowercasedName = lowercase(name);
          if (BOOLEAN_ATTR[lowercasedName]) {
            if (isDefined(value)) {
              if (!!value) {
                element[name] = true;
                element.setAttribute(name, lowercasedName);
              } else {
                element[name] = false;
                element.removeAttribute(lowercasedName);
              }
            } else {
              return (element[name] || (element.attributes.getNamedItem(name) || noop).specified) ? lowercasedName : undefined;
            }
          } else if (isDefined(value)) {
            element.setAttribute(name, value);
          } else if (element.getAttribute) {
            var ret = element.getAttribute(name, 2);
            return ret === null ? undefined : ret;
          }
        },
        prop: function(element, name, value) {
          if (isDefined(value)) {
            element[name] = value;
          } else {
            return element[name];
          }
        },
        text: (function() {
          getText.$dv = '';
          return getText;
          function getText(element, value) {
            if (isUndefined(value)) {
              var nodeType = element.nodeType;
              return (nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT) ? element.textContent : '';
            }
            element.textContent = value;
          }
        })(),
        val: function(element, value) {
          if (isUndefined(value)) {
            if (element.multiple && nodeName_(element) === 'select') {
              var result = [];
              forEach(element.options, function(option) {
                if (option.selected) {
                  result.push(option.value || option.text);
                }
              });
              return result.length === 0 ? null : result;
            }
            return element.value;
          }
          element.value = value;
        },
        html: function(element, value) {
          if (isUndefined(value)) {
            return element.innerHTML;
          }
          jqLiteDealoc(element, true);
          element.innerHTML = value;
        },
        empty: jqLiteEmpty
      }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2) {
          var i,
              key;
          var nodeCount = this.length;
          if (fn !== jqLiteEmpty && (isUndefined((fn.length == 2 && (fn !== jqLiteHasClass && fn !== jqLiteController)) ? arg1 : arg2))) {
            if (isObject(arg1)) {
              for (i = 0; i < nodeCount; i++) {
                if (fn === jqLiteData) {
                  fn(this[i], arg1);
                } else {
                  for (key in arg1) {
                    fn(this[i], key, arg1[key]);
                  }
                }
              }
              return this;
            } else {
              var value = fn.$dv;
              var jj = (isUndefined(value)) ? Math.min(nodeCount, 1) : nodeCount;
              for (var j = 0; j < jj; j++) {
                var nodeValue = fn(this[j], arg1, arg2);
                value = value ? value + nodeValue : nodeValue;
              }
              return value;
            }
          } else {
            for (i = 0; i < nodeCount; i++) {
              fn(this[i], arg1, arg2);
            }
            return this;
          }
        };
      });
      function createEventHandler(element, events) {
        var eventHandler = function(event, type) {
          event.isDefaultPrevented = function() {
            return event.defaultPrevented;
          };
          var eventFns = events[type || event.type];
          var eventFnsLength = eventFns ? eventFns.length : 0;
          if (!eventFnsLength)
            return;
          if (isUndefined(event.immediatePropagationStopped)) {
            var originalStopImmediatePropagation = event.stopImmediatePropagation;
            event.stopImmediatePropagation = function() {
              event.immediatePropagationStopped = true;
              if (event.stopPropagation) {
                event.stopPropagation();
              }
              if (originalStopImmediatePropagation) {
                originalStopImmediatePropagation.call(event);
              }
            };
          }
          event.isImmediatePropagationStopped = function() {
            return event.immediatePropagationStopped === true;
          };
          var handlerWrapper = eventFns.specialHandlerWrapper || defaultHandlerWrapper;
          if ((eventFnsLength > 1)) {
            eventFns = shallowCopy(eventFns);
          }
          for (var i = 0; i < eventFnsLength; i++) {
            if (!event.isImmediatePropagationStopped()) {
              handlerWrapper(element, event, eventFns[i]);
            }
          }
        };
        eventHandler.elem = element;
        return eventHandler;
      }
      function defaultHandlerWrapper(element, event, handler) {
        handler.call(element, event);
      }
      function specialMouseHandlerWrapper(target, event, handler) {
        var related = event.relatedTarget;
        if (!related || (related !== target && !jqLiteContains.call(target, related))) {
          handler.call(target, event);
        }
      }
      forEach({
        removeData: jqLiteRemoveData,
        on: function jqLiteOn(element, type, fn, unsupported) {
          if (isDefined(unsupported))
            throw jqLiteMinErr('onargs', 'jqLite#on() does not support the `selector` or `eventData` parameters');
          if (!jqLiteAcceptsData(element)) {
            return;
          }
          var expandoStore = jqLiteExpandoStore(element, true);
          var events = expandoStore.events;
          var handle = expandoStore.handle;
          if (!handle) {
            handle = expandoStore.handle = createEventHandler(element, events);
          }
          var types = type.indexOf(' ') >= 0 ? type.split(' ') : [type];
          var i = types.length;
          var addHandler = function(type, specialHandlerWrapper, noEventListener) {
            var eventFns = events[type];
            if (!eventFns) {
              eventFns = events[type] = [];
              eventFns.specialHandlerWrapper = specialHandlerWrapper;
              if (type !== '$destroy' && !noEventListener) {
                addEventListenerFn(element, type, handle);
              }
            }
            eventFns.push(fn);
          };
          while (i--) {
            type = types[i];
            if (MOUSE_EVENT_MAP[type]) {
              addHandler(MOUSE_EVENT_MAP[type], specialMouseHandlerWrapper);
              addHandler(type, undefined, true);
            } else {
              addHandler(type);
            }
          }
        },
        off: jqLiteOff,
        one: function(element, type, fn) {
          element = jqLite(element);
          element.on(type, function onFn() {
            element.off(type, fn);
            element.off(type, onFn);
          });
          element.on(type, fn);
        },
        replaceWith: function(element, replaceNode) {
          var index,
              parent = element.parentNode;
          jqLiteDealoc(element);
          forEach(new JQLite(replaceNode), function(node) {
            if (index) {
              parent.insertBefore(node, index.nextSibling);
            } else {
              parent.replaceChild(node, element);
            }
            index = node;
          });
        },
        children: function(element) {
          var children = [];
          forEach(element.childNodes, function(element) {
            if (element.nodeType === NODE_TYPE_ELEMENT) {
              children.push(element);
            }
          });
          return children;
        },
        contents: function(element) {
          return element.contentDocument || element.childNodes || [];
        },
        append: function(element, node) {
          var nodeType = element.nodeType;
          if (nodeType !== NODE_TYPE_ELEMENT && nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT)
            return;
          node = new JQLite(node);
          for (var i = 0,
              ii = node.length; i < ii; i++) {
            var child = node[i];
            element.appendChild(child);
          }
        },
        prepend: function(element, node) {
          if (element.nodeType === NODE_TYPE_ELEMENT) {
            var index = element.firstChild;
            forEach(new JQLite(node), function(child) {
              element.insertBefore(child, index);
            });
          }
        },
        wrap: function(element, wrapNode) {
          jqLiteWrapNode(element, jqLite(wrapNode).eq(0).clone()[0]);
        },
        remove: jqLiteRemove,
        detach: function(element) {
          jqLiteRemove(element, true);
        },
        after: function(element, newElement) {
          var index = element,
              parent = element.parentNode;
          newElement = new JQLite(newElement);
          for (var i = 0,
              ii = newElement.length; i < ii; i++) {
            var node = newElement[i];
            parent.insertBefore(node, index.nextSibling);
            index = node;
          }
        },
        addClass: jqLiteAddClass,
        removeClass: jqLiteRemoveClass,
        toggleClass: function(element, selector, condition) {
          if (selector) {
            forEach(selector.split(' '), function(className) {
              var classCondition = condition;
              if (isUndefined(classCondition)) {
                classCondition = !jqLiteHasClass(element, className);
              }
              (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
            });
          }
        },
        parent: function(element) {
          var parent = element.parentNode;
          return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
        },
        next: function(element) {
          return element.nextElementSibling;
        },
        find: function(element, selector) {
          if (element.getElementsByTagName) {
            return element.getElementsByTagName(selector);
          } else {
            return [];
          }
        },
        clone: jqLiteClone,
        triggerHandler: function(element, event, extraParameters) {
          var dummyEvent,
              eventFnsCopy,
              handlerArgs;
          var eventName = event.type || event;
          var expandoStore = jqLiteExpandoStore(element);
          var events = expandoStore && expandoStore.events;
          var eventFns = events && events[eventName];
          if (eventFns) {
            dummyEvent = {
              preventDefault: function() {
                this.defaultPrevented = true;
              },
              isDefaultPrevented: function() {
                return this.defaultPrevented === true;
              },
              stopImmediatePropagation: function() {
                this.immediatePropagationStopped = true;
              },
              isImmediatePropagationStopped: function() {
                return this.immediatePropagationStopped === true;
              },
              stopPropagation: noop,
              type: eventName,
              target: element
            };
            if (event.type) {
              dummyEvent = extend(dummyEvent, event);
            }
            eventFnsCopy = shallowCopy(eventFns);
            handlerArgs = extraParameters ? [dummyEvent].concat(extraParameters) : [dummyEvent];
            forEach(eventFnsCopy, function(fn) {
              if (!dummyEvent.isImmediatePropagationStopped()) {
                fn.apply(element, handlerArgs);
              }
            });
          }
        }
      }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2, arg3) {
          var value;
          for (var i = 0,
              ii = this.length; i < ii; i++) {
            if (isUndefined(value)) {
              value = fn(this[i], arg1, arg2, arg3);
              if (isDefined(value)) {
                value = jqLite(value);
              }
            } else {
              jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
            }
          }
          return isDefined(value) ? value : this;
        };
        JQLite.prototype.bind = JQLite.prototype.on;
        JQLite.prototype.unbind = JQLite.prototype.off;
      });
      function $$jqLiteProvider() {
        this.$get = function $$jqLite() {
          return extend(JQLite, {
            hasClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteHasClass(node, classes);
            },
            addClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteAddClass(node, classes);
            },
            removeClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteRemoveClass(node, classes);
            }
          });
        };
      }
      function hashKey(obj, nextUidFn) {
        var key = obj && obj.$$hashKey;
        if (key) {
          if (typeof key === 'function') {
            key = obj.$$hashKey();
          }
          return key;
        }
        var objType = typeof obj;
        if (objType == 'function' || (objType == 'object' && obj !== null)) {
          key = obj.$$hashKey = objType + ':' + (nextUidFn || nextUid)();
        } else {
          key = objType + ':' + obj;
        }
        return key;
      }
      function HashMap(array, isolatedUid) {
        if (isolatedUid) {
          var uid = 0;
          this.nextUid = function() {
            return ++uid;
          };
        }
        forEach(array, this.put, this);
      }
      HashMap.prototype = {
        put: function(key, value) {
          this[hashKey(key, this.nextUid)] = value;
        },
        get: function(key) {
          return this[hashKey(key, this.nextUid)];
        },
        remove: function(key) {
          var value = this[key = hashKey(key, this.nextUid)];
          delete this[key];
          return value;
        }
      };
      var $$HashMapProvider = [function() {
        this.$get = [function() {
          return HashMap;
        }];
      }];
      var ARROW_ARG = /^([^\(]+?)=>/;
      var FN_ARGS = /^[^\(]*\(\s*([^\)]*)\)/m;
      var FN_ARG_SPLIT = /,/;
      var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
      var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
      var $injectorMinErr = minErr('$injector');
      function stringifyFn(fn) {
        return Function.prototype.toString.call(fn) + ' ';
      }
      function extractArgs(fn) {
        var fnText = stringifyFn(fn).replace(STRIP_COMMENTS, ''),
            args = fnText.match(ARROW_ARG) || fnText.match(FN_ARGS);
        return args;
      }
      function anonFn(fn) {
        var args = extractArgs(fn);
        if (args) {
          return 'function(' + (args[1] || '').replace(/[\s\r\n]+/, ' ') + ')';
        }
        return 'fn';
      }
      function annotate(fn, strictDi, name) {
        var $inject,
            argDecl,
            last;
        if (typeof fn === 'function') {
          if (!($inject = fn.$inject)) {
            $inject = [];
            if (fn.length) {
              if (strictDi) {
                if (!isString(name) || !name) {
                  name = fn.name || anonFn(fn);
                }
                throw $injectorMinErr('strictdi', '{0} is not using explicit annotation and cannot be invoked in strict mode', name);
              }
              argDecl = extractArgs(fn);
              forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
                arg.replace(FN_ARG, function(all, underscore, name) {
                  $inject.push(name);
                });
              });
            }
            fn.$inject = $inject;
          }
        } else if (isArray(fn)) {
          last = fn.length - 1;
          assertArgFn(fn[last], 'fn');
          $inject = fn.slice(0, last);
        } else {
          assertArgFn(fn, 'fn', true);
        }
        return $inject;
      }
      function createInjector(modulesToLoad, strictDi) {
        strictDi = (strictDi === true);
        var INSTANTIATING = {},
            providerSuffix = 'Provider',
            path = [],
            loadedModules = new HashMap([], true),
            providerCache = {$provide: {
                provider: supportObject(provider),
                factory: supportObject(factory),
                service: supportObject(service),
                value: supportObject(value),
                constant: supportObject(constant),
                decorator: decorator
              }},
            providerInjector = (providerCache.$injector = createInternalInjector(providerCache, function(serviceName, caller) {
              if (angular.isString(caller)) {
                path.push(caller);
              }
              throw $injectorMinErr('unpr', "Unknown provider: {0}", path.join(' <- '));
            })),
            instanceCache = {},
            protoInstanceInjector = createInternalInjector(instanceCache, function(serviceName, caller) {
              var provider = providerInjector.get(serviceName + providerSuffix, caller);
              return instanceInjector.invoke(provider.$get, provider, undefined, serviceName);
            }),
            instanceInjector = protoInstanceInjector;
        providerCache['$injector' + providerSuffix] = {$get: valueFn(protoInstanceInjector)};
        var runBlocks = loadModules(modulesToLoad);
        instanceInjector = protoInstanceInjector.get('$injector');
        instanceInjector.strictDi = strictDi;
        forEach(runBlocks, function(fn) {
          if (fn)
            instanceInjector.invoke(fn);
        });
        return instanceInjector;
        function supportObject(delegate) {
          return function(key, value) {
            if (isObject(key)) {
              forEach(key, reverseParams(delegate));
            } else {
              return delegate(key, value);
            }
          };
        }
        function provider(name, provider_) {
          assertNotHasOwnProperty(name, 'service');
          if (isFunction(provider_) || isArray(provider_)) {
            provider_ = providerInjector.instantiate(provider_);
          }
          if (!provider_.$get) {
            throw $injectorMinErr('pget', "Provider '{0}' must define $get factory method.", name);
          }
          return providerCache[name + providerSuffix] = provider_;
        }
        function enforceReturnValue(name, factory) {
          return function enforcedReturnValue() {
            var result = instanceInjector.invoke(factory, this);
            if (isUndefined(result)) {
              throw $injectorMinErr('undef', "Provider '{0}' must return a value from $get factory method.", name);
            }
            return result;
          };
        }
        function factory(name, factoryFn, enforce) {
          return provider(name, {$get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn});
        }
        function service(name, constructor) {
          return factory(name, ['$injector', function($injector) {
            return $injector.instantiate(constructor);
          }]);
        }
        function value(name, val) {
          return factory(name, valueFn(val), false);
        }
        function constant(name, value) {
          assertNotHasOwnProperty(name, 'constant');
          providerCache[name] = value;
          instanceCache[name] = value;
        }
        function decorator(serviceName, decorFn) {
          var origProvider = providerInjector.get(serviceName + providerSuffix),
              orig$get = origProvider.$get;
          origProvider.$get = function() {
            var origInstance = instanceInjector.invoke(orig$get, origProvider);
            return instanceInjector.invoke(decorFn, null, {$delegate: origInstance});
          };
        }
        function loadModules(modulesToLoad) {
          assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), 'modulesToLoad', 'not an array');
          var runBlocks = [],
              moduleFn;
          forEach(modulesToLoad, function(module) {
            if (loadedModules.get(module))
              return;
            loadedModules.put(module, true);
            function runInvokeQueue(queue) {
              var i,
                  ii;
              for (i = 0, ii = queue.length; i < ii; i++) {
                var invokeArgs = queue[i],
                    provider = providerInjector.get(invokeArgs[0]);
                provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
              }
            }
            try {
              if (isString(module)) {
                moduleFn = angularModule(module);
                runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
                runInvokeQueue(moduleFn._invokeQueue);
                runInvokeQueue(moduleFn._configBlocks);
              } else if (isFunction(module)) {
                runBlocks.push(providerInjector.invoke(module));
              } else if (isArray(module)) {
                runBlocks.push(providerInjector.invoke(module));
              } else {
                assertArgFn(module, 'module');
              }
            } catch (e) {
              if (isArray(module)) {
                module = module[module.length - 1];
              }
              if (e.message && e.stack && e.stack.indexOf(e.message) == -1) {
                e = e.message + '\n' + e.stack;
              }
              throw $injectorMinErr('modulerr', "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e);
            }
          });
          return runBlocks;
        }
        function createInternalInjector(cache, factory) {
          function getService(serviceName, caller) {
            if (cache.hasOwnProperty(serviceName)) {
              if (cache[serviceName] === INSTANTIATING) {
                throw $injectorMinErr('cdep', 'Circular dependency found: {0}', serviceName + ' <- ' + path.join(' <- '));
              }
              return cache[serviceName];
            } else {
              try {
                path.unshift(serviceName);
                cache[serviceName] = INSTANTIATING;
                return cache[serviceName] = factory(serviceName, caller);
              } catch (err) {
                if (cache[serviceName] === INSTANTIATING) {
                  delete cache[serviceName];
                }
                throw err;
              } finally {
                path.shift();
              }
            }
          }
          function injectionArgs(fn, locals, serviceName) {
            var args = [],
                $inject = createInjector.$$annotate(fn, strictDi, serviceName);
            for (var i = 0,
                length = $inject.length; i < length; i++) {
              var key = $inject[i];
              if (typeof key !== 'string') {
                throw $injectorMinErr('itkn', 'Incorrect injection token! Expected service name as string, got {0}', key);
              }
              args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName));
            }
            return args;
          }
          function isClass(func) {
            if (msie <= 11) {
              return false;
            }
            return typeof func === 'function' && /^(?:class\s|constructor\()/.test(stringifyFn(func));
          }
          function invoke(fn, self, locals, serviceName) {
            if (typeof locals === 'string') {
              serviceName = locals;
              locals = null;
            }
            var args = injectionArgs(fn, locals, serviceName);
            if (isArray(fn)) {
              fn = fn[fn.length - 1];
            }
            if (!isClass(fn)) {
              return fn.apply(self, args);
            } else {
              args.unshift(null);
              return new (Function.prototype.bind.apply(fn, args))();
            }
          }
          function instantiate(Type, locals, serviceName) {
            var ctor = (isArray(Type) ? Type[Type.length - 1] : Type);
            var args = injectionArgs(Type, locals, serviceName);
            args.unshift(null);
            return new (Function.prototype.bind.apply(ctor, args))();
          }
          return {
            invoke: invoke,
            instantiate: instantiate,
            get: getService,
            annotate: createInjector.$$annotate,
            has: function(name) {
              return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
            }
          };
        }
      }
      createInjector.$$annotate = annotate;
      function $AnchorScrollProvider() {
        var autoScrollingEnabled = true;
        this.disableAutoScrolling = function() {
          autoScrollingEnabled = false;
        };
        this.$get = ['$window', '$location', '$rootScope', function($window, $location, $rootScope) {
          var document = $window.document;
          function getFirstAnchor(list) {
            var result = null;
            Array.prototype.some.call(list, function(element) {
              if (nodeName_(element) === 'a') {
                result = element;
                return true;
              }
            });
            return result;
          }
          function getYOffset() {
            var offset = scroll.yOffset;
            if (isFunction(offset)) {
              offset = offset();
            } else if (isElement(offset)) {
              var elem = offset[0];
              var style = $window.getComputedStyle(elem);
              if (style.position !== 'fixed') {
                offset = 0;
              } else {
                offset = elem.getBoundingClientRect().bottom;
              }
            } else if (!isNumber(offset)) {
              offset = 0;
            }
            return offset;
          }
          function scrollTo(elem) {
            if (elem) {
              elem.scrollIntoView();
              var offset = getYOffset();
              if (offset) {
                var elemTop = elem.getBoundingClientRect().top;
                $window.scrollBy(0, elemTop - offset);
              }
            } else {
              $window.scrollTo(0, 0);
            }
          }
          function scroll(hash) {
            hash = isString(hash) ? hash : $location.hash();
            var elm;
            if (!hash)
              scrollTo(null);
            else if ((elm = document.getElementById(hash)))
              scrollTo(elm);
            else if ((elm = getFirstAnchor(document.getElementsByName(hash))))
              scrollTo(elm);
            else if (hash === 'top')
              scrollTo(null);
          }
          if (autoScrollingEnabled) {
            $rootScope.$watch(function autoScrollWatch() {
              return $location.hash();
            }, function autoScrollWatchAction(newVal, oldVal) {
              if (newVal === oldVal && newVal === '')
                return;
              jqLiteDocumentLoaded(function() {
                $rootScope.$evalAsync(scroll);
              });
            });
          }
          return scroll;
        }];
      }
      var $animateMinErr = minErr('$animate');
      var ELEMENT_NODE = 1;
      var NG_ANIMATE_CLASSNAME = 'ng-animate';
      function mergeClasses(a, b) {
        if (!a && !b)
          return '';
        if (!a)
          return b;
        if (!b)
          return a;
        if (isArray(a))
          a = a.join(' ');
        if (isArray(b))
          b = b.join(' ');
        return a + ' ' + b;
      }
      function extractElementNode(element) {
        for (var i = 0; i < element.length; i++) {
          var elm = element[i];
          if (elm.nodeType === ELEMENT_NODE) {
            return elm;
          }
        }
      }
      function splitClasses(classes) {
        if (isString(classes)) {
          classes = classes.split(' ');
        }
        var obj = createMap();
        forEach(classes, function(klass) {
          if (klass.length) {
            obj[klass] = true;
          }
        });
        return obj;
      }
      function prepareAnimateOptions(options) {
        return isObject(options) ? options : {};
      }
      var $$CoreAnimateJsProvider = function() {
        this.$get = noop;
      };
      var $$CoreAnimateQueueProvider = function() {
        var postDigestQueue = new HashMap();
        var postDigestElements = [];
        this.$get = ['$$AnimateRunner', '$rootScope', function($$AnimateRunner, $rootScope) {
          return {
            enabled: noop,
            on: noop,
            off: noop,
            pin: noop,
            push: function(element, event, options, domOperation) {
              domOperation && domOperation();
              options = options || {};
              options.from && element.css(options.from);
              options.to && element.css(options.to);
              if (options.addClass || options.removeClass) {
                addRemoveClassesPostDigest(element, options.addClass, options.removeClass);
              }
              var runner = new $$AnimateRunner();
              runner.complete();
              return runner;
            }
          };
          function updateData(data, classes, value) {
            var changed = false;
            if (classes) {
              classes = isString(classes) ? classes.split(' ') : isArray(classes) ? classes : [];
              forEach(classes, function(className) {
                if (className) {
                  changed = true;
                  data[className] = value;
                }
              });
            }
            return changed;
          }
          function handleCSSClassChanges() {
            forEach(postDigestElements, function(element) {
              var data = postDigestQueue.get(element);
              if (data) {
                var existing = splitClasses(element.attr('class'));
                var toAdd = '';
                var toRemove = '';
                forEach(data, function(status, className) {
                  var hasClass = !!existing[className];
                  if (status !== hasClass) {
                    if (status) {
                      toAdd += (toAdd.length ? ' ' : '') + className;
                    } else {
                      toRemove += (toRemove.length ? ' ' : '') + className;
                    }
                  }
                });
                forEach(element, function(elm) {
                  toAdd && jqLiteAddClass(elm, toAdd);
                  toRemove && jqLiteRemoveClass(elm, toRemove);
                });
                postDigestQueue.remove(element);
              }
            });
            postDigestElements.length = 0;
          }
          function addRemoveClassesPostDigest(element, add, remove) {
            var data = postDigestQueue.get(element) || {};
            var classesAdded = updateData(data, add, true);
            var classesRemoved = updateData(data, remove, false);
            if (classesAdded || classesRemoved) {
              postDigestQueue.put(element, data);
              postDigestElements.push(element);
              if (postDigestElements.length === 1) {
                $rootScope.$$postDigest(handleCSSClassChanges);
              }
            }
          }
        }];
      };
      var $AnimateProvider = ['$provide', function($provide) {
        var provider = this;
        this.$$registeredAnimations = Object.create(null);
        this.register = function(name, factory) {
          if (name && name.charAt(0) !== '.') {
            throw $animateMinErr('notcsel', "Expecting class selector starting with '.' got '{0}'.", name);
          }
          var key = name + '-animation';
          provider.$$registeredAnimations[name.substr(1)] = key;
          $provide.factory(key, factory);
        };
        this.classNameFilter = function(expression) {
          if (arguments.length === 1) {
            this.$$classNameFilter = (expression instanceof RegExp) ? expression : null;
            if (this.$$classNameFilter) {
              var reservedRegex = new RegExp("(\\s+|\\/)" + NG_ANIMATE_CLASSNAME + "(\\s+|\\/)");
              if (reservedRegex.test(this.$$classNameFilter.toString())) {
                throw $animateMinErr('nongcls', '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', NG_ANIMATE_CLASSNAME);
              }
            }
          }
          return this.$$classNameFilter;
        };
        this.$get = ['$$animateQueue', function($$animateQueue) {
          function domInsert(element, parentElement, afterElement) {
            if (afterElement) {
              var afterNode = extractElementNode(afterElement);
              if (afterNode && !afterNode.parentNode && !afterNode.previousElementSibling) {
                afterElement = null;
              }
            }
            afterElement ? afterElement.after(element) : parentElement.prepend(element);
          }
          return {
            on: $$animateQueue.on,
            off: $$animateQueue.off,
            pin: $$animateQueue.pin,
            enabled: $$animateQueue.enabled,
            cancel: function(runner) {
              runner.end && runner.end();
            },
            enter: function(element, parent, after, options) {
              parent = parent && jqLite(parent);
              after = after && jqLite(after);
              parent = parent || after.parent();
              domInsert(element, parent, after);
              return $$animateQueue.push(element, 'enter', prepareAnimateOptions(options));
            },
            move: function(element, parent, after, options) {
              parent = parent && jqLite(parent);
              after = after && jqLite(after);
              parent = parent || after.parent();
              domInsert(element, parent, after);
              return $$animateQueue.push(element, 'move', prepareAnimateOptions(options));
            },
            leave: function(element, options) {
              return $$animateQueue.push(element, 'leave', prepareAnimateOptions(options), function() {
                element.remove();
              });
            },
            addClass: function(element, className, options) {
              options = prepareAnimateOptions(options);
              options.addClass = mergeClasses(options.addclass, className);
              return $$animateQueue.push(element, 'addClass', options);
            },
            removeClass: function(element, className, options) {
              options = prepareAnimateOptions(options);
              options.removeClass = mergeClasses(options.removeClass, className);
              return $$animateQueue.push(element, 'removeClass', options);
            },
            setClass: function(element, add, remove, options) {
              options = prepareAnimateOptions(options);
              options.addClass = mergeClasses(options.addClass, add);
              options.removeClass = mergeClasses(options.removeClass, remove);
              return $$animateQueue.push(element, 'setClass', options);
            },
            animate: function(element, from, to, className, options) {
              options = prepareAnimateOptions(options);
              options.from = options.from ? extend(options.from, from) : from;
              options.to = options.to ? extend(options.to, to) : to;
              className = className || 'ng-inline-animate';
              options.tempClasses = mergeClasses(options.tempClasses, className);
              return $$animateQueue.push(element, 'animate', options);
            }
          };
        }];
      }];
      var $$AnimateAsyncRunFactoryProvider = function() {
        this.$get = ['$$rAF', function($$rAF) {
          var waitQueue = [];
          function waitForTick(fn) {
            waitQueue.push(fn);
            if (waitQueue.length > 1)
              return;
            $$rAF(function() {
              for (var i = 0; i < waitQueue.length; i++) {
                waitQueue[i]();
              }
              waitQueue = [];
            });
          }
          return function() {
            var passed = false;
            waitForTick(function() {
              passed = true;
            });
            return function(callback) {
              passed ? callback() : waitForTick(callback);
            };
          };
        }];
      };
      var $$AnimateRunnerFactoryProvider = function() {
        this.$get = ['$q', '$sniffer', '$$animateAsyncRun', '$document', '$timeout', function($q, $sniffer, $$animateAsyncRun, $document, $timeout) {
          var INITIAL_STATE = 0;
          var DONE_PENDING_STATE = 1;
          var DONE_COMPLETE_STATE = 2;
          AnimateRunner.chain = function(chain, callback) {
            var index = 0;
            next();
            function next() {
              if (index === chain.length) {
                callback(true);
                return;
              }
              chain[index](function(response) {
                if (response === false) {
                  callback(false);
                  return;
                }
                index++;
                next();
              });
            }
          };
          AnimateRunner.all = function(runners, callback) {
            var count = 0;
            var status = true;
            forEach(runners, function(runner) {
              runner.done(onProgress);
            });
            function onProgress(response) {
              status = status && response;
              if (++count === runners.length) {
                callback(status);
              }
            }
          };
          function AnimateRunner(host) {
            this.setHost(host);
            var rafTick = $$animateAsyncRun();
            var timeoutTick = function(fn) {
              $timeout(fn, 0, false);
            };
            this._doneCallbacks = [];
            this._tick = function(fn) {
              var doc = $document[0];
              if (doc && doc.hidden) {
                timeoutTick(fn);
              } else {
                rafTick(fn);
              }
            };
            this._state = 0;
          }
          AnimateRunner.prototype = {
            setHost: function(host) {
              this.host = host || {};
            },
            done: function(fn) {
              if (this._state === DONE_COMPLETE_STATE) {
                fn();
              } else {
                this._doneCallbacks.push(fn);
              }
            },
            progress: noop,
            getPromise: function() {
              if (!this.promise) {
                var self = this;
                this.promise = $q(function(resolve, reject) {
                  self.done(function(status) {
                    status === false ? reject() : resolve();
                  });
                });
              }
              return this.promise;
            },
            then: function(resolveHandler, rejectHandler) {
              return this.getPromise().then(resolveHandler, rejectHandler);
            },
            'catch': function(handler) {
              return this.getPromise()['catch'](handler);
            },
            'finally': function(handler) {
              return this.getPromise()['finally'](handler);
            },
            pause: function() {
              if (this.host.pause) {
                this.host.pause();
              }
            },
            resume: function() {
              if (this.host.resume) {
                this.host.resume();
              }
            },
            end: function() {
              if (this.host.end) {
                this.host.end();
              }
              this._resolve(true);
            },
            cancel: function() {
              if (this.host.cancel) {
                this.host.cancel();
              }
              this._resolve(false);
            },
            complete: function(response) {
              var self = this;
              if (self._state === INITIAL_STATE) {
                self._state = DONE_PENDING_STATE;
                self._tick(function() {
                  self._resolve(response);
                });
              }
            },
            _resolve: function(response) {
              if (this._state !== DONE_COMPLETE_STATE) {
                forEach(this._doneCallbacks, function(fn) {
                  fn(response);
                });
                this._doneCallbacks.length = 0;
                this._state = DONE_COMPLETE_STATE;
              }
            }
          };
          return AnimateRunner;
        }];
      };
      var $CoreAnimateCssProvider = function() {
        this.$get = ['$$rAF', '$q', '$$AnimateRunner', function($$rAF, $q, $$AnimateRunner) {
          return function(element, initialOptions) {
            var options = initialOptions || {};
            if (!options.$$prepared) {
              options = copy(options);
            }
            if (options.cleanupStyles) {
              options.from = options.to = null;
            }
            if (options.from) {
              element.css(options.from);
              options.from = null;
            }
            var closed,
                runner = new $$AnimateRunner();
            return {
              start: run,
              end: run
            };
            function run() {
              $$rAF(function() {
                applyAnimationContents();
                if (!closed) {
                  runner.complete();
                }
                closed = true;
              });
              return runner;
            }
            function applyAnimationContents() {
              if (options.addClass) {
                element.addClass(options.addClass);
                options.addClass = null;
              }
              if (options.removeClass) {
                element.removeClass(options.removeClass);
                options.removeClass = null;
              }
              if (options.to) {
                element.css(options.to);
                options.to = null;
              }
            }
          };
        }];
      };
      function Browser(window, document, $log, $sniffer) {
        var self = this,
            location = window.location,
            history = window.history,
            setTimeout = window.setTimeout,
            clearTimeout = window.clearTimeout,
            pendingDeferIds = {};
        self.isMock = false;
        var outstandingRequestCount = 0;
        var outstandingRequestCallbacks = [];
        self.$$completeOutstandingRequest = completeOutstandingRequest;
        self.$$incOutstandingRequestCount = function() {
          outstandingRequestCount++;
        };
        function completeOutstandingRequest(fn) {
          try {
            fn.apply(null, sliceArgs(arguments, 1));
          } finally {
            outstandingRequestCount--;
            if (outstandingRequestCount === 0) {
              while (outstandingRequestCallbacks.length) {
                try {
                  outstandingRequestCallbacks.pop()();
                } catch (e) {
                  $log.error(e);
                }
              }
            }
          }
        }
        function getHash(url) {
          var index = url.indexOf('#');
          return index === -1 ? '' : url.substr(index);
        }
        self.notifyWhenNoOutstandingRequests = function(callback) {
          if (outstandingRequestCount === 0) {
            callback();
          } else {
            outstandingRequestCallbacks.push(callback);
          }
        };
        var cachedState,
            lastHistoryState,
            lastBrowserUrl = location.href,
            baseElement = document.find('base'),
            pendingLocation = null,
            getCurrentState = !$sniffer.history ? noop : function getCurrentState() {
              try {
                return history.state;
              } catch (e) {}
            };
        cacheState();
        lastHistoryState = cachedState;
        self.url = function(url, replace, state) {
          if (isUndefined(state)) {
            state = null;
          }
          if (location !== window.location)
            location = window.location;
          if (history !== window.history)
            history = window.history;
          if (url) {
            var sameState = lastHistoryState === state;
            if (lastBrowserUrl === url && (!$sniffer.history || sameState)) {
              return self;
            }
            var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
            lastBrowserUrl = url;
            lastHistoryState = state;
            if ($sniffer.history && (!sameBase || !sameState)) {
              history[replace ? 'replaceState' : 'pushState'](state, '', url);
              cacheState();
              lastHistoryState = cachedState;
            } else {
              if (!sameBase) {
                pendingLocation = url;
              }
              if (replace) {
                location.replace(url);
              } else if (!sameBase) {
                location.href = url;
              } else {
                location.hash = getHash(url);
              }
              if (location.href !== url) {
                pendingLocation = url;
              }
            }
            if (pendingLocation) {
              pendingLocation = url;
            }
            return self;
          } else {
            return pendingLocation || location.href.replace(/%27/g, "'");
          }
        };
        self.state = function() {
          return cachedState;
        };
        var urlChangeListeners = [],
            urlChangeInit = false;
        function cacheStateAndFireUrlChange() {
          pendingLocation = null;
          cacheState();
          fireUrlChange();
        }
        var lastCachedState = null;
        function cacheState() {
          cachedState = getCurrentState();
          cachedState = isUndefined(cachedState) ? null : cachedState;
          if (equals(cachedState, lastCachedState)) {
            cachedState = lastCachedState;
          }
          lastCachedState = cachedState;
        }
        function fireUrlChange() {
          if (lastBrowserUrl === self.url() && lastHistoryState === cachedState) {
            return;
          }
          lastBrowserUrl = self.url();
          lastHistoryState = cachedState;
          forEach(urlChangeListeners, function(listener) {
            listener(self.url(), cachedState);
          });
        }
        self.onUrlChange = function(callback) {
          if (!urlChangeInit) {
            if ($sniffer.history)
              jqLite(window).on('popstate', cacheStateAndFireUrlChange);
            jqLite(window).on('hashchange', cacheStateAndFireUrlChange);
            urlChangeInit = true;
          }
          urlChangeListeners.push(callback);
          return callback;
        };
        self.$$applicationDestroyed = function() {
          jqLite(window).off('hashchange popstate', cacheStateAndFireUrlChange);
        };
        self.$$checkUrlChange = fireUrlChange;
        self.baseHref = function() {
          var href = baseElement.attr('href');
          return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, '') : '';
        };
        self.defer = function(fn, delay) {
          var timeoutId;
          outstandingRequestCount++;
          timeoutId = setTimeout(function() {
            delete pendingDeferIds[timeoutId];
            completeOutstandingRequest(fn);
          }, delay || 0);
          pendingDeferIds[timeoutId] = true;
          return timeoutId;
        };
        self.defer.cancel = function(deferId) {
          if (pendingDeferIds[deferId]) {
            delete pendingDeferIds[deferId];
            clearTimeout(deferId);
            completeOutstandingRequest(noop);
            return true;
          }
          return false;
        };
      }
      function $BrowserProvider() {
        this.$get = ['$window', '$log', '$sniffer', '$document', function($window, $log, $sniffer, $document) {
          return new Browser($window, $document, $log, $sniffer);
        }];
      }
      function $CacheFactoryProvider() {
        this.$get = function() {
          var caches = {};
          function cacheFactory(cacheId, options) {
            if (cacheId in caches) {
              throw minErr('$cacheFactory')('iid', "CacheId '{0}' is already taken!", cacheId);
            }
            var size = 0,
                stats = extend({}, options, {id: cacheId}),
                data = createMap(),
                capacity = (options && options.capacity) || Number.MAX_VALUE,
                lruHash = createMap(),
                freshEnd = null,
                staleEnd = null;
            return caches[cacheId] = {
              put: function(key, value) {
                if (isUndefined(value))
                  return;
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key] || (lruHash[key] = {key: key});
                  refresh(lruEntry);
                }
                if (!(key in data))
                  size++;
                data[key] = value;
                if (size > capacity) {
                  this.remove(staleEnd.key);
                }
                return value;
              },
              get: function(key) {
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key];
                  if (!lruEntry)
                    return;
                  refresh(lruEntry);
                }
                return data[key];
              },
              remove: function(key) {
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key];
                  if (!lruEntry)
                    return;
                  if (lruEntry == freshEnd)
                    freshEnd = lruEntry.p;
                  if (lruEntry == staleEnd)
                    staleEnd = lruEntry.n;
                  link(lruEntry.n, lruEntry.p);
                  delete lruHash[key];
                }
                if (!(key in data))
                  return;
                delete data[key];
                size--;
              },
              removeAll: function() {
                data = createMap();
                size = 0;
                lruHash = createMap();
                freshEnd = staleEnd = null;
              },
              destroy: function() {
                data = null;
                stats = null;
                lruHash = null;
                delete caches[cacheId];
              },
              info: function() {
                return extend({}, stats, {size: size});
              }
            };
            function refresh(entry) {
              if (entry != freshEnd) {
                if (!staleEnd) {
                  staleEnd = entry;
                } else if (staleEnd == entry) {
                  staleEnd = entry.n;
                }
                link(entry.n, entry.p);
                link(entry, freshEnd);
                freshEnd = entry;
                freshEnd.n = null;
              }
            }
            function link(nextEntry, prevEntry) {
              if (nextEntry != prevEntry) {
                if (nextEntry)
                  nextEntry.p = prevEntry;
                if (prevEntry)
                  prevEntry.n = nextEntry;
              }
            }
          }
          cacheFactory.info = function() {
            var info = {};
            forEach(caches, function(cache, cacheId) {
              info[cacheId] = cache.info();
            });
            return info;
          };
          cacheFactory.get = function(cacheId) {
            return caches[cacheId];
          };
          return cacheFactory;
        };
      }
      function $TemplateCacheProvider() {
        this.$get = ['$cacheFactory', function($cacheFactory) {
          return $cacheFactory('templates');
        }];
      }
      var $compileMinErr = minErr('$compile');
      function UNINITIALIZED_VALUE() {}
      var _UNINITIALIZED_VALUE = new UNINITIALIZED_VALUE();
      $CompileProvider.$inject = ['$provide', '$$sanitizeUriProvider'];
      function $CompileProvider($provide, $$sanitizeUriProvider) {
        var hasDirectives = {},
            Suffix = 'Directive',
            COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/,
            CLASS_DIRECTIVE_REGEXP = /(([\w\-]+)(?:\:([^;]+))?;?)/,
            ALL_OR_NOTHING_ATTRS = makeMap('ngSrc,ngSrcset,src,srcset'),
            REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
        var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
        var bindingCache = createMap();
        function parseIsolateBindings(scope, directiveName, isController) {
          var LOCAL_REGEXP = /^\s*([@&<]|=(\*?))(\??)\s*(\w*)\s*$/;
          var bindings = createMap();
          forEach(scope, function(definition, scopeName) {
            if (definition in bindingCache) {
              bindings[scopeName] = bindingCache[definition];
              return;
            }
            var match = definition.match(LOCAL_REGEXP);
            if (!match) {
              throw $compileMinErr('iscp', "Invalid {3} for directive '{0}'." + " Definition: {... {1}: '{2}' ...}", directiveName, scopeName, definition, (isController ? "controller bindings definition" : "isolate scope definition"));
            }
            bindings[scopeName] = {
              mode: match[1][0],
              collection: match[2] === '*',
              optional: match[3] === '?',
              attrName: match[4] || scopeName
            };
            if (match[4]) {
              bindingCache[definition] = bindings[scopeName];
            }
          });
          return bindings;
        }
        function parseDirectiveBindings(directive, directiveName) {
          var bindings = {
            isolateScope: null,
            bindToController: null
          };
          if (isObject(directive.scope)) {
            if (directive.bindToController === true) {
              bindings.bindToController = parseIsolateBindings(directive.scope, directiveName, true);
              bindings.isolateScope = {};
            } else {
              bindings.isolateScope = parseIsolateBindings(directive.scope, directiveName, false);
            }
          }
          if (isObject(directive.bindToController)) {
            bindings.bindToController = parseIsolateBindings(directive.bindToController, directiveName, true);
          }
          if (isObject(bindings.bindToController)) {
            var controller = directive.controller;
            var controllerAs = directive.controllerAs;
            if (!controller) {
              throw $compileMinErr('noctrl', "Cannot bind to controller without directive '{0}'s controller.", directiveName);
            } else if (!identifierForController(controller, controllerAs)) {
              throw $compileMinErr('noident', "Cannot bind to controller without identifier for directive '{0}'.", directiveName);
            }
          }
          return bindings;
        }
        function assertValidDirectiveName(name) {
          var letter = name.charAt(0);
          if (!letter || letter !== lowercase(letter)) {
            throw $compileMinErr('baddir', "Directive/Component name '{0}' is invalid. The first character must be a lowercase letter", name);
          }
          if (name !== name.trim()) {
            throw $compileMinErr('baddir', "Directive/Component name '{0}' is invalid. The name should not contain leading or trailing whitespaces", name);
          }
        }
        function getDirectiveRequire(directive) {
          var require = directive.require || (directive.controller && directive.name);
          if (!isArray(require) && isObject(require)) {
            forEach(require, function(value, key) {
              var match = value.match(REQUIRE_PREFIX_REGEXP);
              var name = value.substring(match[0].length);
              if (!name)
                require[key] = match[0] + key;
            });
          }
          return require;
        }
        this.directive = function registerDirective(name, directiveFactory) {
          assertNotHasOwnProperty(name, 'directive');
          if (isString(name)) {
            assertValidDirectiveName(name);
            assertArg(directiveFactory, 'directiveFactory');
            if (!hasDirectives.hasOwnProperty(name)) {
              hasDirectives[name] = [];
              $provide.factory(name + Suffix, ['$injector', '$exceptionHandler', function($injector, $exceptionHandler) {
                var directives = [];
                forEach(hasDirectives[name], function(directiveFactory, index) {
                  try {
                    var directive = $injector.invoke(directiveFactory);
                    if (isFunction(directive)) {
                      directive = {compile: valueFn(directive)};
                    } else if (!directive.compile && directive.link) {
                      directive.compile = valueFn(directive.link);
                    }
                    directive.priority = directive.priority || 0;
                    directive.index = index;
                    directive.name = directive.name || name;
                    directive.require = getDirectiveRequire(directive);
                    directive.restrict = directive.restrict || 'EA';
                    directive.$$moduleName = directiveFactory.$$moduleName;
                    directives.push(directive);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                });
                return directives;
              }]);
            }
            hasDirectives[name].push(directiveFactory);
          } else {
            forEach(name, reverseParams(registerDirective));
          }
          return this;
        };
        this.component = function registerComponent(name, options) {
          var controller = options.controller || function() {};
          function factory($injector) {
            function makeInjectable(fn) {
              if (isFunction(fn) || isArray(fn)) {
                return function(tElement, tAttrs) {
                  return $injector.invoke(fn, this, {
                    $element: tElement,
                    $attrs: tAttrs
                  });
                };
              } else {
                return fn;
              }
            }
            var template = (!options.template && !options.templateUrl ? '' : options.template);
            var ddo = {
              controller: controller,
              controllerAs: identifierForController(options.controller) || options.controllerAs || '$ctrl',
              template: makeInjectable(template),
              templateUrl: makeInjectable(options.templateUrl),
              transclude: options.transclude,
              scope: {},
              bindToController: options.bindings || {},
              restrict: 'E',
              require: options.require
            };
            forEach(options, function(val, key) {
              if (key.charAt(0) === '$')
                ddo[key] = val;
            });
            return ddo;
          }
          forEach(options, function(val, key) {
            if (key.charAt(0) === '$') {
              factory[key] = val;
              if (isFunction(controller))
                controller[key] = val;
            }
          });
          factory.$inject = ['$injector'];
          return this.directive(name, factory);
        };
        this.aHrefSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
            return this;
          } else {
            return $$sanitizeUriProvider.aHrefSanitizationWhitelist();
          }
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
            return this;
          } else {
            return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
          }
        };
        var debugInfoEnabled = true;
        this.debugInfoEnabled = function(enabled) {
          if (isDefined(enabled)) {
            debugInfoEnabled = enabled;
            return this;
          }
          return debugInfoEnabled;
        };
        var TTL = 10;
        this.onChangesTtl = function(value) {
          if (arguments.length) {
            TTL = value;
            return this;
          }
          return TTL;
        };
        this.$get = ['$injector', '$interpolate', '$exceptionHandler', '$templateRequest', '$parse', '$controller', '$rootScope', '$sce', '$animate', '$$sanitizeUri', function($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $sce, $animate, $$sanitizeUri) {
          var SIMPLE_ATTR_NAME = /^\w/;
          var specialAttrHolder = window.document.createElement('div');
          var onChangesTtl = TTL;
          var onChangesQueue;
          function flushOnChangesQueue() {
            try {
              if (!(--onChangesTtl)) {
                onChangesQueue = undefined;
                throw $compileMinErr('infchng', '{0} $onChanges() iterations reached. Aborting!\n', TTL);
              }
              $rootScope.$apply(function() {
                var errors = [];
                for (var i = 0,
                    ii = onChangesQueue.length; i < ii; ++i) {
                  try {
                    onChangesQueue[i]();
                  } catch (e) {
                    errors.push(e);
                  }
                }
                onChangesQueue = undefined;
                if (errors.length) {
                  throw errors;
                }
              });
            } finally {
              onChangesTtl++;
            }
          }
          function Attributes(element, attributesToCopy) {
            if (attributesToCopy) {
              var keys = Object.keys(attributesToCopy);
              var i,
                  l,
                  key;
              for (i = 0, l = keys.length; i < l; i++) {
                key = keys[i];
                this[key] = attributesToCopy[key];
              }
            } else {
              this.$attr = {};
            }
            this.$$element = element;
          }
          Attributes.prototype = {
            $normalize: directiveNormalize,
            $addClass: function(classVal) {
              if (classVal && classVal.length > 0) {
                $animate.addClass(this.$$element, classVal);
              }
            },
            $removeClass: function(classVal) {
              if (classVal && classVal.length > 0) {
                $animate.removeClass(this.$$element, classVal);
              }
            },
            $updateClass: function(newClasses, oldClasses) {
              var toAdd = tokenDifference(newClasses, oldClasses);
              if (toAdd && toAdd.length) {
                $animate.addClass(this.$$element, toAdd);
              }
              var toRemove = tokenDifference(oldClasses, newClasses);
              if (toRemove && toRemove.length) {
                $animate.removeClass(this.$$element, toRemove);
              }
            },
            $set: function(key, value, writeAttr, attrName) {
              var node = this.$$element[0],
                  booleanKey = getBooleanAttrName(node, key),
                  aliasedKey = getAliasedAttrName(key),
                  observer = key,
                  nodeName;
              if (booleanKey) {
                this.$$element.prop(key, value);
                attrName = booleanKey;
              } else if (aliasedKey) {
                this[aliasedKey] = value;
                observer = aliasedKey;
              }
              this[key] = value;
              if (attrName) {
                this.$attr[key] = attrName;
              } else {
                attrName = this.$attr[key];
                if (!attrName) {
                  this.$attr[key] = attrName = snake_case(key, '-');
                }
              }
              nodeName = nodeName_(this.$$element);
              if ((nodeName === 'a' && (key === 'href' || key === 'xlinkHref')) || (nodeName === 'img' && key === 'src')) {
                this[key] = value = $$sanitizeUri(value, key === 'src');
              } else if (nodeName === 'img' && key === 'srcset' && isDefined(value)) {
                var result = "";
                var trimmedSrcset = trim(value);
                var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
                var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;
                var rawUris = trimmedSrcset.split(pattern);
                var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
                for (var i = 0; i < nbrUrisWith2parts; i++) {
                  var innerIdx = i * 2;
                  result += $$sanitizeUri(trim(rawUris[innerIdx]), true);
                  result += (" " + trim(rawUris[innerIdx + 1]));
                }
                var lastTuple = trim(rawUris[i * 2]).split(/\s/);
                result += $$sanitizeUri(trim(lastTuple[0]), true);
                if (lastTuple.length === 2) {
                  result += (" " + trim(lastTuple[1]));
                }
                this[key] = value = result;
              }
              if (writeAttr !== false) {
                if (value === null || isUndefined(value)) {
                  this.$$element.removeAttr(attrName);
                } else {
                  if (SIMPLE_ATTR_NAME.test(attrName)) {
                    this.$$element.attr(attrName, value);
                  } else {
                    setSpecialAttr(this.$$element[0], attrName, value);
                  }
                }
              }
              var $$observers = this.$$observers;
              $$observers && forEach($$observers[observer], function(fn) {
                try {
                  fn(value);
                } catch (e) {
                  $exceptionHandler(e);
                }
              });
            },
            $observe: function(key, fn) {
              var attrs = this,
                  $$observers = (attrs.$$observers || (attrs.$$observers = createMap())),
                  listeners = ($$observers[key] || ($$observers[key] = []));
              listeners.push(fn);
              $rootScope.$evalAsync(function() {
                if (!listeners.$$inter && attrs.hasOwnProperty(key) && !isUndefined(attrs[key])) {
                  fn(attrs[key]);
                }
              });
              return function() {
                arrayRemove(listeners, fn);
              };
            }
          };
          function setSpecialAttr(element, attrName, value) {
            specialAttrHolder.innerHTML = "<span " + attrName + ">";
            var attributes = specialAttrHolder.firstChild.attributes;
            var attribute = attributes[0];
            attributes.removeNamedItem(attribute.name);
            attribute.value = value;
            element.attributes.setNamedItem(attribute);
          }
          function safeAddClass($element, className) {
            try {
              $element.addClass(className);
            } catch (e) {}
          }
          var startSymbol = $interpolate.startSymbol(),
              endSymbol = $interpolate.endSymbol(),
              denormalizeTemplate = (startSymbol == '{{' && endSymbol == '}}') ? identity : function denormalizeTemplate(template) {
                return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
              },
              NG_ATTR_BINDING = /^ngAttr[A-Z]/;
          var MULTI_ELEMENT_DIR_RE = /^(.+)Start$/;
          compile.$$addBindingInfo = debugInfoEnabled ? function $$addBindingInfo($element, binding) {
            var bindings = $element.data('$binding') || [];
            if (isArray(binding)) {
              bindings = bindings.concat(binding);
            } else {
              bindings.push(binding);
            }
            $element.data('$binding', bindings);
          } : noop;
          compile.$$addBindingClass = debugInfoEnabled ? function $$addBindingClass($element) {
            safeAddClass($element, 'ng-binding');
          } : noop;
          compile.$$addScopeInfo = debugInfoEnabled ? function $$addScopeInfo($element, scope, isolated, noTemplate) {
            var dataName = isolated ? (noTemplate ? '$isolateScopeNoTemplate' : '$isolateScope') : '$scope';
            $element.data(dataName, scope);
          } : noop;
          compile.$$addScopeClass = debugInfoEnabled ? function $$addScopeClass($element, isolated) {
            safeAddClass($element, isolated ? 'ng-isolate-scope' : 'ng-scope');
          } : noop;
          compile.$$createComment = function(directiveName, comment) {
            var content = '';
            if (debugInfoEnabled) {
              content = ' ' + (directiveName || '') + ': ';
              if (comment)
                content += comment + ' ';
            }
            return window.document.createComment(content);
          };
          return compile;
          function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
            if (!($compileNodes instanceof jqLite)) {
              $compileNodes = jqLite($compileNodes);
            }
            var NOT_EMPTY = /\S+/;
            for (var i = 0,
                len = $compileNodes.length; i < len; i++) {
              var domNode = $compileNodes[i];
              if (domNode.nodeType === NODE_TYPE_TEXT && domNode.nodeValue.match(NOT_EMPTY)) {
                jqLiteWrapNode(domNode, $compileNodes[i] = window.document.createElement('span'));
              }
            }
            var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
            compile.$$addScopeClass($compileNodes);
            var namespace = null;
            return function publicLinkFn(scope, cloneConnectFn, options) {
              assertArg(scope, 'scope');
              if (previousCompileContext && previousCompileContext.needsNewScope) {
                scope = scope.$parent.$new();
              }
              options = options || {};
              var parentBoundTranscludeFn = options.parentBoundTranscludeFn,
                  transcludeControllers = options.transcludeControllers,
                  futureParentElement = options.futureParentElement;
              if (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude) {
                parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
              }
              if (!namespace) {
                namespace = detectNamespaceForChildElements(futureParentElement);
              }
              var $linkNode;
              if (namespace !== 'html') {
                $linkNode = jqLite(wrapTemplate(namespace, jqLite('<div>').append($compileNodes).html()));
              } else if (cloneConnectFn) {
                $linkNode = JQLitePrototype.clone.call($compileNodes);
              } else {
                $linkNode = $compileNodes;
              }
              if (transcludeControllers) {
                for (var controllerName in transcludeControllers) {
                  $linkNode.data('$' + controllerName + 'Controller', transcludeControllers[controllerName].instance);
                }
              }
              compile.$$addScopeInfo($linkNode, scope);
              if (cloneConnectFn)
                cloneConnectFn($linkNode, scope);
              if (compositeLinkFn)
                compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
              return $linkNode;
            };
          }
          function detectNamespaceForChildElements(parentElement) {
            var node = parentElement && parentElement[0];
            if (!node) {
              return 'html';
            } else {
              return nodeName_(node) !== 'foreignobject' && toString.call(node).match(/SVG/) ? 'svg' : 'html';
            }
          }
          function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
            var linkFns = [],
                attrs,
                directives,
                nodeLinkFn,
                childNodes,
                childLinkFn,
                linkFnFound,
                nodeLinkFnFound;
            for (var i = 0; i < nodeList.length; i++) {
              attrs = new Attributes();
              directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined, ignoreDirective);
              nodeLinkFn = (directives.length) ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null;
              if (nodeLinkFn && nodeLinkFn.scope) {
                compile.$$addScopeClass(attrs.$$element);
              }
              childLinkFn = (nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length) ? null : compileNodes(childNodes, nodeLinkFn ? ((nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude) : transcludeFn);
              if (nodeLinkFn || childLinkFn) {
                linkFns.push(i, nodeLinkFn, childLinkFn);
                linkFnFound = true;
                nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
              }
              previousCompileContext = null;
            }
            return linkFnFound ? compositeLinkFn : null;
            function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
              var nodeLinkFn,
                  childLinkFn,
                  node,
                  childScope,
                  i,
                  ii,
                  idx,
                  childBoundTranscludeFn;
              var stableNodeList;
              if (nodeLinkFnFound) {
                var nodeListLength = nodeList.length;
                stableNodeList = new Array(nodeListLength);
                for (i = 0; i < linkFns.length; i += 3) {
                  idx = linkFns[i];
                  stableNodeList[idx] = nodeList[idx];
                }
              } else {
                stableNodeList = nodeList;
              }
              for (i = 0, ii = linkFns.length; i < ii; ) {
                node = stableNodeList[linkFns[i++]];
                nodeLinkFn = linkFns[i++];
                childLinkFn = linkFns[i++];
                if (nodeLinkFn) {
                  if (nodeLinkFn.scope) {
                    childScope = scope.$new();
                    compile.$$addScopeInfo(jqLite(node), childScope);
                  } else {
                    childScope = scope;
                  }
                  if (nodeLinkFn.transcludeOnThisElement) {
                    childBoundTranscludeFn = createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn);
                  } else if (!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn) {
                    childBoundTranscludeFn = parentBoundTranscludeFn;
                  } else if (!parentBoundTranscludeFn && transcludeFn) {
                    childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);
                  } else {
                    childBoundTranscludeFn = null;
                  }
                  nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn);
                } else if (childLinkFn) {
                  childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
                }
              }
            }
          }
          function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
            function boundTranscludeFn(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
              if (!transcludedScope) {
                transcludedScope = scope.$new(false, containingScope);
                transcludedScope.$$transcluded = true;
              }
              return transcludeFn(transcludedScope, cloneFn, {
                parentBoundTranscludeFn: previousBoundTranscludeFn,
                transcludeControllers: controllers,
                futureParentElement: futureParentElement
              });
            }
            var boundSlots = boundTranscludeFn.$$slots = createMap();
            for (var slotName in transcludeFn.$$slots) {
              if (transcludeFn.$$slots[slotName]) {
                boundSlots[slotName] = createBoundTranscludeFn(scope, transcludeFn.$$slots[slotName], previousBoundTranscludeFn);
              } else {
                boundSlots[slotName] = null;
              }
            }
            return boundTranscludeFn;
          }
          function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
            var nodeType = node.nodeType,
                attrsMap = attrs.$attr,
                match,
                className;
            switch (nodeType) {
              case NODE_TYPE_ELEMENT:
                addDirective(directives, directiveNormalize(nodeName_(node)), 'E', maxPriority, ignoreDirective);
                for (var attr,
                    name,
                    nName,
                    ngAttrName,
                    value,
                    isNgAttr,
                    nAttrs = node.attributes,
                    j = 0,
                    jj = nAttrs && nAttrs.length; j < jj; j++) {
                  var attrStartName = false;
                  var attrEndName = false;
                  attr = nAttrs[j];
                  name = attr.name;
                  value = trim(attr.value);
                  ngAttrName = directiveNormalize(name);
                  if (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) {
                    name = name.replace(PREFIX_REGEXP, '').substr(8).replace(/_(.)/g, function(match, letter) {
                      return letter.toUpperCase();
                    });
                  }
                  var multiElementMatch = ngAttrName.match(MULTI_ELEMENT_DIR_RE);
                  if (multiElementMatch && directiveIsMultiElement(multiElementMatch[1])) {
                    attrStartName = name;
                    attrEndName = name.substr(0, name.length - 5) + 'end';
                    name = name.substr(0, name.length - 6);
                  }
                  nName = directiveNormalize(name.toLowerCase());
                  attrsMap[nName] = name;
                  if (isNgAttr || !attrs.hasOwnProperty(nName)) {
                    attrs[nName] = value;
                    if (getBooleanAttrName(node, nName)) {
                      attrs[nName] = true;
                    }
                  }
                  addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);
                  addDirective(directives, nName, 'A', maxPriority, ignoreDirective, attrStartName, attrEndName);
                }
                className = node.className;
                if (isObject(className)) {
                  className = className.animVal;
                }
                if (isString(className) && className !== '') {
                  while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                    nName = directiveNormalize(match[2]);
                    if (addDirective(directives, nName, 'C', maxPriority, ignoreDirective)) {
                      attrs[nName] = trim(match[3]);
                    }
                    className = className.substr(match.index + match[0].length);
                  }
                }
                break;
              case NODE_TYPE_TEXT:
                if (msie === 11) {
                  while (node.parentNode && node.nextSibling && node.nextSibling.nodeType === NODE_TYPE_TEXT) {
                    node.nodeValue = node.nodeValue + node.nextSibling.nodeValue;
                    node.parentNode.removeChild(node.nextSibling);
                  }
                }
                addTextInterpolateDirective(directives, node.nodeValue);
                break;
              case NODE_TYPE_COMMENT:
                try {
                  match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                  if (match) {
                    nName = directiveNormalize(match[1]);
                    if (addDirective(directives, nName, 'M', maxPriority, ignoreDirective)) {
                      attrs[nName] = trim(match[2]);
                    }
                  }
                } catch (e) {}
                break;
            }
            directives.sort(byPriority);
            return directives;
          }
          function groupScan(node, attrStart, attrEnd) {
            var nodes = [];
            var depth = 0;
            if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
              do {
                if (!node) {
                  throw $compileMinErr('uterdir', "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                }
                if (node.nodeType == NODE_TYPE_ELEMENT) {
                  if (node.hasAttribute(attrStart))
                    depth++;
                  if (node.hasAttribute(attrEnd))
                    depth--;
                }
                nodes.push(node);
                node = node.nextSibling;
              } while (depth > 0);
            } else {
              nodes.push(node);
            }
            return jqLite(nodes);
          }
          function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
            return function groupedElementsLink(scope, element, attrs, controllers, transcludeFn) {
              element = groupScan(element[0], attrStart, attrEnd);
              return linkFn(scope, element, attrs, controllers, transcludeFn);
            };
          }
          function compilationGenerator(eager, $compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
            var compiled;
            if (eager) {
              return compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext);
            }
            return function lazyCompilation() {
              if (!compiled) {
                compiled = compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext);
                $compileNodes = transcludeFn = previousCompileContext = null;
              }
              return compiled.apply(this, arguments);
            };
          }
          function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
            previousCompileContext = previousCompileContext || {};
            var terminalPriority = -Number.MAX_VALUE,
                newScopeDirective = previousCompileContext.newScopeDirective,
                controllerDirectives = previousCompileContext.controllerDirectives,
                newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective,
                templateDirective = previousCompileContext.templateDirective,
                nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective,
                hasTranscludeDirective = false,
                hasTemplate = false,
                hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective,
                $compileNode = templateAttrs.$$element = jqLite(compileNode),
                directive,
                directiveName,
                $template,
                replaceDirective = originalReplaceDirective,
                childTranscludeFn = transcludeFn,
                linkFn,
                didScanForMultipleTransclusion = false,
                mightHaveMultipleTransclusionError = false,
                directiveValue;
            for (var i = 0,
                ii = directives.length; i < ii; i++) {
              directive = directives[i];
              var attrStart = directive.$$start;
              var attrEnd = directive.$$end;
              if (attrStart) {
                $compileNode = groupScan(compileNode, attrStart, attrEnd);
              }
              $template = undefined;
              if (terminalPriority > directive.priority) {
                break;
              }
              if (directiveValue = directive.scope) {
                if (!directive.templateUrl) {
                  if (isObject(directiveValue)) {
                    assertNoDuplicate('new/isolated scope', newIsolateScopeDirective || newScopeDirective, directive, $compileNode);
                    newIsolateScopeDirective = directive;
                  } else {
                    assertNoDuplicate('new/isolated scope', newIsolateScopeDirective, directive, $compileNode);
                  }
                }
                newScopeDirective = newScopeDirective || directive;
              }
              directiveName = directive.name;
              if (!didScanForMultipleTransclusion && ((directive.replace && (directive.templateUrl || directive.template)) || (directive.transclude && !directive.$$tlb))) {
                var candidateDirective;
                for (var scanningIndex = i + 1; candidateDirective = directives[scanningIndex++]; ) {
                  if ((candidateDirective.transclude && !candidateDirective.$$tlb) || (candidateDirective.replace && (candidateDirective.templateUrl || candidateDirective.template))) {
                    mightHaveMultipleTransclusionError = true;
                    break;
                  }
                }
                didScanForMultipleTransclusion = true;
              }
              if (!directive.templateUrl && directive.controller) {
                directiveValue = directive.controller;
                controllerDirectives = controllerDirectives || createMap();
                assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode);
                controllerDirectives[directiveName] = directive;
              }
              if (directiveValue = directive.transclude) {
                hasTranscludeDirective = true;
                if (!directive.$$tlb) {
                  assertNoDuplicate('transclusion', nonTlbTranscludeDirective, directive, $compileNode);
                  nonTlbTranscludeDirective = directive;
                }
                if (directiveValue == 'element') {
                  hasElementTranscludeDirective = true;
                  terminalPriority = directive.priority;
                  $template = $compileNode;
                  $compileNode = templateAttrs.$$element = jqLite(compile.$$createComment(directiveName, templateAttrs[directiveName]));
                  compileNode = $compileNode[0];
                  replaceWith(jqCollection, sliceArgs($template), compileNode);
                  $template[0].$$parentNode = $template[0].parentNode;
                  childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {nonTlbTranscludeDirective: nonTlbTranscludeDirective});
                } else {
                  var slots = createMap();
                  $template = jqLite(jqLiteClone(compileNode)).contents();
                  if (isObject(directiveValue)) {
                    $template = [];
                    var slotMap = createMap();
                    var filledSlots = createMap();
                    forEach(directiveValue, function(elementSelector, slotName) {
                      var optional = (elementSelector.charAt(0) === '?');
                      elementSelector = optional ? elementSelector.substring(1) : elementSelector;
                      slotMap[elementSelector] = slotName;
                      slots[slotName] = null;
                      filledSlots[slotName] = optional;
                    });
                    forEach($compileNode.contents(), function(node) {
                      var slotName = slotMap[directiveNormalize(nodeName_(node))];
                      if (slotName) {
                        filledSlots[slotName] = true;
                        slots[slotName] = slots[slotName] || [];
                        slots[slotName].push(node);
                      } else {
                        $template.push(node);
                      }
                    });
                    forEach(filledSlots, function(filled, slotName) {
                      if (!filled) {
                        throw $compileMinErr('reqslot', 'Required transclusion slot `{0}` was not filled.', slotName);
                      }
                    });
                    for (var slotName in slots) {
                      if (slots[slotName]) {
                        slots[slotName] = compilationGenerator(mightHaveMultipleTransclusionError, slots[slotName], transcludeFn);
                      }
                    }
                  }
                  $compileNode.empty();
                  childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, undefined, undefined, {needsNewScope: directive.$$isolateScope || directive.$$newScope});
                  childTranscludeFn.$$slots = slots;
                }
              }
              if (directive.template) {
                hasTemplate = true;
                assertNoDuplicate('template', templateDirective, directive, $compileNode);
                templateDirective = directive;
                directiveValue = (isFunction(directive.template)) ? directive.template($compileNode, templateAttrs) : directive.template;
                directiveValue = denormalizeTemplate(directiveValue);
                if (directive.replace) {
                  replaceDirective = directive;
                  if (jqLiteIsTextNode(directiveValue)) {
                    $template = [];
                  } else {
                    $template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));
                  }
                  compileNode = $template[0];
                  if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                    throw $compileMinErr('tplrt', "Template for directive '{0}' must have exactly one root element. {1}", directiveName, '');
                  }
                  replaceWith(jqCollection, $compileNode, compileNode);
                  var newTemplateAttrs = {$attr: {}};
                  var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
                  var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                  if (newIsolateScopeDirective || newScopeDirective) {
                    markDirectiveScope(templateDirectives, newIsolateScopeDirective, newScopeDirective);
                  }
                  directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
                  mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                  ii = directives.length;
                } else {
                  $compileNode.html(directiveValue);
                }
              }
              if (directive.templateUrl) {
                hasTemplate = true;
                assertNoDuplicate('template', templateDirective, directive, $compileNode);
                templateDirective = directive;
                if (directive.replace) {
                  replaceDirective = directive;
                }
                nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                  controllerDirectives: controllerDirectives,
                  newScopeDirective: (newScopeDirective !== directive) && newScopeDirective,
                  newIsolateScopeDirective: newIsolateScopeDirective,
                  templateDirective: templateDirective,
                  nonTlbTranscludeDirective: nonTlbTranscludeDirective
                });
                ii = directives.length;
              } else if (directive.compile) {
                try {
                  linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                  var context = directive.$$originalDirective || directive;
                  if (isFunction(linkFn)) {
                    addLinkFns(null, bind(context, linkFn), attrStart, attrEnd);
                  } else if (linkFn) {
                    addLinkFns(bind(context, linkFn.pre), bind(context, linkFn.post), attrStart, attrEnd);
                  }
                } catch (e) {
                  $exceptionHandler(e, startingTag($compileNode));
                }
              }
              if (directive.terminal) {
                nodeLinkFn.terminal = true;
                terminalPriority = Math.max(terminalPriority, directive.priority);
              }
            }
            nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === true;
            nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
            nodeLinkFn.templateOnThisElement = hasTemplate;
            nodeLinkFn.transclude = childTranscludeFn;
            previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;
            return nodeLinkFn;
            function addLinkFns(pre, post, attrStart, attrEnd) {
              if (pre) {
                if (attrStart)
                  pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
                pre.require = directive.require;
                pre.directiveName = directiveName;
                if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                  pre = cloneAndAnnotateFn(pre, {isolateScope: true});
                }
                preLinkFns.push(pre);
              }
              if (post) {
                if (attrStart)
                  post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
                post.require = directive.require;
                post.directiveName = directiveName;
                if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                  post = cloneAndAnnotateFn(post, {isolateScope: true});
                }
                postLinkFns.push(post);
              }
            }
            function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
              var i,
                  ii,
                  linkFn,
                  isolateScope,
                  controllerScope,
                  elementControllers,
                  transcludeFn,
                  $element,
                  attrs,
                  scopeBindingInfo;
              if (compileNode === linkNode) {
                attrs = templateAttrs;
                $element = templateAttrs.$$element;
              } else {
                $element = jqLite(linkNode);
                attrs = new Attributes($element, templateAttrs);
              }
              controllerScope = scope;
              if (newIsolateScopeDirective) {
                isolateScope = scope.$new(true);
              } else if (newScopeDirective) {
                controllerScope = scope.$parent;
              }
              if (boundTranscludeFn) {
                transcludeFn = controllersBoundTransclude;
                transcludeFn.$$boundTransclude = boundTranscludeFn;
                transcludeFn.isSlotFilled = function(slotName) {
                  return !!boundTranscludeFn.$$slots[slotName];
                };
              }
              if (controllerDirectives) {
                elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective);
              }
              if (newIsolateScopeDirective) {
                compile.$$addScopeInfo($element, isolateScope, true, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective)));
                compile.$$addScopeClass($element, true);
                isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings;
                scopeBindingInfo = initializeDirectiveBindings(scope, attrs, isolateScope, isolateScope.$$isolateBindings, newIsolateScopeDirective);
                if (scopeBindingInfo.removeWatches) {
                  isolateScope.$on('$destroy', scopeBindingInfo.removeWatches);
                }
              }
              for (var name in elementControllers) {
                var controllerDirective = controllerDirectives[name];
                var controller = elementControllers[name];
                var bindings = controllerDirective.$$bindings.bindToController;
                if (controller.identifier && bindings) {
                  controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                } else {
                  controller.bindingInfo = {};
                }
                var controllerResult = controller();
                if (controllerResult !== controller.instance) {
                  controller.instance = controllerResult;
                  $element.data('$' + controllerDirective.name + 'Controller', controllerResult);
                  controller.bindingInfo.removeWatches && controller.bindingInfo.removeWatches();
                  controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                }
              }
              forEach(controllerDirectives, function(controllerDirective, name) {
                var require = controllerDirective.require;
                if (controllerDirective.bindToController && !isArray(require) && isObject(require)) {
                  extend(elementControllers[name].instance, getControllers(name, require, $element, elementControllers));
                }
              });
              forEach(elementControllers, function(controller) {
                var controllerInstance = controller.instance;
                if (isFunction(controllerInstance.$onChanges)) {
                  try {
                    controllerInstance.$onChanges(controller.bindingInfo.initialChanges);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (isFunction(controllerInstance.$onInit)) {
                  try {
                    controllerInstance.$onInit();
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (isFunction(controllerInstance.$onDestroy)) {
                  controllerScope.$on('$destroy', function callOnDestroyHook() {
                    controllerInstance.$onDestroy();
                  });
                }
              });
              for (i = 0, ii = preLinkFns.length; i < ii; i++) {
                linkFn = preLinkFns[i];
                invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
              }
              var scopeToChild = scope;
              if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
                scopeToChild = isolateScope;
              }
              childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);
              for (i = postLinkFns.length - 1; i >= 0; i--) {
                linkFn = postLinkFns[i];
                invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
              }
              forEach(elementControllers, function(controller) {
                var controllerInstance = controller.instance;
                if (isFunction(controllerInstance.$postLink)) {
                  controllerInstance.$postLink();
                }
              });
              function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement, slotName) {
                var transcludeControllers;
                if (!isScope(scope)) {
                  slotName = futureParentElement;
                  futureParentElement = cloneAttachFn;
                  cloneAttachFn = scope;
                  scope = undefined;
                }
                if (hasElementTranscludeDirective) {
                  transcludeControllers = elementControllers;
                }
                if (!futureParentElement) {
                  futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element;
                }
                if (slotName) {
                  var slotTranscludeFn = boundTranscludeFn.$$slots[slotName];
                  if (slotTranscludeFn) {
                    return slotTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                  } else if (isUndefined(slotTranscludeFn)) {
                    throw $compileMinErr('noslot', 'No parent directive that requires a transclusion with slot name "{0}". ' + 'Element: {1}', slotName, startingTag($element));
                  }
                } else {
                  return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                }
              }
            }
          }
          function getControllers(directiveName, require, $element, elementControllers) {
            var value;
            if (isString(require)) {
              var match = require.match(REQUIRE_PREFIX_REGEXP);
              var name = require.substring(match[0].length);
              var inheritType = match[1] || match[3];
              var optional = match[2] === '?';
              if (inheritType === '^^') {
                $element = $element.parent();
              } else {
                value = elementControllers && elementControllers[name];
                value = value && value.instance;
              }
              if (!value) {
                var dataName = '$' + name + 'Controller';
                value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
              }
              if (!value && !optional) {
                throw $compileMinErr('ctreq', "Controller '{0}', required by directive '{1}', can't be found!", name, directiveName);
              }
            } else if (isArray(require)) {
              value = [];
              for (var i = 0,
                  ii = require.length; i < ii; i++) {
                value[i] = getControllers(directiveName, require[i], $element, elementControllers);
              }
            } else if (isObject(require)) {
              value = {};
              forEach(require, function(controller, property) {
                value[property] = getControllers(directiveName, controller, $element, elementControllers);
              });
            }
            return value || null;
          }
          function setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective) {
            var elementControllers = createMap();
            for (var controllerKey in controllerDirectives) {
              var directive = controllerDirectives[controllerKey];
              var locals = {
                $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                $element: $element,
                $attrs: attrs,
                $transclude: transcludeFn
              };
              var controller = directive.controller;
              if (controller == '@') {
                controller = attrs[directive.name];
              }
              var controllerInstance = $controller(controller, locals, true, directive.controllerAs);
              elementControllers[directive.name] = controllerInstance;
              $element.data('$' + directive.name + 'Controller', controllerInstance.instance);
            }
            return elementControllers;
          }
          function markDirectiveScope(directives, isolateScope, newScope) {
            for (var j = 0,
                jj = directives.length; j < jj; j++) {
              directives[j] = inherit(directives[j], {
                $$isolateScope: isolateScope,
                $$newScope: newScope
              });
            }
          }
          function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
            if (name === ignoreDirective)
              return null;
            var match = null;
            if (hasDirectives.hasOwnProperty(name)) {
              for (var directive,
                  directives = $injector.get(name + Suffix),
                  i = 0,
                  ii = directives.length; i < ii; i++) {
                try {
                  directive = directives[i];
                  if ((isUndefined(maxPriority) || maxPriority > directive.priority) && directive.restrict.indexOf(location) != -1) {
                    if (startAttrName) {
                      directive = inherit(directive, {
                        $$start: startAttrName,
                        $$end: endAttrName
                      });
                    }
                    if (!directive.$$bindings) {
                      var bindings = directive.$$bindings = parseDirectiveBindings(directive, directive.name);
                      if (isObject(bindings.isolateScope)) {
                        directive.$$isolateBindings = bindings.isolateScope;
                      }
                    }
                    tDirectives.push(directive);
                    match = directive;
                  }
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
            }
            return match;
          }
          function directiveIsMultiElement(name) {
            if (hasDirectives.hasOwnProperty(name)) {
              for (var directive,
                  directives = $injector.get(name + Suffix),
                  i = 0,
                  ii = directives.length; i < ii; i++) {
                directive = directives[i];
                if (directive.multiElement) {
                  return true;
                }
              }
            }
            return false;
          }
          function mergeTemplateAttributes(dst, src) {
            var srcAttr = src.$attr,
                dstAttr = dst.$attr,
                $element = dst.$$element;
            forEach(dst, function(value, key) {
              if (key.charAt(0) != '$') {
                if (src[key] && src[key] !== value) {
                  value += (key === 'style' ? ';' : ' ') + src[key];
                }
                dst.$set(key, value, true, srcAttr[key]);
              }
            });
            forEach(src, function(value, key) {
              if (!dst.hasOwnProperty(key) && key.charAt(0) !== '$') {
                dst[key] = value;
                if (key !== 'class' && key !== 'style') {
                  dstAttr[key] = srcAttr[key];
                }
              }
            });
          }
          function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
            var linkQueue = [],
                afterTemplateNodeLinkFn,
                afterTemplateChildLinkFn,
                beforeTemplateCompileNode = $compileNode[0],
                origAsyncDirective = directives.shift(),
                derivedSyncDirective = inherit(origAsyncDirective, {
                  templateUrl: null,
                  transclude: null,
                  replace: null,
                  $$originalDirective: origAsyncDirective
                }),
                templateUrl = (isFunction(origAsyncDirective.templateUrl)) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl,
                templateNamespace = origAsyncDirective.templateNamespace;
            $compileNode.empty();
            $templateRequest(templateUrl).then(function(content) {
              var compileNode,
                  tempTemplateAttrs,
                  $template,
                  childBoundTranscludeFn;
              content = denormalizeTemplate(content);
              if (origAsyncDirective.replace) {
                if (jqLiteIsTextNode(content)) {
                  $template = [];
                } else {
                  $template = removeComments(wrapTemplate(templateNamespace, trim(content)));
                }
                compileNode = $template[0];
                if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                  throw $compileMinErr('tplrt', "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                }
                tempTemplateAttrs = {$attr: {}};
                replaceWith($rootElement, $compileNode, compileNode);
                var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                if (isObject(origAsyncDirective.scope)) {
                  markDirectiveScope(templateDirectives, true);
                }
                directives = templateDirectives.concat(directives);
                mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
              } else {
                compileNode = beforeTemplateCompileNode;
                $compileNode.html(content);
              }
              directives.unshift(derivedSyncDirective);
              afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext);
              forEach($rootElement, function(node, i) {
                if (node == compileNode) {
                  $rootElement[i] = $compileNode[0];
                }
              });
              afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
              while (linkQueue.length) {
                var scope = linkQueue.shift(),
                    beforeTemplateLinkNode = linkQueue.shift(),
                    linkRootElement = linkQueue.shift(),
                    boundTranscludeFn = linkQueue.shift(),
                    linkNode = $compileNode[0];
                if (scope.$$destroyed)
                  continue;
                if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                  var oldClasses = beforeTemplateLinkNode.className;
                  if (!(previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace)) {
                    linkNode = jqLiteClone(compileNode);
                  }
                  replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
                  safeAddClass(jqLite(linkNode), oldClasses);
                }
                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                  childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                } else {
                  childBoundTranscludeFn = boundTranscludeFn;
                }
                afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn);
              }
              linkQueue = null;
            });
            return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
              var childBoundTranscludeFn = boundTranscludeFn;
              if (scope.$$destroyed)
                return;
              if (linkQueue) {
                linkQueue.push(scope, node, rootElement, childBoundTranscludeFn);
              } else {
                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                  childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                }
                afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn);
              }
            };
          }
          function byPriority(a, b) {
            var diff = b.priority - a.priority;
            if (diff !== 0)
              return diff;
            if (a.name !== b.name)
              return (a.name < b.name) ? -1 : 1;
            return a.index - b.index;
          }
          function assertNoDuplicate(what, previousDirective, directive, element) {
            function wrapModuleNameIfDefined(moduleName) {
              return moduleName ? (' (module: ' + moduleName + ')') : '';
            }
            if (previousDirective) {
              throw $compileMinErr('multidir', 'Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}', previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName), directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element));
            }
          }
          function addTextInterpolateDirective(directives, text) {
            var interpolateFn = $interpolate(text, true);
            if (interpolateFn) {
              directives.push({
                priority: 0,
                compile: function textInterpolateCompileFn(templateNode) {
                  var templateNodeParent = templateNode.parent(),
                      hasCompileParent = !!templateNodeParent.length;
                  if (hasCompileParent)
                    compile.$$addBindingClass(templateNodeParent);
                  return function textInterpolateLinkFn(scope, node) {
                    var parent = node.parent();
                    if (!hasCompileParent)
                      compile.$$addBindingClass(parent);
                    compile.$$addBindingInfo(parent, interpolateFn.expressions);
                    scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                      node[0].nodeValue = value;
                    });
                  };
                }
              });
            }
          }
          function wrapTemplate(type, template) {
            type = lowercase(type || 'html');
            switch (type) {
              case 'svg':
              case 'math':
                var wrapper = window.document.createElement('div');
                wrapper.innerHTML = '<' + type + '>' + template + '</' + type + '>';
                return wrapper.childNodes[0].childNodes;
              default:
                return template;
            }
          }
          function getTrustedContext(node, attrNormalizedName) {
            if (attrNormalizedName == "srcdoc") {
              return $sce.HTML;
            }
            var tag = nodeName_(node);
            if (attrNormalizedName == "xlinkHref" || (tag == "form" && attrNormalizedName == "action") || (tag != "img" && (attrNormalizedName == "src" || attrNormalizedName == "ngSrc"))) {
              return $sce.RESOURCE_URL;
            }
          }
          function addAttrInterpolateDirective(node, directives, value, name, allOrNothing) {
            var trustedContext = getTrustedContext(node, name);
            allOrNothing = ALL_OR_NOTHING_ATTRS[name] || allOrNothing;
            var interpolateFn = $interpolate(value, true, trustedContext, allOrNothing);
            if (!interpolateFn)
              return;
            if (name === "multiple" && nodeName_(node) === "select") {
              throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
            }
            directives.push({
              priority: 100,
              compile: function() {
                return {pre: function attrInterpolatePreLinkFn(scope, element, attr) {
                    var $$observers = (attr.$$observers || (attr.$$observers = createMap()));
                    if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
                      throw $compileMinErr('nodomevents', "Interpolations for HTML DOM event attributes are disallowed.  Please use the " + "ng- versions (such as ng-click instead of onclick) instead.");
                    }
                    var newValue = attr[name];
                    if (newValue !== value) {
                      interpolateFn = newValue && $interpolate(newValue, true, trustedContext, allOrNothing);
                      value = newValue;
                    }
                    if (!interpolateFn)
                      return;
                    attr[name] = interpolateFn(scope);
                    ($$observers[name] || ($$observers[name] = [])).$$inter = true;
                    (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {
                      if (name === 'class' && newValue != oldValue) {
                        attr.$updateClass(newValue, oldValue);
                      } else {
                        attr.$set(name, newValue);
                      }
                    });
                  }};
              }
            });
          }
          function replaceWith($rootElement, elementsToRemove, newNode) {
            var firstElementToRemove = elementsToRemove[0],
                removeCount = elementsToRemove.length,
                parent = firstElementToRemove.parentNode,
                i,
                ii;
            if ($rootElement) {
              for (i = 0, ii = $rootElement.length; i < ii; i++) {
                if ($rootElement[i] == firstElementToRemove) {
                  $rootElement[i++] = newNode;
                  for (var j = i,
                      j2 = j + removeCount - 1,
                      jj = $rootElement.length; j < jj; j++, j2++) {
                    if (j2 < jj) {
                      $rootElement[j] = $rootElement[j2];
                    } else {
                      delete $rootElement[j];
                    }
                  }
                  $rootElement.length -= removeCount - 1;
                  if ($rootElement.context === firstElementToRemove) {
                    $rootElement.context = newNode;
                  }
                  break;
                }
              }
            }
            if (parent) {
              parent.replaceChild(newNode, firstElementToRemove);
            }
            var fragment = window.document.createDocumentFragment();
            for (i = 0; i < removeCount; i++) {
              fragment.appendChild(elementsToRemove[i]);
            }
            if (jqLite.hasData(firstElementToRemove)) {
              jqLite.data(newNode, jqLite.data(firstElementToRemove));
              jqLite(firstElementToRemove).off('$destroy');
            }
            jqLite.cleanData(fragment.querySelectorAll('*'));
            for (i = 1; i < removeCount; i++) {
              delete elementsToRemove[i];
            }
            elementsToRemove[0] = newNode;
            elementsToRemove.length = 1;
          }
          function cloneAndAnnotateFn(fn, annotation) {
            return extend(function() {
              return fn.apply(null, arguments);
            }, fn, annotation);
          }
          function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
            try {
              linkFn(scope, $element, attrs, controllers, transcludeFn);
            } catch (e) {
              $exceptionHandler(e, startingTag($element));
            }
          }
          function initializeDirectiveBindings(scope, attrs, destination, bindings, directive) {
            var removeWatchCollection = [];
            var initialChanges = {};
            var changes;
            forEach(bindings, function initializeBinding(definition, scopeName) {
              var attrName = definition.attrName,
                  optional = definition.optional,
                  mode = definition.mode,
                  lastValue,
                  parentGet,
                  parentSet,
                  compare,
                  removeWatch;
              switch (mode) {
                case '@':
                  if (!optional && !hasOwnProperty.call(attrs, attrName)) {
                    destination[scopeName] = attrs[attrName] = void 0;
                  }
                  attrs.$observe(attrName, function(value) {
                    if (isString(value) || isBoolean(value)) {
                      var oldValue = destination[scopeName];
                      recordChanges(scopeName, value, oldValue);
                      destination[scopeName] = value;
                    }
                  });
                  attrs.$$observers[attrName].$$scope = scope;
                  lastValue = attrs[attrName];
                  if (isString(lastValue)) {
                    destination[scopeName] = $interpolate(lastValue)(scope);
                  } else if (isBoolean(lastValue)) {
                    destination[scopeName] = lastValue;
                  }
                  initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]);
                  break;
                case '=':
                  if (!hasOwnProperty.call(attrs, attrName)) {
                    if (optional)
                      break;
                    attrs[attrName] = void 0;
                  }
                  if (optional && !attrs[attrName])
                    break;
                  parentGet = $parse(attrs[attrName]);
                  if (parentGet.literal) {
                    compare = equals;
                  } else {
                    compare = function simpleCompare(a, b) {
                      return a === b || (a !== a && b !== b);
                    };
                  }
                  parentSet = parentGet.assign || function() {
                    lastValue = destination[scopeName] = parentGet(scope);
                    throw $compileMinErr('nonassign', "Expression '{0}' in attribute '{1}' used with directive '{2}' is non-assignable!", attrs[attrName], attrName, directive.name);
                  };
                  lastValue = destination[scopeName] = parentGet(scope);
                  var parentValueWatch = function parentValueWatch(parentValue) {
                    if (!compare(parentValue, destination[scopeName])) {
                      if (!compare(parentValue, lastValue)) {
                        destination[scopeName] = parentValue;
                      } else {
                        parentSet(scope, parentValue = destination[scopeName]);
                      }
                    }
                    return lastValue = parentValue;
                  };
                  parentValueWatch.$stateful = true;
                  if (definition.collection) {
                    removeWatch = scope.$watchCollection(attrs[attrName], parentValueWatch);
                  } else {
                    removeWatch = scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal);
                  }
                  removeWatchCollection.push(removeWatch);
                  break;
                case '<':
                  if (!hasOwnProperty.call(attrs, attrName)) {
                    if (optional)
                      break;
                    attrs[attrName] = void 0;
                  }
                  if (optional && !attrs[attrName])
                    break;
                  parentGet = $parse(attrs[attrName]);
                  var initialValue = destination[scopeName] = parentGet(scope);
                  initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]);
                  removeWatch = scope.$watch(parentGet, function parentValueWatchAction(newValue, oldValue) {
                    if (oldValue === newValue) {
                      if (oldValue === initialValue)
                        return;
                      oldValue = initialValue;
                    }
                    recordChanges(scopeName, newValue, oldValue);
                    destination[scopeName] = newValue;
                  }, parentGet.literal);
                  removeWatchCollection.push(removeWatch);
                  break;
                case '&':
                  parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop;
                  if (parentGet === noop && optional)
                    break;
                  destination[scopeName] = function(locals) {
                    return parentGet(scope, locals);
                  };
                  break;
              }
            });
            function recordChanges(key, currentValue, previousValue) {
              if (isFunction(destination.$onChanges) && currentValue !== previousValue) {
                if (!onChangesQueue) {
                  scope.$$postDigest(flushOnChangesQueue);
                  onChangesQueue = [];
                }
                if (!changes) {
                  changes = {};
                  onChangesQueue.push(triggerOnChangesHook);
                }
                if (changes[key]) {
                  previousValue = changes[key].previousValue;
                }
                changes[key] = new SimpleChange(previousValue, currentValue);
              }
            }
            function triggerOnChangesHook() {
              destination.$onChanges(changes);
              changes = undefined;
            }
            return {
              initialChanges: initialChanges,
              removeWatches: removeWatchCollection.length && function removeWatches() {
                for (var i = 0,
                    ii = removeWatchCollection.length; i < ii; ++i) {
                  removeWatchCollection[i]();
                }
              }
            };
          }
        }];
      }
      function SimpleChange(previous, current) {
        this.previousValue = previous;
        this.currentValue = current;
      }
      SimpleChange.prototype.isFirstChange = function() {
        return this.previousValue === _UNINITIALIZED_VALUE;
      };
      var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i;
      function directiveNormalize(name) {
        return camelCase(name.replace(PREFIX_REGEXP, ''));
      }
      function nodesetLinkingFn(scope, nodeList, rootElement, boundTranscludeFn) {}
      function directiveLinkingFn(nodesetLinkingFn, scope, node, rootElement, boundTranscludeFn) {}
      function tokenDifference(str1, str2) {
        var values = '',
            tokens1 = str1.split(/\s+/),
            tokens2 = str2.split(/\s+/);
        outer: for (var i = 0; i < tokens1.length; i++) {
          var token = tokens1[i];
          for (var j = 0; j < tokens2.length; j++) {
            if (token == tokens2[j])
              continue outer;
          }
          values += (values.length > 0 ? ' ' : '') + token;
        }
        return values;
      }
      function removeComments(jqNodes) {
        jqNodes = jqLite(jqNodes);
        var i = jqNodes.length;
        if (i <= 1) {
          return jqNodes;
        }
        while (i--) {
          var node = jqNodes[i];
          if (node.nodeType === NODE_TYPE_COMMENT) {
            splice.call(jqNodes, i, 1);
          }
        }
        return jqNodes;
      }
      var $controllerMinErr = minErr('$controller');
      var CNTRL_REG = /^(\S+)(\s+as\s+([\w$]+))?$/;
      function identifierForController(controller, ident) {
        if (ident && isString(ident))
          return ident;
        if (isString(controller)) {
          var match = CNTRL_REG.exec(controller);
          if (match)
            return match[3];
        }
      }
      function $ControllerProvider() {
        var controllers = {},
            globals = false;
        this.has = function(name) {
          return controllers.hasOwnProperty(name);
        };
        this.register = function(name, constructor) {
          assertNotHasOwnProperty(name, 'controller');
          if (isObject(name)) {
            extend(controllers, name);
          } else {
            controllers[name] = constructor;
          }
        };
        this.allowGlobals = function() {
          globals = true;
        };
        this.$get = ['$injector', '$window', function($injector, $window) {
          return function $controller(expression, locals, later, ident) {
            var instance,
                match,
                constructor,
                identifier;
            later = later === true;
            if (ident && isString(ident)) {
              identifier = ident;
            }
            if (isString(expression)) {
              match = expression.match(CNTRL_REG);
              if (!match) {
                throw $controllerMinErr('ctrlfmt', "Badly formed controller string '{0}'. " + "Must match `__name__ as __id__` or `__name__`.", expression);
              }
              constructor = match[1], identifier = identifier || match[3];
              expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, true) || (globals ? getter($window, constructor, true) : undefined);
              assertArgFn(expression, constructor, true);
            }
            if (later) {
              var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
              instance = Object.create(controllerPrototype || null);
              if (identifier) {
                addIdentifier(locals, identifier, instance, constructor || expression.name);
              }
              var instantiate;
              return instantiate = extend(function $controllerInit() {
                var result = $injector.invoke(expression, instance, locals, constructor);
                if (result !== instance && (isObject(result) || isFunction(result))) {
                  instance = result;
                  if (identifier) {
                    addIdentifier(locals, identifier, instance, constructor || expression.name);
                  }
                }
                return instance;
              }, {
                instance: instance,
                identifier: identifier
              });
            }
            instance = $injector.instantiate(expression, locals, constructor);
            if (identifier) {
              addIdentifier(locals, identifier, instance, constructor || expression.name);
            }
            return instance;
          };
          function addIdentifier(locals, identifier, instance, name) {
            if (!(locals && isObject(locals.$scope))) {
              throw minErr('$controller')('noscp', "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", name, identifier);
            }
            locals.$scope[identifier] = instance;
          }
        }];
      }
      function $DocumentProvider() {
        this.$get = ['$window', function(window) {
          return jqLite(window.document);
        }];
      }
      function $ExceptionHandlerProvider() {
        this.$get = ['$log', function($log) {
          return function(exception, cause) {
            $log.error.apply($log, arguments);
          };
        }];
      }
      var $$ForceReflowProvider = function() {
        this.$get = ['$document', function($document) {
          return function(domNode) {
            if (domNode) {
              if (!domNode.nodeType && domNode instanceof jqLite) {
                domNode = domNode[0];
              }
            } else {
              domNode = $document[0].body;
            }
            return domNode.offsetWidth + 1;
          };
        }];
      };
      var APPLICATION_JSON = 'application/json';
      var CONTENT_TYPE_APPLICATION_JSON = {'Content-Type': APPLICATION_JSON + ';charset=utf-8'};
      var JSON_START = /^\[|^\{(?!\{)/;
      var JSON_ENDS = {
        '[': /]$/,
        '{': /}$/
      };
      var JSON_PROTECTION_PREFIX = /^\)\]\}',?\n/;
      var $httpMinErr = minErr('$http');
      var $httpMinErrLegacyFn = function(method) {
        return function() {
          throw $httpMinErr('legacy', 'The method `{0}` on the promise returned from `$http` has been disabled.', method);
        };
      };
      function serializeValue(v) {
        if (isObject(v)) {
          return isDate(v) ? v.toISOString() : toJson(v);
        }
        return v;
      }
      function $HttpParamSerializerProvider() {
        this.$get = function() {
          return function ngParamSerializer(params) {
            if (!params)
              return '';
            var parts = [];
            forEachSorted(params, function(value, key) {
              if (value === null || isUndefined(value))
                return;
              if (isArray(value)) {
                forEach(value, function(v) {
                  parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(v)));
                });
              } else {
                parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(value)));
              }
            });
            return parts.join('&');
          };
        };
      }
      function $HttpParamSerializerJQLikeProvider() {
        this.$get = function() {
          return function jQueryLikeParamSerializer(params) {
            if (!params)
              return '';
            var parts = [];
            serialize(params, '', true);
            return parts.join('&');
            function serialize(toSerialize, prefix, topLevel) {
              if (toSerialize === null || isUndefined(toSerialize))
                return;
              if (isArray(toSerialize)) {
                forEach(toSerialize, function(value, index) {
                  serialize(value, prefix + '[' + (isObject(value) ? index : '') + ']');
                });
              } else if (isObject(toSerialize) && !isDate(toSerialize)) {
                forEachSorted(toSerialize, function(value, key) {
                  serialize(value, prefix + (topLevel ? '' : '[') + key + (topLevel ? '' : ']'));
                });
              } else {
                parts.push(encodeUriQuery(prefix) + '=' + encodeUriQuery(serializeValue(toSerialize)));
              }
            }
          };
        };
      }
      function defaultHttpResponseTransform(data, headers) {
        if (isString(data)) {
          var tempData = data.replace(JSON_PROTECTION_PREFIX, '').trim();
          if (tempData) {
            var contentType = headers('Content-Type');
            if ((contentType && (contentType.indexOf(APPLICATION_JSON) === 0)) || isJsonLike(tempData)) {
              data = fromJson(tempData);
            }
          }
        }
        return data;
      }
      function isJsonLike(str) {
        var jsonStart = str.match(JSON_START);
        return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
      }
      function parseHeaders(headers) {
        var parsed = createMap(),
            i;
        function fillInParsed(key, val) {
          if (key) {
            parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
          }
        }
        if (isString(headers)) {
          forEach(headers.split('\n'), function(line) {
            i = line.indexOf(':');
            fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));
          });
        } else if (isObject(headers)) {
          forEach(headers, function(headerVal, headerKey) {
            fillInParsed(lowercase(headerKey), trim(headerVal));
          });
        }
        return parsed;
      }
      function headersGetter(headers) {
        var headersObj;
        return function(name) {
          if (!headersObj)
            headersObj = parseHeaders(headers);
          if (name) {
            var value = headersObj[lowercase(name)];
            if (value === void 0) {
              value = null;
            }
            return value;
          }
          return headersObj;
        };
      }
      function transformData(data, headers, status, fns) {
        if (isFunction(fns)) {
          return fns(data, headers, status);
        }
        forEach(fns, function(fn) {
          data = fn(data, headers, status);
        });
        return data;
      }
      function isSuccess(status) {
        return 200 <= status && status < 300;
      }
      function $HttpProvider() {
        var defaults = this.defaults = {
          transformResponse: [defaultHttpResponseTransform],
          transformRequest: [function(d) {
            return isObject(d) && !isFile(d) && !isBlob(d) && !isFormData(d) ? toJson(d) : d;
          }],
          headers: {
            common: {'Accept': 'application/json, text/plain, */*'},
            post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
            put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
            patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
          },
          xsrfCookieName: 'XSRF-TOKEN',
          xsrfHeaderName: 'X-XSRF-TOKEN',
          paramSerializer: '$httpParamSerializer'
        };
        var useApplyAsync = false;
        this.useApplyAsync = function(value) {
          if (isDefined(value)) {
            useApplyAsync = !!value;
            return this;
          }
          return useApplyAsync;
        };
        var useLegacyPromise = true;
        this.useLegacyPromiseExtensions = function(value) {
          if (isDefined(value)) {
            useLegacyPromise = !!value;
            return this;
          }
          return useLegacyPromise;
        };
        var interceptorFactories = this.interceptors = [];
        this.$get = ['$httpBackend', '$$cookieReader', '$cacheFactory', '$rootScope', '$q', '$injector', function($httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector) {
          var defaultCache = $cacheFactory('$http');
          defaults.paramSerializer = isString(defaults.paramSerializer) ? $injector.get(defaults.paramSerializer) : defaults.paramSerializer;
          var reversedInterceptors = [];
          forEach(interceptorFactories, function(interceptorFactory) {
            reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
          });
          function $http(requestConfig) {
            if (!isObject(requestConfig)) {
              throw minErr('$http')('badreq', 'Http request configuration must be an object.  Received: {0}', requestConfig);
            }
            if (!isString(requestConfig.url)) {
              throw minErr('$http')('badreq', 'Http request configuration url must be a string.  Received: {0}', requestConfig.url);
            }
            var config = extend({
              method: 'get',
              transformRequest: defaults.transformRequest,
              transformResponse: defaults.transformResponse,
              paramSerializer: defaults.paramSerializer
            }, requestConfig);
            config.headers = mergeHeaders(requestConfig);
            config.method = uppercase(config.method);
            config.paramSerializer = isString(config.paramSerializer) ? $injector.get(config.paramSerializer) : config.paramSerializer;
            var serverRequest = function(config) {
              var headers = config.headers;
              var reqData = transformData(config.data, headersGetter(headers), undefined, config.transformRequest);
              if (isUndefined(reqData)) {
                forEach(headers, function(value, header) {
                  if (lowercase(header) === 'content-type') {
                    delete headers[header];
                  }
                });
              }
              if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
                config.withCredentials = defaults.withCredentials;
              }
              return sendReq(config, reqData).then(transformResponse, transformResponse);
            };
            var chain = [serverRequest, undefined];
            var promise = $q.when(config);
            forEach(reversedInterceptors, function(interceptor) {
              if (interceptor.request || interceptor.requestError) {
                chain.unshift(interceptor.request, interceptor.requestError);
              }
              if (interceptor.response || interceptor.responseError) {
                chain.push(interceptor.response, interceptor.responseError);
              }
            });
            while (chain.length) {
              var thenFn = chain.shift();
              var rejectFn = chain.shift();
              promise = promise.then(thenFn, rejectFn);
            }
            if (useLegacyPromise) {
              promise.success = function(fn) {
                assertArgFn(fn, 'fn');
                promise.then(function(response) {
                  fn(response.data, response.status, response.headers, config);
                });
                return promise;
              };
              promise.error = function(fn) {
                assertArgFn(fn, 'fn');
                promise.then(null, function(response) {
                  fn(response.data, response.status, response.headers, config);
                });
                return promise;
              };
            } else {
              promise.success = $httpMinErrLegacyFn('success');
              promise.error = $httpMinErrLegacyFn('error');
            }
            return promise;
            function transformResponse(response) {
              var resp = extend({}, response);
              resp.data = transformData(response.data, response.headers, response.status, config.transformResponse);
              return (isSuccess(response.status)) ? resp : $q.reject(resp);
            }
            function executeHeaderFns(headers, config) {
              var headerContent,
                  processedHeaders = {};
              forEach(headers, function(headerFn, header) {
                if (isFunction(headerFn)) {
                  headerContent = headerFn(config);
                  if (headerContent != null) {
                    processedHeaders[header] = headerContent;
                  }
                } else {
                  processedHeaders[header] = headerFn;
                }
              });
              return processedHeaders;
            }
            function mergeHeaders(config) {
              var defHeaders = defaults.headers,
                  reqHeaders = extend({}, config.headers),
                  defHeaderName,
                  lowercaseDefHeaderName,
                  reqHeaderName;
              defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
              defaultHeadersIteration: for (defHeaderName in defHeaders) {
                lowercaseDefHeaderName = lowercase(defHeaderName);
                for (reqHeaderName in reqHeaders) {
                  if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
                    continue defaultHeadersIteration;
                  }
                }
                reqHeaders[defHeaderName] = defHeaders[defHeaderName];
              }
              return executeHeaderFns(reqHeaders, shallowCopy(config));
            }
          }
          $http.pendingRequests = [];
          createShortMethods('get', 'delete', 'head', 'jsonp');
          createShortMethodsWithData('post', 'put', 'patch');
          $http.defaults = defaults;
          return $http;
          function createShortMethods(names) {
            forEach(arguments, function(name) {
              $http[name] = function(url, config) {
                return $http(extend({}, config || {}, {
                  method: name,
                  url: url
                }));
              };
            });
          }
          function createShortMethodsWithData(name) {
            forEach(arguments, function(name) {
              $http[name] = function(url, data, config) {
                return $http(extend({}, config || {}, {
                  method: name,
                  url: url,
                  data: data
                }));
              };
            });
          }
          function sendReq(config, reqData) {
            var deferred = $q.defer(),
                promise = deferred.promise,
                cache,
                cachedResp,
                reqHeaders = config.headers,
                url = buildUrl(config.url, config.paramSerializer(config.params));
            $http.pendingRequests.push(config);
            promise.then(removePendingReq, removePendingReq);
            if ((config.cache || defaults.cache) && config.cache !== false && (config.method === 'GET' || config.method === 'JSONP')) {
              cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache;
            }
            if (cache) {
              cachedResp = cache.get(url);
              if (isDefined(cachedResp)) {
                if (isPromiseLike(cachedResp)) {
                  cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult);
                } else {
                  if (isArray(cachedResp)) {
                    resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]);
                  } else {
                    resolvePromise(cachedResp, 200, {}, 'OK');
                  }
                }
              } else {
                cache.put(url, promise);
              }
            }
            if (isUndefined(cachedResp)) {
              var xsrfValue = urlIsSameOrigin(config.url) ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined;
              if (xsrfValue) {
                reqHeaders[(config.xsrfHeaderName || defaults.xsrfHeaderName)] = xsrfValue;
              }
              $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType, createApplyHandlers(config.eventHandlers), createApplyHandlers(config.uploadEventHandlers));
            }
            return promise;
            function createApplyHandlers(eventHandlers) {
              if (eventHandlers) {
                var applyHandlers = {};
                forEach(eventHandlers, function(eventHandler, key) {
                  applyHandlers[key] = function(event) {
                    if (useApplyAsync) {
                      $rootScope.$applyAsync(callEventHandler);
                    } else if ($rootScope.$$phase) {
                      callEventHandler();
                    } else {
                      $rootScope.$apply(callEventHandler);
                    }
                    function callEventHandler() {
                      eventHandler(event);
                    }
                  };
                });
                return applyHandlers;
              }
            }
            function done(status, response, headersString, statusText) {
              if (cache) {
                if (isSuccess(status)) {
                  cache.put(url, [status, response, parseHeaders(headersString), statusText]);
                } else {
                  cache.remove(url);
                }
              }
              function resolveHttpPromise() {
                resolvePromise(response, status, headersString, statusText);
              }
              if (useApplyAsync) {
                $rootScope.$applyAsync(resolveHttpPromise);
              } else {
                resolveHttpPromise();
                if (!$rootScope.$$phase)
                  $rootScope.$apply();
              }
            }
            function resolvePromise(response, status, headers, statusText) {
              status = status >= -1 ? status : 0;
              (isSuccess(status) ? deferred.resolve : deferred.reject)({
                data: response,
                status: status,
                headers: headersGetter(headers),
                config: config,
                statusText: statusText
              });
            }
            function resolvePromiseWithResult(result) {
              resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText);
            }
            function removePendingReq() {
              var idx = $http.pendingRequests.indexOf(config);
              if (idx !== -1)
                $http.pendingRequests.splice(idx, 1);
            }
          }
          function buildUrl(url, serializedParams) {
            if (serializedParams.length > 0) {
              url += ((url.indexOf('?') == -1) ? '?' : '&') + serializedParams;
            }
            return url;
          }
        }];
      }
      function $xhrFactoryProvider() {
        this.$get = function() {
          return function createXhr() {
            return new window.XMLHttpRequest();
          };
        };
      }
      function $HttpBackendProvider() {
        this.$get = ['$browser', '$window', '$document', '$xhrFactory', function($browser, $window, $document, $xhrFactory) {
          return createHttpBackend($browser, $xhrFactory, $browser.defer, $window.angular.callbacks, $document[0]);
        }];
      }
      function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
        return function(method, url, post, callback, headers, timeout, withCredentials, responseType, eventHandlers, uploadEventHandlers) {
          $browser.$$incOutstandingRequestCount();
          url = url || $browser.url();
          if (lowercase(method) == 'jsonp') {
            var callbackId = '_' + (callbacks.counter++).toString(36);
            callbacks[callbackId] = function(data) {
              callbacks[callbackId].data = data;
              callbacks[callbackId].called = true;
            };
            var jsonpDone = jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId), callbackId, function(status, text) {
              completeRequest(callback, status, callbacks[callbackId].data, "", text);
              callbacks[callbackId] = noop;
            });
          } else {
            var xhr = createXhr(method, url);
            xhr.open(method, url, true);
            forEach(headers, function(value, key) {
              if (isDefined(value)) {
                xhr.setRequestHeader(key, value);
              }
            });
            xhr.onload = function requestLoaded() {
              var statusText = xhr.statusText || '';
              var response = ('response' in xhr) ? xhr.response : xhr.responseText;
              var status = xhr.status === 1223 ? 204 : xhr.status;
              if (status === 0) {
                status = response ? 200 : urlResolve(url).protocol == 'file' ? 404 : 0;
              }
              completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText);
            };
            var requestError = function() {
              completeRequest(callback, -1, null, null, '');
            };
            xhr.onerror = requestError;
            xhr.onabort = requestError;
            forEach(eventHandlers, function(value, key) {
              xhr.addEventListener(key, value);
            });
            forEach(uploadEventHandlers, function(value, key) {
              xhr.upload.addEventListener(key, value);
            });
            if (withCredentials) {
              xhr.withCredentials = true;
            }
            if (responseType) {
              try {
                xhr.responseType = responseType;
              } catch (e) {
                if (responseType !== 'json') {
                  throw e;
                }
              }
            }
            xhr.send(isUndefined(post) ? null : post);
          }
          if (timeout > 0) {
            var timeoutId = $browserDefer(timeoutRequest, timeout);
          } else if (isPromiseLike(timeout)) {
            timeout.then(timeoutRequest);
          }
          function timeoutRequest() {
            jsonpDone && jsonpDone();
            xhr && xhr.abort();
          }
          function completeRequest(callback, status, response, headersString, statusText) {
            if (isDefined(timeoutId)) {
              $browserDefer.cancel(timeoutId);
            }
            jsonpDone = xhr = null;
            callback(status, response, headersString, statusText);
            $browser.$$completeOutstandingRequest(noop);
          }
        };
        function jsonpReq(url, callbackId, done) {
          var script = rawDocument.createElement('script'),
              callback = null;
          script.type = "text/javascript";
          script.src = url;
          script.async = true;
          callback = function(event) {
            removeEventListenerFn(script, "load", callback);
            removeEventListenerFn(script, "error", callback);
            rawDocument.body.removeChild(script);
            script = null;
            var status = -1;
            var text = "unknown";
            if (event) {
              if (event.type === "load" && !callbacks[callbackId].called) {
                event = {type: "error"};
              }
              text = event.type;
              status = event.type === "error" ? 404 : 200;
            }
            if (done) {
              done(status, text);
            }
          };
          addEventListenerFn(script, "load", callback);
          addEventListenerFn(script, "error", callback);
          rawDocument.body.appendChild(script);
          return callback;
        }
      }
      var $interpolateMinErr = angular.$interpolateMinErr = minErr('$interpolate');
      $interpolateMinErr.throwNoconcat = function(text) {
        throw $interpolateMinErr('noconcat', "Error while interpolating: {0}\nStrict Contextual Escaping disallows " + "interpolations that concatenate multiple expressions when a trusted value is " + "required.  See http://docs.angularjs.org/api/ng.$sce", text);
      };
      $interpolateMinErr.interr = function(text, err) {
        return $interpolateMinErr('interr', "Can't interpolate: {0}\n{1}", text, err.toString());
      };
      function $InterpolateProvider() {
        var startSymbol = '{{';
        var endSymbol = '}}';
        this.startSymbol = function(value) {
          if (value) {
            startSymbol = value;
            return this;
          } else {
            return startSymbol;
          }
        };
        this.endSymbol = function(value) {
          if (value) {
            endSymbol = value;
            return this;
          } else {
            return endSymbol;
          }
        };
        this.$get = ['$parse', '$exceptionHandler', '$sce', function($parse, $exceptionHandler, $sce) {
          var startSymbolLength = startSymbol.length,
              endSymbolLength = endSymbol.length,
              escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), 'g'),
              escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), 'g');
          function escape(ch) {
            return '\\\\\\' + ch;
          }
          function unescapeText(text) {
            return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol);
          }
          function stringify(value) {
            if (value == null) {
              return '';
            }
            switch (typeof value) {
              case 'string':
                break;
              case 'number':
                value = '' + value;
                break;
              default:
                value = toJson(value);
            }
            return value;
          }
          function constantWatchDelegate(scope, listener, objectEquality, constantInterp) {
            var unwatch;
            return unwatch = scope.$watch(function constantInterpolateWatch(scope) {
              unwatch();
              return constantInterp(scope);
            }, listener, objectEquality);
          }
          function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
            if (!text.length || text.indexOf(startSymbol) === -1) {
              var constantInterp;
              if (!mustHaveExpression) {
                var unescapedText = unescapeText(text);
                constantInterp = valueFn(unescapedText);
                constantInterp.exp = text;
                constantInterp.expressions = [];
                constantInterp.$$watchDelegate = constantWatchDelegate;
              }
              return constantInterp;
            }
            allOrNothing = !!allOrNothing;
            var startIndex,
                endIndex,
                index = 0,
                expressions = [],
                parseFns = [],
                textLength = text.length,
                exp,
                concat = [],
                expressionPositions = [];
            while (index < textLength) {
              if (((startIndex = text.indexOf(startSymbol, index)) != -1) && ((endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1)) {
                if (index !== startIndex) {
                  concat.push(unescapeText(text.substring(index, startIndex)));
                }
                exp = text.substring(startIndex + startSymbolLength, endIndex);
                expressions.push(exp);
                parseFns.push($parse(exp, parseStringifyInterceptor));
                index = endIndex + endSymbolLength;
                expressionPositions.push(concat.length);
                concat.push('');
              } else {
                if (index !== textLength) {
                  concat.push(unescapeText(text.substring(index)));
                }
                break;
              }
            }
            if (trustedContext && concat.length > 1) {
              $interpolateMinErr.throwNoconcat(text);
            }
            if (!mustHaveExpression || expressions.length) {
              var compute = function(values) {
                for (var i = 0,
                    ii = expressions.length; i < ii; i++) {
                  if (allOrNothing && isUndefined(values[i]))
                    return;
                  concat[expressionPositions[i]] = values[i];
                }
                return concat.join('');
              };
              var getValue = function(value) {
                return trustedContext ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value);
              };
              return extend(function interpolationFn(context) {
                var i = 0;
                var ii = expressions.length;
                var values = new Array(ii);
                try {
                  for (; i < ii; i++) {
                    values[i] = parseFns[i](context);
                  }
                  return compute(values);
                } catch (err) {
                  $exceptionHandler($interpolateMinErr.interr(text, err));
                }
              }, {
                exp: text,
                expressions: expressions,
                $$watchDelegate: function(scope, listener) {
                  var lastValue;
                  return scope.$watchGroup(parseFns, function interpolateFnWatcher(values, oldValues) {
                    var currValue = compute(values);
                    if (isFunction(listener)) {
                      listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope);
                    }
                    lastValue = currValue;
                  });
                }
              });
            }
            function parseStringifyInterceptor(value) {
              try {
                value = getValue(value);
                return allOrNothing && !isDefined(value) ? value : stringify(value);
              } catch (err) {
                $exceptionHandler($interpolateMinErr.interr(text, err));
              }
            }
          }
          $interpolate.startSymbol = function() {
            return startSymbol;
          };
          $interpolate.endSymbol = function() {
            return endSymbol;
          };
          return $interpolate;
        }];
      }
      function $IntervalProvider() {
        this.$get = ['$rootScope', '$window', '$q', '$$q', '$browser', function($rootScope, $window, $q, $$q, $browser) {
          var intervals = {};
          function interval(fn, delay, count, invokeApply) {
            var hasParams = arguments.length > 4,
                args = hasParams ? sliceArgs(arguments, 4) : [],
                setInterval = $window.setInterval,
                clearInterval = $window.clearInterval,
                iteration = 0,
                skipApply = (isDefined(invokeApply) && !invokeApply),
                deferred = (skipApply ? $$q : $q).defer(),
                promise = deferred.promise;
            count = isDefined(count) ? count : 0;
            promise.$$intervalId = setInterval(function tick() {
              if (skipApply) {
                $browser.defer(callback);
              } else {
                $rootScope.$evalAsync(callback);
              }
              deferred.notify(iteration++);
              if (count > 0 && iteration >= count) {
                deferred.resolve(iteration);
                clearInterval(promise.$$intervalId);
                delete intervals[promise.$$intervalId];
              }
              if (!skipApply)
                $rootScope.$apply();
            }, delay);
            intervals[promise.$$intervalId] = deferred;
            return promise;
            function callback() {
              if (!hasParams) {
                fn(iteration);
              } else {
                fn.apply(null, args);
              }
            }
          }
          interval.cancel = function(promise) {
            if (promise && promise.$$intervalId in intervals) {
              intervals[promise.$$intervalId].reject('canceled');
              $window.clearInterval(promise.$$intervalId);
              delete intervals[promise.$$intervalId];
              return true;
            }
            return false;
          };
          return interval;
        }];
      }
      var PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/,
          DEFAULT_PORTS = {
            'http': 80,
            'https': 443,
            'ftp': 21
          };
      var $locationMinErr = minErr('$location');
      function encodePath(path) {
        var segments = path.split('/'),
            i = segments.length;
        while (i--) {
          segments[i] = encodeUriSegment(segments[i]);
        }
        return segments.join('/');
      }
      function parseAbsoluteUrl(absoluteUrl, locationObj) {
        var parsedUrl = urlResolve(absoluteUrl);
        locationObj.$$protocol = parsedUrl.protocol;
        locationObj.$$host = parsedUrl.hostname;
        locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
      }
      function parseAppUrl(relativeUrl, locationObj) {
        var prefixed = (relativeUrl.charAt(0) !== '/');
        if (prefixed) {
          relativeUrl = '/' + relativeUrl;
        }
        var match = urlResolve(relativeUrl);
        locationObj.$$path = decodeURIComponent(prefixed && match.pathname.charAt(0) === '/' ? match.pathname.substring(1) : match.pathname);
        locationObj.$$search = parseKeyValue(match.search);
        locationObj.$$hash = decodeURIComponent(match.hash);
        if (locationObj.$$path && locationObj.$$path.charAt(0) != '/') {
          locationObj.$$path = '/' + locationObj.$$path;
        }
      }
      function startsWith(haystack, needle) {
        return haystack.lastIndexOf(needle, 0) === 0;
      }
      function stripBaseUrl(base, url) {
        if (startsWith(url, base)) {
          return url.substr(base.length);
        }
      }
      function stripHash(url) {
        var index = url.indexOf('#');
        return index == -1 ? url : url.substr(0, index);
      }
      function trimEmptyHash(url) {
        return url.replace(/(#.+)|#$/, '$1');
      }
      function stripFile(url) {
        return url.substr(0, stripHash(url).lastIndexOf('/') + 1);
      }
      function serverBase(url) {
        return url.substring(0, url.indexOf('/', url.indexOf('//') + 2));
      }
      function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
        this.$$html5 = true;
        basePrefix = basePrefix || '';
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
          var pathUrl = stripBaseUrl(appBaseNoFile, url);
          if (!isString(pathUrl)) {
            throw $locationMinErr('ipthprfx', 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
          }
          parseAppUrl(pathUrl, this);
          if (!this.$$path) {
            this.$$path = '/';
          }
          this.$$compose();
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
        };
        this.$$parseLinkUrl = function(url, relHref) {
          if (relHref && relHref[0] === '#') {
            this.hash(relHref.slice(1));
            return true;
          }
          var appUrl,
              prevAppUrl;
          var rewrittenUrl;
          if (isDefined(appUrl = stripBaseUrl(appBase, url))) {
            prevAppUrl = appUrl;
            if (isDefined(appUrl = stripBaseUrl(basePrefix, appUrl))) {
              rewrittenUrl = appBaseNoFile + (stripBaseUrl('/', appUrl) || appUrl);
            } else {
              rewrittenUrl = appBase + prevAppUrl;
            }
          } else if (isDefined(appUrl = stripBaseUrl(appBaseNoFile, url))) {
            rewrittenUrl = appBaseNoFile + appUrl;
          } else if (appBaseNoFile == url + '/') {
            rewrittenUrl = appBaseNoFile;
          }
          if (rewrittenUrl) {
            this.$$parse(rewrittenUrl);
          }
          return !!rewrittenUrl;
        };
      }
      function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
          var withoutBaseUrl = stripBaseUrl(appBase, url) || stripBaseUrl(appBaseNoFile, url);
          var withoutHashUrl;
          if (!isUndefined(withoutBaseUrl) && withoutBaseUrl.charAt(0) === '#') {
            withoutHashUrl = stripBaseUrl(hashPrefix, withoutBaseUrl);
            if (isUndefined(withoutHashUrl)) {
              withoutHashUrl = withoutBaseUrl;
            }
          } else {
            if (this.$$html5) {
              withoutHashUrl = withoutBaseUrl;
            } else {
              withoutHashUrl = '';
              if (isUndefined(withoutBaseUrl)) {
                appBase = url;
                this.replace();
              }
            }
          }
          parseAppUrl(withoutHashUrl, this);
          this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);
          this.$$compose();
          function removeWindowsDriveName(path, url, base) {
            var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
            var firstPathSegmentMatch;
            if (startsWith(url, base)) {
              url = url.replace(base, '');
            }
            if (windowsFilePathExp.exec(url)) {
              return path;
            }
            firstPathSegmentMatch = windowsFilePathExp.exec(path);
            return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
          }
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : '');
        };
        this.$$parseLinkUrl = function(url, relHref) {
          if (stripHash(appBase) == stripHash(url)) {
            this.$$parse(url);
            return true;
          }
          return false;
        };
      }
      function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
        this.$$html5 = true;
        LocationHashbangUrl.apply(this, arguments);
        this.$$parseLinkUrl = function(url, relHref) {
          if (relHref && relHref[0] === '#') {
            this.hash(relHref.slice(1));
            return true;
          }
          var rewrittenUrl;
          var appUrl;
          if (appBase == stripHash(url)) {
            rewrittenUrl = url;
          } else if ((appUrl = stripBaseUrl(appBaseNoFile, url))) {
            rewrittenUrl = appBase + hashPrefix + appUrl;
          } else if (appBaseNoFile === url + '/') {
            rewrittenUrl = appBaseNoFile;
          }
          if (rewrittenUrl) {
            this.$$parse(rewrittenUrl);
          }
          return !!rewrittenUrl;
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBase + hashPrefix + this.$$url;
        };
      }
      var locationPrototype = {
        $$absUrl: '',
        $$html5: false,
        $$replace: false,
        absUrl: locationGetter('$$absUrl'),
        url: function(url) {
          if (isUndefined(url)) {
            return this.$$url;
          }
          var match = PATH_MATCH.exec(url);
          if (match[1] || url === '')
            this.path(decodeURIComponent(match[1]));
          if (match[2] || match[1] || url === '')
            this.search(match[3] || '');
          this.hash(match[5] || '');
          return this;
        },
        protocol: locationGetter('$$protocol'),
        host: locationGetter('$$host'),
        port: locationGetter('$$port'),
        path: locationGetterSetter('$$path', function(path) {
          path = path !== null ? path.toString() : '';
          return path.charAt(0) == '/' ? path : '/' + path;
        }),
        search: function(search, paramValue) {
          switch (arguments.length) {
            case 0:
              return this.$$search;
            case 1:
              if (isString(search) || isNumber(search)) {
                search = search.toString();
                this.$$search = parseKeyValue(search);
              } else if (isObject(search)) {
                search = copy(search, {});
                forEach(search, function(value, key) {
                  if (value == null)
                    delete search[key];
                });
                this.$$search = search;
              } else {
                throw $locationMinErr('isrcharg', 'The first argument of the `$location#search()` call must be a string or an object.');
              }
              break;
            default:
              if (isUndefined(paramValue) || paramValue === null) {
                delete this.$$search[search];
              } else {
                this.$$search[search] = paramValue;
              }
          }
          this.$$compose();
          return this;
        },
        hash: locationGetterSetter('$$hash', function(hash) {
          return hash !== null ? hash.toString() : '';
        }),
        replace: function() {
          this.$$replace = true;
          return this;
        }
      };
      forEach([LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url], function(Location) {
        Location.prototype = Object.create(locationPrototype);
        Location.prototype.state = function(state) {
          if (!arguments.length) {
            return this.$$state;
          }
          if (Location !== LocationHtml5Url || !this.$$html5) {
            throw $locationMinErr('nostate', 'History API state support is available only ' + 'in HTML5 mode and only in browsers supporting HTML5 History API');
          }
          this.$$state = isUndefined(state) ? null : state;
          return this;
        };
      });
      function locationGetter(property) {
        return function() {
          return this[property];
        };
      }
      function locationGetterSetter(property, preprocess) {
        return function(value) {
          if (isUndefined(value)) {
            return this[property];
          }
          this[property] = preprocess(value);
          this.$$compose();
          return this;
        };
      }
      function $LocationProvider() {
        var hashPrefix = '',
            html5Mode = {
              enabled: false,
              requireBase: true,
              rewriteLinks: true
            };
        this.hashPrefix = function(prefix) {
          if (isDefined(prefix)) {
            hashPrefix = prefix;
            return this;
          } else {
            return hashPrefix;
          }
        };
        this.html5Mode = function(mode) {
          if (isBoolean(mode)) {
            html5Mode.enabled = mode;
            return this;
          } else if (isObject(mode)) {
            if (isBoolean(mode.enabled)) {
              html5Mode.enabled = mode.enabled;
            }
            if (isBoolean(mode.requireBase)) {
              html5Mode.requireBase = mode.requireBase;
            }
            if (isBoolean(mode.rewriteLinks)) {
              html5Mode.rewriteLinks = mode.rewriteLinks;
            }
            return this;
          } else {
            return html5Mode;
          }
        };
        this.$get = ['$rootScope', '$browser', '$sniffer', '$rootElement', '$window', function($rootScope, $browser, $sniffer, $rootElement, $window) {
          var $location,
              LocationMode,
              baseHref = $browser.baseHref(),
              initialUrl = $browser.url(),
              appBase;
          if (html5Mode.enabled) {
            if (!baseHref && html5Mode.requireBase) {
              throw $locationMinErr('nobase', "$location in HTML5 mode requires a <base> tag to be present!");
            }
            appBase = serverBase(initialUrl) + (baseHref || '/');
            LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
          } else {
            appBase = stripHash(initialUrl);
            LocationMode = LocationHashbangUrl;
          }
          var appBaseNoFile = stripFile(appBase);
          $location = new LocationMode(appBase, appBaseNoFile, '#' + hashPrefix);
          $location.$$parseLinkUrl(initialUrl, initialUrl);
          $location.$$state = $browser.state();
          var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
          function setBrowserUrlWithFallback(url, replace, state) {
            var oldUrl = $location.url();
            var oldState = $location.$$state;
            try {
              $browser.url(url, replace, state);
              $location.$$state = $browser.state();
            } catch (e) {
              $location.url(oldUrl);
              $location.$$state = oldState;
              throw e;
            }
          }
          $rootElement.on('click', function(event) {
            if (!html5Mode.rewriteLinks || event.ctrlKey || event.metaKey || event.shiftKey || event.which == 2 || event.button == 2)
              return;
            var elm = jqLite(event.target);
            while (nodeName_(elm[0]) !== 'a') {
              if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0])
                return;
            }
            var absHref = elm.prop('href');
            var relHref = elm.attr('href') || elm.attr('xlink:href');
            if (isObject(absHref) && absHref.toString() === '[object SVGAnimatedString]') {
              absHref = urlResolve(absHref.animVal).href;
            }
            if (IGNORE_URI_REGEXP.test(absHref))
              return;
            if (absHref && !elm.attr('target') && !event.isDefaultPrevented()) {
              if ($location.$$parseLinkUrl(absHref, relHref)) {
                event.preventDefault();
                if ($location.absUrl() != $browser.url()) {
                  $rootScope.$apply();
                  $window.angular['ff-684208-preventDefault'] = true;
                }
              }
            }
          });
          if (trimEmptyHash($location.absUrl()) != trimEmptyHash(initialUrl)) {
            $browser.url($location.absUrl(), true);
          }
          var initializing = true;
          $browser.onUrlChange(function(newUrl, newState) {
            if (isUndefined(stripBaseUrl(appBaseNoFile, newUrl))) {
              $window.location.href = newUrl;
              return;
            }
            $rootScope.$evalAsync(function() {
              var oldUrl = $location.absUrl();
              var oldState = $location.$$state;
              var defaultPrevented;
              newUrl = trimEmptyHash(newUrl);
              $location.$$parse(newUrl);
              $location.$$state = newState;
              defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, newState, oldState).defaultPrevented;
              if ($location.absUrl() !== newUrl)
                return;
              if (defaultPrevented) {
                $location.$$parse(oldUrl);
                $location.$$state = oldState;
                setBrowserUrlWithFallback(oldUrl, false, oldState);
              } else {
                initializing = false;
                afterLocationChange(oldUrl, oldState);
              }
            });
            if (!$rootScope.$$phase)
              $rootScope.$digest();
          });
          $rootScope.$watch(function $locationWatch() {
            var oldUrl = trimEmptyHash($browser.url());
            var newUrl = trimEmptyHash($location.absUrl());
            var oldState = $browser.state();
            var currentReplace = $location.$$replace;
            var urlOrStateChanged = oldUrl !== newUrl || ($location.$$html5 && $sniffer.history && oldState !== $location.$$state);
            if (initializing || urlOrStateChanged) {
              initializing = false;
              $rootScope.$evalAsync(function() {
                var newUrl = $location.absUrl();
                var defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                if ($location.absUrl() !== newUrl)
                  return;
                if (defaultPrevented) {
                  $location.$$parse(oldUrl);
                  $location.$$state = oldState;
                } else {
                  if (urlOrStateChanged) {
                    setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state);
                  }
                  afterLocationChange(oldUrl, oldState);
                }
              });
            }
            $location.$$replace = false;
          });
          return $location;
          function afterLocationChange(oldUrl, oldState) {
            $rootScope.$broadcast('$locationChangeSuccess', $location.absUrl(), oldUrl, $location.$$state, oldState);
          }
        }];
      }
      function $LogProvider() {
        var debug = true,
            self = this;
        this.debugEnabled = function(flag) {
          if (isDefined(flag)) {
            debug = flag;
            return this;
          } else {
            return debug;
          }
        };
        this.$get = ['$window', function($window) {
          return {
            log: consoleLog('log'),
            info: consoleLog('info'),
            warn: consoleLog('warn'),
            error: consoleLog('error'),
            debug: (function() {
              var fn = consoleLog('debug');
              return function() {
                if (debug) {
                  fn.apply(self, arguments);
                }
              };
            }())
          };
          function formatError(arg) {
            if (arg instanceof Error) {
              if (arg.stack) {
                arg = (arg.message && arg.stack.indexOf(arg.message) === -1) ? 'Error: ' + arg.message + '\n' + arg.stack : arg.stack;
              } else if (arg.sourceURL) {
                arg = arg.message + '\n' + arg.sourceURL + ':' + arg.line;
              }
            }
            return arg;
          }
          function consoleLog(type) {
            var console = $window.console || {},
                logFn = console[type] || console.log || noop,
                hasApply = false;
            try {
              hasApply = !!logFn.apply;
            } catch (e) {}
            if (hasApply) {
              return function() {
                var args = [];
                forEach(arguments, function(arg) {
                  args.push(formatError(arg));
                });
                return logFn.apply(console, args);
              };
            }
            return function(arg1, arg2) {
              logFn(arg1, arg2 == null ? '' : arg2);
            };
          }
        }];
      }
      var $parseMinErr = minErr('$parse');
      function ensureSafeMemberName(name, fullExpression) {
        if (name === "__defineGetter__" || name === "__defineSetter__" || name === "__lookupGetter__" || name === "__lookupSetter__" || name === "__proto__") {
          throw $parseMinErr('isecfld', 'Attempting to access a disallowed field in Angular expressions! ' + 'Expression: {0}', fullExpression);
        }
        return name;
      }
      function getStringValue(name) {
        return name + '';
      }
      function ensureSafeObject(obj, fullExpression) {
        if (obj) {
          if (obj.constructor === obj) {
            throw $parseMinErr('isecfn', 'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj.window === obj) {
            throw $parseMinErr('isecwindow', 'Referencing the Window in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj.children && (obj.nodeName || (obj.prop && obj.attr && obj.find))) {
            throw $parseMinErr('isecdom', 'Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj === Object) {
            throw $parseMinErr('isecobj', 'Referencing Object in Angular expressions is disallowed! Expression: {0}', fullExpression);
          }
        }
        return obj;
      }
      var CALL = Function.prototype.call;
      var APPLY = Function.prototype.apply;
      var BIND = Function.prototype.bind;
      function ensureSafeFunction(obj, fullExpression) {
        if (obj) {
          if (obj.constructor === obj) {
            throw $parseMinErr('isecfn', 'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj === CALL || obj === APPLY || obj === BIND) {
            throw $parseMinErr('isecff', 'Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}', fullExpression);
          }
        }
      }
      function ensureSafeAssignContext(obj, fullExpression) {
        if (obj) {
          if (obj === (0).constructor || obj === (false).constructor || obj === ''.constructor || obj === {}.constructor || obj === [].constructor || obj === Function.constructor) {
            throw $parseMinErr('isecaf', 'Assigning to a constructor is disallowed! Expression: {0}', fullExpression);
          }
        }
      }
      var OPERATORS = createMap();
      forEach('+ - * / % === !== == != < > <= >= && || ! = |'.split(' '), function(operator) {
        OPERATORS[operator] = true;
      });
      var ESCAPE = {
        "n": "\n",
        "f": "\f",
        "r": "\r",
        "t": "\t",
        "v": "\v",
        "'": "'",
        '"': '"'
      };
      var Lexer = function(options) {
        this.options = options;
      };
      Lexer.prototype = {
        constructor: Lexer,
        lex: function(text) {
          this.text = text;
          this.index = 0;
          this.tokens = [];
          while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            if (ch === '"' || ch === "'") {
              this.readString(ch);
            } else if (this.isNumber(ch) || ch === '.' && this.isNumber(this.peek())) {
              this.readNumber();
            } else if (this.isIdentifierStart(this.peekMultichar())) {
              this.readIdent();
            } else if (this.is(ch, '(){}[].,;:?')) {
              this.tokens.push({
                index: this.index,
                text: ch
              });
              this.index++;
            } else if (this.isWhitespace(ch)) {
              this.index++;
            } else {
              var ch2 = ch + this.peek();
              var ch3 = ch2 + this.peek(2);
              var op1 = OPERATORS[ch];
              var op2 = OPERATORS[ch2];
              var op3 = OPERATORS[ch3];
              if (op1 || op2 || op3) {
                var token = op3 ? ch3 : (op2 ? ch2 : ch);
                this.tokens.push({
                  index: this.index,
                  text: token,
                  operator: true
                });
                this.index += token.length;
              } else {
                this.throwError('Unexpected next character ', this.index, this.index + 1);
              }
            }
          }
          return this.tokens;
        },
        is: function(ch, chars) {
          return chars.indexOf(ch) !== -1;
        },
        peek: function(i) {
          var num = i || 1;
          return (this.index + num < this.text.length) ? this.text.charAt(this.index + num) : false;
        },
        isNumber: function(ch) {
          return ('0' <= ch && ch <= '9') && typeof ch === "string";
        },
        isWhitespace: function(ch) {
          return (ch === ' ' || ch === '\r' || ch === '\t' || ch === '\n' || ch === '\v' || ch === '\u00A0');
        },
        isIdentifierStart: function(ch) {
          return this.options.isIdentifierStart ? this.options.isIdentifierStart(ch, this.codePointAt(ch)) : this.isValidIdentifierStart(ch);
        },
        isValidIdentifierStart: function(ch) {
          return ('a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || '_' === ch || ch === '$');
        },
        isIdentifierContinue: function(ch) {
          return this.options.isIdentifierContinue ? this.options.isIdentifierContinue(ch, this.codePointAt(ch)) : this.isValidIdentifierContinue(ch);
        },
        isValidIdentifierContinue: function(ch, cp) {
          return this.isValidIdentifierStart(ch, cp) || this.isNumber(ch);
        },
        codePointAt: function(ch) {
          if (ch.length === 1)
            return ch.charCodeAt(0);
          return (ch.charCodeAt(0) << 10) + ch.charCodeAt(1) - 0x35FDC00;
        },
        peekMultichar: function() {
          var ch = this.text.charAt(this.index);
          var peek = this.peek();
          if (!peek) {
            return ch;
          }
          var cp1 = ch.charCodeAt(0);
          var cp2 = peek.charCodeAt(0);
          if (cp1 >= 0xD800 && cp1 <= 0xDBFF && cp2 >= 0xDC00 && cp2 <= 0xDFFF) {
            return ch + peek;
          }
          return ch;
        },
        isExpOperator: function(ch) {
          return (ch === '-' || ch === '+' || this.isNumber(ch));
        },
        throwError: function(error, start, end) {
          end = end || this.index;
          var colStr = (isDefined(start) ? 's ' + start + '-' + this.index + ' [' + this.text.substring(start, end) + ']' : ' ' + end);
          throw $parseMinErr('lexerr', 'Lexer Error: {0} at column{1} in expression [{2}].', error, colStr, this.text);
        },
        readNumber: function() {
          var number = '';
          var start = this.index;
          while (this.index < this.text.length) {
            var ch = lowercase(this.text.charAt(this.index));
            if (ch == '.' || this.isNumber(ch)) {
              number += ch;
            } else {
              var peekCh = this.peek();
              if (ch == 'e' && this.isExpOperator(peekCh)) {
                number += ch;
              } else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && number.charAt(number.length - 1) == 'e') {
                number += ch;
              } else if (this.isExpOperator(ch) && (!peekCh || !this.isNumber(peekCh)) && number.charAt(number.length - 1) == 'e') {
                this.throwError('Invalid exponent');
              } else {
                break;
              }
            }
            this.index++;
          }
          this.tokens.push({
            index: start,
            text: number,
            constant: true,
            value: Number(number)
          });
        },
        readIdent: function() {
          var start = this.index;
          this.index += this.peekMultichar().length;
          while (this.index < this.text.length) {
            var ch = this.peekMultichar();
            if (!this.isIdentifierContinue(ch)) {
              break;
            }
            this.index += ch.length;
          }
          this.tokens.push({
            index: start,
            text: this.text.slice(start, this.index),
            identifier: true
          });
        },
        readString: function(quote) {
          var start = this.index;
          this.index++;
          var string = '';
          var rawString = quote;
          var escape = false;
          while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            rawString += ch;
            if (escape) {
              if (ch === 'u') {
                var hex = this.text.substring(this.index + 1, this.index + 5);
                if (!hex.match(/[\da-f]{4}/i)) {
                  this.throwError('Invalid unicode escape [\\u' + hex + ']');
                }
                this.index += 4;
                string += String.fromCharCode(parseInt(hex, 16));
              } else {
                var rep = ESCAPE[ch];
                string = string + (rep || ch);
              }
              escape = false;
            } else if (ch === '\\') {
              escape = true;
            } else if (ch === quote) {
              this.index++;
              this.tokens.push({
                index: start,
                text: rawString,
                constant: true,
                value: string
              });
              return;
            } else {
              string += ch;
            }
            this.index++;
          }
          this.throwError('Unterminated quote', start);
        }
      };
      var AST = function(lexer, options) {
        this.lexer = lexer;
        this.options = options;
      };
      AST.Program = 'Program';
      AST.ExpressionStatement = 'ExpressionStatement';
      AST.AssignmentExpression = 'AssignmentExpression';
      AST.ConditionalExpression = 'ConditionalExpression';
      AST.LogicalExpression = 'LogicalExpression';
      AST.BinaryExpression = 'BinaryExpression';
      AST.UnaryExpression = 'UnaryExpression';
      AST.CallExpression = 'CallExpression';
      AST.MemberExpression = 'MemberExpression';
      AST.Identifier = 'Identifier';
      AST.Literal = 'Literal';
      AST.ArrayExpression = 'ArrayExpression';
      AST.Property = 'Property';
      AST.ObjectExpression = 'ObjectExpression';
      AST.ThisExpression = 'ThisExpression';
      AST.LocalsExpression = 'LocalsExpression';
      AST.NGValueParameter = 'NGValueParameter';
      AST.prototype = {
        ast: function(text) {
          this.text = text;
          this.tokens = this.lexer.lex(text);
          var value = this.program();
          if (this.tokens.length !== 0) {
            this.throwError('is an unexpected token', this.tokens[0]);
          }
          return value;
        },
        program: function() {
          var body = [];
          while (true) {
            if (this.tokens.length > 0 && !this.peek('}', ')', ';', ']'))
              body.push(this.expressionStatement());
            if (!this.expect(';')) {
              return {
                type: AST.Program,
                body: body
              };
            }
          }
        },
        expressionStatement: function() {
          return {
            type: AST.ExpressionStatement,
            expression: this.filterChain()
          };
        },
        filterChain: function() {
          var left = this.expression();
          var token;
          while ((token = this.expect('|'))) {
            left = this.filter(left);
          }
          return left;
        },
        expression: function() {
          return this.assignment();
        },
        assignment: function() {
          var result = this.ternary();
          if (this.expect('=')) {
            result = {
              type: AST.AssignmentExpression,
              left: result,
              right: this.assignment(),
              operator: '='
            };
          }
          return result;
        },
        ternary: function() {
          var test = this.logicalOR();
          var alternate;
          var consequent;
          if (this.expect('?')) {
            alternate = this.expression();
            if (this.consume(':')) {
              consequent = this.expression();
              return {
                type: AST.ConditionalExpression,
                test: test,
                alternate: alternate,
                consequent: consequent
              };
            }
          }
          return test;
        },
        logicalOR: function() {
          var left = this.logicalAND();
          while (this.expect('||')) {
            left = {
              type: AST.LogicalExpression,
              operator: '||',
              left: left,
              right: this.logicalAND()
            };
          }
          return left;
        },
        logicalAND: function() {
          var left = this.equality();
          while (this.expect('&&')) {
            left = {
              type: AST.LogicalExpression,
              operator: '&&',
              left: left,
              right: this.equality()
            };
          }
          return left;
        },
        equality: function() {
          var left = this.relational();
          var token;
          while ((token = this.expect('==', '!=', '===', '!=='))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.relational()
            };
          }
          return left;
        },
        relational: function() {
          var left = this.additive();
          var token;
          while ((token = this.expect('<', '>', '<=', '>='))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.additive()
            };
          }
          return left;
        },
        additive: function() {
          var left = this.multiplicative();
          var token;
          while ((token = this.expect('+', '-'))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.multiplicative()
            };
          }
          return left;
        },
        multiplicative: function() {
          var left = this.unary();
          var token;
          while ((token = this.expect('*', '/', '%'))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.unary()
            };
          }
          return left;
        },
        unary: function() {
          var token;
          if ((token = this.expect('+', '-', '!'))) {
            return {
              type: AST.UnaryExpression,
              operator: token.text,
              prefix: true,
              argument: this.unary()
            };
          } else {
            return this.primary();
          }
        },
        primary: function() {
          var primary;
          if (this.expect('(')) {
            primary = this.filterChain();
            this.consume(')');
          } else if (this.expect('[')) {
            primary = this.arrayDeclaration();
          } else if (this.expect('{')) {
            primary = this.object();
          } else if (this.selfReferential.hasOwnProperty(this.peek().text)) {
            primary = copy(this.selfReferential[this.consume().text]);
          } else if (this.options.literals.hasOwnProperty(this.peek().text)) {
            primary = {
              type: AST.Literal,
              value: this.options.literals[this.consume().text]
            };
          } else if (this.peek().identifier) {
            primary = this.identifier();
          } else if (this.peek().constant) {
            primary = this.constant();
          } else {
            this.throwError('not a primary expression', this.peek());
          }
          var next;
          while ((next = this.expect('(', '[', '.'))) {
            if (next.text === '(') {
              primary = {
                type: AST.CallExpression,
                callee: primary,
                arguments: this.parseArguments()
              };
              this.consume(')');
            } else if (next.text === '[') {
              primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.expression(),
                computed: true
              };
              this.consume(']');
            } else if (next.text === '.') {
              primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.identifier(),
                computed: false
              };
            } else {
              this.throwError('IMPOSSIBLE');
            }
          }
          return primary;
        },
        filter: function(baseExpression) {
          var args = [baseExpression];
          var result = {
            type: AST.CallExpression,
            callee: this.identifier(),
            arguments: args,
            filter: true
          };
          while (this.expect(':')) {
            args.push(this.expression());
          }
          return result;
        },
        parseArguments: function() {
          var args = [];
          if (this.peekToken().text !== ')') {
            do {
              args.push(this.filterChain());
            } while (this.expect(','));
          }
          return args;
        },
        identifier: function() {
          var token = this.consume();
          if (!token.identifier) {
            this.throwError('is not a valid identifier', token);
          }
          return {
            type: AST.Identifier,
            name: token.text
          };
        },
        constant: function() {
          return {
            type: AST.Literal,
            value: this.consume().value
          };
        },
        arrayDeclaration: function() {
          var elements = [];
          if (this.peekToken().text !== ']') {
            do {
              if (this.peek(']')) {
                break;
              }
              elements.push(this.expression());
            } while (this.expect(','));
          }
          this.consume(']');
          return {
            type: AST.ArrayExpression,
            elements: elements
          };
        },
        object: function() {
          var properties = [],
              property;
          if (this.peekToken().text !== '}') {
            do {
              if (this.peek('}')) {
                break;
              }
              property = {
                type: AST.Property,
                kind: 'init'
              };
              if (this.peek().constant) {
                property.key = this.constant();
                property.computed = false;
                this.consume(':');
                property.value = this.expression();
              } else if (this.peek().identifier) {
                property.key = this.identifier();
                property.computed = false;
                if (this.peek(':')) {
                  this.consume(':');
                  property.value = this.expression();
                } else {
                  property.value = property.key;
                }
              } else if (this.peek('[')) {
                this.consume('[');
                property.key = this.expression();
                this.consume(']');
                property.computed = true;
                this.consume(':');
                property.value = this.expression();
              } else {
                this.throwError("invalid key", this.peek());
              }
              properties.push(property);
            } while (this.expect(','));
          }
          this.consume('}');
          return {
            type: AST.ObjectExpression,
            properties: properties
          };
        },
        throwError: function(msg, token) {
          throw $parseMinErr('syntax', 'Syntax Error: Token \'{0}\' {1} at column {2} of the expression [{3}] starting at [{4}].', token.text, msg, (token.index + 1), this.text, this.text.substring(token.index));
        },
        consume: function(e1) {
          if (this.tokens.length === 0) {
            throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
          }
          var token = this.expect(e1);
          if (!token) {
            this.throwError('is unexpected, expecting [' + e1 + ']', this.peek());
          }
          return token;
        },
        peekToken: function() {
          if (this.tokens.length === 0) {
            throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
          }
          return this.tokens[0];
        },
        peek: function(e1, e2, e3, e4) {
          return this.peekAhead(0, e1, e2, e3, e4);
        },
        peekAhead: function(i, e1, e2, e3, e4) {
          if (this.tokens.length > i) {
            var token = this.tokens[i];
            var t = token.text;
            if (t === e1 || t === e2 || t === e3 || t === e4 || (!e1 && !e2 && !e3 && !e4)) {
              return token;
            }
          }
          return false;
        },
        expect: function(e1, e2, e3, e4) {
          var token = this.peek(e1, e2, e3, e4);
          if (token) {
            this.tokens.shift();
            return token;
          }
          return false;
        },
        selfReferential: {
          'this': {type: AST.ThisExpression},
          '$locals': {type: AST.LocalsExpression}
        }
      };
      function ifDefined(v, d) {
        return typeof v !== 'undefined' ? v : d;
      }
      function plusFn(l, r) {
        if (typeof l === 'undefined')
          return r;
        if (typeof r === 'undefined')
          return l;
        return l + r;
      }
      function isStateless($filter, filterName) {
        var fn = $filter(filterName);
        return !fn.$stateful;
      }
      function findConstantAndWatchExpressions(ast, $filter) {
        var allConstants;
        var argsToWatch;
        switch (ast.type) {
          case AST.Program:
            allConstants = true;
            forEach(ast.body, function(expr) {
              findConstantAndWatchExpressions(expr.expression, $filter);
              allConstants = allConstants && expr.expression.constant;
            });
            ast.constant = allConstants;
            break;
          case AST.Literal:
            ast.constant = true;
            ast.toWatch = [];
            break;
          case AST.UnaryExpression:
            findConstantAndWatchExpressions(ast.argument, $filter);
            ast.constant = ast.argument.constant;
            ast.toWatch = ast.argument.toWatch;
            break;
          case AST.BinaryExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
            break;
          case AST.LogicalExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = ast.constant ? [] : [ast];
            break;
          case AST.ConditionalExpression:
            findConstantAndWatchExpressions(ast.test, $filter);
            findConstantAndWatchExpressions(ast.alternate, $filter);
            findConstantAndWatchExpressions(ast.consequent, $filter);
            ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant;
            ast.toWatch = ast.constant ? [] : [ast];
            break;
          case AST.Identifier:
            ast.constant = false;
            ast.toWatch = [ast];
            break;
          case AST.MemberExpression:
            findConstantAndWatchExpressions(ast.object, $filter);
            if (ast.computed) {
              findConstantAndWatchExpressions(ast.property, $filter);
            }
            ast.constant = ast.object.constant && (!ast.computed || ast.property.constant);
            ast.toWatch = [ast];
            break;
          case AST.CallExpression:
            allConstants = ast.filter ? isStateless($filter, ast.callee.name) : false;
            argsToWatch = [];
            forEach(ast.arguments, function(expr) {
              findConstantAndWatchExpressions(expr, $filter);
              allConstants = allConstants && expr.constant;
              if (!expr.constant) {
                argsToWatch.push.apply(argsToWatch, expr.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = ast.filter && isStateless($filter, ast.callee.name) ? argsToWatch : [ast];
            break;
          case AST.AssignmentExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = [ast];
            break;
          case AST.ArrayExpression:
            allConstants = true;
            argsToWatch = [];
            forEach(ast.elements, function(expr) {
              findConstantAndWatchExpressions(expr, $filter);
              allConstants = allConstants && expr.constant;
              if (!expr.constant) {
                argsToWatch.push.apply(argsToWatch, expr.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = argsToWatch;
            break;
          case AST.ObjectExpression:
            allConstants = true;
            argsToWatch = [];
            forEach(ast.properties, function(property) {
              findConstantAndWatchExpressions(property.value, $filter);
              allConstants = allConstants && property.value.constant && !property.computed;
              if (!property.value.constant) {
                argsToWatch.push.apply(argsToWatch, property.value.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = argsToWatch;
            break;
          case AST.ThisExpression:
            ast.constant = false;
            ast.toWatch = [];
            break;
          case AST.LocalsExpression:
            ast.constant = false;
            ast.toWatch = [];
            break;
        }
      }
      function getInputs(body) {
        if (body.length != 1)
          return;
        var lastExpression = body[0].expression;
        var candidate = lastExpression.toWatch;
        if (candidate.length !== 1)
          return candidate;
        return candidate[0] !== lastExpression ? candidate : undefined;
      }
      function isAssignable(ast) {
        return ast.type === AST.Identifier || ast.type === AST.MemberExpression;
      }
      function assignableAST(ast) {
        if (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {
          return {
            type: AST.AssignmentExpression,
            left: ast.body[0].expression,
            right: {type: AST.NGValueParameter},
            operator: '='
          };
        }
      }
      function isLiteral(ast) {
        return ast.body.length === 0 || ast.body.length === 1 && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression);
      }
      function isConstant(ast) {
        return ast.constant;
      }
      function ASTCompiler(astBuilder, $filter) {
        this.astBuilder = astBuilder;
        this.$filter = $filter;
      }
      ASTCompiler.prototype = {
        compile: function(expression, expensiveChecks) {
          var self = this;
          var ast = this.astBuilder.ast(expression);
          this.state = {
            nextId: 0,
            filters: {},
            expensiveChecks: expensiveChecks,
            fn: {
              vars: [],
              body: [],
              own: {}
            },
            assign: {
              vars: [],
              body: [],
              own: {}
            },
            inputs: []
          };
          findConstantAndWatchExpressions(ast, self.$filter);
          var extra = '';
          var assignable;
          this.stage = 'assign';
          if ((assignable = assignableAST(ast))) {
            this.state.computing = 'assign';
            var result = this.nextId();
            this.recurse(assignable, result);
            this.return_(result);
            extra = 'fn.assign=' + this.generateFunction('assign', 's,v,l');
          }
          var toWatch = getInputs(ast.body);
          self.stage = 'inputs';
          forEach(toWatch, function(watch, key) {
            var fnKey = 'fn' + key;
            self.state[fnKey] = {
              vars: [],
              body: [],
              own: {}
            };
            self.state.computing = fnKey;
            var intoId = self.nextId();
            self.recurse(watch, intoId);
            self.return_(intoId);
            self.state.inputs.push(fnKey);
            watch.watchId = key;
          });
          this.state.computing = 'fn';
          this.stage = 'main';
          this.recurse(ast);
          var fnString = '"' + this.USE + ' ' + this.STRICT + '";\n' + this.filterPrefix() + 'var fn=' + this.generateFunction('fn', 's,l,a,i') + extra + this.watchFns() + 'return fn;';
          var fn = (new Function('$filter', 'ensureSafeMemberName', 'ensureSafeObject', 'ensureSafeFunction', 'getStringValue', 'ensureSafeAssignContext', 'ifDefined', 'plus', 'text', fnString))(this.$filter, ensureSafeMemberName, ensureSafeObject, ensureSafeFunction, getStringValue, ensureSafeAssignContext, ifDefined, plusFn, expression);
          this.state = this.stage = undefined;
          fn.literal = isLiteral(ast);
          fn.constant = isConstant(ast);
          return fn;
        },
        USE: 'use',
        STRICT: 'strict',
        watchFns: function() {
          var result = [];
          var fns = this.state.inputs;
          var self = this;
          forEach(fns, function(name) {
            result.push('var ' + name + '=' + self.generateFunction(name, 's'));
          });
          if (fns.length) {
            result.push('fn.inputs=[' + fns.join(',') + '];');
          }
          return result.join('');
        },
        generateFunction: function(name, params) {
          return 'function(' + params + '){' + this.varsPrefix(name) + this.body(name) + '};';
        },
        filterPrefix: function() {
          var parts = [];
          var self = this;
          forEach(this.state.filters, function(id, filter) {
            parts.push(id + '=$filter(' + self.escape(filter) + ')');
          });
          if (parts.length)
            return 'var ' + parts.join(',') + ';';
          return '';
        },
        varsPrefix: function(section) {
          return this.state[section].vars.length ? 'var ' + this.state[section].vars.join(',') + ';' : '';
        },
        body: function(section) {
          return this.state[section].body.join('');
        },
        recurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
          var left,
              right,
              self = this,
              args,
              expression,
              computed;
          recursionFn = recursionFn || noop;
          if (!skipWatchIdCheck && isDefined(ast.watchId)) {
            intoId = intoId || this.nextId();
            this.if_('i', this.lazyAssign(intoId, this.computedMember('i', ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, true));
            return;
          }
          switch (ast.type) {
            case AST.Program:
              forEach(ast.body, function(expression, pos) {
                self.recurse(expression.expression, undefined, undefined, function(expr) {
                  right = expr;
                });
                if (pos !== ast.body.length - 1) {
                  self.current().body.push(right, ';');
                } else {
                  self.return_(right);
                }
              });
              break;
            case AST.Literal:
              expression = this.escape(ast.value);
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.UnaryExpression:
              this.recurse(ast.argument, undefined, undefined, function(expr) {
                right = expr;
              });
              expression = ast.operator + '(' + this.ifDefined(right, 0) + ')';
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.BinaryExpression:
              this.recurse(ast.left, undefined, undefined, function(expr) {
                left = expr;
              });
              this.recurse(ast.right, undefined, undefined, function(expr) {
                right = expr;
              });
              if (ast.operator === '+') {
                expression = this.plus(left, right);
              } else if (ast.operator === '-') {
                expression = this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);
              } else {
                expression = '(' + left + ')' + ast.operator + '(' + right + ')';
              }
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.LogicalExpression:
              intoId = intoId || this.nextId();
              self.recurse(ast.left, intoId);
              self.if_(ast.operator === '&&' ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId));
              recursionFn(intoId);
              break;
            case AST.ConditionalExpression:
              intoId = intoId || this.nextId();
              self.recurse(ast.test, intoId);
              self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId));
              recursionFn(intoId);
              break;
            case AST.Identifier:
              intoId = intoId || this.nextId();
              if (nameId) {
                nameId.context = self.stage === 'inputs' ? 's' : this.assign(this.nextId(), this.getHasOwnProperty('l', ast.name) + '?l:s');
                nameId.computed = false;
                nameId.name = ast.name;
              }
              ensureSafeMemberName(ast.name);
              self.if_(self.stage === 'inputs' || self.not(self.getHasOwnProperty('l', ast.name)), function() {
                self.if_(self.stage === 'inputs' || 's', function() {
                  if (create && create !== 1) {
                    self.if_(self.not(self.nonComputedMember('s', ast.name)), self.lazyAssign(self.nonComputedMember('s', ast.name), '{}'));
                  }
                  self.assign(intoId, self.nonComputedMember('s', ast.name));
                });
              }, intoId && self.lazyAssign(intoId, self.nonComputedMember('l', ast.name)));
              if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.name)) {
                self.addEnsureSafeObject(intoId);
              }
              recursionFn(intoId);
              break;
            case AST.MemberExpression:
              left = nameId && (nameId.context = this.nextId()) || this.nextId();
              intoId = intoId || this.nextId();
              self.recurse(ast.object, left, undefined, function() {
                self.if_(self.notNull(left), function() {
                  if (create && create !== 1) {
                    self.addEnsureSafeAssignContext(left);
                  }
                  if (ast.computed) {
                    right = self.nextId();
                    self.recurse(ast.property, right);
                    self.getStringValue(right);
                    self.addEnsureSafeMemberName(right);
                    if (create && create !== 1) {
                      self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), '{}'));
                    }
                    expression = self.ensureSafeObject(self.computedMember(left, right));
                    self.assign(intoId, expression);
                    if (nameId) {
                      nameId.computed = true;
                      nameId.name = right;
                    }
                  } else {
                    ensureSafeMemberName(ast.property.name);
                    if (create && create !== 1) {
                      self.if_(self.not(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), '{}'));
                    }
                    expression = self.nonComputedMember(left, ast.property.name);
                    if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.property.name)) {
                      expression = self.ensureSafeObject(expression);
                    }
                    self.assign(intoId, expression);
                    if (nameId) {
                      nameId.computed = false;
                      nameId.name = ast.property.name;
                    }
                  }
                }, function() {
                  self.assign(intoId, 'undefined');
                });
                recursionFn(intoId);
              }, !!create);
              break;
            case AST.CallExpression:
              intoId = intoId || this.nextId();
              if (ast.filter) {
                right = self.filter(ast.callee.name);
                args = [];
                forEach(ast.arguments, function(expr) {
                  var argument = self.nextId();
                  self.recurse(expr, argument);
                  args.push(argument);
                });
                expression = right + '(' + args.join(',') + ')';
                self.assign(intoId, expression);
                recursionFn(intoId);
              } else {
                right = self.nextId();
                left = {};
                args = [];
                self.recurse(ast.callee, right, left, function() {
                  self.if_(self.notNull(right), function() {
                    self.addEnsureSafeFunction(right);
                    forEach(ast.arguments, function(expr) {
                      self.recurse(expr, self.nextId(), undefined, function(argument) {
                        args.push(self.ensureSafeObject(argument));
                      });
                    });
                    if (left.name) {
                      if (!self.state.expensiveChecks) {
                        self.addEnsureSafeObject(left.context);
                      }
                      expression = self.member(left.context, left.name, left.computed) + '(' + args.join(',') + ')';
                    } else {
                      expression = right + '(' + args.join(',') + ')';
                    }
                    expression = self.ensureSafeObject(expression);
                    self.assign(intoId, expression);
                  }, function() {
                    self.assign(intoId, 'undefined');
                  });
                  recursionFn(intoId);
                });
              }
              break;
            case AST.AssignmentExpression:
              right = this.nextId();
              left = {};
              if (!isAssignable(ast.left)) {
                throw $parseMinErr('lval', 'Trying to assign a value to a non l-value');
              }
              this.recurse(ast.left, undefined, left, function() {
                self.if_(self.notNull(left.context), function() {
                  self.recurse(ast.right, right);
                  self.addEnsureSafeObject(self.member(left.context, left.name, left.computed));
                  self.addEnsureSafeAssignContext(left.context);
                  expression = self.member(left.context, left.name, left.computed) + ast.operator + right;
                  self.assign(intoId, expression);
                  recursionFn(intoId || expression);
                });
              }, 1);
              break;
            case AST.ArrayExpression:
              args = [];
              forEach(ast.elements, function(expr) {
                self.recurse(expr, self.nextId(), undefined, function(argument) {
                  args.push(argument);
                });
              });
              expression = '[' + args.join(',') + ']';
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.ObjectExpression:
              args = [];
              computed = false;
              forEach(ast.properties, function(property) {
                if (property.computed) {
                  computed = true;
                }
              });
              if (computed) {
                intoId = intoId || this.nextId();
                this.assign(intoId, '{}');
                forEach(ast.properties, function(property) {
                  if (property.computed) {
                    left = self.nextId();
                    self.recurse(property.key, left);
                  } else {
                    left = property.key.type === AST.Identifier ? property.key.name : ('' + property.key.value);
                  }
                  right = self.nextId();
                  self.recurse(property.value, right);
                  self.assign(self.member(intoId, left, property.computed), right);
                });
              } else {
                forEach(ast.properties, function(property) {
                  self.recurse(property.value, ast.constant ? undefined : self.nextId(), undefined, function(expr) {
                    args.push(self.escape(property.key.type === AST.Identifier ? property.key.name : ('' + property.key.value)) + ':' + expr);
                  });
                });
                expression = '{' + args.join(',') + '}';
                this.assign(intoId, expression);
              }
              recursionFn(intoId || expression);
              break;
            case AST.ThisExpression:
              this.assign(intoId, 's');
              recursionFn('s');
              break;
            case AST.LocalsExpression:
              this.assign(intoId, 'l');
              recursionFn('l');
              break;
            case AST.NGValueParameter:
              this.assign(intoId, 'v');
              recursionFn('v');
              break;
          }
        },
        getHasOwnProperty: function(element, property) {
          var key = element + '.' + property;
          var own = this.current().own;
          if (!own.hasOwnProperty(key)) {
            own[key] = this.nextId(false, element + '&&(' + this.escape(property) + ' in ' + element + ')');
          }
          return own[key];
        },
        assign: function(id, value) {
          if (!id)
            return;
          this.current().body.push(id, '=', value, ';');
          return id;
        },
        filter: function(filterName) {
          if (!this.state.filters.hasOwnProperty(filterName)) {
            this.state.filters[filterName] = this.nextId(true);
          }
          return this.state.filters[filterName];
        },
        ifDefined: function(id, defaultValue) {
          return 'ifDefined(' + id + ',' + this.escape(defaultValue) + ')';
        },
        plus: function(left, right) {
          return 'plus(' + left + ',' + right + ')';
        },
        return_: function(id) {
          this.current().body.push('return ', id, ';');
        },
        if_: function(test, alternate, consequent) {
          if (test === true) {
            alternate();
          } else {
            var body = this.current().body;
            body.push('if(', test, '){');
            alternate();
            body.push('}');
            if (consequent) {
              body.push('else{');
              consequent();
              body.push('}');
            }
          }
        },
        not: function(expression) {
          return '!(' + expression + ')';
        },
        notNull: function(expression) {
          return expression + '!=null';
        },
        nonComputedMember: function(left, right) {
          var SAFE_IDENTIFIER = /[$_a-zA-Z][$_a-zA-Z0-9]*/;
          var UNSAFE_CHARACTERS = /[^$_a-zA-Z0-9]/g;
          if (SAFE_IDENTIFIER.test(right)) {
            return left + '.' + right;
          } else {
            return left + '["' + right.replace(UNSAFE_CHARACTERS, this.stringEscapeFn) + '"]';
          }
        },
        computedMember: function(left, right) {
          return left + '[' + right + ']';
        },
        member: function(left, right, computed) {
          if (computed)
            return this.computedMember(left, right);
          return this.nonComputedMember(left, right);
        },
        addEnsureSafeObject: function(item) {
          this.current().body.push(this.ensureSafeObject(item), ';');
        },
        addEnsureSafeMemberName: function(item) {
          this.current().body.push(this.ensureSafeMemberName(item), ';');
        },
        addEnsureSafeFunction: function(item) {
          this.current().body.push(this.ensureSafeFunction(item), ';');
        },
        addEnsureSafeAssignContext: function(item) {
          this.current().body.push(this.ensureSafeAssignContext(item), ';');
        },
        ensureSafeObject: function(item) {
          return 'ensureSafeObject(' + item + ',text)';
        },
        ensureSafeMemberName: function(item) {
          return 'ensureSafeMemberName(' + item + ',text)';
        },
        ensureSafeFunction: function(item) {
          return 'ensureSafeFunction(' + item + ',text)';
        },
        getStringValue: function(item) {
          this.assign(item, 'getStringValue(' + item + ')');
        },
        ensureSafeAssignContext: function(item) {
          return 'ensureSafeAssignContext(' + item + ',text)';
        },
        lazyRecurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
          var self = this;
          return function() {
            self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
          };
        },
        lazyAssign: function(id, value) {
          var self = this;
          return function() {
            self.assign(id, value);
          };
        },
        stringEscapeRegex: /[^ a-zA-Z0-9]/g,
        stringEscapeFn: function(c) {
          return '\\u' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4);
        },
        escape: function(value) {
          if (isString(value))
            return "'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'";
          if (isNumber(value))
            return value.toString();
          if (value === true)
            return 'true';
          if (value === false)
            return 'false';
          if (value === null)
            return 'null';
          if (typeof value === 'undefined')
            return 'undefined';
          throw $parseMinErr('esc', 'IMPOSSIBLE');
        },
        nextId: function(skip, init) {
          var id = 'v' + (this.state.nextId++);
          if (!skip) {
            this.current().vars.push(id + (init ? '=' + init : ''));
          }
          return id;
        },
        current: function() {
          return this.state[this.state.computing];
        }
      };
      function ASTInterpreter(astBuilder, $filter) {
        this.astBuilder = astBuilder;
        this.$filter = $filter;
      }
      ASTInterpreter.prototype = {
        compile: function(expression, expensiveChecks) {
          var self = this;
          var ast = this.astBuilder.ast(expression);
          this.expression = expression;
          this.expensiveChecks = expensiveChecks;
          findConstantAndWatchExpressions(ast, self.$filter);
          var assignable;
          var assign;
          if ((assignable = assignableAST(ast))) {
            assign = this.recurse(assignable);
          }
          var toWatch = getInputs(ast.body);
          var inputs;
          if (toWatch) {
            inputs = [];
            forEach(toWatch, function(watch, key) {
              var input = self.recurse(watch);
              watch.input = input;
              inputs.push(input);
              watch.watchId = key;
            });
          }
          var expressions = [];
          forEach(ast.body, function(expression) {
            expressions.push(self.recurse(expression.expression));
          });
          var fn = ast.body.length === 0 ? noop : ast.body.length === 1 ? expressions[0] : function(scope, locals) {
            var lastValue;
            forEach(expressions, function(exp) {
              lastValue = exp(scope, locals);
            });
            return lastValue;
          };
          if (assign) {
            fn.assign = function(scope, value, locals) {
              return assign(scope, locals, value);
            };
          }
          if (inputs) {
            fn.inputs = inputs;
          }
          fn.literal = isLiteral(ast);
          fn.constant = isConstant(ast);
          return fn;
        },
        recurse: function(ast, context, create) {
          var left,
              right,
              self = this,
              args,
              expression;
          if (ast.input) {
            return this.inputs(ast.input, ast.watchId);
          }
          switch (ast.type) {
            case AST.Literal:
              return this.value(ast.value, context);
            case AST.UnaryExpression:
              right = this.recurse(ast.argument);
              return this['unary' + ast.operator](right, context);
            case AST.BinaryExpression:
              left = this.recurse(ast.left);
              right = this.recurse(ast.right);
              return this['binary' + ast.operator](left, right, context);
            case AST.LogicalExpression:
              left = this.recurse(ast.left);
              right = this.recurse(ast.right);
              return this['binary' + ast.operator](left, right, context);
            case AST.ConditionalExpression:
              return this['ternary?:'](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context);
            case AST.Identifier:
              ensureSafeMemberName(ast.name, self.expression);
              return self.identifier(ast.name, self.expensiveChecks || isPossiblyDangerousMemberName(ast.name), context, create, self.expression);
            case AST.MemberExpression:
              left = this.recurse(ast.object, false, !!create);
              if (!ast.computed) {
                ensureSafeMemberName(ast.property.name, self.expression);
                right = ast.property.name;
              }
              if (ast.computed)
                right = this.recurse(ast.property);
              return ast.computed ? this.computedMember(left, right, context, create, self.expression) : this.nonComputedMember(left, right, self.expensiveChecks, context, create, self.expression);
            case AST.CallExpression:
              args = [];
              forEach(ast.arguments, function(expr) {
                args.push(self.recurse(expr));
              });
              if (ast.filter)
                right = this.$filter(ast.callee.name);
              if (!ast.filter)
                right = this.recurse(ast.callee, true);
              return ast.filter ? function(scope, locals, assign, inputs) {
                var values = [];
                for (var i = 0; i < args.length; ++i) {
                  values.push(args[i](scope, locals, assign, inputs));
                }
                var value = right.apply(undefined, values, inputs);
                return context ? {
                  context: undefined,
                  name: undefined,
                  value: value
                } : value;
              } : function(scope, locals, assign, inputs) {
                var rhs = right(scope, locals, assign, inputs);
                var value;
                if (rhs.value != null) {
                  ensureSafeObject(rhs.context, self.expression);
                  ensureSafeFunction(rhs.value, self.expression);
                  var values = [];
                  for (var i = 0; i < args.length; ++i) {
                    values.push(ensureSafeObject(args[i](scope, locals, assign, inputs), self.expression));
                  }
                  value = ensureSafeObject(rhs.value.apply(rhs.context, values), self.expression);
                }
                return context ? {value: value} : value;
              };
            case AST.AssignmentExpression:
              left = this.recurse(ast.left, true, 1);
              right = this.recurse(ast.right);
              return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs);
                var rhs = right(scope, locals, assign, inputs);
                ensureSafeObject(lhs.value, self.expression);
                ensureSafeAssignContext(lhs.context);
                lhs.context[lhs.name] = rhs;
                return context ? {value: rhs} : rhs;
              };
            case AST.ArrayExpression:
              args = [];
              forEach(ast.elements, function(expr) {
                args.push(self.recurse(expr));
              });
              return function(scope, locals, assign, inputs) {
                var value = [];
                for (var i = 0; i < args.length; ++i) {
                  value.push(args[i](scope, locals, assign, inputs));
                }
                return context ? {value: value} : value;
              };
            case AST.ObjectExpression:
              args = [];
              forEach(ast.properties, function(property) {
                if (property.computed) {
                  args.push({
                    key: self.recurse(property.key),
                    computed: true,
                    value: self.recurse(property.value)
                  });
                } else {
                  args.push({
                    key: property.key.type === AST.Identifier ? property.key.name : ('' + property.key.value),
                    computed: false,
                    value: self.recurse(property.value)
                  });
                }
              });
              return function(scope, locals, assign, inputs) {
                var value = {};
                for (var i = 0; i < args.length; ++i) {
                  if (args[i].computed) {
                    value[args[i].key(scope, locals, assign, inputs)] = args[i].value(scope, locals, assign, inputs);
                  } else {
                    value[args[i].key] = args[i].value(scope, locals, assign, inputs);
                  }
                }
                return context ? {value: value} : value;
              };
            case AST.ThisExpression:
              return function(scope) {
                return context ? {value: scope} : scope;
              };
            case AST.LocalsExpression:
              return function(scope, locals) {
                return context ? {value: locals} : locals;
              };
            case AST.NGValueParameter:
              return function(scope, locals, assign) {
                return context ? {value: assign} : assign;
              };
          }
        },
        'unary+': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = argument(scope, locals, assign, inputs);
            if (isDefined(arg)) {
              arg = +arg;
            } else {
              arg = 0;
            }
            return context ? {value: arg} : arg;
          };
        },
        'unary-': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = argument(scope, locals, assign, inputs);
            if (isDefined(arg)) {
              arg = -arg;
            } else {
              arg = 0;
            }
            return context ? {value: arg} : arg;
          };
        },
        'unary!': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = !argument(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary+': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs = right(scope, locals, assign, inputs);
            var arg = plusFn(lhs, rhs);
            return context ? {value: arg} : arg;
          };
        },
        'binary-': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs = right(scope, locals, assign, inputs);
            var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
            return context ? {value: arg} : arg;
          };
        },
        'binary*': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary/': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary%': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary===': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary!==': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary==': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary!=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary<': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary>': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary<=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary>=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary&&': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary||': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'ternary?:': function(test, alternate, consequent, context) {
          return function(scope, locals, assign, inputs) {
            var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        value: function(value, context) {
          return function() {
            return context ? {
              context: undefined,
              name: undefined,
              value: value
            } : value;
          };
        },
        identifier: function(name, expensiveChecks, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var base = locals && (name in locals) ? locals : scope;
            if (create && create !== 1 && base && !(base[name])) {
              base[name] = {};
            }
            var value = base ? base[name] : undefined;
            if (expensiveChecks) {
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: base,
                name: name,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        computedMember: function(left, right, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs;
            var value;
            if (lhs != null) {
              rhs = right(scope, locals, assign, inputs);
              rhs = getStringValue(rhs);
              ensureSafeMemberName(rhs, expression);
              if (create && create !== 1) {
                ensureSafeAssignContext(lhs);
                if (lhs && !(lhs[rhs])) {
                  lhs[rhs] = {};
                }
              }
              value = lhs[rhs];
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: lhs,
                name: rhs,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        nonComputedMember: function(left, right, expensiveChecks, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            if (create && create !== 1) {
              ensureSafeAssignContext(lhs);
              if (lhs && !(lhs[right])) {
                lhs[right] = {};
              }
            }
            var value = lhs != null ? lhs[right] : undefined;
            if (expensiveChecks || isPossiblyDangerousMemberName(right)) {
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: lhs,
                name: right,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        inputs: function(input, watchId) {
          return function(scope, value, locals, inputs) {
            if (inputs)
              return inputs[watchId];
            return input(scope, value, locals);
          };
        }
      };
      var Parser = function(lexer, $filter, options) {
        this.lexer = lexer;
        this.$filter = $filter;
        this.options = options;
        this.ast = new AST(lexer, options);
        this.astCompiler = options.csp ? new ASTInterpreter(this.ast, $filter) : new ASTCompiler(this.ast, $filter);
      };
      Parser.prototype = {
        constructor: Parser,
        parse: function(text) {
          return this.astCompiler.compile(text, this.options.expensiveChecks);
        }
      };
      function isPossiblyDangerousMemberName(name) {
        return name == 'constructor';
      }
      var objectValueOf = Object.prototype.valueOf;
      function getValueOf(value) {
        return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
      }
      function $ParseProvider() {
        var cacheDefault = createMap();
        var cacheExpensive = createMap();
        var literals = {
          'true': true,
          'false': false,
          'null': null,
          'undefined': undefined
        };
        var identStart,
            identContinue;
        this.addLiteral = function(literalName, literalValue) {
          literals[literalName] = literalValue;
        };
        this.setIdentifierFns = function(identifierStart, identifierContinue) {
          identStart = identifierStart;
          identContinue = identifierContinue;
          return this;
        };
        this.$get = ['$filter', function($filter) {
          var noUnsafeEval = csp().noUnsafeEval;
          var $parseOptions = {
            csp: noUnsafeEval,
            expensiveChecks: false,
            literals: copy(literals),
            isIdentifierStart: isFunction(identStart) && identStart,
            isIdentifierContinue: isFunction(identContinue) && identContinue
          },
              $parseOptionsExpensive = {
                csp: noUnsafeEval,
                expensiveChecks: true,
                literals: copy(literals),
                isIdentifierStart: isFunction(identStart) && identStart,
                isIdentifierContinue: isFunction(identContinue) && identContinue
              };
          var runningChecksEnabled = false;
          $parse.$$runningExpensiveChecks = function() {
            return runningChecksEnabled;
          };
          return $parse;
          function $parse(exp, interceptorFn, expensiveChecks) {
            var parsedExpression,
                oneTime,
                cacheKey;
            expensiveChecks = expensiveChecks || runningChecksEnabled;
            switch (typeof exp) {
              case 'string':
                exp = exp.trim();
                cacheKey = exp;
                var cache = (expensiveChecks ? cacheExpensive : cacheDefault);
                parsedExpression = cache[cacheKey];
                if (!parsedExpression) {
                  if (exp.charAt(0) === ':' && exp.charAt(1) === ':') {
                    oneTime = true;
                    exp = exp.substring(2);
                  }
                  var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions;
                  var lexer = new Lexer(parseOptions);
                  var parser = new Parser(lexer, $filter, parseOptions);
                  parsedExpression = parser.parse(exp);
                  if (parsedExpression.constant) {
                    parsedExpression.$$watchDelegate = constantWatchDelegate;
                  } else if (oneTime) {
                    parsedExpression.$$watchDelegate = parsedExpression.literal ? oneTimeLiteralWatchDelegate : oneTimeWatchDelegate;
                  } else if (parsedExpression.inputs) {
                    parsedExpression.$$watchDelegate = inputsWatchDelegate;
                  }
                  if (expensiveChecks) {
                    parsedExpression = expensiveChecksInterceptor(parsedExpression);
                  }
                  cache[cacheKey] = parsedExpression;
                }
                return addInterceptor(parsedExpression, interceptorFn);
              case 'function':
                return addInterceptor(exp, interceptorFn);
              default:
                return addInterceptor(noop, interceptorFn);
            }
          }
          function expensiveChecksInterceptor(fn) {
            if (!fn)
              return fn;
            expensiveCheckFn.$$watchDelegate = fn.$$watchDelegate;
            expensiveCheckFn.assign = expensiveChecksInterceptor(fn.assign);
            expensiveCheckFn.constant = fn.constant;
            expensiveCheckFn.literal = fn.literal;
            for (var i = 0; fn.inputs && i < fn.inputs.length; ++i) {
              fn.inputs[i] = expensiveChecksInterceptor(fn.inputs[i]);
            }
            expensiveCheckFn.inputs = fn.inputs;
            return expensiveCheckFn;
            function expensiveCheckFn(scope, locals, assign, inputs) {
              var expensiveCheckOldValue = runningChecksEnabled;
              runningChecksEnabled = true;
              try {
                return fn(scope, locals, assign, inputs);
              } finally {
                runningChecksEnabled = expensiveCheckOldValue;
              }
            }
          }
          function expressionInputDirtyCheck(newValue, oldValueOfValue) {
            if (newValue == null || oldValueOfValue == null) {
              return newValue === oldValueOfValue;
            }
            if (typeof newValue === 'object') {
              newValue = getValueOf(newValue);
              if (typeof newValue === 'object') {
                return false;
              }
            }
            return newValue === oldValueOfValue || (newValue !== newValue && oldValueOfValue !== oldValueOfValue);
          }
          function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
            var inputExpressions = parsedExpression.inputs;
            var lastResult;
            if (inputExpressions.length === 1) {
              var oldInputValueOf = expressionInputDirtyCheck;
              inputExpressions = inputExpressions[0];
              return scope.$watch(function expressionInputWatch(scope) {
                var newInputValue = inputExpressions(scope);
                if (!expressionInputDirtyCheck(newInputValue, oldInputValueOf)) {
                  lastResult = parsedExpression(scope, undefined, undefined, [newInputValue]);
                  oldInputValueOf = newInputValue && getValueOf(newInputValue);
                }
                return lastResult;
              }, listener, objectEquality, prettyPrintExpression);
            }
            var oldInputValueOfValues = [];
            var oldInputValues = [];
            for (var i = 0,
                ii = inputExpressions.length; i < ii; i++) {
              oldInputValueOfValues[i] = expressionInputDirtyCheck;
              oldInputValues[i] = null;
            }
            return scope.$watch(function expressionInputsWatch(scope) {
              var changed = false;
              for (var i = 0,
                  ii = inputExpressions.length; i < ii; i++) {
                var newInputValue = inputExpressions[i](scope);
                if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) {
                  oldInputValues[i] = newInputValue;
                  oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue);
                }
              }
              if (changed) {
                lastResult = parsedExpression(scope, undefined, undefined, oldInputValues);
              }
              return lastResult;
            }, listener, objectEquality, prettyPrintExpression);
          }
          function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch,
                lastValue;
            return unwatch = scope.$watch(function oneTimeWatch(scope) {
              return parsedExpression(scope);
            }, function oneTimeListener(value, old, scope) {
              lastValue = value;
              if (isFunction(listener)) {
                listener.apply(this, arguments);
              }
              if (isDefined(value)) {
                scope.$$postDigest(function() {
                  if (isDefined(lastValue)) {
                    unwatch();
                  }
                });
              }
            }, objectEquality);
          }
          function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch,
                lastValue;
            return unwatch = scope.$watch(function oneTimeWatch(scope) {
              return parsedExpression(scope);
            }, function oneTimeListener(value, old, scope) {
              lastValue = value;
              if (isFunction(listener)) {
                listener.call(this, value, old, scope);
              }
              if (isAllDefined(value)) {
                scope.$$postDigest(function() {
                  if (isAllDefined(lastValue))
                    unwatch();
                });
              }
            }, objectEquality);
            function isAllDefined(value) {
              var allDefined = true;
              forEach(value, function(val) {
                if (!isDefined(val))
                  allDefined = false;
              });
              return allDefined;
            }
          }
          function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch;
            return unwatch = scope.$watch(function constantWatch(scope) {
              unwatch();
              return parsedExpression(scope);
            }, listener, objectEquality);
          }
          function addInterceptor(parsedExpression, interceptorFn) {
            if (!interceptorFn)
              return parsedExpression;
            var watchDelegate = parsedExpression.$$watchDelegate;
            var useInputs = false;
            var regularWatch = watchDelegate !== oneTimeLiteralWatchDelegate && watchDelegate !== oneTimeWatchDelegate;
            var fn = regularWatch ? function regularInterceptedExpression(scope, locals, assign, inputs) {
              var value = useInputs && inputs ? inputs[0] : parsedExpression(scope, locals, assign, inputs);
              return interceptorFn(value, scope, locals);
            } : function oneTimeInterceptedExpression(scope, locals, assign, inputs) {
              var value = parsedExpression(scope, locals, assign, inputs);
              var result = interceptorFn(value, scope, locals);
              return isDefined(value) ? result : value;
            };
            if (parsedExpression.$$watchDelegate && parsedExpression.$$watchDelegate !== inputsWatchDelegate) {
              fn.$$watchDelegate = parsedExpression.$$watchDelegate;
            } else if (!interceptorFn.$stateful) {
              fn.$$watchDelegate = inputsWatchDelegate;
              useInputs = !parsedExpression.inputs;
              fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [parsedExpression];
            }
            return fn;
          }
        }];
      }
      function $QProvider() {
        this.$get = ['$rootScope', '$exceptionHandler', function($rootScope, $exceptionHandler) {
          return qFactory(function(callback) {
            $rootScope.$evalAsync(callback);
          }, $exceptionHandler);
        }];
      }
      function $$QProvider() {
        this.$get = ['$browser', '$exceptionHandler', function($browser, $exceptionHandler) {
          return qFactory(function(callback) {
            $browser.defer(callback);
          }, $exceptionHandler);
        }];
      }
      function qFactory(nextTick, exceptionHandler) {
        var $qMinErr = minErr('$q', TypeError);
        var defer = function() {
          var d = new Deferred();
          d.resolve = simpleBind(d, d.resolve);
          d.reject = simpleBind(d, d.reject);
          d.notify = simpleBind(d, d.notify);
          return d;
        };
        function Promise() {
          this.$$state = {status: 0};
        }
        extend(Promise.prototype, {
          then: function(onFulfilled, onRejected, progressBack) {
            if (isUndefined(onFulfilled) && isUndefined(onRejected) && isUndefined(progressBack)) {
              return this;
            }
            var result = new Deferred();
            this.$$state.pending = this.$$state.pending || [];
            this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]);
            if (this.$$state.status > 0)
              scheduleProcessQueue(this.$$state);
            return result.promise;
          },
          "catch": function(callback) {
            return this.then(null, callback);
          },
          "finally": function(callback, progressBack) {
            return this.then(function(value) {
              return handleCallback(value, true, callback);
            }, function(error) {
              return handleCallback(error, false, callback);
            }, progressBack);
          }
        });
        function simpleBind(context, fn) {
          return function(value) {
            fn.call(context, value);
          };
        }
        function processQueue(state) {
          var fn,
              deferred,
              pending;
          pending = state.pending;
          state.processScheduled = false;
          state.pending = undefined;
          for (var i = 0,
              ii = pending.length; i < ii; ++i) {
            deferred = pending[i][0];
            fn = pending[i][state.status];
            try {
              if (isFunction(fn)) {
                deferred.resolve(fn(state.value));
              } else if (state.status === 1) {
                deferred.resolve(state.value);
              } else {
                deferred.reject(state.value);
              }
            } catch (e) {
              deferred.reject(e);
              exceptionHandler(e);
            }
          }
        }
        function scheduleProcessQueue(state) {
          if (state.processScheduled || !state.pending)
            return;
          state.processScheduled = true;
          nextTick(function() {
            processQueue(state);
          });
        }
        function Deferred() {
          this.promise = new Promise();
        }
        extend(Deferred.prototype, {
          resolve: function(val) {
            if (this.promise.$$state.status)
              return;
            if (val === this.promise) {
              this.$$reject($qMinErr('qcycle', "Expected promise to be resolved with value other than itself '{0}'", val));
            } else {
              this.$$resolve(val);
            }
          },
          $$resolve: function(val) {
            var then;
            var that = this;
            var done = false;
            try {
              if ((isObject(val) || isFunction(val)))
                then = val && val.then;
              if (isFunction(then)) {
                this.promise.$$state.status = -1;
                then.call(val, resolvePromise, rejectPromise, simpleBind(this, this.notify));
              } else {
                this.promise.$$state.value = val;
                this.promise.$$state.status = 1;
                scheduleProcessQueue(this.promise.$$state);
              }
            } catch (e) {
              rejectPromise(e);
              exceptionHandler(e);
            }
            function resolvePromise(val) {
              if (done)
                return;
              done = true;
              that.$$resolve(val);
            }
            function rejectPromise(val) {
              if (done)
                return;
              done = true;
              that.$$reject(val);
            }
          },
          reject: function(reason) {
            if (this.promise.$$state.status)
              return;
            this.$$reject(reason);
          },
          $$reject: function(reason) {
            this.promise.$$state.value = reason;
            this.promise.$$state.status = 2;
            scheduleProcessQueue(this.promise.$$state);
          },
          notify: function(progress) {
            var callbacks = this.promise.$$state.pending;
            if ((this.promise.$$state.status <= 0) && callbacks && callbacks.length) {
              nextTick(function() {
                var callback,
                    result;
                for (var i = 0,
                    ii = callbacks.length; i < ii; i++) {
                  result = callbacks[i][0];
                  callback = callbacks[i][3];
                  try {
                    result.notify(isFunction(callback) ? callback(progress) : progress);
                  } catch (e) {
                    exceptionHandler(e);
                  }
                }
              });
            }
          }
        });
        var reject = function(reason) {
          var result = new Deferred();
          result.reject(reason);
          return result.promise;
        };
        var makePromise = function makePromise(value, resolved) {
          var result = new Deferred();
          if (resolved) {
            result.resolve(value);
          } else {
            result.reject(value);
          }
          return result.promise;
        };
        var handleCallback = function handleCallback(value, isResolved, callback) {
          var callbackOutput = null;
          try {
            if (isFunction(callback))
              callbackOutput = callback();
          } catch (e) {
            return makePromise(e, false);
          }
          if (isPromiseLike(callbackOutput)) {
            return callbackOutput.then(function() {
              return makePromise(value, isResolved);
            }, function(error) {
              return makePromise(error, false);
            });
          } else {
            return makePromise(value, isResolved);
          }
        };
        var when = function(value, callback, errback, progressBack) {
          var result = new Deferred();
          result.resolve(value);
          return result.promise.then(callback, errback, progressBack);
        };
        var resolve = when;
        function all(promises) {
          var deferred = new Deferred(),
              counter = 0,
              results = isArray(promises) ? [] : {};
          forEach(promises, function(promise, key) {
            counter++;
            when(promise).then(function(value) {
              if (results.hasOwnProperty(key))
                return;
              results[key] = value;
              if (!(--counter))
                deferred.resolve(results);
            }, function(reason) {
              if (results.hasOwnProperty(key))
                return;
              deferred.reject(reason);
            });
          });
          if (counter === 0) {
            deferred.resolve(results);
          }
          return deferred.promise;
        }
        var $Q = function Q(resolver) {
          if (!isFunction(resolver)) {
            throw $qMinErr('norslvr', "Expected resolverFn, got '{0}'", resolver);
          }
          var deferred = new Deferred();
          function resolveFn(value) {
            deferred.resolve(value);
          }
          function rejectFn(reason) {
            deferred.reject(reason);
          }
          resolver(resolveFn, rejectFn);
          return deferred.promise;
        };
        $Q.prototype = Promise.prototype;
        $Q.defer = defer;
        $Q.reject = reject;
        $Q.when = when;
        $Q.resolve = resolve;
        $Q.all = all;
        return $Q;
      }
      function $$RAFProvider() {
        this.$get = ['$window', '$timeout', function($window, $timeout) {
          var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame;
          var cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame;
          var rafSupported = !!requestAnimationFrame;
          var raf = rafSupported ? function(fn) {
            var id = requestAnimationFrame(fn);
            return function() {
              cancelAnimationFrame(id);
            };
          } : function(fn) {
            var timer = $timeout(fn, 16.66, false);
            return function() {
              $timeout.cancel(timer);
            };
          };
          raf.supported = rafSupported;
          return raf;
        }];
      }
      function $RootScopeProvider() {
        var TTL = 10;
        var $rootScopeMinErr = minErr('$rootScope');
        var lastDirtyWatch = null;
        var applyAsyncId = null;
        this.digestTtl = function(value) {
          if (arguments.length) {
            TTL = value;
          }
          return TTL;
        };
        function createChildScopeClass(parent) {
          function ChildScope() {
            this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null;
            this.$$listeners = {};
            this.$$listenerCount = {};
            this.$$watchersCount = 0;
            this.$id = nextUid();
            this.$$ChildScope = null;
          }
          ChildScope.prototype = parent;
          return ChildScope;
        }
        this.$get = ['$exceptionHandler', '$parse', '$browser', function($exceptionHandler, $parse, $browser) {
          function destroyChildScope($event) {
            $event.currentScope.$$destroyed = true;
          }
          function cleanUpScope($scope) {
            if (msie === 9) {
              $scope.$$childHead && cleanUpScope($scope.$$childHead);
              $scope.$$nextSibling && cleanUpScope($scope.$$nextSibling);
            }
            $scope.$parent = $scope.$$nextSibling = $scope.$$prevSibling = $scope.$$childHead = $scope.$$childTail = $scope.$root = $scope.$$watchers = null;
          }
          function Scope() {
            this.$id = nextUid();
            this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
            this.$root = this;
            this.$$destroyed = false;
            this.$$listeners = {};
            this.$$listenerCount = {};
            this.$$watchersCount = 0;
            this.$$isolateBindings = null;
          }
          Scope.prototype = {
            constructor: Scope,
            $new: function(isolate, parent) {
              var child;
              parent = parent || this;
              if (isolate) {
                child = new Scope();
                child.$root = this.$root;
              } else {
                if (!this.$$ChildScope) {
                  this.$$ChildScope = createChildScopeClass(this);
                }
                child = new this.$$ChildScope();
              }
              child.$parent = parent;
              child.$$prevSibling = parent.$$childTail;
              if (parent.$$childHead) {
                parent.$$childTail.$$nextSibling = child;
                parent.$$childTail = child;
              } else {
                parent.$$childHead = parent.$$childTail = child;
              }
              if (isolate || parent != this)
                child.$on('$destroy', destroyChildScope);
              return child;
            },
            $watch: function(watchExp, listener, objectEquality, prettyPrintExpression) {
              var get = $parse(watchExp);
              if (get.$$watchDelegate) {
                return get.$$watchDelegate(this, listener, objectEquality, get, watchExp);
              }
              var scope = this,
                  array = scope.$$watchers,
                  watcher = {
                    fn: listener,
                    last: initWatchVal,
                    get: get,
                    exp: prettyPrintExpression || watchExp,
                    eq: !!objectEquality
                  };
              lastDirtyWatch = null;
              if (!isFunction(listener)) {
                watcher.fn = noop;
              }
              if (!array) {
                array = scope.$$watchers = [];
              }
              array.unshift(watcher);
              incrementWatchersCount(this, 1);
              return function deregisterWatch() {
                if (arrayRemove(array, watcher) >= 0) {
                  incrementWatchersCount(scope, -1);
                }
                lastDirtyWatch = null;
              };
            },
            $watchGroup: function(watchExpressions, listener) {
              var oldValues = new Array(watchExpressions.length);
              var newValues = new Array(watchExpressions.length);
              var deregisterFns = [];
              var self = this;
              var changeReactionScheduled = false;
              var firstRun = true;
              if (!watchExpressions.length) {
                var shouldCall = true;
                self.$evalAsync(function() {
                  if (shouldCall)
                    listener(newValues, newValues, self);
                });
                return function deregisterWatchGroup() {
                  shouldCall = false;
                };
              }
              if (watchExpressions.length === 1) {
                return this.$watch(watchExpressions[0], function watchGroupAction(value, oldValue, scope) {
                  newValues[0] = value;
                  oldValues[0] = oldValue;
                  listener(newValues, (value === oldValue) ? newValues : oldValues, scope);
                });
              }
              forEach(watchExpressions, function(expr, i) {
                var unwatchFn = self.$watch(expr, function watchGroupSubAction(value, oldValue) {
                  newValues[i] = value;
                  oldValues[i] = oldValue;
                  if (!changeReactionScheduled) {
                    changeReactionScheduled = true;
                    self.$evalAsync(watchGroupAction);
                  }
                });
                deregisterFns.push(unwatchFn);
              });
              function watchGroupAction() {
                changeReactionScheduled = false;
                if (firstRun) {
                  firstRun = false;
                  listener(newValues, newValues, self);
                } else {
                  listener(newValues, oldValues, self);
                }
              }
              return function deregisterWatchGroup() {
                while (deregisterFns.length) {
                  deregisterFns.shift()();
                }
              };
            },
            $watchCollection: function(obj, listener) {
              $watchCollectionInterceptor.$stateful = true;
              var self = this;
              var newValue;
              var oldValue;
              var veryOldValue;
              var trackVeryOldValue = (listener.length > 1);
              var changeDetected = 0;
              var changeDetector = $parse(obj, $watchCollectionInterceptor);
              var internalArray = [];
              var internalObject = {};
              var initRun = true;
              var oldLength = 0;
              function $watchCollectionInterceptor(_value) {
                newValue = _value;
                var newLength,
                    key,
                    bothNaN,
                    newItem,
                    oldItem;
                if (isUndefined(newValue))
                  return;
                if (!isObject(newValue)) {
                  if (oldValue !== newValue) {
                    oldValue = newValue;
                    changeDetected++;
                  }
                } else if (isArrayLike(newValue)) {
                  if (oldValue !== internalArray) {
                    oldValue = internalArray;
                    oldLength = oldValue.length = 0;
                    changeDetected++;
                  }
                  newLength = newValue.length;
                  if (oldLength !== newLength) {
                    changeDetected++;
                    oldValue.length = oldLength = newLength;
                  }
                  for (var i = 0; i < newLength; i++) {
                    oldItem = oldValue[i];
                    newItem = newValue[i];
                    bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
                    if (!bothNaN && (oldItem !== newItem)) {
                      changeDetected++;
                      oldValue[i] = newItem;
                    }
                  }
                } else {
                  if (oldValue !== internalObject) {
                    oldValue = internalObject = {};
                    oldLength = 0;
                    changeDetected++;
                  }
                  newLength = 0;
                  for (key in newValue) {
                    if (hasOwnProperty.call(newValue, key)) {
                      newLength++;
                      newItem = newValue[key];
                      oldItem = oldValue[key];
                      if (key in oldValue) {
                        bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
                        if (!bothNaN && (oldItem !== newItem)) {
                          changeDetected++;
                          oldValue[key] = newItem;
                        }
                      } else {
                        oldLength++;
                        oldValue[key] = newItem;
                        changeDetected++;
                      }
                    }
                  }
                  if (oldLength > newLength) {
                    changeDetected++;
                    for (key in oldValue) {
                      if (!hasOwnProperty.call(newValue, key)) {
                        oldLength--;
                        delete oldValue[key];
                      }
                    }
                  }
                }
                return changeDetected;
              }
              function $watchCollectionAction() {
                if (initRun) {
                  initRun = false;
                  listener(newValue, newValue, self);
                } else {
                  listener(newValue, veryOldValue, self);
                }
                if (trackVeryOldValue) {
                  if (!isObject(newValue)) {
                    veryOldValue = newValue;
                  } else if (isArrayLike(newValue)) {
                    veryOldValue = new Array(newValue.length);
                    for (var i = 0; i < newValue.length; i++) {
                      veryOldValue[i] = newValue[i];
                    }
                  } else {
                    veryOldValue = {};
                    for (var key in newValue) {
                      if (hasOwnProperty.call(newValue, key)) {
                        veryOldValue[key] = newValue[key];
                      }
                    }
                  }
                }
              }
              return this.$watch(changeDetector, $watchCollectionAction);
            },
            $digest: function() {
              var watch,
                  value,
                  last,
                  fn,
                  get,
                  watchers,
                  length,
                  dirty,
                  ttl = TTL,
                  next,
                  current,
                  target = this,
                  watchLog = [],
                  logIdx,
                  asyncTask;
              beginPhase('$digest');
              $browser.$$checkUrlChange();
              if (this === $rootScope && applyAsyncId !== null) {
                $browser.defer.cancel(applyAsyncId);
                flushApplyAsync();
              }
              lastDirtyWatch = null;
              do {
                dirty = false;
                current = target;
                for (var asyncQueuePosition = 0; asyncQueuePosition < asyncQueue.length; asyncQueuePosition++) {
                  try {
                    asyncTask = asyncQueue[asyncQueuePosition];
                    asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                  lastDirtyWatch = null;
                }
                asyncQueue.length = 0;
                traverseScopesLoop: do {
                  if ((watchers = current.$$watchers)) {
                    length = watchers.length;
                    while (length--) {
                      try {
                        watch = watchers[length];
                        if (watch) {
                          get = watch.get;
                          if ((value = get(current)) !== (last = watch.last) && !(watch.eq ? equals(value, last) : (typeof value === 'number' && typeof last === 'number' && isNaN(value) && isNaN(last)))) {
                            dirty = true;
                            lastDirtyWatch = watch;
                            watch.last = watch.eq ? copy(value, null) : value;
                            fn = watch.fn;
                            fn(value, ((last === initWatchVal) ? value : last), current);
                            if (ttl < 5) {
                              logIdx = 4 - ttl;
                              if (!watchLog[logIdx])
                                watchLog[logIdx] = [];
                              watchLog[logIdx].push({
                                msg: isFunction(watch.exp) ? 'fn: ' + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                newVal: value,
                                oldVal: last
                              });
                            }
                          } else if (watch === lastDirtyWatch) {
                            dirty = false;
                            break traverseScopesLoop;
                          }
                        }
                      } catch (e) {
                        $exceptionHandler(e);
                      }
                    }
                  }
                  if (!(next = ((current.$$watchersCount && current.$$childHead) || (current !== target && current.$$nextSibling)))) {
                    while (current !== target && !(next = current.$$nextSibling)) {
                      current = current.$parent;
                    }
                  }
                } while ((current = next));
                if ((dirty || asyncQueue.length) && !(ttl--)) {
                  clearPhase();
                  throw $rootScopeMinErr('infdig', '{0} $digest() iterations reached. Aborting!\n' + 'Watchers fired in the last 5 iterations: {1}', TTL, watchLog);
                }
              } while (dirty || asyncQueue.length);
              clearPhase();
              while (postDigestQueuePosition < postDigestQueue.length) {
                try {
                  postDigestQueue[postDigestQueuePosition++]();
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
              postDigestQueue.length = postDigestQueuePosition = 0;
            },
            $destroy: function() {
              if (this.$$destroyed)
                return;
              var parent = this.$parent;
              this.$broadcast('$destroy');
              this.$$destroyed = true;
              if (this === $rootScope) {
                $browser.$$applicationDestroyed();
              }
              incrementWatchersCount(this, -this.$$watchersCount);
              for (var eventName in this.$$listenerCount) {
                decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
              }
              if (parent && parent.$$childHead == this)
                parent.$$childHead = this.$$nextSibling;
              if (parent && parent.$$childTail == this)
                parent.$$childTail = this.$$prevSibling;
              if (this.$$prevSibling)
                this.$$prevSibling.$$nextSibling = this.$$nextSibling;
              if (this.$$nextSibling)
                this.$$nextSibling.$$prevSibling = this.$$prevSibling;
              this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;
              this.$on = this.$watch = this.$watchGroup = function() {
                return noop;
              };
              this.$$listeners = {};
              this.$$nextSibling = null;
              cleanUpScope(this);
            },
            $eval: function(expr, locals) {
              return $parse(expr)(this, locals);
            },
            $evalAsync: function(expr, locals) {
              if (!$rootScope.$$phase && !asyncQueue.length) {
                $browser.defer(function() {
                  if (asyncQueue.length) {
                    $rootScope.$digest();
                  }
                });
              }
              asyncQueue.push({
                scope: this,
                expression: $parse(expr),
                locals: locals
              });
            },
            $$postDigest: function(fn) {
              postDigestQueue.push(fn);
            },
            $apply: function(expr) {
              try {
                beginPhase('$apply');
                try {
                  return this.$eval(expr);
                } finally {
                  clearPhase();
                }
              } catch (e) {
                $exceptionHandler(e);
              } finally {
                try {
                  $rootScope.$digest();
                } catch (e) {
                  $exceptionHandler(e);
                  throw e;
                }
              }
            },
            $applyAsync: function(expr) {
              var scope = this;
              expr && applyAsyncQueue.push($applyAsyncExpression);
              expr = $parse(expr);
              scheduleApplyAsync();
              function $applyAsyncExpression() {
                scope.$eval(expr);
              }
            },
            $on: function(name, listener) {
              var namedListeners = this.$$listeners[name];
              if (!namedListeners) {
                this.$$listeners[name] = namedListeners = [];
              }
              namedListeners.push(listener);
              var current = this;
              do {
                if (!current.$$listenerCount[name]) {
                  current.$$listenerCount[name] = 0;
                }
                current.$$listenerCount[name]++;
              } while ((current = current.$parent));
              var self = this;
              return function() {
                var indexOfListener = namedListeners.indexOf(listener);
                if (indexOfListener !== -1) {
                  namedListeners[indexOfListener] = null;
                  decrementListenerCount(self, 1, name);
                }
              };
            },
            $emit: function(name, args) {
              var empty = [],
                  namedListeners,
                  scope = this,
                  stopPropagation = false,
                  event = {
                    name: name,
                    targetScope: scope,
                    stopPropagation: function() {
                      stopPropagation = true;
                    },
                    preventDefault: function() {
                      event.defaultPrevented = true;
                    },
                    defaultPrevented: false
                  },
                  listenerArgs = concat([event], arguments, 1),
                  i,
                  length;
              do {
                namedListeners = scope.$$listeners[name] || empty;
                event.currentScope = scope;
                for (i = 0, length = namedListeners.length; i < length; i++) {
                  if (!namedListeners[i]) {
                    namedListeners.splice(i, 1);
                    i--;
                    length--;
                    continue;
                  }
                  try {
                    namedListeners[i].apply(null, listenerArgs);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (stopPropagation) {
                  event.currentScope = null;
                  return event;
                }
                scope = scope.$parent;
              } while (scope);
              event.currentScope = null;
              return event;
            },
            $broadcast: function(name, args) {
              var target = this,
                  current = target,
                  next = target,
                  event = {
                    name: name,
                    targetScope: target,
                    preventDefault: function() {
                      event.defaultPrevented = true;
                    },
                    defaultPrevented: false
                  };
              if (!target.$$listenerCount[name])
                return event;
              var listenerArgs = concat([event], arguments, 1),
                  listeners,
                  i,
                  length;
              while ((current = next)) {
                event.currentScope = current;
                listeners = current.$$listeners[name] || [];
                for (i = 0, length = listeners.length; i < length; i++) {
                  if (!listeners[i]) {
                    listeners.splice(i, 1);
                    i--;
                    length--;
                    continue;
                  }
                  try {
                    listeners[i].apply(null, listenerArgs);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (!(next = ((current.$$listenerCount[name] && current.$$childHead) || (current !== target && current.$$nextSibling)))) {
                  while (current !== target && !(next = current.$$nextSibling)) {
                    current = current.$parent;
                  }
                }
              }
              event.currentScope = null;
              return event;
            }
          };
          var $rootScope = new Scope();
          var asyncQueue = $rootScope.$$asyncQueue = [];
          var postDigestQueue = $rootScope.$$postDigestQueue = [];
          var applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];
          var postDigestQueuePosition = 0;
          return $rootScope;
          function beginPhase(phase) {
            if ($rootScope.$$phase) {
              throw $rootScopeMinErr('inprog', '{0} already in progress', $rootScope.$$phase);
            }
            $rootScope.$$phase = phase;
          }
          function clearPhase() {
            $rootScope.$$phase = null;
          }
          function incrementWatchersCount(current, count) {
            do {
              current.$$watchersCount += count;
            } while ((current = current.$parent));
          }
          function decrementListenerCount(current, count, name) {
            do {
              current.$$listenerCount[name] -= count;
              if (current.$$listenerCount[name] === 0) {
                delete current.$$listenerCount[name];
              }
            } while ((current = current.$parent));
          }
          function initWatchVal() {}
          function flushApplyAsync() {
            while (applyAsyncQueue.length) {
              try {
                applyAsyncQueue.shift()();
              } catch (e) {
                $exceptionHandler(e);
              }
            }
            applyAsyncId = null;
          }
          function scheduleApplyAsync() {
            if (applyAsyncId === null) {
              applyAsyncId = $browser.defer(function() {
                $rootScope.$apply(flushApplyAsync);
              });
            }
          }
        }];
      }
      function $$SanitizeUriProvider() {
        var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/,
            imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
        this.aHrefSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            aHrefSanitizationWhitelist = regexp;
            return this;
          }
          return aHrefSanitizationWhitelist;
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            imgSrcSanitizationWhitelist = regexp;
            return this;
          }
          return imgSrcSanitizationWhitelist;
        };
        this.$get = function() {
          return function sanitizeUri(uri, isImage) {
            var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
            var normalizedVal;
            normalizedVal = urlResolve(uri).href;
            if (normalizedVal !== '' && !normalizedVal.match(regex)) {
              return 'unsafe:' + normalizedVal;
            }
            return uri;
          };
        };
      }
      var $sceMinErr = minErr('$sce');
      var SCE_CONTEXTS = {
        HTML: 'html',
        CSS: 'css',
        URL: 'url',
        RESOURCE_URL: 'resourceUrl',
        JS: 'js'
      };
      function adjustMatcher(matcher) {
        if (matcher === 'self') {
          return matcher;
        } else if (isString(matcher)) {
          if (matcher.indexOf('***') > -1) {
            throw $sceMinErr('iwcard', 'Illegal sequence *** in string matcher.  String: {0}', matcher);
          }
          matcher = escapeForRegexp(matcher).replace('\\*\\*', '.*').replace('\\*', '[^:/.?&;]*');
          return new RegExp('^' + matcher + '$');
        } else if (isRegExp(matcher)) {
          return new RegExp('^' + matcher.source + '$');
        } else {
          throw $sceMinErr('imatcher', 'Matchers may only be "self", string patterns or RegExp objects');
        }
      }
      function adjustMatchers(matchers) {
        var adjustedMatchers = [];
        if (isDefined(matchers)) {
          forEach(matchers, function(matcher) {
            adjustedMatchers.push(adjustMatcher(matcher));
          });
        }
        return adjustedMatchers;
      }
      function $SceDelegateProvider() {
        this.SCE_CONTEXTS = SCE_CONTEXTS;
        var resourceUrlWhitelist = ['self'],
            resourceUrlBlacklist = [];
        this.resourceUrlWhitelist = function(value) {
          if (arguments.length) {
            resourceUrlWhitelist = adjustMatchers(value);
          }
          return resourceUrlWhitelist;
        };
        this.resourceUrlBlacklist = function(value) {
          if (arguments.length) {
            resourceUrlBlacklist = adjustMatchers(value);
          }
          return resourceUrlBlacklist;
        };
        this.$get = ['$injector', function($injector) {
          var htmlSanitizer = function htmlSanitizer(html) {
            throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
          };
          if ($injector.has('$sanitize')) {
            htmlSanitizer = $injector.get('$sanitize');
          }
          function matchUrl(matcher, parsedUrl) {
            if (matcher === 'self') {
              return urlIsSameOrigin(parsedUrl);
            } else {
              return !!matcher.exec(parsedUrl.href);
            }
          }
          function isResourceUrlAllowedByPolicy(url) {
            var parsedUrl = urlResolve(url.toString());
            var i,
                n,
                allowed = false;
            for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
              if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                allowed = true;
                break;
              }
            }
            if (allowed) {
              for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
                if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                  allowed = false;
                  break;
                }
              }
            }
            return allowed;
          }
          function generateHolderType(Base) {
            var holderType = function TrustedValueHolderType(trustedValue) {
              this.$$unwrapTrustedValue = function() {
                return trustedValue;
              };
            };
            if (Base) {
              holderType.prototype = new Base();
            }
            holderType.prototype.valueOf = function sceValueOf() {
              return this.$$unwrapTrustedValue();
            };
            holderType.prototype.toString = function sceToString() {
              return this.$$unwrapTrustedValue().toString();
            };
            return holderType;
          }
          var trustedValueHolderBase = generateHolderType(),
              byType = {};
          byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);
          function trustAs(type, trustedValue) {
            var Constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
            if (!Constructor) {
              throw $sceMinErr('icontext', 'Attempted to trust a value in invalid context. Context: {0}; Value: {1}', type, trustedValue);
            }
            if (trustedValue === null || isUndefined(trustedValue) || trustedValue === '') {
              return trustedValue;
            }
            if (typeof trustedValue !== 'string') {
              throw $sceMinErr('itype', 'Attempted to trust a non-string value in a content requiring a string: Context: {0}', type);
            }
            return new Constructor(trustedValue);
          }
          function valueOf(maybeTrusted) {
            if (maybeTrusted instanceof trustedValueHolderBase) {
              return maybeTrusted.$$unwrapTrustedValue();
            } else {
              return maybeTrusted;
            }
          }
          function getTrusted(type, maybeTrusted) {
            if (maybeTrusted === null || isUndefined(maybeTrusted) || maybeTrusted === '') {
              return maybeTrusted;
            }
            var constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
            if (constructor && maybeTrusted instanceof constructor) {
              return maybeTrusted.$$unwrapTrustedValue();
            }
            if (type === SCE_CONTEXTS.RESOURCE_URL) {
              if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
                return maybeTrusted;
              } else {
                throw $sceMinErr('insecurl', 'Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}', maybeTrusted.toString());
              }
            } else if (type === SCE_CONTEXTS.HTML) {
              return htmlSanitizer(maybeTrusted);
            }
            throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
          }
          return {
            trustAs: trustAs,
            getTrusted: getTrusted,
            valueOf: valueOf
          };
        }];
      }
      function $SceProvider() {
        var enabled = true;
        this.enabled = function(value) {
          if (arguments.length) {
            enabled = !!value;
          }
          return enabled;
        };
        this.$get = ['$parse', '$sceDelegate', function($parse, $sceDelegate) {
          if (enabled && msie < 8) {
            throw $sceMinErr('iequirks', 'Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks ' + 'mode.  You can fix this by adding the text <!doctype html> to the top of your HTML ' + 'document.  See http://docs.angularjs.org/api/ng.$sce for more information.');
          }
          var sce = shallowCopy(SCE_CONTEXTS);
          sce.isEnabled = function() {
            return enabled;
          };
          sce.trustAs = $sceDelegate.trustAs;
          sce.getTrusted = $sceDelegate.getTrusted;
          sce.valueOf = $sceDelegate.valueOf;
          if (!enabled) {
            sce.trustAs = sce.getTrusted = function(type, value) {
              return value;
            };
            sce.valueOf = identity;
          }
          sce.parseAs = function sceParseAs(type, expr) {
            var parsed = $parse(expr);
            if (parsed.literal && parsed.constant) {
              return parsed;
            } else {
              return $parse(expr, function(value) {
                return sce.getTrusted(type, value);
              });
            }
          };
          var parse = sce.parseAs,
              getTrusted = sce.getTrusted,
              trustAs = sce.trustAs;
          forEach(SCE_CONTEXTS, function(enumValue, name) {
            var lName = lowercase(name);
            sce[camelCase("parse_as_" + lName)] = function(expr) {
              return parse(enumValue, expr);
            };
            sce[camelCase("get_trusted_" + lName)] = function(value) {
              return getTrusted(enumValue, value);
            };
            sce[camelCase("trust_as_" + lName)] = function(value) {
              return trustAs(enumValue, value);
            };
          });
          return sce;
        }];
      }
      function $SnifferProvider() {
        this.$get = ['$window', '$document', function($window, $document) {
          var eventSupport = {},
              isChromePackagedApp = $window.chrome && $window.chrome.app && $window.chrome.app.runtime,
              hasHistoryPushState = !isChromePackagedApp && $window.history && $window.history.pushState,
              android = toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]),
              boxee = /Boxee/i.test(($window.navigator || {}).userAgent),
              document = $document[0] || {},
              vendorPrefix,
              vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/,
              bodyStyle = document.body && document.body.style,
              transitions = false,
              animations = false,
              match;
          if (bodyStyle) {
            for (var prop in bodyStyle) {
              if (match = vendorRegex.exec(prop)) {
                vendorPrefix = match[0];
                vendorPrefix = vendorPrefix[0].toUpperCase() + vendorPrefix.substr(1);
                break;
              }
            }
            if (!vendorPrefix) {
              vendorPrefix = ('WebkitOpacity' in bodyStyle) && 'webkit';
            }
            transitions = !!(('transition' in bodyStyle) || (vendorPrefix + 'Transition' in bodyStyle));
            animations = !!(('animation' in bodyStyle) || (vendorPrefix + 'Animation' in bodyStyle));
            if (android && (!transitions || !animations)) {
              transitions = isString(bodyStyle.webkitTransition);
              animations = isString(bodyStyle.webkitAnimation);
            }
          }
          return {
            history: !!(hasHistoryPushState && !(android < 4) && !boxee),
            hasEvent: function(event) {
              if (event === 'input' && msie <= 11)
                return false;
              if (isUndefined(eventSupport[event])) {
                var divElm = document.createElement('div');
                eventSupport[event] = 'on' + event in divElm;
              }
              return eventSupport[event];
            },
            csp: csp(),
            vendorPrefix: vendorPrefix,
            transitions: transitions,
            animations: animations,
            android: android
          };
        }];
      }
      var $templateRequestMinErr = minErr('$compile');
      function $TemplateRequestProvider() {
        var httpOptions;
        this.httpOptions = function(val) {
          if (val) {
            httpOptions = val;
            return this;
          }
          return httpOptions;
        };
        this.$get = ['$templateCache', '$http', '$q', '$sce', function($templateCache, $http, $q, $sce) {
          function handleRequestFn(tpl, ignoreRequestError) {
            handleRequestFn.totalPendingRequests++;
            if (!isString(tpl) || isUndefined($templateCache.get(tpl))) {
              tpl = $sce.getTrustedResourceUrl(tpl);
            }
            var transformResponse = $http.defaults && $http.defaults.transformResponse;
            if (isArray(transformResponse)) {
              transformResponse = transformResponse.filter(function(transformer) {
                return transformer !== defaultHttpResponseTransform;
              });
            } else if (transformResponse === defaultHttpResponseTransform) {
              transformResponse = null;
            }
            return $http.get(tpl, extend({
              cache: $templateCache,
              transformResponse: transformResponse
            }, httpOptions))['finally'](function() {
              handleRequestFn.totalPendingRequests--;
            }).then(function(response) {
              $templateCache.put(tpl, response.data);
              return response.data;
            }, handleError);
            function handleError(resp) {
              if (!ignoreRequestError) {
                throw $templateRequestMinErr('tpload', 'Failed to load template: {0} (HTTP status: {1} {2})', tpl, resp.status, resp.statusText);
              }
              return $q.reject(resp);
            }
          }
          handleRequestFn.totalPendingRequests = 0;
          return handleRequestFn;
        }];
      }
      function $$TestabilityProvider() {
        this.$get = ['$rootScope', '$browser', '$location', function($rootScope, $browser, $location) {
          var testability = {};
          testability.findBindings = function(element, expression, opt_exactMatch) {
            var bindings = element.getElementsByClassName('ng-binding');
            var matches = [];
            forEach(bindings, function(binding) {
              var dataBinding = angular.element(binding).data('$binding');
              if (dataBinding) {
                forEach(dataBinding, function(bindingName) {
                  if (opt_exactMatch) {
                    var matcher = new RegExp('(^|\\s)' + escapeForRegexp(expression) + '(\\s|\\||$)');
                    if (matcher.test(bindingName)) {
                      matches.push(binding);
                    }
                  } else {
                    if (bindingName.indexOf(expression) != -1) {
                      matches.push(binding);
                    }
                  }
                });
              }
            });
            return matches;
          };
          testability.findModels = function(element, expression, opt_exactMatch) {
            var prefixes = ['ng-', 'data-ng-', 'ng\\:'];
            for (var p = 0; p < prefixes.length; ++p) {
              var attributeEquals = opt_exactMatch ? '=' : '*=';
              var selector = '[' + prefixes[p] + 'model' + attributeEquals + '"' + expression + '"]';
              var elements = element.querySelectorAll(selector);
              if (elements.length) {
                return elements;
              }
            }
          };
          testability.getLocation = function() {
            return $location.url();
          };
          testability.setLocation = function(url) {
            if (url !== $location.url()) {
              $location.url(url);
              $rootScope.$digest();
            }
          };
          testability.whenStable = function(callback) {
            $browser.notifyWhenNoOutstandingRequests(callback);
          };
          return testability;
        }];
      }
      function $TimeoutProvider() {
        this.$get = ['$rootScope', '$browser', '$q', '$$q', '$exceptionHandler', function($rootScope, $browser, $q, $$q, $exceptionHandler) {
          var deferreds = {};
          function timeout(fn, delay, invokeApply) {
            if (!isFunction(fn)) {
              invokeApply = delay;
              delay = fn;
              fn = noop;
            }
            var args = sliceArgs(arguments, 3),
                skipApply = (isDefined(invokeApply) && !invokeApply),
                deferred = (skipApply ? $$q : $q).defer(),
                promise = deferred.promise,
                timeoutId;
            timeoutId = $browser.defer(function() {
              try {
                deferred.resolve(fn.apply(null, args));
              } catch (e) {
                deferred.reject(e);
                $exceptionHandler(e);
              } finally {
                delete deferreds[promise.$$timeoutId];
              }
              if (!skipApply)
                $rootScope.$apply();
            }, delay);
            promise.$$timeoutId = timeoutId;
            deferreds[timeoutId] = deferred;
            return promise;
          }
          timeout.cancel = function(promise) {
            if (promise && promise.$$timeoutId in deferreds) {
              deferreds[promise.$$timeoutId].reject('canceled');
              delete deferreds[promise.$$timeoutId];
              return $browser.defer.cancel(promise.$$timeoutId);
            }
            return false;
          };
          return timeout;
        }];
      }
      var urlParsingNode = window.document.createElement("a");
      var originUrl = urlResolve(window.location.href);
      function urlResolve(url) {
        var href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute('href', href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
        };
      }
      function urlIsSameOrigin(requestUrl) {
        var parsed = (isString(requestUrl)) ? urlResolve(requestUrl) : requestUrl;
        return (parsed.protocol === originUrl.protocol && parsed.host === originUrl.host);
      }
      function $WindowProvider() {
        this.$get = valueFn(window);
      }
      function $$CookieReader($document) {
        var rawDocument = $document[0] || {};
        var lastCookies = {};
        var lastCookieString = '';
        function safeDecodeURIComponent(str) {
          try {
            return decodeURIComponent(str);
          } catch (e) {
            return str;
          }
        }
        return function() {
          var cookieArray,
              cookie,
              i,
              index,
              name;
          var currentCookieString = rawDocument.cookie || '';
          if (currentCookieString !== lastCookieString) {
            lastCookieString = currentCookieString;
            cookieArray = lastCookieString.split('; ');
            lastCookies = {};
            for (i = 0; i < cookieArray.length; i++) {
              cookie = cookieArray[i];
              index = cookie.indexOf('=');
              if (index > 0) {
                name = safeDecodeURIComponent(cookie.substring(0, index));
                if (isUndefined(lastCookies[name])) {
                  lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));
                }
              }
            }
          }
          return lastCookies;
        };
      }
      $$CookieReader.$inject = ['$document'];
      function $$CookieReaderProvider() {
        this.$get = $$CookieReader;
      }
      $FilterProvider.$inject = ['$provide'];
      function $FilterProvider($provide) {
        var suffix = 'Filter';
        function register(name, factory) {
          if (isObject(name)) {
            var filters = {};
            forEach(name, function(filter, key) {
              filters[key] = register(key, filter);
            });
            return filters;
          } else {
            return $provide.factory(name + suffix, factory);
          }
        }
        this.register = register;
        this.$get = ['$injector', function($injector) {
          return function(name) {
            return $injector.get(name + suffix);
          };
        }];
        register('currency', currencyFilter);
        register('date', dateFilter);
        register('filter', filterFilter);
        register('json', jsonFilter);
        register('limitTo', limitToFilter);
        register('lowercase', lowercaseFilter);
        register('number', numberFilter);
        register('orderBy', orderByFilter);
        register('uppercase', uppercaseFilter);
      }
      function filterFilter() {
        return function(array, expression, comparator) {
          if (!isArrayLike(array)) {
            if (array == null) {
              return array;
            } else {
              throw minErr('filter')('notarray', 'Expected array but received: {0}', array);
            }
          }
          var expressionType = getTypeForFilter(expression);
          var predicateFn;
          var matchAgainstAnyProp;
          switch (expressionType) {
            case 'function':
              predicateFn = expression;
              break;
            case 'boolean':
            case 'null':
            case 'number':
            case 'string':
              matchAgainstAnyProp = true;
            case 'object':
              predicateFn = createPredicateFn(expression, comparator, matchAgainstAnyProp);
              break;
            default:
              return array;
          }
          return Array.prototype.filter.call(array, predicateFn);
        };
      }
      function createPredicateFn(expression, comparator, matchAgainstAnyProp) {
        var shouldMatchPrimitives = isObject(expression) && ('$' in expression);
        var predicateFn;
        if (comparator === true) {
          comparator = equals;
        } else if (!isFunction(comparator)) {
          comparator = function(actual, expected) {
            if (isUndefined(actual)) {
              return false;
            }
            if ((actual === null) || (expected === null)) {
              return actual === expected;
            }
            if (isObject(expected) || (isObject(actual) && !hasCustomToString(actual))) {
              return false;
            }
            actual = lowercase('' + actual);
            expected = lowercase('' + expected);
            return actual.indexOf(expected) !== -1;
          };
        }
        predicateFn = function(item) {
          if (shouldMatchPrimitives && !isObject(item)) {
            return deepCompare(item, expression.$, comparator, false);
          }
          return deepCompare(item, expression, comparator, matchAgainstAnyProp);
        };
        return predicateFn;
      }
      function deepCompare(actual, expected, comparator, matchAgainstAnyProp, dontMatchWholeObject) {
        var actualType = getTypeForFilter(actual);
        var expectedType = getTypeForFilter(expected);
        if ((expectedType === 'string') && (expected.charAt(0) === '!')) {
          return !deepCompare(actual, expected.substring(1), comparator, matchAgainstAnyProp);
        } else if (isArray(actual)) {
          return actual.some(function(item) {
            return deepCompare(item, expected, comparator, matchAgainstAnyProp);
          });
        }
        switch (actualType) {
          case 'object':
            var key;
            if (matchAgainstAnyProp) {
              for (key in actual) {
                if ((key.charAt(0) !== '$') && deepCompare(actual[key], expected, comparator, true)) {
                  return true;
                }
              }
              return dontMatchWholeObject ? false : deepCompare(actual, expected, comparator, false);
            } else if (expectedType === 'object') {
              for (key in expected) {
                var expectedVal = expected[key];
                if (isFunction(expectedVal) || isUndefined(expectedVal)) {
                  continue;
                }
                var matchAnyProperty = key === '$';
                var actualVal = matchAnyProperty ? actual : actual[key];
                if (!deepCompare(actualVal, expectedVal, comparator, matchAnyProperty, matchAnyProperty)) {
                  return false;
                }
              }
              return true;
            } else {
              return comparator(actual, expected);
            }
            break;
          case 'function':
            return false;
          default:
            return comparator(actual, expected);
        }
      }
      function getTypeForFilter(val) {
        return (val === null) ? 'null' : typeof val;
      }
      var MAX_DIGITS = 22;
      var DECIMAL_SEP = '.';
      var ZERO_CHAR = '0';
      currencyFilter.$inject = ['$locale'];
      function currencyFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(amount, currencySymbol, fractionSize) {
          if (isUndefined(currencySymbol)) {
            currencySymbol = formats.CURRENCY_SYM;
          }
          if (isUndefined(fractionSize)) {
            fractionSize = formats.PATTERNS[1].maxFrac;
          }
          return (amount == null) ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(/\u00A4/g, currencySymbol);
        };
      }
      numberFilter.$inject = ['$locale'];
      function numberFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(number, fractionSize) {
          return (number == null) ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
        };
      }
      function parse(numStr) {
        var exponent = 0,
            digits,
            numberOfIntegerDigits;
        var i,
            j,
            zeros;
        if ((numberOfIntegerDigits = numStr.indexOf(DECIMAL_SEP)) > -1) {
          numStr = numStr.replace(DECIMAL_SEP, '');
        }
        if ((i = numStr.search(/e/i)) > 0) {
          if (numberOfIntegerDigits < 0)
            numberOfIntegerDigits = i;
          numberOfIntegerDigits += +numStr.slice(i + 1);
          numStr = numStr.substring(0, i);
        } else if (numberOfIntegerDigits < 0) {
          numberOfIntegerDigits = numStr.length;
        }
        for (i = 0; numStr.charAt(i) == ZERO_CHAR; i++) {}
        if (i == (zeros = numStr.length)) {
          digits = [0];
          numberOfIntegerDigits = 1;
        } else {
          zeros--;
          while (numStr.charAt(zeros) == ZERO_CHAR)
            zeros--;
          numberOfIntegerDigits -= i;
          digits = [];
          for (j = 0; i <= zeros; i++, j++) {
            digits[j] = +numStr.charAt(i);
          }
        }
        if (numberOfIntegerDigits > MAX_DIGITS) {
          digits = digits.splice(0, MAX_DIGITS - 1);
          exponent = numberOfIntegerDigits - 1;
          numberOfIntegerDigits = 1;
        }
        return {
          d: digits,
          e: exponent,
          i: numberOfIntegerDigits
        };
      }
      function roundNumber(parsedNumber, fractionSize, minFrac, maxFrac) {
        var digits = parsedNumber.d;
        var fractionLen = digits.length - parsedNumber.i;
        fractionSize = (isUndefined(fractionSize)) ? Math.min(Math.max(minFrac, fractionLen), maxFrac) : +fractionSize;
        var roundAt = fractionSize + parsedNumber.i;
        var digit = digits[roundAt];
        if (roundAt > 0) {
          digits.splice(Math.max(parsedNumber.i, roundAt));
          for (var j = roundAt; j < digits.length; j++) {
            digits[j] = 0;
          }
        } else {
          fractionLen = Math.max(0, fractionLen);
          parsedNumber.i = 1;
          digits.length = Math.max(1, roundAt = fractionSize + 1);
          digits[0] = 0;
          for (var i = 1; i < roundAt; i++)
            digits[i] = 0;
        }
        if (digit >= 5) {
          if (roundAt - 1 < 0) {
            for (var k = 0; k > roundAt; k--) {
              digits.unshift(0);
              parsedNumber.i++;
            }
            digits.unshift(1);
            parsedNumber.i++;
          } else {
            digits[roundAt - 1]++;
          }
        }
        for (; fractionLen < Math.max(0, fractionSize); fractionLen++)
          digits.push(0);
        var carry = digits.reduceRight(function(carry, d, i, digits) {
          d = d + carry;
          digits[i] = d % 10;
          return Math.floor(d / 10);
        }, 0);
        if (carry) {
          digits.unshift(carry);
          parsedNumber.i++;
        }
      }
      function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
        if (!(isString(number) || isNumber(number)) || isNaN(number))
          return '';
        var isInfinity = !isFinite(number);
        var isZero = false;
        var numStr = Math.abs(number) + '',
            formattedText = '',
            parsedNumber;
        if (isInfinity) {
          formattedText = '\u221e';
        } else {
          parsedNumber = parse(numStr);
          roundNumber(parsedNumber, fractionSize, pattern.minFrac, pattern.maxFrac);
          var digits = parsedNumber.d;
          var integerLen = parsedNumber.i;
          var exponent = parsedNumber.e;
          var decimals = [];
          isZero = digits.reduce(function(isZero, d) {
            return isZero && !d;
          }, true);
          while (integerLen < 0) {
            digits.unshift(0);
            integerLen++;
          }
          if (integerLen > 0) {
            decimals = digits.splice(integerLen, digits.length);
          } else {
            decimals = digits;
            digits = [0];
          }
          var groups = [];
          if (digits.length >= pattern.lgSize) {
            groups.unshift(digits.splice(-pattern.lgSize, digits.length).join(''));
          }
          while (digits.length > pattern.gSize) {
            groups.unshift(digits.splice(-pattern.gSize, digits.length).join(''));
          }
          if (digits.length) {
            groups.unshift(digits.join(''));
          }
          formattedText = groups.join(groupSep);
          if (decimals.length) {
            formattedText += decimalSep + decimals.join('');
          }
          if (exponent) {
            formattedText += 'e+' + exponent;
          }
        }
        if (number < 0 && !isZero) {
          return pattern.negPre + formattedText + pattern.negSuf;
        } else {
          return pattern.posPre + formattedText + pattern.posSuf;
        }
      }
      function padNumber(num, digits, trim, negWrap) {
        var neg = '';
        if (num < 0 || (negWrap && num <= 0)) {
          if (negWrap) {
            num = -num + 1;
          } else {
            num = -num;
            neg = '-';
          }
        }
        num = '' + num;
        while (num.length < digits)
          num = ZERO_CHAR + num;
        if (trim) {
          num = num.substr(num.length - digits);
        }
        return neg + num;
      }
      function dateGetter(name, size, offset, trim, negWrap) {
        offset = offset || 0;
        return function(date) {
          var value = date['get' + name]();
          if (offset > 0 || value > -offset) {
            value += offset;
          }
          if (value === 0 && offset == -12)
            value = 12;
          return padNumber(value, size, trim, negWrap);
        };
      }
      function dateStrGetter(name, shortForm, standAlone) {
        return function(date, formats) {
          var value = date['get' + name]();
          var propPrefix = (standAlone ? 'STANDALONE' : '') + (shortForm ? 'SHORT' : '');
          var get = uppercase(propPrefix + name);
          return formats[get][value];
        };
      }
      function timeZoneGetter(date, formats, offset) {
        var zone = -1 * offset;
        var paddedZone = (zone >= 0) ? "+" : "";
        paddedZone += padNumber(Math[zone > 0 ? 'floor' : 'ceil'](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
        return paddedZone;
      }
      function getFirstThursdayOfYear(year) {
        var dayOfWeekOnFirst = (new Date(year, 0, 1)).getDay();
        return new Date(year, 0, ((dayOfWeekOnFirst <= 4) ? 5 : 12) - dayOfWeekOnFirst);
      }
      function getThursdayThisWeek(datetime) {
        return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()));
      }
      function weekGetter(size) {
        return function(date) {
          var firstThurs = getFirstThursdayOfYear(date.getFullYear()),
              thisThurs = getThursdayThisWeek(date);
          var diff = +thisThurs - +firstThurs,
              result = 1 + Math.round(diff / 6.048e8);
          return padNumber(result, size);
        };
      }
      function ampmGetter(date, formats) {
        return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
      }
      function eraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
      }
      function longEraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
      }
      var DATE_FORMATS = {
        yyyy: dateGetter('FullYear', 4, 0, false, true),
        yy: dateGetter('FullYear', 2, 0, true, true),
        y: dateGetter('FullYear', 1, 0, false, true),
        MMMM: dateStrGetter('Month'),
        MMM: dateStrGetter('Month', true),
        MM: dateGetter('Month', 2, 1),
        M: dateGetter('Month', 1, 1),
        LLLL: dateStrGetter('Month', false, true),
        dd: dateGetter('Date', 2),
        d: dateGetter('Date', 1),
        HH: dateGetter('Hours', 2),
        H: dateGetter('Hours', 1),
        hh: dateGetter('Hours', 2, -12),
        h: dateGetter('Hours', 1, -12),
        mm: dateGetter('Minutes', 2),
        m: dateGetter('Minutes', 1),
        ss: dateGetter('Seconds', 2),
        s: dateGetter('Seconds', 1),
        sss: dateGetter('Milliseconds', 3),
        EEEE: dateStrGetter('Day'),
        EEE: dateStrGetter('Day', true),
        a: ampmGetter,
        Z: timeZoneGetter,
        ww: weekGetter(2),
        w: weekGetter(1),
        G: eraGetter,
        GG: eraGetter,
        GGG: eraGetter,
        GGGG: longEraGetter
      };
      var DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/,
          NUMBER_STRING = /^\-?\d+$/;
      dateFilter.$inject = ['$locale'];
      function dateFilter($locale) {
        var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        function jsonStringToDate(string) {
          var match;
          if (match = string.match(R_ISO8601_STR)) {
            var date = new Date(0),
                tzHour = 0,
                tzMin = 0,
                dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,
                timeSetter = match[8] ? date.setUTCHours : date.setHours;
            if (match[9]) {
              tzHour = toInt(match[9] + match[10]);
              tzMin = toInt(match[9] + match[11]);
            }
            dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
            var h = toInt(match[4] || 0) - tzHour;
            var m = toInt(match[5] || 0) - tzMin;
            var s = toInt(match[6] || 0);
            var ms = Math.round(parseFloat('0.' + (match[7] || 0)) * 1000);
            timeSetter.call(date, h, m, s, ms);
            return date;
          }
          return string;
        }
        return function(date, format, timezone) {
          var text = '',
              parts = [],
              fn,
              match;
          format = format || 'mediumDate';
          format = $locale.DATETIME_FORMATS[format] || format;
          if (isString(date)) {
            date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date);
          }
          if (isNumber(date)) {
            date = new Date(date);
          }
          if (!isDate(date) || !isFinite(date.getTime())) {
            return date;
          }
          while (format) {
            match = DATE_FORMATS_SPLIT.exec(format);
            if (match) {
              parts = concat(parts, match, 1);
              format = parts.pop();
            } else {
              parts.push(format);
              format = null;
            }
          }
          var dateTimezoneOffset = date.getTimezoneOffset();
          if (timezone) {
            dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
            date = convertTimezoneToLocal(date, timezone, true);
          }
          forEach(parts, function(value) {
            fn = DATE_FORMATS[value];
            text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) : value === "''" ? "'" : value.replace(/(^'|'$)/g, '').replace(/''/g, "'");
          });
          return text;
        };
      }
      function jsonFilter() {
        return function(object, spacing) {
          if (isUndefined(spacing)) {
            spacing = 2;
          }
          return toJson(object, spacing);
        };
      }
      var lowercaseFilter = valueFn(lowercase);
      var uppercaseFilter = valueFn(uppercase);
      function limitToFilter() {
        return function(input, limit, begin) {
          if (Math.abs(Number(limit)) === Infinity) {
            limit = Number(limit);
          } else {
            limit = toInt(limit);
          }
          if (isNaN(limit))
            return input;
          if (isNumber(input))
            input = input.toString();
          if (!isArrayLike(input))
            return input;
          begin = (!begin || isNaN(begin)) ? 0 : toInt(begin);
          begin = (begin < 0) ? Math.max(0, input.length + begin) : begin;
          if (limit >= 0) {
            return sliceFn(input, begin, begin + limit);
          } else {
            if (begin === 0) {
              return sliceFn(input, limit, input.length);
            } else {
              return sliceFn(input, Math.max(0, begin + limit), begin);
            }
          }
        };
      }
      function sliceFn(input, begin, end) {
        if (isString(input))
          return input.slice(begin, end);
        return slice.call(input, begin, end);
      }
      orderByFilter.$inject = ['$parse'];
      function orderByFilter($parse) {
        return function(array, sortPredicate, reverseOrder, compareFn) {
          if (array == null)
            return array;
          if (!isArrayLike(array)) {
            throw minErr('orderBy')('notarray', 'Expected array but received: {0}', array);
          }
          if (!isArray(sortPredicate)) {
            sortPredicate = [sortPredicate];
          }
          if (sortPredicate.length === 0) {
            sortPredicate = ['+'];
          }
          var predicates = processPredicates(sortPredicate);
          var descending = reverseOrder ? -1 : 1;
          var compare = isFunction(compareFn) ? compareFn : defaultCompare;
          var compareValues = Array.prototype.map.call(array, getComparisonObject);
          compareValues.sort(doComparison);
          array = compareValues.map(function(item) {
            return item.value;
          });
          return array;
          function getComparisonObject(value, index) {
            return {
              value: value,
              tieBreaker: {
                value: index,
                type: 'number',
                index: index
              },
              predicateValues: predicates.map(function(predicate) {
                return getPredicateValue(predicate.get(value), index);
              })
            };
          }
          function doComparison(v1, v2) {
            for (var i = 0,
                ii = predicates.length; i < ii; i++) {
              var result = compare(v1.predicateValues[i], v2.predicateValues[i]);
              if (result) {
                return result * predicates[i].descending * descending;
              }
            }
            return compare(v1.tieBreaker, v2.tieBreaker) * descending;
          }
        };
        function processPredicates(sortPredicates) {
          return sortPredicates.map(function(predicate) {
            var descending = 1,
                get = identity;
            if (isFunction(predicate)) {
              get = predicate;
            } else if (isString(predicate)) {
              if ((predicate.charAt(0) == '+' || predicate.charAt(0) == '-')) {
                descending = predicate.charAt(0) == '-' ? -1 : 1;
                predicate = predicate.substring(1);
              }
              if (predicate !== '') {
                get = $parse(predicate);
                if (get.constant) {
                  var key = get();
                  get = function(value) {
                    return value[key];
                  };
                }
              }
            }
            return {
              get: get,
              descending: descending
            };
          });
        }
        function isPrimitive(value) {
          switch (typeof value) {
            case 'number':
            case 'boolean':
            case 'string':
              return true;
            default:
              return false;
          }
        }
        function objectValue(value) {
          if (isFunction(value.valueOf)) {
            value = value.valueOf();
            if (isPrimitive(value))
              return value;
          }
          if (hasCustomToString(value)) {
            value = value.toString();
            if (isPrimitive(value))
              return value;
          }
          return value;
        }
        function getPredicateValue(value, index) {
          var type = typeof value;
          if (value === null) {
            type = 'string';
            value = 'null';
          } else if (type === 'object') {
            value = objectValue(value);
          }
          return {
            value: value,
            type: type,
            index: index
          };
        }
        function defaultCompare(v1, v2) {
          var result = 0;
          var type1 = v1.type;
          var type2 = v2.type;
          if (type1 === type2) {
            var value1 = v1.value;
            var value2 = v2.value;
            if (type1 === 'string') {
              value1 = value1.toLowerCase();
              value2 = value2.toLowerCase();
            } else if (type1 === 'object') {
              if (isObject(value1))
                value1 = v1.index;
              if (isObject(value2))
                value2 = v2.index;
            }
            if (value1 !== value2) {
              result = value1 < value2 ? -1 : 1;
            }
          } else {
            result = type1 < type2 ? -1 : 1;
          }
          return result;
        }
      }
      function ngDirective(directive) {
        if (isFunction(directive)) {
          directive = {link: directive};
        }
        directive.restrict = directive.restrict || 'AC';
        return valueFn(directive);
      }
      var htmlAnchorDirective = valueFn({
        restrict: 'E',
        compile: function(element, attr) {
          if (!attr.href && !attr.xlinkHref) {
            return function(scope, element) {
              if (element[0].nodeName.toLowerCase() !== 'a')
                return;
              var href = toString.call(element.prop('href')) === '[object SVGAnimatedString]' ? 'xlink:href' : 'href';
              element.on('click', function(event) {
                if (!element.attr(href)) {
                  event.preventDefault();
                }
              });
            };
          }
        }
      });
      var ngAttributeAliasDirectives = {};
      forEach(BOOLEAN_ATTR, function(propName, attrName) {
        if (propName == "multiple")
          return;
        function defaultLinkFn(scope, element, attr) {
          scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
            attr.$set(attrName, !!value);
          });
        }
        var normalized = directiveNormalize('ng-' + attrName);
        var linkFn = defaultLinkFn;
        if (propName === 'checked') {
          linkFn = function(scope, element, attr) {
            if (attr.ngModel !== attr[normalized]) {
              defaultLinkFn(scope, element, attr);
            }
          };
        }
        ngAttributeAliasDirectives[normalized] = function() {
          return {
            restrict: 'A',
            priority: 100,
            link: linkFn
          };
        };
      });
      forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
        ngAttributeAliasDirectives[ngAttr] = function() {
          return {
            priority: 100,
            link: function(scope, element, attr) {
              if (ngAttr === "ngPattern" && attr.ngPattern.charAt(0) == "/") {
                var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                if (match) {
                  attr.$set("ngPattern", new RegExp(match[1], match[2]));
                  return;
                }
              }
              scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
                attr.$set(ngAttr, value);
              });
            }
          };
        };
      });
      forEach(['src', 'srcset', 'href'], function(attrName) {
        var normalized = directiveNormalize('ng-' + attrName);
        ngAttributeAliasDirectives[normalized] = function() {
          return {
            priority: 99,
            link: function(scope, element, attr) {
              var propName = attrName,
                  name = attrName;
              if (attrName === 'href' && toString.call(element.prop('href')) === '[object SVGAnimatedString]') {
                name = 'xlinkHref';
                attr.$attr[name] = 'xlink:href';
                propName = null;
              }
              attr.$observe(normalized, function(value) {
                if (!value) {
                  if (attrName === 'href') {
                    attr.$set(name, null);
                  }
                  return;
                }
                attr.$set(name, value);
                if (msie && propName)
                  element.prop(propName, attr[name]);
              });
            }
          };
        };
      });
      var nullFormCtrl = {
        $addControl: noop,
        $$renameControl: nullFormRenameControl,
        $removeControl: noop,
        $setValidity: noop,
        $setDirty: noop,
        $setPristine: noop,
        $setSubmitted: noop
      },
          SUBMITTED_CLASS = 'ng-submitted';
      function nullFormRenameControl(control, name) {
        control.$name = name;
      }
      FormController.$inject = ['$element', '$attrs', '$scope', '$animate', '$interpolate'];
      function FormController(element, attrs, $scope, $animate, $interpolate) {
        var form = this,
            controls = [];
        form.$error = {};
        form.$$success = {};
        form.$pending = undefined;
        form.$name = $interpolate(attrs.name || attrs.ngForm || '')($scope);
        form.$dirty = false;
        form.$pristine = true;
        form.$valid = true;
        form.$invalid = false;
        form.$submitted = false;
        form.$$parentForm = nullFormCtrl;
        form.$rollbackViewValue = function() {
          forEach(controls, function(control) {
            control.$rollbackViewValue();
          });
        };
        form.$commitViewValue = function() {
          forEach(controls, function(control) {
            control.$commitViewValue();
          });
        };
        form.$addControl = function(control) {
          assertNotHasOwnProperty(control.$name, 'input');
          controls.push(control);
          if (control.$name) {
            form[control.$name] = control;
          }
          control.$$parentForm = form;
        };
        form.$$renameControl = function(control, newName) {
          var oldName = control.$name;
          if (form[oldName] === control) {
            delete form[oldName];
          }
          form[newName] = control;
          control.$name = newName;
        };
        form.$removeControl = function(control) {
          if (control.$name && form[control.$name] === control) {
            delete form[control.$name];
          }
          forEach(form.$pending, function(value, name) {
            form.$setValidity(name, null, control);
          });
          forEach(form.$error, function(value, name) {
            form.$setValidity(name, null, control);
          });
          forEach(form.$$success, function(value, name) {
            form.$setValidity(name, null, control);
          });
          arrayRemove(controls, control);
          control.$$parentForm = nullFormCtrl;
        };
        addSetValidityMethod({
          ctrl: this,
          $element: element,
          set: function(object, property, controller) {
            var list = object[property];
            if (!list) {
              object[property] = [controller];
            } else {
              var index = list.indexOf(controller);
              if (index === -1) {
                list.push(controller);
              }
            }
          },
          unset: function(object, property, controller) {
            var list = object[property];
            if (!list) {
              return;
            }
            arrayRemove(list, controller);
            if (list.length === 0) {
              delete object[property];
            }
          },
          $animate: $animate
        });
        form.$setDirty = function() {
          $animate.removeClass(element, PRISTINE_CLASS);
          $animate.addClass(element, DIRTY_CLASS);
          form.$dirty = true;
          form.$pristine = false;
          form.$$parentForm.$setDirty();
        };
        form.$setPristine = function() {
          $animate.setClass(element, PRISTINE_CLASS, DIRTY_CLASS + ' ' + SUBMITTED_CLASS);
          form.$dirty = false;
          form.$pristine = true;
          form.$submitted = false;
          forEach(controls, function(control) {
            control.$setPristine();
          });
        };
        form.$setUntouched = function() {
          forEach(controls, function(control) {
            control.$setUntouched();
          });
        };
        form.$setSubmitted = function() {
          $animate.addClass(element, SUBMITTED_CLASS);
          form.$submitted = true;
          form.$$parentForm.$setSubmitted();
        };
      }
      var formDirectiveFactory = function(isNgForm) {
        return ['$timeout', '$parse', function($timeout, $parse) {
          var formDirective = {
            name: 'form',
            restrict: isNgForm ? 'EAC' : 'E',
            require: ['form', '^^?form'],
            controller: FormController,
            compile: function ngFormCompile(formElement, attr) {
              formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
              var nameAttr = attr.name ? 'name' : (isNgForm && attr.ngForm ? 'ngForm' : false);
              return {pre: function ngFormPreLink(scope, formElement, attr, ctrls) {
                  var controller = ctrls[0];
                  if (!('action' in attr)) {
                    var handleFormSubmission = function(event) {
                      scope.$apply(function() {
                        controller.$commitViewValue();
                        controller.$setSubmitted();
                      });
                      event.preventDefault();
                    };
                    addEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                    formElement.on('$destroy', function() {
                      $timeout(function() {
                        removeEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                      }, 0, false);
                    });
                  }
                  var parentFormCtrl = ctrls[1] || controller.$$parentForm;
                  parentFormCtrl.$addControl(controller);
                  var setter = nameAttr ? getSetter(controller.$name) : noop;
                  if (nameAttr) {
                    setter(scope, controller);
                    attr.$observe(nameAttr, function(newValue) {
                      if (controller.$name === newValue)
                        return;
                      setter(scope, undefined);
                      controller.$$parentForm.$$renameControl(controller, newValue);
                      setter = getSetter(controller.$name);
                      setter(scope, controller);
                    });
                  }
                  formElement.on('$destroy', function() {
                    controller.$$parentForm.$removeControl(controller);
                    setter(scope, undefined);
                    extend(controller, nullFormCtrl);
                  });
                }};
            }
          };
          return formDirective;
          function getSetter(expression) {
            if (expression === '') {
              return $parse('this[""]').assign;
            }
            return $parse(expression).assign || noop;
          }
        }];
      };
      var formDirective = formDirectiveFactory();
      var ngFormDirective = formDirectiveFactory(true);
      var ISO_DATE_REGEXP = /^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/;
      var URL_REGEXP = /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:/?#]+|\[[a-f\d:]+\])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i;
      var EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+\/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&'*+\/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/;
      var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/;
      var DATE_REGEXP = /^(\d{4,})-(\d{2})-(\d{2})$/;
      var DATETIMELOCAL_REGEXP = /^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
      var WEEK_REGEXP = /^(\d{4,})-W(\d\d)$/;
      var MONTH_REGEXP = /^(\d{4,})-(\d\d)$/;
      var TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
      var PARTIAL_VALIDATION_EVENTS = 'keydown wheel mousedown';
      var PARTIAL_VALIDATION_TYPES = createMap();
      forEach('date,datetime-local,month,time,week'.split(','), function(type) {
        PARTIAL_VALIDATION_TYPES[type] = true;
      });
      var inputType = {
        'text': textInputType,
        'date': createDateInputType('date', DATE_REGEXP, createDateParser(DATE_REGEXP, ['yyyy', 'MM', 'dd']), 'yyyy-MM-dd'),
        'datetime-local': createDateInputType('datetimelocal', DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, ['yyyy', 'MM', 'dd', 'HH', 'mm', 'ss', 'sss']), 'yyyy-MM-ddTHH:mm:ss.sss'),
        'time': createDateInputType('time', TIME_REGEXP, createDateParser(TIME_REGEXP, ['HH', 'mm', 'ss', 'sss']), 'HH:mm:ss.sss'),
        'week': createDateInputType('week', WEEK_REGEXP, weekParser, 'yyyy-Www'),
        'month': createDateInputType('month', MONTH_REGEXP, createDateParser(MONTH_REGEXP, ['yyyy', 'MM']), 'yyyy-MM'),
        'number': numberInputType,
        'url': urlInputType,
        'email': emailInputType,
        'radio': radioInputType,
        'checkbox': checkboxInputType,
        'hidden': noop,
        'button': noop,
        'submit': noop,
        'reset': noop,
        'file': noop
      };
      function stringBasedInputType(ctrl) {
        ctrl.$formatters.push(function(value) {
          return ctrl.$isEmpty(value) ? value : value.toString();
        });
      }
      function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
      }
      function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        var type = lowercase(element[0].type);
        if (!$sniffer.android) {
          var composing = false;
          element.on('compositionstart', function() {
            composing = true;
          });
          element.on('compositionend', function() {
            composing = false;
            listener();
          });
        }
        var timeout;
        var listener = function(ev) {
          if (timeout) {
            $browser.defer.cancel(timeout);
            timeout = null;
          }
          if (composing)
            return;
          var value = element.val(),
              event = ev && ev.type;
          if (type !== 'password' && (!attr.ngTrim || attr.ngTrim !== 'false')) {
            value = trim(value);
          }
          if (ctrl.$viewValue !== value || (value === '' && ctrl.$$hasNativeValidators)) {
            ctrl.$setViewValue(value, event);
          }
        };
        if ($sniffer.hasEvent('input')) {
          element.on('input', listener);
        } else {
          var deferListener = function(ev, input, origValue) {
            if (!timeout) {
              timeout = $browser.defer(function() {
                timeout = null;
                if (!input || input.value !== origValue) {
                  listener(ev);
                }
              });
            }
          };
          element.on('keydown', function(event) {
            var key = event.keyCode;
            if (key === 91 || (15 < key && key < 19) || (37 <= key && key <= 40))
              return;
            deferListener(event, this, this.value);
          });
          if ($sniffer.hasEvent('paste')) {
            element.on('paste cut', deferListener);
          }
        }
        element.on('change', listener);
        if (PARTIAL_VALIDATION_TYPES[type] && ctrl.$$hasNativeValidators && type === attr.type) {
          element.on(PARTIAL_VALIDATION_EVENTS, function(ev) {
            if (!timeout) {
              var validity = this[VALIDITY_STATE_PROPERTY];
              var origBadInput = validity.badInput;
              var origTypeMismatch = validity.typeMismatch;
              timeout = $browser.defer(function() {
                timeout = null;
                if (validity.badInput !== origBadInput || validity.typeMismatch !== origTypeMismatch) {
                  listener(ev);
                }
              });
            }
          });
        }
        ctrl.$render = function() {
          var value = ctrl.$isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue;
          if (element.val() !== value) {
            element.val(value);
          }
        };
      }
      function weekParser(isoWeek, existingDate) {
        if (isDate(isoWeek)) {
          return isoWeek;
        }
        if (isString(isoWeek)) {
          WEEK_REGEXP.lastIndex = 0;
          var parts = WEEK_REGEXP.exec(isoWeek);
          if (parts) {
            var year = +parts[1],
                week = +parts[2],
                hours = 0,
                minutes = 0,
                seconds = 0,
                milliseconds = 0,
                firstThurs = getFirstThursdayOfYear(year),
                addDays = (week - 1) * 7;
            if (existingDate) {
              hours = existingDate.getHours();
              minutes = existingDate.getMinutes();
              seconds = existingDate.getSeconds();
              milliseconds = existingDate.getMilliseconds();
            }
            return new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
          }
        }
        return NaN;
      }
      function createDateParser(regexp, mapping) {
        return function(iso, date) {
          var parts,
              map;
          if (isDate(iso)) {
            return iso;
          }
          if (isString(iso)) {
            if (iso.charAt(0) == '"' && iso.charAt(iso.length - 1) == '"') {
              iso = iso.substring(1, iso.length - 1);
            }
            if (ISO_DATE_REGEXP.test(iso)) {
              return new Date(iso);
            }
            regexp.lastIndex = 0;
            parts = regexp.exec(iso);
            if (parts) {
              parts.shift();
              if (date) {
                map = {
                  yyyy: date.getFullYear(),
                  MM: date.getMonth() + 1,
                  dd: date.getDate(),
                  HH: date.getHours(),
                  mm: date.getMinutes(),
                  ss: date.getSeconds(),
                  sss: date.getMilliseconds() / 1000
                };
              } else {
                map = {
                  yyyy: 1970,
                  MM: 1,
                  dd: 1,
                  HH: 0,
                  mm: 0,
                  ss: 0,
                  sss: 0
                };
              }
              forEach(parts, function(part, index) {
                if (index < mapping.length) {
                  map[mapping[index]] = +part;
                }
              });
              return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1000 || 0);
            }
          }
          return NaN;
        };
      }
      function createDateInputType(type, regexp, parseDate, format) {
        return function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
          badInputChecker(scope, element, attr, ctrl);
          baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
          var timezone = ctrl && ctrl.$options && ctrl.$options.timezone;
          var previousDate;
          ctrl.$$parserName = type;
          ctrl.$parsers.push(function(value) {
            if (ctrl.$isEmpty(value))
              return null;
            if (regexp.test(value)) {
              var parsedDate = parseDate(value, previousDate);
              if (timezone) {
                parsedDate = convertTimezoneToLocal(parsedDate, timezone);
              }
              return parsedDate;
            }
            return undefined;
          });
          ctrl.$formatters.push(function(value) {
            if (value && !isDate(value)) {
              throw ngModelMinErr('datefmt', 'Expected `{0}` to be a date', value);
            }
            if (isValidDate(value)) {
              previousDate = value;
              if (previousDate && timezone) {
                previousDate = convertTimezoneToLocal(previousDate, timezone, true);
              }
              return $filter('date')(value, format, timezone);
            } else {
              previousDate = null;
              return '';
            }
          });
          if (isDefined(attr.min) || attr.ngMin) {
            var minVal;
            ctrl.$validators.min = function(value) {
              return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
            };
            attr.$observe('min', function(val) {
              minVal = parseObservedDateValue(val);
              ctrl.$validate();
            });
          }
          if (isDefined(attr.max) || attr.ngMax) {
            var maxVal;
            ctrl.$validators.max = function(value) {
              return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
            };
            attr.$observe('max', function(val) {
              maxVal = parseObservedDateValue(val);
              ctrl.$validate();
            });
          }
          function isValidDate(value) {
            return value && !(value.getTime && value.getTime() !== value.getTime());
          }
          function parseObservedDateValue(val) {
            return isDefined(val) && !isDate(val) ? parseDate(val) || undefined : val;
          }
        };
      }
      function badInputChecker(scope, element, attr, ctrl) {
        var node = element[0];
        var nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
        if (nativeValidation) {
          ctrl.$parsers.push(function(value) {
            var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
            return validity.badInput || validity.typeMismatch ? undefined : value;
          });
        }
      }
      function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        badInputChecker(scope, element, attr, ctrl);
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        ctrl.$$parserName = 'number';
        ctrl.$parsers.push(function(value) {
          if (ctrl.$isEmpty(value))
            return null;
          if (NUMBER_REGEXP.test(value))
            return parseFloat(value);
          return undefined;
        });
        ctrl.$formatters.push(function(value) {
          if (!ctrl.$isEmpty(value)) {
            if (!isNumber(value)) {
              throw ngModelMinErr('numfmt', 'Expected `{0}` to be a number', value);
            }
            value = value.toString();
          }
          return value;
        });
        if (isDefined(attr.min) || attr.ngMin) {
          var minVal;
          ctrl.$validators.min = function(value) {
            return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
          };
          attr.$observe('min', function(val) {
            if (isDefined(val) && !isNumber(val)) {
              val = parseFloat(val, 10);
            }
            minVal = isNumber(val) && !isNaN(val) ? val : undefined;
            ctrl.$validate();
          });
        }
        if (isDefined(attr.max) || attr.ngMax) {
          var maxVal;
          ctrl.$validators.max = function(value) {
            return ctrl.$isEmpty(value) || isUndefined(maxVal) || value <= maxVal;
          };
          attr.$observe('max', function(val) {
            if (isDefined(val) && !isNumber(val)) {
              val = parseFloat(val, 10);
            }
            maxVal = isNumber(val) && !isNaN(val) ? val : undefined;
            ctrl.$validate();
          });
        }
      }
      function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$$parserName = 'url';
        ctrl.$validators.url = function(modelValue, viewValue) {
          var value = modelValue || viewValue;
          return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
        };
      }
      function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$$parserName = 'email';
        ctrl.$validators.email = function(modelValue, viewValue) {
          var value = modelValue || viewValue;
          return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
        };
      }
      function radioInputType(scope, element, attr, ctrl) {
        if (isUndefined(attr.name)) {
          element.attr('name', nextUid());
        }
        var listener = function(ev) {
          if (element[0].checked) {
            ctrl.$setViewValue(attr.value, ev && ev.type);
          }
        };
        element.on('click', listener);
        ctrl.$render = function() {
          var value = attr.value;
          element[0].checked = (value == ctrl.$viewValue);
        };
        attr.$observe('value', ctrl.$render);
      }
      function parseConstantExpr($parse, context, name, expression, fallback) {
        var parseFn;
        if (isDefined(expression)) {
          parseFn = $parse(expression);
          if (!parseFn.constant) {
            throw ngModelMinErr('constexpr', 'Expected constant expression for `{0}`, but saw ' + '`{1}`.', name, expression);
          }
          return parseFn(context);
        }
        return fallback;
      }
      function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
        var trueValue = parseConstantExpr($parse, scope, 'ngTrueValue', attr.ngTrueValue, true);
        var falseValue = parseConstantExpr($parse, scope, 'ngFalseValue', attr.ngFalseValue, false);
        var listener = function(ev) {
          ctrl.$setViewValue(element[0].checked, ev && ev.type);
        };
        element.on('click', listener);
        ctrl.$render = function() {
          element[0].checked = ctrl.$viewValue;
        };
        ctrl.$isEmpty = function(value) {
          return value === false;
        };
        ctrl.$formatters.push(function(value) {
          return equals(value, trueValue);
        });
        ctrl.$parsers.push(function(value) {
          return value ? trueValue : falseValue;
        });
      }
      var inputDirective = ['$browser', '$sniffer', '$filter', '$parse', function($browser, $sniffer, $filter, $parse) {
        return {
          restrict: 'E',
          require: ['?ngModel'],
          link: {pre: function(scope, element, attr, ctrls) {
              if (ctrls[0]) {
                (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse);
              }
            }}
        };
      }];
      var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
      var ngValueDirective = function() {
        return {
          restrict: 'A',
          priority: 100,
          compile: function(tpl, tplAttr) {
            if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
              return function ngValueConstantLink(scope, elm, attr) {
                attr.$set('value', scope.$eval(attr.ngValue));
              };
            } else {
              return function ngValueLink(scope, elm, attr) {
                scope.$watch(attr.ngValue, function valueWatchAction(value) {
                  attr.$set('value', value);
                });
              };
            }
          }
        };
      };
      var ngBindDirective = ['$compile', function($compile) {
        return {
          restrict: 'AC',
          compile: function ngBindCompile(templateElement) {
            $compile.$$addBindingClass(templateElement);
            return function ngBindLink(scope, element, attr) {
              $compile.$$addBindingInfo(element, attr.ngBind);
              element = element[0];
              scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
                element.textContent = isUndefined(value) ? '' : value;
              });
            };
          }
        };
      }];
      var ngBindTemplateDirective = ['$interpolate', '$compile', function($interpolate, $compile) {
        return {compile: function ngBindTemplateCompile(templateElement) {
            $compile.$$addBindingClass(templateElement);
            return function ngBindTemplateLink(scope, element, attr) {
              var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
              $compile.$$addBindingInfo(element, interpolateFn.expressions);
              element = element[0];
              attr.$observe('ngBindTemplate', function(value) {
                element.textContent = isUndefined(value) ? '' : value;
              });
            };
          }};
      }];
      var ngBindHtmlDirective = ['$sce', '$parse', '$compile', function($sce, $parse, $compile) {
        return {
          restrict: 'A',
          compile: function ngBindHtmlCompile(tElement, tAttrs) {
            var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);
            var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function sceValueOf(val) {
              return $sce.valueOf(val);
            });
            $compile.$$addBindingClass(tElement);
            return function ngBindHtmlLink(scope, element, attr) {
              $compile.$$addBindingInfo(element, attr.ngBindHtml);
              scope.$watch(ngBindHtmlWatch, function ngBindHtmlWatchAction() {
                var value = ngBindHtmlGetter(scope);
                element.html($sce.getTrustedHtml(value) || '');
              });
            };
          }
        };
      }];
      var ngChangeDirective = valueFn({
        restrict: 'A',
        require: 'ngModel',
        link: function(scope, element, attr, ctrl) {
          ctrl.$viewChangeListeners.push(function() {
            scope.$eval(attr.ngChange);
          });
        }
      });
      function classDirective(name, selector) {
        name = 'ngClass' + name;
        return ['$animate', function($animate) {
          return {
            restrict: 'AC',
            link: function(scope, element, attr) {
              var oldVal;
              scope.$watch(attr[name], ngClassWatchAction, true);
              attr.$observe('class', function(value) {
                ngClassWatchAction(scope.$eval(attr[name]));
              });
              if (name !== 'ngClass') {
                scope.$watch('$index', function($index, old$index) {
                  var mod = $index & 1;
                  if (mod !== (old$index & 1)) {
                    var classes = arrayClasses(scope.$eval(attr[name]));
                    mod === selector ? addClasses(classes) : removeClasses(classes);
                  }
                });
              }
              function addClasses(classes) {
                var newClasses = digestClassCounts(classes, 1);
                attr.$addClass(newClasses);
              }
              function removeClasses(classes) {
                var newClasses = digestClassCounts(classes, -1);
                attr.$removeClass(newClasses);
              }
              function digestClassCounts(classes, count) {
                var classCounts = element.data('$classCounts') || createMap();
                var classesToUpdate = [];
                forEach(classes, function(className) {
                  if (count > 0 || classCounts[className]) {
                    classCounts[className] = (classCounts[className] || 0) + count;
                    if (classCounts[className] === +(count > 0)) {
                      classesToUpdate.push(className);
                    }
                  }
                });
                element.data('$classCounts', classCounts);
                return classesToUpdate.join(' ');
              }
              function updateClasses(oldClasses, newClasses) {
                var toAdd = arrayDifference(newClasses, oldClasses);
                var toRemove = arrayDifference(oldClasses, newClasses);
                toAdd = digestClassCounts(toAdd, 1);
                toRemove = digestClassCounts(toRemove, -1);
                if (toAdd && toAdd.length) {
                  $animate.addClass(element, toAdd);
                }
                if (toRemove && toRemove.length) {
                  $animate.removeClass(element, toRemove);
                }
              }
              function ngClassWatchAction(newVal) {
                if (selector === true || (scope.$index & 1) === selector) {
                  var newClasses = arrayClasses(newVal || []);
                  if (!oldVal) {
                    addClasses(newClasses);
                  } else if (!equals(newVal, oldVal)) {
                    var oldClasses = arrayClasses(oldVal);
                    updateClasses(oldClasses, newClasses);
                  }
                }
                if (isArray(newVal)) {
                  oldVal = newVal.map(function(v) {
                    return shallowCopy(v);
                  });
                } else {
                  oldVal = shallowCopy(newVal);
                }
              }
            }
          };
          function arrayDifference(tokens1, tokens2) {
            var values = [];
            outer: for (var i = 0; i < tokens1.length; i++) {
              var token = tokens1[i];
              for (var j = 0; j < tokens2.length; j++) {
                if (token == tokens2[j])
                  continue outer;
              }
              values.push(token);
            }
            return values;
          }
          function arrayClasses(classVal) {
            var classes = [];
            if (isArray(classVal)) {
              forEach(classVal, function(v) {
                classes = classes.concat(arrayClasses(v));
              });
              return classes;
            } else if (isString(classVal)) {
              return classVal.split(' ');
            } else if (isObject(classVal)) {
              forEach(classVal, function(v, k) {
                if (v) {
                  classes = classes.concat(k.split(' '));
                }
              });
              return classes;
            }
            return classVal;
          }
        }];
      }
      var ngClassDirective = classDirective('', true);
      var ngClassOddDirective = classDirective('Odd', 0);
      var ngClassEvenDirective = classDirective('Even', 1);
      var ngCloakDirective = ngDirective({compile: function(element, attr) {
          attr.$set('ngCloak', undefined);
          element.removeClass('ng-cloak');
        }});
      var ngControllerDirective = [function() {
        return {
          restrict: 'A',
          scope: true,
          controller: '@',
          priority: 500
        };
      }];
      var ngEventDirectives = {};
      var forceAsyncEvents = {
        'blur': true,
        'focus': true
      };
      forEach('click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste'.split(' '), function(eventName) {
        var directiveName = directiveNormalize('ng-' + eventName);
        ngEventDirectives[directiveName] = ['$parse', '$rootScope', function($parse, $rootScope) {
          return {
            restrict: 'A',
            compile: function($element, attr) {
              var fn = $parse(attr[directiveName], null, true);
              return function ngEventHandler(scope, element) {
                element.on(eventName, function(event) {
                  var callback = function() {
                    fn(scope, {$event: event});
                  };
                  if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                    scope.$evalAsync(callback);
                  } else {
                    scope.$apply(callback);
                  }
                });
              };
            }
          };
        }];
      });
      var ngIfDirective = ['$animate', '$compile', function($animate, $compile) {
        return {
          multiElement: true,
          transclude: 'element',
          priority: 600,
          terminal: true,
          restrict: 'A',
          $$tlb: true,
          link: function($scope, $element, $attr, ctrl, $transclude) {
            var block,
                childScope,
                previousElements;
            $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
              if (value) {
                if (!childScope) {
                  $transclude(function(clone, newScope) {
                    childScope = newScope;
                    clone[clone.length++] = $compile.$$createComment('end ngIf', $attr.ngIf);
                    block = {clone: clone};
                    $animate.enter(clone, $element.parent(), $element);
                  });
                }
              } else {
                if (previousElements) {
                  previousElements.remove();
                  previousElements = null;
                }
                if (childScope) {
                  childScope.$destroy();
                  childScope = null;
                }
                if (block) {
                  previousElements = getBlockNodes(block.clone);
                  $animate.leave(previousElements).then(function() {
                    previousElements = null;
                  });
                  block = null;
                }
              }
            });
          }
        };
      }];
      var ngIncludeDirective = ['$templateRequest', '$anchorScroll', '$animate', function($templateRequest, $anchorScroll, $animate) {
        return {
          restrict: 'ECA',
          priority: 400,
          terminal: true,
          transclude: 'element',
          controller: angular.noop,
          compile: function(element, attr) {
            var srcExp = attr.ngInclude || attr.src,
                onloadExp = attr.onload || '',
                autoScrollExp = attr.autoscroll;
            return function(scope, $element, $attr, ctrl, $transclude) {
              var changeCounter = 0,
                  currentScope,
                  previousElement,
                  currentElement;
              var cleanupLastIncludeContent = function() {
                if (previousElement) {
                  previousElement.remove();
                  previousElement = null;
                }
                if (currentScope) {
                  currentScope.$destroy();
                  currentScope = null;
                }
                if (currentElement) {
                  $animate.leave(currentElement).then(function() {
                    previousElement = null;
                  });
                  previousElement = currentElement;
                  currentElement = null;
                }
              };
              scope.$watch(srcExp, function ngIncludeWatchAction(src) {
                var afterAnimation = function() {
                  if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                    $anchorScroll();
                  }
                };
                var thisChangeId = ++changeCounter;
                if (src) {
                  $templateRequest(src, true).then(function(response) {
                    if (scope.$$destroyed)
                      return;
                    if (thisChangeId !== changeCounter)
                      return;
                    var newScope = scope.$new();
                    ctrl.template = response;
                    var clone = $transclude(newScope, function(clone) {
                      cleanupLastIncludeContent();
                      $animate.enter(clone, null, $element).then(afterAnimation);
                    });
                    currentScope = newScope;
                    currentElement = clone;
                    currentScope.$emit('$includeContentLoaded', src);
                    scope.$eval(onloadExp);
                  }, function() {
                    if (scope.$$destroyed)
                      return;
                    if (thisChangeId === changeCounter) {
                      cleanupLastIncludeContent();
                      scope.$emit('$includeContentError', src);
                    }
                  });
                  scope.$emit('$includeContentRequested', src);
                } else {
                  cleanupLastIncludeContent();
                  ctrl.template = null;
                }
              });
            };
          }
        };
      }];
      var ngIncludeFillContentDirective = ['$compile', function($compile) {
        return {
          restrict: 'ECA',
          priority: -400,
          require: 'ngInclude',
          link: function(scope, $element, $attr, ctrl) {
            if (toString.call($element[0]).match(/SVG/)) {
              $element.empty();
              $compile(jqLiteBuildFragment(ctrl.template, window.document).childNodes)(scope, function namespaceAdaptedClone(clone) {
                $element.append(clone);
              }, {futureParentElement: $element});
              return;
            }
            $element.html(ctrl.template);
            $compile($element.contents())(scope);
          }
        };
      }];
      var ngInitDirective = ngDirective({
        priority: 450,
        compile: function() {
          return {pre: function(scope, element, attrs) {
              scope.$eval(attrs.ngInit);
            }};
        }
      });
      var ngListDirective = function() {
        return {
          restrict: 'A',
          priority: 100,
          require: 'ngModel',
          link: function(scope, element, attr, ctrl) {
            var ngList = element.attr(attr.$attr.ngList) || ', ';
            var trimValues = attr.ngTrim !== 'false';
            var separator = trimValues ? trim(ngList) : ngList;
            var parse = function(viewValue) {
              if (isUndefined(viewValue))
                return;
              var list = [];
              if (viewValue) {
                forEach(viewValue.split(separator), function(value) {
                  if (value)
                    list.push(trimValues ? trim(value) : value);
                });
              }
              return list;
            };
            ctrl.$parsers.push(parse);
            ctrl.$formatters.push(function(value) {
              if (isArray(value)) {
                return value.join(ngList);
              }
              return undefined;
            });
            ctrl.$isEmpty = function(value) {
              return !value || !value.length;
            };
          }
        };
      };
      var VALID_CLASS = 'ng-valid',
          INVALID_CLASS = 'ng-invalid',
          PRISTINE_CLASS = 'ng-pristine',
          DIRTY_CLASS = 'ng-dirty',
          UNTOUCHED_CLASS = 'ng-untouched',
          TOUCHED_CLASS = 'ng-touched',
          PENDING_CLASS = 'ng-pending',
          EMPTY_CLASS = 'ng-empty',
          NOT_EMPTY_CLASS = 'ng-not-empty';
      var ngModelMinErr = minErr('ngModel');
      var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$parse', '$animate', '$timeout', '$rootScope', '$q', '$interpolate', function($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $rootScope, $q, $interpolate) {
        this.$viewValue = Number.NaN;
        this.$modelValue = Number.NaN;
        this.$$rawModelValue = undefined;
        this.$validators = {};
        this.$asyncValidators = {};
        this.$parsers = [];
        this.$formatters = [];
        this.$viewChangeListeners = [];
        this.$untouched = true;
        this.$touched = false;
        this.$pristine = true;
        this.$dirty = false;
        this.$valid = true;
        this.$invalid = false;
        this.$error = {};
        this.$$success = {};
        this.$pending = undefined;
        this.$name = $interpolate($attr.name || '', false)($scope);
        this.$$parentForm = nullFormCtrl;
        var parsedNgModel = $parse($attr.ngModel),
            parsedNgModelAssign = parsedNgModel.assign,
            ngModelGet = parsedNgModel,
            ngModelSet = parsedNgModelAssign,
            pendingDebounce = null,
            parserValid,
            ctrl = this;
        this.$$setOptions = function(options) {
          ctrl.$options = options;
          if (options && options.getterSetter) {
            var invokeModelGetter = $parse($attr.ngModel + '()'),
                invokeModelSetter = $parse($attr.ngModel + '($$$p)');
            ngModelGet = function($scope) {
              var modelValue = parsedNgModel($scope);
              if (isFunction(modelValue)) {
                modelValue = invokeModelGetter($scope);
              }
              return modelValue;
            };
            ngModelSet = function($scope, newValue) {
              if (isFunction(parsedNgModel($scope))) {
                invokeModelSetter($scope, {$$$p: newValue});
              } else {
                parsedNgModelAssign($scope, newValue);
              }
            };
          } else if (!parsedNgModel.assign) {
            throw ngModelMinErr('nonassign', "Expression '{0}' is non-assignable. Element: {1}", $attr.ngModel, startingTag($element));
          }
        };
        this.$render = noop;
        this.$isEmpty = function(value) {
          return isUndefined(value) || value === '' || value === null || value !== value;
        };
        this.$$updateEmptyClasses = function(value) {
          if (ctrl.$isEmpty(value)) {
            $animate.removeClass($element, NOT_EMPTY_CLASS);
            $animate.addClass($element, EMPTY_CLASS);
          } else {
            $animate.removeClass($element, EMPTY_CLASS);
            $animate.addClass($element, NOT_EMPTY_CLASS);
          }
        };
        var currentValidationRunId = 0;
        addSetValidityMethod({
          ctrl: this,
          $element: $element,
          set: function(object, property) {
            object[property] = true;
          },
          unset: function(object, property) {
            delete object[property];
          },
          $animate: $animate
        });
        this.$setPristine = function() {
          ctrl.$dirty = false;
          ctrl.$pristine = true;
          $animate.removeClass($element, DIRTY_CLASS);
          $animate.addClass($element, PRISTINE_CLASS);
        };
        this.$setDirty = function() {
          ctrl.$dirty = true;
          ctrl.$pristine = false;
          $animate.removeClass($element, PRISTINE_CLASS);
          $animate.addClass($element, DIRTY_CLASS);
          ctrl.$$parentForm.$setDirty();
        };
        this.$setUntouched = function() {
          ctrl.$touched = false;
          ctrl.$untouched = true;
          $animate.setClass($element, UNTOUCHED_CLASS, TOUCHED_CLASS);
        };
        this.$setTouched = function() {
          ctrl.$touched = true;
          ctrl.$untouched = false;
          $animate.setClass($element, TOUCHED_CLASS, UNTOUCHED_CLASS);
        };
        this.$rollbackViewValue = function() {
          $timeout.cancel(pendingDebounce);
          ctrl.$viewValue = ctrl.$$lastCommittedViewValue;
          ctrl.$render();
        };
        this.$validate = function() {
          if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
            return;
          }
          var viewValue = ctrl.$$lastCommittedViewValue;
          var modelValue = ctrl.$$rawModelValue;
          var prevValid = ctrl.$valid;
          var prevModelValue = ctrl.$modelValue;
          var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
          ctrl.$$runValidators(modelValue, viewValue, function(allValid) {
            if (!allowInvalid && prevValid !== allValid) {
              ctrl.$modelValue = allValid ? modelValue : undefined;
              if (ctrl.$modelValue !== prevModelValue) {
                ctrl.$$writeModelToScope();
              }
            }
          });
        };
        this.$$runValidators = function(modelValue, viewValue, doneCallback) {
          currentValidationRunId++;
          var localValidationRunId = currentValidationRunId;
          if (!processParseErrors()) {
            validationDone(false);
            return;
          }
          if (!processSyncValidators()) {
            validationDone(false);
            return;
          }
          processAsyncValidators();
          function processParseErrors() {
            var errorKey = ctrl.$$parserName || 'parse';
            if (isUndefined(parserValid)) {
              setValidity(errorKey, null);
            } else {
              if (!parserValid) {
                forEach(ctrl.$validators, function(v, name) {
                  setValidity(name, null);
                });
                forEach(ctrl.$asyncValidators, function(v, name) {
                  setValidity(name, null);
                });
              }
              setValidity(errorKey, parserValid);
              return parserValid;
            }
            return true;
          }
          function processSyncValidators() {
            var syncValidatorsValid = true;
            forEach(ctrl.$validators, function(validator, name) {
              var result = validator(modelValue, viewValue);
              syncValidatorsValid = syncValidatorsValid && result;
              setValidity(name, result);
            });
            if (!syncValidatorsValid) {
              forEach(ctrl.$asyncValidators, function(v, name) {
                setValidity(name, null);
              });
              return false;
            }
            return true;
          }
          function processAsyncValidators() {
            var validatorPromises = [];
            var allValid = true;
            forEach(ctrl.$asyncValidators, function(validator, name) {
              var promise = validator(modelValue, viewValue);
              if (!isPromiseLike(promise)) {
                throw ngModelMinErr('nopromise', "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
              }
              setValidity(name, undefined);
              validatorPromises.push(promise.then(function() {
                setValidity(name, true);
              }, function() {
                allValid = false;
                setValidity(name, false);
              }));
            });
            if (!validatorPromises.length) {
              validationDone(true);
            } else {
              $q.all(validatorPromises).then(function() {
                validationDone(allValid);
              }, noop);
            }
          }
          function setValidity(name, isValid) {
            if (localValidationRunId === currentValidationRunId) {
              ctrl.$setValidity(name, isValid);
            }
          }
          function validationDone(allValid) {
            if (localValidationRunId === currentValidationRunId) {
              doneCallback(allValid);
            }
          }
        };
        this.$commitViewValue = function() {
          var viewValue = ctrl.$viewValue;
          $timeout.cancel(pendingDebounce);
          if (ctrl.$$lastCommittedViewValue === viewValue && (viewValue !== '' || !ctrl.$$hasNativeValidators)) {
            return;
          }
          ctrl.$$updateEmptyClasses(viewValue);
          ctrl.$$lastCommittedViewValue = viewValue;
          if (ctrl.$pristine) {
            this.$setDirty();
          }
          this.$$parseAndValidate();
        };
        this.$$parseAndValidate = function() {
          var viewValue = ctrl.$$lastCommittedViewValue;
          var modelValue = viewValue;
          parserValid = isUndefined(modelValue) ? undefined : true;
          if (parserValid) {
            for (var i = 0; i < ctrl.$parsers.length; i++) {
              modelValue = ctrl.$parsers[i](modelValue);
              if (isUndefined(modelValue)) {
                parserValid = false;
                break;
              }
            }
          }
          if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
            ctrl.$modelValue = ngModelGet($scope);
          }
          var prevModelValue = ctrl.$modelValue;
          var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
          ctrl.$$rawModelValue = modelValue;
          if (allowInvalid) {
            ctrl.$modelValue = modelValue;
            writeToModelIfNeeded();
          }
          ctrl.$$runValidators(modelValue, ctrl.$$lastCommittedViewValue, function(allValid) {
            if (!allowInvalid) {
              ctrl.$modelValue = allValid ? modelValue : undefined;
              writeToModelIfNeeded();
            }
          });
          function writeToModelIfNeeded() {
            if (ctrl.$modelValue !== prevModelValue) {
              ctrl.$$writeModelToScope();
            }
          }
        };
        this.$$writeModelToScope = function() {
          ngModelSet($scope, ctrl.$modelValue);
          forEach(ctrl.$viewChangeListeners, function(listener) {
            try {
              listener();
            } catch (e) {
              $exceptionHandler(e);
            }
          });
        };
        this.$setViewValue = function(value, trigger) {
          ctrl.$viewValue = value;
          if (!ctrl.$options || ctrl.$options.updateOnDefault) {
            ctrl.$$debounceViewValueCommit(trigger);
          }
        };
        this.$$debounceViewValueCommit = function(trigger) {
          var debounceDelay = 0,
              options = ctrl.$options,
              debounce;
          if (options && isDefined(options.debounce)) {
            debounce = options.debounce;
            if (isNumber(debounce)) {
              debounceDelay = debounce;
            } else if (isNumber(debounce[trigger])) {
              debounceDelay = debounce[trigger];
            } else if (isNumber(debounce['default'])) {
              debounceDelay = debounce['default'];
            }
          }
          $timeout.cancel(pendingDebounce);
          if (debounceDelay) {
            pendingDebounce = $timeout(function() {
              ctrl.$commitViewValue();
            }, debounceDelay);
          } else if ($rootScope.$$phase) {
            ctrl.$commitViewValue();
          } else {
            $scope.$apply(function() {
              ctrl.$commitViewValue();
            });
          }
        };
        $scope.$watch(function ngModelWatch() {
          var modelValue = ngModelGet($scope);
          if (modelValue !== ctrl.$modelValue && (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)) {
            ctrl.$modelValue = ctrl.$$rawModelValue = modelValue;
            parserValid = undefined;
            var formatters = ctrl.$formatters,
                idx = formatters.length;
            var viewValue = modelValue;
            while (idx--) {
              viewValue = formatters[idx](viewValue);
            }
            if (ctrl.$viewValue !== viewValue) {
              ctrl.$$updateEmptyClasses(viewValue);
              ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue;
              ctrl.$render();
              ctrl.$$runValidators(modelValue, viewValue, noop);
            }
          }
          return modelValue;
        });
      }];
      var ngModelDirective = ['$rootScope', function($rootScope) {
        return {
          restrict: 'A',
          require: ['ngModel', '^?form', '^?ngModelOptions'],
          controller: NgModelController,
          priority: 1,
          compile: function ngModelCompile(element) {
            element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS);
            return {
              pre: function ngModelPreLink(scope, element, attr, ctrls) {
                var modelCtrl = ctrls[0],
                    formCtrl = ctrls[1] || modelCtrl.$$parentForm;
                modelCtrl.$$setOptions(ctrls[2] && ctrls[2].$options);
                formCtrl.$addControl(modelCtrl);
                attr.$observe('name', function(newValue) {
                  if (modelCtrl.$name !== newValue) {
                    modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue);
                  }
                });
                scope.$on('$destroy', function() {
                  modelCtrl.$$parentForm.$removeControl(modelCtrl);
                });
              },
              post: function ngModelPostLink(scope, element, attr, ctrls) {
                var modelCtrl = ctrls[0];
                if (modelCtrl.$options && modelCtrl.$options.updateOn) {
                  element.on(modelCtrl.$options.updateOn, function(ev) {
                    modelCtrl.$$debounceViewValueCommit(ev && ev.type);
                  });
                }
                element.on('blur', function() {
                  if (modelCtrl.$touched)
                    return;
                  if ($rootScope.$$phase) {
                    scope.$evalAsync(modelCtrl.$setTouched);
                  } else {
                    scope.$apply(modelCtrl.$setTouched);
                  }
                });
              }
            };
          }
        };
      }];
      var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
      var ngModelOptionsDirective = function() {
        return {
          restrict: 'A',
          controller: ['$scope', '$attrs', function($scope, $attrs) {
            var that = this;
            this.$options = copy($scope.$eval($attrs.ngModelOptions));
            if (isDefined(this.$options.updateOn)) {
              this.$options.updateOnDefault = false;
              this.$options.updateOn = trim(this.$options.updateOn.replace(DEFAULT_REGEXP, function() {
                that.$options.updateOnDefault = true;
                return ' ';
              }));
            } else {
              this.$options.updateOnDefault = true;
            }
          }]
        };
      };
      function addSetValidityMethod(context) {
        var ctrl = context.ctrl,
            $element = context.$element,
            classCache = {},
            set = context.set,
            unset = context.unset,
            $animate = context.$animate;
        classCache[INVALID_CLASS] = !(classCache[VALID_CLASS] = $element.hasClass(VALID_CLASS));
        ctrl.$setValidity = setValidity;
        function setValidity(validationErrorKey, state, controller) {
          if (isUndefined(state)) {
            createAndSet('$pending', validationErrorKey, controller);
          } else {
            unsetAndCleanup('$pending', validationErrorKey, controller);
          }
          if (!isBoolean(state)) {
            unset(ctrl.$error, validationErrorKey, controller);
            unset(ctrl.$$success, validationErrorKey, controller);
          } else {
            if (state) {
              unset(ctrl.$error, validationErrorKey, controller);
              set(ctrl.$$success, validationErrorKey, controller);
            } else {
              set(ctrl.$error, validationErrorKey, controller);
              unset(ctrl.$$success, validationErrorKey, controller);
            }
          }
          if (ctrl.$pending) {
            cachedToggleClass(PENDING_CLASS, true);
            ctrl.$valid = ctrl.$invalid = undefined;
            toggleValidationCss('', null);
          } else {
            cachedToggleClass(PENDING_CLASS, false);
            ctrl.$valid = isObjectEmpty(ctrl.$error);
            ctrl.$invalid = !ctrl.$valid;
            toggleValidationCss('', ctrl.$valid);
          }
          var combinedState;
          if (ctrl.$pending && ctrl.$pending[validationErrorKey]) {
            combinedState = undefined;
          } else if (ctrl.$error[validationErrorKey]) {
            combinedState = false;
          } else if (ctrl.$$success[validationErrorKey]) {
            combinedState = true;
          } else {
            combinedState = null;
          }
          toggleValidationCss(validationErrorKey, combinedState);
          ctrl.$$parentForm.$setValidity(validationErrorKey, combinedState, ctrl);
        }
        function createAndSet(name, value, controller) {
          if (!ctrl[name]) {
            ctrl[name] = {};
          }
          set(ctrl[name], value, controller);
        }
        function unsetAndCleanup(name, value, controller) {
          if (ctrl[name]) {
            unset(ctrl[name], value, controller);
          }
          if (isObjectEmpty(ctrl[name])) {
            ctrl[name] = undefined;
          }
        }
        function cachedToggleClass(className, switchValue) {
          if (switchValue && !classCache[className]) {
            $animate.addClass($element, className);
            classCache[className] = true;
          } else if (!switchValue && classCache[className]) {
            $animate.removeClass($element, className);
            classCache[className] = false;
          }
        }
        function toggleValidationCss(validationErrorKey, isValid) {
          validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
          cachedToggleClass(VALID_CLASS + validationErrorKey, isValid === true);
          cachedToggleClass(INVALID_CLASS + validationErrorKey, isValid === false);
        }
      }
      function isObjectEmpty(obj) {
        if (obj) {
          for (var prop in obj) {
            if (obj.hasOwnProperty(prop)) {
              return false;
            }
          }
        }
        return true;
      }
      var ngNonBindableDirective = ngDirective({
        terminal: true,
        priority: 1000
      });
      var ngOptionsMinErr = minErr('ngOptions');
      var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;
      var ngOptionsDirective = ['$compile', '$document', '$parse', function($compile, $document, $parse) {
        function parseOptionsExpression(optionsExp, selectElement, scope) {
          var match = optionsExp.match(NG_OPTIONS_REGEXP);
          if (!(match)) {
            throw ngOptionsMinErr('iexp', "Expected expression in form of " + "'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" + " but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
          }
          var valueName = match[5] || match[7];
          var keyName = match[6];
          var selectAs = / as /.test(match[0]) && match[1];
          var trackBy = match[9];
          var valueFn = $parse(match[2] ? match[1] : valueName);
          var selectAsFn = selectAs && $parse(selectAs);
          var viewValueFn = selectAsFn || valueFn;
          var trackByFn = trackBy && $parse(trackBy);
          var getTrackByValueFn = trackBy ? function(value, locals) {
            return trackByFn(scope, locals);
          } : function getHashOfValue(value) {
            return hashKey(value);
          };
          var getTrackByValue = function(value, key) {
            return getTrackByValueFn(value, getLocals(value, key));
          };
          var displayFn = $parse(match[2] || match[1]);
          var groupByFn = $parse(match[3] || '');
          var disableWhenFn = $parse(match[4] || '');
          var valuesFn = $parse(match[8]);
          var locals = {};
          var getLocals = keyName ? function(value, key) {
            locals[keyName] = key;
            locals[valueName] = value;
            return locals;
          } : function(value) {
            locals[valueName] = value;
            return locals;
          };
          function Option(selectValue, viewValue, label, group, disabled) {
            this.selectValue = selectValue;
            this.viewValue = viewValue;
            this.label = label;
            this.group = group;
            this.disabled = disabled;
          }
          function getOptionValuesKeys(optionValues) {
            var optionValuesKeys;
            if (!keyName && isArrayLike(optionValues)) {
              optionValuesKeys = optionValues;
            } else {
              optionValuesKeys = [];
              for (var itemKey in optionValues) {
                if (optionValues.hasOwnProperty(itemKey) && itemKey.charAt(0) !== '$') {
                  optionValuesKeys.push(itemKey);
                }
              }
            }
            return optionValuesKeys;
          }
          return {
            trackBy: trackBy,
            getTrackByValue: getTrackByValue,
            getWatchables: $parse(valuesFn, function(optionValues) {
              var watchedArray = [];
              optionValues = optionValues || [];
              var optionValuesKeys = getOptionValuesKeys(optionValues);
              var optionValuesLength = optionValuesKeys.length;
              for (var index = 0; index < optionValuesLength; index++) {
                var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
                var value = optionValues[key];
                var locals = getLocals(value, key);
                var selectValue = getTrackByValueFn(value, locals);
                watchedArray.push(selectValue);
                if (match[2] || match[1]) {
                  var label = displayFn(scope, locals);
                  watchedArray.push(label);
                }
                if (match[4]) {
                  var disableWhen = disableWhenFn(scope, locals);
                  watchedArray.push(disableWhen);
                }
              }
              return watchedArray;
            }),
            getOptions: function() {
              var optionItems = [];
              var selectValueMap = {};
              var optionValues = valuesFn(scope) || [];
              var optionValuesKeys = getOptionValuesKeys(optionValues);
              var optionValuesLength = optionValuesKeys.length;
              for (var index = 0; index < optionValuesLength; index++) {
                var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
                var value = optionValues[key];
                var locals = getLocals(value, key);
                var viewValue = viewValueFn(scope, locals);
                var selectValue = getTrackByValueFn(viewValue, locals);
                var label = displayFn(scope, locals);
                var group = groupByFn(scope, locals);
                var disabled = disableWhenFn(scope, locals);
                var optionItem = new Option(selectValue, viewValue, label, group, disabled);
                optionItems.push(optionItem);
                selectValueMap[selectValue] = optionItem;
              }
              return {
                items: optionItems,
                selectValueMap: selectValueMap,
                getOptionFromViewValue: function(value) {
                  return selectValueMap[getTrackByValue(value)];
                },
                getViewValueFromOption: function(option) {
                  return trackBy ? angular.copy(option.viewValue) : option.viewValue;
                }
              };
            }
          };
        }
        var optionTemplate = window.document.createElement('option'),
            optGroupTemplate = window.document.createElement('optgroup');
        function ngOptionsPostLink(scope, selectElement, attr, ctrls) {
          var selectCtrl = ctrls[0];
          var ngModelCtrl = ctrls[1];
          var multiple = attr.multiple;
          var emptyOption;
          for (var i = 0,
              children = selectElement.children(),
              ii = children.length; i < ii; i++) {
            if (children[i].value === '') {
              emptyOption = children.eq(i);
              break;
            }
          }
          var providedEmptyOption = !!emptyOption;
          var unknownOption = jqLite(optionTemplate.cloneNode(false));
          unknownOption.val('?');
          var options;
          var ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope);
          var listFragment = $document[0].createDocumentFragment();
          var renderEmptyOption = function() {
            if (!providedEmptyOption) {
              selectElement.prepend(emptyOption);
            }
            selectElement.val('');
            emptyOption.prop('selected', true);
            emptyOption.attr('selected', true);
          };
          var removeEmptyOption = function() {
            if (!providedEmptyOption) {
              emptyOption.remove();
            }
          };
          var renderUnknownOption = function() {
            selectElement.prepend(unknownOption);
            selectElement.val('?');
            unknownOption.prop('selected', true);
            unknownOption.attr('selected', true);
          };
          var removeUnknownOption = function() {
            unknownOption.remove();
          };
          if (!multiple) {
            selectCtrl.writeValue = function writeNgOptionsValue(value) {
              var option = options.getOptionFromViewValue(value);
              if (option) {
                if (selectElement[0].value !== option.selectValue) {
                  removeUnknownOption();
                  removeEmptyOption();
                  selectElement[0].value = option.selectValue;
                  option.element.selected = true;
                }
                option.element.setAttribute('selected', 'selected');
              } else {
                if (value === null || providedEmptyOption) {
                  removeUnknownOption();
                  renderEmptyOption();
                } else {
                  removeEmptyOption();
                  renderUnknownOption();
                }
              }
            };
            selectCtrl.readValue = function readNgOptionsValue() {
              var selectedOption = options.selectValueMap[selectElement.val()];
              if (selectedOption && !selectedOption.disabled) {
                removeEmptyOption();
                removeUnknownOption();
                return options.getViewValueFromOption(selectedOption);
              }
              return null;
            };
            if (ngOptions.trackBy) {
              scope.$watch(function() {
                return ngOptions.getTrackByValue(ngModelCtrl.$viewValue);
              }, function() {
                ngModelCtrl.$render();
              });
            }
          } else {
            ngModelCtrl.$isEmpty = function(value) {
              return !value || value.length === 0;
            };
            selectCtrl.writeValue = function writeNgOptionsMultiple(value) {
              options.items.forEach(function(option) {
                option.element.selected = false;
              });
              if (value) {
                value.forEach(function(item) {
                  var option = options.getOptionFromViewValue(item);
                  if (option)
                    option.element.selected = true;
                });
              }
            };
            selectCtrl.readValue = function readNgOptionsMultiple() {
              var selectedValues = selectElement.val() || [],
                  selections = [];
              forEach(selectedValues, function(value) {
                var option = options.selectValueMap[value];
                if (option && !option.disabled)
                  selections.push(options.getViewValueFromOption(option));
              });
              return selections;
            };
            if (ngOptions.trackBy) {
              scope.$watchCollection(function() {
                if (isArray(ngModelCtrl.$viewValue)) {
                  return ngModelCtrl.$viewValue.map(function(value) {
                    return ngOptions.getTrackByValue(value);
                  });
                }
              }, function() {
                ngModelCtrl.$render();
              });
            }
          }
          if (providedEmptyOption) {
            emptyOption.remove();
            $compile(emptyOption)(scope);
            emptyOption.removeClass('ng-scope');
          } else {
            emptyOption = jqLite(optionTemplate.cloneNode(false));
          }
          selectElement.empty();
          updateOptions();
          scope.$watchCollection(ngOptions.getWatchables, updateOptions);
          function addOptionElement(option, parent) {
            var optionElement = optionTemplate.cloneNode(false);
            parent.appendChild(optionElement);
            updateOptionElement(option, optionElement);
          }
          function updateOptionElement(option, element) {
            option.element = element;
            element.disabled = option.disabled;
            if (option.label !== element.label) {
              element.label = option.label;
              element.textContent = option.label;
            }
            if (option.value !== element.value)
              element.value = option.selectValue;
          }
          function updateOptions() {
            var previousValue = options && selectCtrl.readValue();
            if (options) {
              for (var i = options.items.length - 1; i >= 0; i--) {
                var option = options.items[i];
                if (option.group) {
                  jqLiteRemove(option.element.parentNode);
                } else {
                  jqLiteRemove(option.element);
                }
              }
            }
            options = ngOptions.getOptions();
            var groupElementMap = {};
            if (providedEmptyOption) {
              selectElement.prepend(emptyOption);
            }
            options.items.forEach(function addOption(option) {
              var groupElement;
              if (isDefined(option.group)) {
                groupElement = groupElementMap[option.group];
                if (!groupElement) {
                  groupElement = optGroupTemplate.cloneNode(false);
                  listFragment.appendChild(groupElement);
                  groupElement.label = option.group;
                  groupElementMap[option.group] = groupElement;
                }
                addOptionElement(option, groupElement);
              } else {
                addOptionElement(option, listFragment);
              }
            });
            selectElement[0].appendChild(listFragment);
            ngModelCtrl.$render();
            if (!ngModelCtrl.$isEmpty(previousValue)) {
              var nextValue = selectCtrl.readValue();
              var isNotPrimitive = ngOptions.trackBy || multiple;
              if (isNotPrimitive ? !equals(previousValue, nextValue) : previousValue !== nextValue) {
                ngModelCtrl.$setViewValue(nextValue);
                ngModelCtrl.$render();
              }
            }
          }
        }
        return {
          restrict: 'A',
          terminal: true,
          require: ['select', 'ngModel'],
          link: {
            pre: function ngOptionsPreLink(scope, selectElement, attr, ctrls) {
              ctrls[0].registerOption = noop;
            },
            post: ngOptionsPostLink
          }
        };
      }];
      var ngPluralizeDirective = ['$locale', '$interpolate', '$log', function($locale, $interpolate, $log) {
        var BRACE = /{}/g,
            IS_WHEN = /^when(Minus)?(.+)$/;
        return {link: function(scope, element, attr) {
            var numberExp = attr.count,
                whenExp = attr.$attr.when && element.attr(attr.$attr.when),
                offset = attr.offset || 0,
                whens = scope.$eval(whenExp) || {},
                whensExpFns = {},
                startSymbol = $interpolate.startSymbol(),
                endSymbol = $interpolate.endSymbol(),
                braceReplacement = startSymbol + numberExp + '-' + offset + endSymbol,
                watchRemover = angular.noop,
                lastCount;
            forEach(attr, function(expression, attributeName) {
              var tmpMatch = IS_WHEN.exec(attributeName);
              if (tmpMatch) {
                var whenKey = (tmpMatch[1] ? '-' : '') + lowercase(tmpMatch[2]);
                whens[whenKey] = element.attr(attr.$attr[attributeName]);
              }
            });
            forEach(whens, function(expression, key) {
              whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
            });
            scope.$watch(numberExp, function ngPluralizeWatchAction(newVal) {
              var count = parseFloat(newVal);
              var countIsNaN = isNaN(count);
              if (!countIsNaN && !(count in whens)) {
                count = $locale.pluralCat(count - offset);
              }
              if ((count !== lastCount) && !(countIsNaN && isNumber(lastCount) && isNaN(lastCount))) {
                watchRemover();
                var whenExpFn = whensExpFns[count];
                if (isUndefined(whenExpFn)) {
                  if (newVal != null) {
                    $log.debug("ngPluralize: no rule defined for '" + count + "' in " + whenExp);
                  }
                  watchRemover = noop;
                  updateElementText();
                } else {
                  watchRemover = scope.$watch(whenExpFn, updateElementText);
                }
                lastCount = count;
              }
            });
            function updateElementText(newText) {
              element.text(newText || '');
            }
          }};
      }];
      var ngRepeatDirective = ['$parse', '$animate', '$compile', function($parse, $animate, $compile) {
        var NG_REMOVED = '$$NG_REMOVED';
        var ngRepeatMinErr = minErr('ngRepeat');
        var updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
          scope[valueIdentifier] = value;
          if (keyIdentifier)
            scope[keyIdentifier] = key;
          scope.$index = index;
          scope.$first = (index === 0);
          scope.$last = (index === (arrayLength - 1));
          scope.$middle = !(scope.$first || scope.$last);
          scope.$odd = !(scope.$even = (index & 1) === 0);
        };
        var getBlockStart = function(block) {
          return block.clone[0];
        };
        var getBlockEnd = function(block) {
          return block.clone[block.clone.length - 1];
        };
        return {
          restrict: 'A',
          multiElement: true,
          transclude: 'element',
          priority: 1000,
          terminal: true,
          $$tlb: true,
          compile: function ngRepeatCompile($element, $attr) {
            var expression = $attr.ngRepeat;
            var ngRepeatEndComment = $compile.$$createComment('end ngRepeat', expression);
            var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
            if (!match) {
              throw ngRepeatMinErr('iexp', "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
            }
            var lhs = match[1];
            var rhs = match[2];
            var aliasAs = match[3];
            var trackByExp = match[4];
            match = lhs.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/);
            if (!match) {
              throw ngRepeatMinErr('iidexp', "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
            }
            var valueIdentifier = match[3] || match[1];
            var keyIdentifier = match[2];
            if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) {
              throw ngRepeatMinErr('badident', "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", aliasAs);
            }
            var trackByExpGetter,
                trackByIdExpFn,
                trackByIdArrayFn,
                trackByIdObjFn;
            var hashFnLocals = {$id: hashKey};
            if (trackByExp) {
              trackByExpGetter = $parse(trackByExp);
            } else {
              trackByIdArrayFn = function(key, value) {
                return hashKey(value);
              };
              trackByIdObjFn = function(key) {
                return key;
              };
            }
            return function ngRepeatLink($scope, $element, $attr, ctrl, $transclude) {
              if (trackByExpGetter) {
                trackByIdExpFn = function(key, value, index) {
                  if (keyIdentifier)
                    hashFnLocals[keyIdentifier] = key;
                  hashFnLocals[valueIdentifier] = value;
                  hashFnLocals.$index = index;
                  return trackByExpGetter($scope, hashFnLocals);
                };
              }
              var lastBlockMap = createMap();
              $scope.$watchCollection(rhs, function ngRepeatAction(collection) {
                var index,
                    length,
                    previousNode = $element[0],
                    nextNode,
                    nextBlockMap = createMap(),
                    collectionLength,
                    key,
                    value,
                    trackById,
                    trackByIdFn,
                    collectionKeys,
                    block,
                    nextBlockOrder,
                    elementsToRemove;
                if (aliasAs) {
                  $scope[aliasAs] = collection;
                }
                if (isArrayLike(collection)) {
                  collectionKeys = collection;
                  trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
                } else {
                  trackByIdFn = trackByIdExpFn || trackByIdObjFn;
                  collectionKeys = [];
                  for (var itemKey in collection) {
                    if (hasOwnProperty.call(collection, itemKey) && itemKey.charAt(0) !== '$') {
                      collectionKeys.push(itemKey);
                    }
                  }
                }
                collectionLength = collectionKeys.length;
                nextBlockOrder = new Array(collectionLength);
                for (index = 0; index < collectionLength; index++) {
                  key = (collection === collectionKeys) ? index : collectionKeys[index];
                  value = collection[key];
                  trackById = trackByIdFn(key, value, index);
                  if (lastBlockMap[trackById]) {
                    block = lastBlockMap[trackById];
                    delete lastBlockMap[trackById];
                    nextBlockMap[trackById] = block;
                    nextBlockOrder[index] = block;
                  } else if (nextBlockMap[trackById]) {
                    forEach(nextBlockOrder, function(block) {
                      if (block && block.scope)
                        lastBlockMap[block.id] = block;
                    });
                    throw ngRepeatMinErr('dupes', "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, value);
                  } else {
                    nextBlockOrder[index] = {
                      id: trackById,
                      scope: undefined,
                      clone: undefined
                    };
                    nextBlockMap[trackById] = true;
                  }
                }
                for (var blockKey in lastBlockMap) {
                  block = lastBlockMap[blockKey];
                  elementsToRemove = getBlockNodes(block.clone);
                  $animate.leave(elementsToRemove);
                  if (elementsToRemove[0].parentNode) {
                    for (index = 0, length = elementsToRemove.length; index < length; index++) {
                      elementsToRemove[index][NG_REMOVED] = true;
                    }
                  }
                  block.scope.$destroy();
                }
                for (index = 0; index < collectionLength; index++) {
                  key = (collection === collectionKeys) ? index : collectionKeys[index];
                  value = collection[key];
                  block = nextBlockOrder[index];
                  if (block.scope) {
                    nextNode = previousNode;
                    do {
                      nextNode = nextNode.nextSibling;
                    } while (nextNode && nextNode[NG_REMOVED]);
                    if (getBlockStart(block) != nextNode) {
                      $animate.move(getBlockNodes(block.clone), null, previousNode);
                    }
                    previousNode = getBlockEnd(block);
                    updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                  } else {
                    $transclude(function ngRepeatTransclude(clone, scope) {
                      block.scope = scope;
                      var endNode = ngRepeatEndComment.cloneNode(false);
                      clone[clone.length++] = endNode;
                      $animate.enter(clone, null, previousNode);
                      previousNode = endNode;
                      block.clone = clone;
                      nextBlockMap[block.id] = block;
                      updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                    });
                  }
                }
                lastBlockMap = nextBlockMap;
              });
            };
          }
        };
      }];
      var NG_HIDE_CLASS = 'ng-hide';
      var NG_HIDE_IN_PROGRESS_CLASS = 'ng-hide-animate';
      var ngShowDirective = ['$animate', function($animate) {
        return {
          restrict: 'A',
          multiElement: true,
          link: function(scope, element, attr) {
            scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
              $animate[value ? 'removeClass' : 'addClass'](element, NG_HIDE_CLASS, {tempClasses: NG_HIDE_IN_PROGRESS_CLASS});
            });
          }
        };
      }];
      var ngHideDirective = ['$animate', function($animate) {
        return {
          restrict: 'A',
          multiElement: true,
          link: function(scope, element, attr) {
            scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
              $animate[value ? 'addClass' : 'removeClass'](element, NG_HIDE_CLASS, {tempClasses: NG_HIDE_IN_PROGRESS_CLASS});
            });
          }
        };
      }];
      var ngStyleDirective = ngDirective(function(scope, element, attr) {
        scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
          if (oldStyles && (newStyles !== oldStyles)) {
            forEach(oldStyles, function(val, style) {
              element.css(style, '');
            });
          }
          if (newStyles)
            element.css(newStyles);
        }, true);
      });
      var ngSwitchDirective = ['$animate', '$compile', function($animate, $compile) {
        return {
          require: 'ngSwitch',
          controller: ['$scope', function ngSwitchController() {
            this.cases = {};
          }],
          link: function(scope, element, attr, ngSwitchController) {
            var watchExpr = attr.ngSwitch || attr.on,
                selectedTranscludes = [],
                selectedElements = [],
                previousLeaveAnimations = [],
                selectedScopes = [];
            var spliceFactory = function(array, index) {
              return function() {
                array.splice(index, 1);
              };
            };
            scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
              var i,
                  ii;
              for (i = 0, ii = previousLeaveAnimations.length; i < ii; ++i) {
                $animate.cancel(previousLeaveAnimations[i]);
              }
              previousLeaveAnimations.length = 0;
              for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
                var selected = getBlockNodes(selectedElements[i].clone);
                selectedScopes[i].$destroy();
                var promise = previousLeaveAnimations[i] = $animate.leave(selected);
                promise.then(spliceFactory(previousLeaveAnimations, i));
              }
              selectedElements.length = 0;
              selectedScopes.length = 0;
              if ((selectedTranscludes = ngSwitchController.cases['!' + value] || ngSwitchController.cases['?'])) {
                forEach(selectedTranscludes, function(selectedTransclude) {
                  selectedTransclude.transclude(function(caseElement, selectedScope) {
                    selectedScopes.push(selectedScope);
                    var anchor = selectedTransclude.element;
                    caseElement[caseElement.length++] = $compile.$$createComment('end ngSwitchWhen');
                    var block = {clone: caseElement};
                    selectedElements.push(block);
                    $animate.enter(caseElement, anchor.parent(), anchor);
                  });
                });
              }
            });
          }
        };
      }];
      var ngSwitchWhenDirective = ngDirective({
        transclude: 'element',
        priority: 1200,
        require: '^ngSwitch',
        multiElement: true,
        link: function(scope, element, attrs, ctrl, $transclude) {
          ctrl.cases['!' + attrs.ngSwitchWhen] = (ctrl.cases['!' + attrs.ngSwitchWhen] || []);
          ctrl.cases['!' + attrs.ngSwitchWhen].push({
            transclude: $transclude,
            element: element
          });
        }
      });
      var ngSwitchDefaultDirective = ngDirective({
        transclude: 'element',
        priority: 1200,
        require: '^ngSwitch',
        multiElement: true,
        link: function(scope, element, attr, ctrl, $transclude) {
          ctrl.cases['?'] = (ctrl.cases['?'] || []);
          ctrl.cases['?'].push({
            transclude: $transclude,
            element: element
          });
        }
      });
      var ngTranscludeMinErr = minErr('ngTransclude');
      var ngTranscludeDirective = ngDirective({
        restrict: 'EAC',
        link: function($scope, $element, $attrs, controller, $transclude) {
          if ($attrs.ngTransclude === $attrs.$attr.ngTransclude) {
            $attrs.ngTransclude = '';
          }
          function ngTranscludeCloneAttachFn(clone) {
            if (clone.length) {
              $element.empty();
              $element.append(clone);
            }
          }
          if (!$transclude) {
            throw ngTranscludeMinErr('orphan', 'Illegal use of ngTransclude directive in the template! ' + 'No parent directive that requires a transclusion found. ' + 'Element: {0}', startingTag($element));
          }
          var slotName = $attrs.ngTransclude || $attrs.ngTranscludeSlot;
          $transclude(ngTranscludeCloneAttachFn, null, slotName);
        }
      });
      var scriptDirective = ['$templateCache', function($templateCache) {
        return {
          restrict: 'E',
          terminal: true,
          compile: function(element, attr) {
            if (attr.type == 'text/ng-template') {
              var templateUrl = attr.id,
                  text = element[0].text;
              $templateCache.put(templateUrl, text);
            }
          }
        };
      }];
      var noopNgModelController = {
        $setViewValue: noop,
        $render: noop
      };
      function chromeHack(optionElement) {
        if (optionElement[0].hasAttribute('selected')) {
          optionElement[0].selected = true;
        }
      }
      var SelectController = ['$element', '$scope', function($element, $scope) {
        var self = this,
            optionsMap = new HashMap();
        self.ngModelCtrl = noopNgModelController;
        self.unknownOption = jqLite(window.document.createElement('option'));
        self.renderUnknownOption = function(val) {
          var unknownVal = '? ' + hashKey(val) + ' ?';
          self.unknownOption.val(unknownVal);
          $element.prepend(self.unknownOption);
          $element.val(unknownVal);
        };
        $scope.$on('$destroy', function() {
          self.renderUnknownOption = noop;
        });
        self.removeUnknownOption = function() {
          if (self.unknownOption.parent())
            self.unknownOption.remove();
        };
        self.readValue = function readSingleValue() {
          self.removeUnknownOption();
          return $element.val();
        };
        self.writeValue = function writeSingleValue(value) {
          if (self.hasOption(value)) {
            self.removeUnknownOption();
            $element.val(value);
            if (value === '')
              self.emptyOption.prop('selected', true);
          } else {
            if (value == null && self.emptyOption) {
              self.removeUnknownOption();
              $element.val('');
            } else {
              self.renderUnknownOption(value);
            }
          }
        };
        self.addOption = function(value, element) {
          if (element[0].nodeType === NODE_TYPE_COMMENT)
            return;
          assertNotHasOwnProperty(value, '"option value"');
          if (value === '') {
            self.emptyOption = element;
          }
          var count = optionsMap.get(value) || 0;
          optionsMap.put(value, count + 1);
          self.ngModelCtrl.$render();
          chromeHack(element);
        };
        self.removeOption = function(value) {
          var count = optionsMap.get(value);
          if (count) {
            if (count === 1) {
              optionsMap.remove(value);
              if (value === '') {
                self.emptyOption = undefined;
              }
            } else {
              optionsMap.put(value, count - 1);
            }
          }
        };
        self.hasOption = function(value) {
          return !!optionsMap.get(value);
        };
        self.registerOption = function(optionScope, optionElement, optionAttrs, interpolateValueFn, interpolateTextFn) {
          if (interpolateValueFn) {
            var oldVal;
            optionAttrs.$observe('value', function valueAttributeObserveAction(newVal) {
              if (isDefined(oldVal)) {
                self.removeOption(oldVal);
              }
              oldVal = newVal;
              self.addOption(newVal, optionElement);
            });
          } else if (interpolateTextFn) {
            optionScope.$watch(interpolateTextFn, function interpolateWatchAction(newVal, oldVal) {
              optionAttrs.$set('value', newVal);
              if (oldVal !== newVal) {
                self.removeOption(oldVal);
              }
              self.addOption(newVal, optionElement);
            });
          } else {
            self.addOption(optionAttrs.value, optionElement);
          }
          optionElement.on('$destroy', function() {
            self.removeOption(optionAttrs.value);
            self.ngModelCtrl.$render();
          });
        };
      }];
      var selectDirective = function() {
        return {
          restrict: 'E',
          require: ['select', '?ngModel'],
          controller: SelectController,
          priority: 1,
          link: {
            pre: selectPreLink,
            post: selectPostLink
          }
        };
        function selectPreLink(scope, element, attr, ctrls) {
          var ngModelCtrl = ctrls[1];
          if (!ngModelCtrl)
            return;
          var selectCtrl = ctrls[0];
          selectCtrl.ngModelCtrl = ngModelCtrl;
          element.on('change', function() {
            scope.$apply(function() {
              ngModelCtrl.$setViewValue(selectCtrl.readValue());
            });
          });
          if (attr.multiple) {
            selectCtrl.readValue = function readMultipleValue() {
              var array = [];
              forEach(element.find('option'), function(option) {
                if (option.selected) {
                  array.push(option.value);
                }
              });
              return array;
            };
            selectCtrl.writeValue = function writeMultipleValue(value) {
              var items = new HashMap(value);
              forEach(element.find('option'), function(option) {
                option.selected = isDefined(items.get(option.value));
              });
            };
            var lastView,
                lastViewRef = NaN;
            scope.$watch(function selectMultipleWatch() {
              if (lastViewRef === ngModelCtrl.$viewValue && !equals(lastView, ngModelCtrl.$viewValue)) {
                lastView = shallowCopy(ngModelCtrl.$viewValue);
                ngModelCtrl.$render();
              }
              lastViewRef = ngModelCtrl.$viewValue;
            });
            ngModelCtrl.$isEmpty = function(value) {
              return !value || value.length === 0;
            };
          }
        }
        function selectPostLink(scope, element, attrs, ctrls) {
          var ngModelCtrl = ctrls[1];
          if (!ngModelCtrl)
            return;
          var selectCtrl = ctrls[0];
          ngModelCtrl.$render = function() {
            selectCtrl.writeValue(ngModelCtrl.$viewValue);
          };
        }
      };
      var optionDirective = ['$interpolate', function($interpolate) {
        return {
          restrict: 'E',
          priority: 100,
          compile: function(element, attr) {
            if (isDefined(attr.value)) {
              var interpolateValueFn = $interpolate(attr.value, true);
            } else {
              var interpolateTextFn = $interpolate(element.text(), true);
              if (!interpolateTextFn) {
                attr.$set('value', element.text());
              }
            }
            return function(scope, element, attr) {
              var selectCtrlName = '$selectController',
                  parent = element.parent(),
                  selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
              if (selectCtrl) {
                selectCtrl.registerOption(scope, element, attr, interpolateValueFn, interpolateTextFn);
              }
            };
          }
        };
      }];
      var styleDirective = valueFn({
        restrict: 'E',
        terminal: false
      });
      var requiredDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            attr.required = true;
            ctrl.$validators.required = function(modelValue, viewValue) {
              return !attr.required || !ctrl.$isEmpty(viewValue);
            };
            attr.$observe('required', function() {
              ctrl.$validate();
            });
          }
        };
      };
      var patternDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            var regexp,
                patternExp = attr.ngPattern || attr.pattern;
            attr.$observe('pattern', function(regex) {
              if (isString(regex) && regex.length > 0) {
                regex = new RegExp('^' + regex + '$');
              }
              if (regex && !regex.test) {
                throw minErr('ngPattern')('noregexp', 'Expected {0} to be a RegExp but was {1}. Element: {2}', patternExp, regex, startingTag(elm));
              }
              regexp = regex || undefined;
              ctrl.$validate();
            });
            ctrl.$validators.pattern = function(modelValue, viewValue) {
              return ctrl.$isEmpty(viewValue) || isUndefined(regexp) || regexp.test(viewValue);
            };
          }
        };
      };
      var maxlengthDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            var maxlength = -1;
            attr.$observe('maxlength', function(value) {
              var intVal = toInt(value);
              maxlength = isNaN(intVal) ? -1 : intVal;
              ctrl.$validate();
            });
            ctrl.$validators.maxlength = function(modelValue, viewValue) {
              return (maxlength < 0) || ctrl.$isEmpty(viewValue) || (viewValue.length <= maxlength);
            };
          }
        };
      };
      var minlengthDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            var minlength = 0;
            attr.$observe('minlength', function(value) {
              minlength = toInt(value) || 0;
              ctrl.$validate();
            });
            ctrl.$validators.minlength = function(modelValue, viewValue) {
              return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
            };
          }
        };
      };
      if (window.angular.bootstrap) {
        if (window.console) {
          console.log('WARNING: Tried to load angular more than once.');
        }
        return;
      }
      bindJQuery();
      publishExternalAPI(angular);
      angular.module("ngLocale", [], ["$provide", function($provide) {
        var PLURAL_CATEGORY = {
          ZERO: "zero",
          ONE: "one",
          TWO: "two",
          FEW: "few",
          MANY: "many",
          OTHER: "other"
        };
        function getDecimals(n) {
          n = n + '';
          var i = n.indexOf('.');
          return (i == -1) ? 0 : n.length - i - 1;
        }
        function getVF(n, opt_precision) {
          var v = opt_precision;
          if (undefined === v) {
            v = Math.min(getDecimals(n), 3);
          }
          var base = Math.pow(10, v);
          var f = ((n * base) | 0) % base;
          return {
            v: v,
            f: f
          };
        }
        $provide.value("$locale", {
          "DATETIME_FORMATS": {
            "AMPMS": ["AM", "PM"],
            "DAY": ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            "ERANAMES": ["Before Christ", "Anno Domini"],
            "ERAS": ["BC", "AD"],
            "FIRSTDAYOFWEEK": 6,
            "MONTH": ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            "SHORTDAY": ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            "SHORTMONTH": ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            "STANDALONEMONTH": ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            "WEEKENDRANGE": [5, 6],
            "fullDate": "EEEE, MMMM d, y",
            "longDate": "MMMM d, y",
            "medium": "MMM d, y h:mm:ss a",
            "mediumDate": "MMM d, y",
            "mediumTime": "h:mm:ss a",
            "short": "M/d/yy h:mm a",
            "shortDate": "M/d/yy",
            "shortTime": "h:mm a"
          },
          "NUMBER_FORMATS": {
            "CURRENCY_SYM": "$",
            "DECIMAL_SEP": ".",
            "GROUP_SEP": ",",
            "PATTERNS": [{
              "gSize": 3,
              "lgSize": 3,
              "maxFrac": 3,
              "minFrac": 0,
              "minInt": 1,
              "negPre": "-",
              "negSuf": "",
              "posPre": "",
              "posSuf": ""
            }, {
              "gSize": 3,
              "lgSize": 3,
              "maxFrac": 2,
              "minFrac": 2,
              "minInt": 1,
              "negPre": "-\u00a4",
              "negSuf": "",
              "posPre": "\u00a4",
              "posSuf": ""
            }]
          },
          "id": "en-us",
          "localeID": "en_US",
          "pluralCat": function(n, opt_precision) {
            var i = n | 0;
            var vf = getVF(n, opt_precision);
            if (i == 1 && vf.v == 0) {
              return PLURAL_CATEGORY.ONE;
            }
            return PLURAL_CATEGORY.OTHER;
          }
        });
      }]);
      jqLite(window.document).ready(function() {
        angularInit(window.document, bootstrap);
      });
    })(window);
    !window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("88", ["ca"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('ca');
  return module.exports;
});

$__System.registerDynamic("56", ["c9", "88"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.Factory = exports.Directive = exports.Filter = exports.Service = exports.Config = exports.Run = exports.Inject = exports.RouteConfig = exports.View = exports.Component = undefined;
  var _extends2 = $__require('c9');
  var _extends3 = _interopRequireDefault(_extends2);
  var _angular = $__require('88');
  var _angular2 = _interopRequireDefault(_angular);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var app = _angular2.default.module('app', []);
  app.run(function($rootScope, $state) {
    $rootScope.$on('$stateChangeStart', function(evt, to, params) {
      if (to.redirectTo) {
        evt.preventDefault();
        $state.go(to.redirectTo, params);
      }
    });
  });
  function Run() {
    return function decorator(target, key, descriptor) {
      app.run(descriptor.value);
    };
  }
  function Config() {
    return function decorator(target, key, descriptor) {
      app.config(descriptor.value);
    };
  }
  function Factory(options) {
    return function decorator(target) {
      options = options ? options : {};
      if (!options.factoryName) {
        throw new Error('@Factory() must contains factoryName property!');
      }
      app.factory(options.factoryName, target.factory);
    };
  }
  function Service(options) {
    return function decorator(target) {
      options = options ? options : {};
      if (!options.serviceName) {
        throw new Error('@Service() must contains serviceName property!');
      }
      app.service(options.serviceName, target);
    };
  }
  function Filter(filter) {
    return function decorator(target, key, descriptor) {
      filter = filter ? filter : {};
      if (!filter.filterName) {
        throw new Error('@Filter() must contains filterName property!');
      }
      app.filter(filter.filterName, descriptor.value);
    };
  }
  function Inject() {
    for (var _len = arguments.length,
        dependencies = Array(_len),
        _key = 0; _key < _len; _key++) {
      dependencies[_key] = arguments[_key];
    }
    return function decorator(target, key, descriptor) {
      if (descriptor) {
        var fn = descriptor.value;
        fn.$inject = dependencies;
      } else {
        target.$inject = dependencies;
      }
    };
  }
  function Component(component) {
    return function decorator(target) {
      component = component ? component : {};
      if (!component.selector) {
        throw new Error('@Component() must contains selector property!');
      }
      if (target.$initView) {
        target.$initView(component.selector);
      }
      target.$isComponent = true;
    };
  }
  function View(view) {
    var options = view ? view : {};
    var defaults = {
      template: options.template,
      restrict: 'E',
      scope: {},
      bindToController: true,
      controllerAs: 'vm',
      link: function link(scope, element, attrs) {
        if (attrs.required && !scope.hasOwnProperty("required")) {
          scope.required = true;
        }
      }
    };
    return function decorator(target) {
      if (target.$isComponent) {
        throw new Error('@View() must be placed after @Component()!');
      }
      target.$initView = function(directiveName) {
        directiveName = pascalCaseToCamelCase(directiveName);
        directiveName = dashCaseToCamelCase(directiveName);
        options.bindToController = options.bindToController || options.bind || {};
        app.directive(directiveName, function() {
          return (0, _extends3.default)(defaults, {controller: target}, options);
        });
      };
      target.$isView = true;
    };
  }
  function Directive(options) {
    return function decorator(target) {
      var directiveName = dashCaseToCamelCase(options.selector);
      app.directive(directiveName, target.directiveFactory);
    };
  }
  function RouteConfig(stateName, options) {
    return function decorator(target) {
      app.config(['$stateProvider', function($stateProvider) {
        $stateProvider.state(stateName, (0, _extends3.default)({
          controller: target,
          controllerAs: 'vm'
        }, options));
      }]);
      app.controller(target.name, target);
    };
  }
  function pascalCaseToCamelCase(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
  }
  function dashCaseToCamelCase(string) {
    return string.replace(/-([a-z])/ig, function(all, letter) {
      return letter.toUpperCase();
    });
  }
  exports.default = app;
  exports.Component = Component;
  exports.View = View;
  exports.RouteConfig = RouteConfig;
  exports.Inject = Inject;
  exports.Run = Run;
  exports.Config = Config;
  exports.Service = Service;
  exports.Filter = Filter;
  exports.Directive = Directive;
  exports.Factory = Factory;
  return module.exports;
});

$__System.registerDynamic("cb", ["4d", "4e", "56", "48"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _classCallCheck2 = $__require('4d');
  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
  var _createClass2 = $__require('4e');
  var _createClass3 = _interopRequireDefault(_createClass2);
  var _dec,
      _class;
  var _ngDecorators = $__require('56');
  var _lodash = $__require('48');
  var _lodash2 = _interopRequireDefault(_lodash);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var PostLoader = (_dec = (0, _ngDecorators.Factory)({factoryName: 'postLoader'}), _dec(_class = function() {
    function PostLoader() {
      (0, _classCallCheck3.default)(this, PostLoader);
      this.events = [];
    }
    (0, _createClass3.default)(PostLoader, [{
      key: 'add',
      value: function add(event) {
        this.events.push(event);
      }
    }, {
      key: 'call',
      value: function call() {
        _lodash2.default.each(this.events, function(event) {
          event();
        });
      }
    }], [{
      key: 'factory',
      value: function factory() {
        PostLoader.instance = new PostLoader();
        return PostLoader.instance;
      }
    }]);
    return PostLoader;
  }()) || _class);
  exports.default = PostLoader;
  return module.exports;
});

$__System.registerDynamic("cc", ["c0", "c3", "cb"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('c0');
  $__require('c3');
  $__require('cb');
  return module.exports;
});

$__System.registerDynamic("cd", ["67"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('67');
  module.exports = function create(P, D) {
    return $.create(P, D);
  };
  return module.exports;
});

$__System.registerDynamic("84", ["cd"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = {
    "default": $__require('cd'),
    __esModule: true
  };
  return module.exports;
});

$__System.registerDynamic("4c", ["33"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  exports.__esModule = true;
  var _defineProperty = $__require('33');
  var _defineProperty2 = _interopRequireDefault(_defineProperty);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  exports.default = function(obj, key, value) {
    if (key in obj) {
      (0, _defineProperty2.default)(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  };
  return module.exports;
});

$__System.registerDynamic("65", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var core = module.exports = {version: '1.2.6'};
  if (typeof __e == 'number')
    __e = core;
  return module.exports;
});

$__System.registerDynamic("ce", ["65"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var core = $__require('65');
  module.exports = function stringify(it) {
    return (core.JSON && core.JSON.stringify || JSON.stringify).apply(JSON, arguments);
  };
  return module.exports;
});

$__System.registerDynamic("5c", ["ce"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = {
    "default": $__require('ce'),
    __esModule: true
  };
  return module.exports;
});

$__System.registerDynamic("54", ["4c", "5c", "4d", "4e", "48", "4f", "cf", "c2"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _defineProperty2 = $__require('4c');
  var _defineProperty3 = _interopRequireDefault(_defineProperty2);
  var _stringify = $__require('5c');
  var _stringify2 = _interopRequireDefault(_stringify);
  var _classCallCheck2 = $__require('4d');
  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
  var _createClass2 = $__require('4e');
  var _createClass3 = _interopRequireDefault(_createClass2);
  var _lodash = $__require('48');
  var _lodash2 = _interopRequireDefault(_lodash);
  var _index = $__require('4f');
  var _index2 = _interopRequireDefault(_index);
  var _eventListener = $__require('cf');
  var _eventListener2 = _interopRequireDefault(_eventListener);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var ID_PROP;
  var DataCollection = $__require('c2');
  var DataModel = function() {
    function DataModel(Service, data, stateModel) {
      var _this = this;
      (0, _classCallCheck3.default)(this, DataModel);
      ID_PROP = _index2.default.config.getIdPropertyName();
      this._service = Service;
      this._namespace = this._service.getPropertyName();
      this._stateModel = stateModel;
      if (!_lodash2.default.isObject(data)) {
        data = {};
      }
      this.setOriginalData(data);
      _lodash2.default.each(data, function(value, key) {
        var setVar = value;
        setVar = _this.convertToDataCollection(key, setVar);
        _this[key] = setVar;
      }, this);
      this._setSocketListener();
      var that = this;
      this._events = new _eventListener2.default({
        bubble: function bubble(event) {
          that._events.bubble.apply(that._events, arguments);
        },
        hasStatus: function hasStatus(search) {},
        get: function get(prop, ifFound) {
          if (_lodash2.default.has(that, prop) && that[prop]) {
            ifFound(that[prop]);
          }
        },
        set: function set(prop, value) {}
      });
    }
    (0, _createClass3.default)(DataModel, [{
      key: '_on',
      value: function _on(event, callerFn) {
        if (arguments.length == 2) {
          this._events.on(event, callerFn);
        } else {
          this._events.on(event);
        }
      }
    }, {
      key: 'getOriginalData',
      value: function getOriginalData() {
        return this._originalData || {};
      }
    }, {
      key: 'setOriginalData',
      value: function setOriginalData(data) {
        this._originalData = JSON.parse((0, _stringify2.default)(data));
      }
    }, {
      key: 'onBubble',
      value: function onBubble(eventFn) {
        this._events.onBubble(eventFn);
      }
    }, {
      key: 'onCustom',
      value: function onCustom(event, fn) {
        this._events.on(event, fn);
      }
    }, {
      key: 'onStateChange',
      value: function onStateChange(statusFn) {
        this._events.on("state", statusFn);
      }
    }, {
      key: 'onUpdate',
      value: function onUpdate(updateFn) {
        this._events.on("update", updateFn);
      }
    }, {
      key: 'onCreate',
      value: function onCreate(createFn) {
        this._events.on("create", createFn);
      }
    }, {
      key: 'onDelete',
      value: function onDelete(deleteFn) {
        this._events.on("delete", deleteFn);
      }
    }, {
      key: 'updateData',
      value: function updateData(event, data) {
        var _this2 = this;
        if (!_lodash2.default.isObject(data)) {
          return false;
        }
        _lodash2.default.each(data, function(value, key) {
          if (!_lodash2.default.has(_this2, key)) {
            _this2[key] = value;
          } else {
            value = _this2[key];
          }
          _this2[key] = value = _this2.convertToDataCollection(key, value);
          if (_this2._isDataCollection(value) && _lodash2.default.has(data, key)) {
            value.updateData(event, data[key]);
          }
        }, this);
      }
    }, {
      key: '_isDataCollection',
      value: function _isDataCollection(value) {
        return _lodash2.default.isArray(value) && _lodash2.default.has(value, "_inlineCount");
      }
    }, {
      key: 'convertToDataCollection',
      value: function convertToDataCollection(key, value) {
        if (_lodash2.default.isArray(value) && !this._isDataCollection(value)) {
          var childService = this._service.getService(key);
          if (childService) {
            var that = this;
            var instance = new DataCollection();
            instance.init(childService, value, this._stateModel);
            value = instance;
            this._stateModel.setBaseLevel(this._service.getPropertyName() + "#" + this[ID_PROP]);
            value._setParentLinkFunction(function(model) {
              model[that._namespace + "Id"] = that[ID_PROP];
            });
            value.onBubble(function() {
              that._events.triggerBubble.apply(that._events, arguments);
            });
            if (that._service) {
              that._service.configDataCollection(value);
            }
          }
        }
        return value;
      }
    }, {
      key: '_setSocketListener',
      value: function _setSocketListener() {
        if (!this[ID_PROP]) {
          return;
        }
        var that = this;
        this._stateModel.getSocket().on("update:" + this._service.getPropertyName() + "#" + this[ID_PROP], function(struct) {
          if (_lodash2.default.isObject(struct) && !_lodash2.default.isArray(struct)) {
            _lodash2.default.each(struct, function(value, name) {
              that[name] = value;
            });
            that._events.trigger("update", struct);
          }
        });
        this._stateModel.getSocket().on("delete:" + this._service.getPropertyName() + "#" + this[ID_PROP], function() {
          that._events.trigger("delete");
        });
        this._stateModel.getSocket().on("state:" + this._service.getPropertyName() + "#" + this[ID_PROP], function(struct) {
          that.setState(struct.state);
        });
      }
    }, {
      key: 'hasState',
      value: function hasState(checkString) {
        if (!this._states) {
          return false;
        }
        return this._states.indexOf(checkString) !== -1;
      }
    }, {
      key: 'setState',
      value: function setState(changedState) {
        var _this3 = this;
        if (!this._service.states) {
          return false;
        }
        if (!this._states) {
          this._states = [];
        }
        var toSet = [];
        _lodash2.default.each(this._service.states, function(keys, name) {
          if (_lodash2.default.isArray(keys) && keys.indexOf(changedState) !== -1) {
            toSet.push(name);
          }
        }, this);
        if (toSet.length) {
          var removeStates = [];
          _lodash2.default.each(toSet, function(stateCategory) {
            _lodash2.default.each(_this3._states, function(currentState) {
              if (_lodash2.default.startsWith(currentState, stateCategory)) {
                removeStates.push(currentState);
              }
            }, _this3);
          }, this);
          if (removeStates.length) {
            _lodash2.default.each(removeStates, function(name) {
              _this3._states.splice(_this3._states.indexOf(name), 1);
            }, this);
          }
          _lodash2.default.each(toSet, function(setCategory) {
            _this3._states.push(setCategory + ":" + changedState);
            _this3._events.trigger("state", setCategory + ":" + changedState);
          }, this);
        }
      }
    }, {
      key: '_getBaseNamespace',
      value: function _getBaseNamespace() {
        return this._baseNamespace;
      }
    }, {
      key: '_hasBaseNamespace',
      value: function _hasBaseNamespace() {
        return this._baseNamespace ? true : false;
      }
    }, {
      key: '_setBaseNamespace',
      value: function _setBaseNamespace(baseNamespace) {
        this._baseNamespace = baseNamespace;
      }
    }, {
      key: 'setId',
      value: function setId(id) {
        if (typeof id == "string") {
          id = parseInt(id, 10);
        }
        this[ID_PROP] = id;
        this._setSocketListener();
      }
    }, {
      key: 'revert',
      value: function revert() {}
    }, {
      key: 'save',
      value: function save() {
        var that = this;
        return this._service.save(this.export()).then(function(data) {
          if (data[ID_PROP]) {
            that.setId(data[ID_PROP]);
            that._events.trigger("create", (0, _defineProperty3.default)({}, ID_PROP, data[ID_PROP]));
          }
        });
      }
    }, {
      key: 'pushChanges',
      value: function pushChanges(name) {
        var sendStructure = {};
        sendStructure[ID_PROP] = this[ID_PROP];
        sendStructure[name] = this[name];
        return this._service.save(sendStructure);
      }
    }, {
      key: 'delete',
      value: function _delete() {
        if (this[ID_PROP]) {
          return this._service.delete(this[ID_PROP]);
        }
        this._events.trigger("delete");
      }
    }, {
      key: 'getNamespace',
      value: function getNamespace() {
        return this._namespace;
      }
    }, {
      key: 'filter',
      value: function filter() {
        throw new Error("There's no use case to filter items on a DataModel. Did you expect this to be a DataCollection? Check your code, boyo.");
      }
    }, {
      key: 'export',
      value: function _export(data) {
        var _this4 = this;
        var returnObj = {};
        var parseData = this;
        if (data) {
          parseData = data;
        }
        _lodash2.default.each(parseData, function(value, key) {
          if (_lodash2.default.isFunction(value)) {
            return;
          }
          if (key && _lodash2.default.isString(key) && (key.indexOf("_") === 0 || key.indexOf("$$") === 0)) {
            return;
          }
          switch (true) {
            case _this4._isDataCollection(value):
              returnObj[key] = value._export();
              break;
            case value instanceof DataModel:
              returnObj[key] = value.export();
              break;
            case _lodash2.default.isArray(value):
              var returnArray = [];
              _lodash2.default.each(value, function(item) {
                returnArray.push(_this4.export(item));
              }, _this4);
              returnObj[key] = returnArray;
              break;
            default:
              returnObj[key] = value;
          }
        }, this);
        return returnObj;
      }
    }]);
    return DataModel;
  }();
  exports.default = DataModel;
  return module.exports;
});

$__System.registerDynamic("4d", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  exports.__esModule = true;
  exports.default = function(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  return module.exports;
});

$__System.registerDynamic("67", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $Object = Object;
  module.exports = {
    create: $Object.create,
    getProto: $Object.getPrototypeOf,
    isEnum: {}.propertyIsEnumerable,
    getDesc: $Object.getOwnPropertyDescriptor,
    setDesc: $Object.defineProperty,
    setDescs: $Object.defineProperties,
    getKeys: $Object.keys,
    getNames: $Object.getOwnPropertyNames,
    getSymbols: $Object.getOwnPropertySymbols,
    each: [].forEach
  };
  return module.exports;
});

$__System.registerDynamic("d0", ["67"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('67');
  module.exports = function defineProperty(it, key, desc) {
    return $.setDesc(it, key, desc);
  };
  return module.exports;
});

$__System.registerDynamic("33", ["d0"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = {
    "default": $__require('d0'),
    __esModule: true
  };
  return module.exports;
});

$__System.registerDynamic("4e", ["33"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  exports.__esModule = true;
  var _defineProperty = $__require('33');
  var _defineProperty2 = _interopRequireDefault(_defineProperty);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  exports.default = function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        (0, _defineProperty2.default)(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  return module.exports;
});

$__System.registerDynamic("cf", ["4d", "4e", "48"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _classCallCheck2 = $__require('4d');
  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
  var _createClass2 = $__require('4e');
  var _createClass3 = _interopRequireDefault(_createClass2);
  var _lodash = $__require('48');
  var _lodash2 = _interopRequireDefault(_lodash);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var EventListener = function() {
    function EventListener(scope) {
      (0, _classCallCheck3.default)(this, EventListener);
      this.listeners = {_all: []};
      this.scope = scope || {};
    }
    (0, _createClass3.default)(EventListener, [{
      key: 'onBubble',
      value: function onBubble(eventFn) {
        this.on("_bubble", eventFn);
      }
    }, {
      key: 'bubble',
      value: function bubble(event) {
        if (!event) {
          return false;
        }
        var sendArgs = [];
        _lodash2.default.each(arguments, function(value, key) {
          sendArgs.push(value);
        });
        sendArgs.unshift("_bubble");
        this.trigger.apply(this, sendArgs);
      }
    }, {
      key: 'on',
      value: function on(event, callback) {
        if (arguments.length == 2) {
          if (!this.listeners[event]) {
            this.listeners[event] = [];
          }
          this.listeners[event].push(callback);
        } else if (arguments.length == 1 && _lodash2.default.isFunction(event)) {
          this.listeners['_all'].push(event);
        }
      }
    }, {
      key: 'triggerBubble',
      value: function triggerBubble() {
        var sendArgs = [];
        _lodash2.default.each(arguments, function(value, key) {
          sendArgs.push(value);
        });
        sendArgs.unshift("_bubble");
        this.trigger.apply(this, sendArgs);
      }
    }, {
      key: 'trigger',
      value: function trigger(event) {
        var _this = this;
        if (!arguments) {
          return false;
        }
        event = arguments[0];
        var trimCount = 0;
        var isBubbling = false;
        if (event == "_bubble") {
          isBubbling = true;
          trimCount = 1;
          event = arguments[1];
        }
        var sendArgs = [];
        _lodash2.default.each(arguments, function(value, key) {
          if (key > trimCount) {
            sendArgs.push(value);
          }
        });
        if (this.listeners[event]) {
          _lodash2.default.each(this.listeners[event], function(eventFn) {
            if (eventFn.apply(_this.scope, sendArgs) === false) {}
          }, this);
        }
        sendArgs.unshift(event);
        if (this.listeners._all.length) {
          _lodash2.default.each(this.listeners._all, function(eventFn) {
            eventFn.apply(_this.scope, sendArgs);
          }, this);
        }
        if (isBubbling) {
          if (!this.listeners._bubble) {
            return false;
          }
          _lodash2.default.each(this.listeners._bubble, function(event) {
            event.apply(_this.scope, sendArgs);
          }, this);
        }
      }
    }]);
    return EventListener;
  }();
  exports.default = EventListener;
  return module.exports;
});

$__System.registerDynamic("d1", ["@empty"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  "format cjs";
  (function(Buffer, process) {
    ;
    (function() {
      var undefined;
      var VERSION = '4.13.1';
      var LARGE_ARRAY_SIZE = 200;
      var FUNC_ERROR_TEXT = 'Expected a function';
      var HASH_UNDEFINED = '__lodash_hash_undefined__';
      var PLACEHOLDER = '__lodash_placeholder__';
      var BIND_FLAG = 1,
          BIND_KEY_FLAG = 2,
          CURRY_BOUND_FLAG = 4,
          CURRY_FLAG = 8,
          CURRY_RIGHT_FLAG = 16,
          PARTIAL_FLAG = 32,
          PARTIAL_RIGHT_FLAG = 64,
          ARY_FLAG = 128,
          REARG_FLAG = 256,
          FLIP_FLAG = 512;
      var UNORDERED_COMPARE_FLAG = 1,
          PARTIAL_COMPARE_FLAG = 2;
      var DEFAULT_TRUNC_LENGTH = 30,
          DEFAULT_TRUNC_OMISSION = '...';
      var HOT_COUNT = 150,
          HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1,
          LAZY_MAP_FLAG = 2,
          LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0,
          MAX_SAFE_INTEGER = 9007199254740991,
          MAX_INTEGER = 1.7976931348623157e+308,
          NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295,
          MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
          HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var argsTag = '[object Arguments]',
          arrayTag = '[object Array]',
          boolTag = '[object Boolean]',
          dateTag = '[object Date]',
          errorTag = '[object Error]',
          funcTag = '[object Function]',
          genTag = '[object GeneratorFunction]',
          mapTag = '[object Map]',
          numberTag = '[object Number]',
          objectTag = '[object Object]',
          promiseTag = '[object Promise]',
          regexpTag = '[object RegExp]',
          setTag = '[object Set]',
          stringTag = '[object String]',
          symbolTag = '[object Symbol]',
          weakMapTag = '[object WeakMap]',
          weakSetTag = '[object WeakSet]';
      var arrayBufferTag = '[object ArrayBuffer]',
          dataViewTag = '[object DataView]',
          float32Tag = '[object Float32Array]',
          float64Tag = '[object Float64Array]',
          int8Tag = '[object Int8Array]',
          int16Tag = '[object Int16Array]',
          int32Tag = '[object Int32Array]',
          uint8Tag = '[object Uint8Array]',
          uint8ClampedTag = '[object Uint8ClampedArray]',
          uint16Tag = '[object Uint16Array]',
          uint32Tag = '[object Uint32Array]';
      var reEmptyStringLeading = /\b__p \+= '';/g,
          reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
          reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
          reUnescapedHtml = /[&<>"'`]/g,
          reHasEscapedHtml = RegExp(reEscapedHtml.source),
          reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g,
          reEvaluate = /<%([\s\S]+?)%>/g,
          reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
          reIsPlainProp = /^\w*$/,
          rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(\.|\[\])(?:\4|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
          reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrim = /^\s+|\s+$/g,
          reTrimStart = /^\s+/,
          reTrimEnd = /\s+$/;
      var reBasicWord = /[a-zA-Z0-9]+/g;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reHasHexPrefix = /^0x/i;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = '\\ud800-\\udfff',
          rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
          rsComboSymbolsRange = '\\u20d0-\\u20f0',
          rsDingbatRange = '\\u2700-\\u27bf',
          rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
          rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
          rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
          rsPunctuationRange = '\\u2000-\\u206f',
          rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
          rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
          rsVarRange = '\\ufe0e\\ufe0f',
          rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]",
          rsAstral = '[' + rsAstralRange + ']',
          rsBreak = '[' + rsBreakRange + ']',
          rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',
          rsDigits = '\\d+',
          rsDingbat = '[' + rsDingbatRange + ']',
          rsLower = '[' + rsLowerRange + ']',
          rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
          rsFitz = '\\ud83c[\\udffb-\\udfff]',
          rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
          rsNonAstral = '[^' + rsAstralRange + ']',
          rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
          rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
          rsUpper = '[' + rsUpperRange + ']',
          rsZWJ = '\\u200d';
      var rsLowerMisc = '(?:' + rsLower + '|' + rsMisc + ')',
          rsUpperMisc = '(?:' + rsUpper + '|' + rsMisc + ')',
          rsOptLowerContr = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
          rsOptUpperContr = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
          reOptMod = rsModifier + '?',
          rsOptVar = '[' + rsVarRange + ']?',
          rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
          rsSeq = rsOptVar + reOptMod + rsOptJoin,
          rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
          rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
      var reApos = RegExp(rsApos, 'g');
      var reComboMark = RegExp(rsCombo, 'g');
      var reComplexSymbol = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
      var reComplexWord = RegExp([rsUpper + '?' + rsLower + '+' + rsOptLowerContr + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')', rsUpperMisc + '+' + rsOptUpperContr + '(?=' + [rsBreak, rsUpper + rsLowerMisc, '$'].join('|') + ')', rsUpper + '?' + rsLowerMisc + '+' + rsOptLowerContr, rsUpper + '+' + rsOptUpperContr, rsDigits, rsEmoji].join('|'), 'g');
      var reHasComplexSymbol = RegExp('[' + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');
      var reHasComplexWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = ['Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array', 'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object', 'Promise', 'Reflect', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array', 'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap', '_', 'isFinite', 'parseInt', 'setTimeout'];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        '\xc0': 'A',
        '\xc1': 'A',
        '\xc2': 'A',
        '\xc3': 'A',
        '\xc4': 'A',
        '\xc5': 'A',
        '\xe0': 'a',
        '\xe1': 'a',
        '\xe2': 'a',
        '\xe3': 'a',
        '\xe4': 'a',
        '\xe5': 'a',
        '\xc7': 'C',
        '\xe7': 'c',
        '\xd0': 'D',
        '\xf0': 'd',
        '\xc8': 'E',
        '\xc9': 'E',
        '\xca': 'E',
        '\xcb': 'E',
        '\xe8': 'e',
        '\xe9': 'e',
        '\xea': 'e',
        '\xeb': 'e',
        '\xcC': 'I',
        '\xcd': 'I',
        '\xce': 'I',
        '\xcf': 'I',
        '\xeC': 'i',
        '\xed': 'i',
        '\xee': 'i',
        '\xef': 'i',
        '\xd1': 'N',
        '\xf1': 'n',
        '\xd2': 'O',
        '\xd3': 'O',
        '\xd4': 'O',
        '\xd5': 'O',
        '\xd6': 'O',
        '\xd8': 'O',
        '\xf2': 'o',
        '\xf3': 'o',
        '\xf4': 'o',
        '\xf5': 'o',
        '\xf6': 'o',
        '\xf8': 'o',
        '\xd9': 'U',
        '\xda': 'U',
        '\xdb': 'U',
        '\xdc': 'U',
        '\xf9': 'u',
        '\xfa': 'u',
        '\xfb': 'u',
        '\xfc': 'u',
        '\xdd': 'Y',
        '\xfd': 'y',
        '\xff': 'y',
        '\xc6': 'Ae',
        '\xe6': 'ae',
        '\xde': 'Th',
        '\xfe': 'th',
        '\xdf': 'ss'
      };
      var htmlEscapes = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;',
        '`': '&#96;'
      };
      var htmlUnescapes = {
        '&amp;': '&',
        '&lt;': '<',
        '&gt;': '>',
        '&quot;': '"',
        '&#39;': "'",
        '&#96;': '`'
      };
      var stringEscapes = {
        '\\': '\\',
        "'": "'",
        '\n': 'n',
        '\r': 'r',
        '\u2028': 'u2028',
        '\u2029': 'u2029'
      };
      var freeParseFloat = parseFloat,
          freeParseInt = parseInt;
      var freeExports = typeof exports == 'object' && exports;
      var freeModule = freeExports && typeof module == 'object' && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeGlobal = checkGlobal(typeof global == 'object' && global);
      var freeSelf = checkGlobal(typeof self == 'object' && self);
      var thisGlobal = checkGlobal(typeof this == 'object' && this);
      var root = freeGlobal || freeSelf || thisGlobal || Function('return this')();
      function addMapEntry(map, pair) {
        map.set(pair[0], pair[1]);
        return map;
      }
      function addSetEntry(set, value) {
        set.add(value);
        return set;
      }
      function apply(func, thisArg, args) {
        var length = args.length;
        switch (length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1,
            length = array ? array.length : 0;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index = -1,
            length = array ? array.length : 0;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array ? array.length : 0;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index = -1,
            length = array ? array.length : 0;
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index = -1,
            length = array ? array.length : 0,
            resIndex = 0,
            result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array ? array.length : 0;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index = -1,
            length = array ? array.length : 0;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index = -1,
            length = array ? array.length : 0,
            result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index = -1,
            length = values.length,
            offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1,
            length = array ? array.length : 0;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array ? array.length : 0;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index = -1,
            length = array ? array.length : 0;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection) {
          if (predicate(value, key, collection)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length,
            index = fromIndex + (fromRight ? 1 : -1);
        while ((fromRight ? index-- : ++index < length)) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        if (value !== value) {
          return indexOfNaN(array, fromIndex);
        }
        var index = fromIndex - 1,
            length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1,
            length = array.length;
        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseMean(array, iteratee) {
        var length = array ? array.length : 0;
        return length ? (baseSum(array, iteratee) / length) : NAN;
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result,
            index = -1,
            length = array.length;
        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined) {
            result = result === undefined ? current : (result + current);
          }
        }
        return result;
      }
      function baseTimes(n, iteratee) {
        var index = -1,
            result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1,
            length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
        return index;
      }
      function checkGlobal(value) {
        return (value && value.Object === Object) ? value : null;
      }
      function countHolders(array, placeholder) {
        var length = array.length,
            result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            result++;
          }
        }
        return result;
      }
      function deburrLetter(letter) {
        return deburredLetters[letter];
      }
      function escapeHtmlChar(chr) {
        return htmlEscapes[chr];
      }
      function escapeStringChar(chr) {
        return '\\' + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined : object[key];
      }
      function indexOfNaN(array, fromIndex, fromRight) {
        var length = array.length,
            index = fromIndex + (fromRight ? 1 : -1);
        while ((fromRight ? index-- : ++index < length)) {
          var other = array[index];
          if (other !== other) {
            return index;
          }
        }
        return -1;
      }
      function isHostObject(value) {
        var result = false;
        if (value != null && typeof value.toString != 'function') {
          try {
            result = !!(value + '');
          } catch (e) {}
        }
        return result;
      }
      function iteratorToArray(iterator) {
        var data,
            result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map) {
        var index = -1,
            result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function replaceHolders(array, placeholder) {
        var index = -1,
            length = array.length,
            resIndex = 0,
            result = [];
        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set) {
        var index = -1,
            result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set) {
        var index = -1,
            result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      function stringSize(string) {
        if (!(string && reHasComplexSymbol.test(string))) {
          return string.length;
        }
        var result = reComplexSymbol.lastIndex = 0;
        while (reComplexSymbol.test(string)) {
          result++;
        }
        return result;
      }
      function stringToArray(string) {
        return string.match(reComplexSymbol);
      }
      function unescapeHtmlChar(chr) {
        return htmlUnescapes[chr];
      }
      function runInContext(context) {
        context = context ? _.defaults({}, context, _.pick(root, contextProps)) : root;
        var Date = context.Date,
            Error = context.Error,
            Math = context.Math,
            RegExp = context.RegExp,
            TypeError = context.TypeError;
        var arrayProto = context.Array.prototype,
            objectProto = context.Object.prototype,
            stringProto = context.String.prototype;
        var coreJsData = context['__core-js_shared__'];
        var maskSrcKey = (function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
          return uid ? ('Symbol(src)_1.' + uid) : '';
        }());
        var funcToString = context.Function.prototype.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var objectCtorString = funcToString.call(Object);
        var objectToString = objectProto.toString;
        var oldDash = root._;
        var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
        var Buffer = moduleExports ? context.Buffer : undefined,
            Reflect = context.Reflect,
            Symbol = context.Symbol,
            Uint8Array = context.Uint8Array,
            enumerate = Reflect ? Reflect.enumerate : undefined,
            getOwnPropertySymbols = Object.getOwnPropertySymbols,
            iteratorSymbol = typeof(iteratorSymbol = Symbol && Symbol.iterator) == 'symbol' ? iteratorSymbol : undefined,
            objectCreate = Object.create,
            propertyIsEnumerable = objectProto.propertyIsEnumerable,
            splice = arrayProto.splice;
        var setTimeout = function(func, wait) {
          return context.setTimeout.call(root, func, wait);
        };
        var nativeCeil = Math.ceil,
            nativeFloor = Math.floor,
            nativeGetPrototype = Object.getPrototypeOf,
            nativeIsFinite = context.isFinite,
            nativeJoin = arrayProto.join,
            nativeKeys = Object.keys,
            nativeMax = Math.max,
            nativeMin = Math.min,
            nativeParseInt = context.parseInt,
            nativeRandom = Math.random,
            nativeReplace = stringProto.replace,
            nativeReverse = arrayProto.reverse,
            nativeSplit = stringProto.split;
        var DataView = getNative(context, 'DataView'),
            Map = getNative(context, 'Map'),
            Promise = getNative(context, 'Promise'),
            Set = getNative(context, 'Set'),
            WeakMap = getNative(context, 'WeakMap'),
            nativeCreate = getNative(Object, 'create');
        var metaMap = WeakMap && new WeakMap;
        var nonEnumShadows = !propertyIsEnumerable.call({'valueOf': 1}, 'valueOf');
        var realNames = {};
        var dataViewCtorString = toSource(DataView),
            mapCtorString = toSource(Map),
            promiseCtorString = toSource(Promise),
            setCtorString = toSource(Set),
            weakMapCtorString = toSource(WeakMap);
        var symbolProto = Symbol ? Symbol.prototype : undefined,
            symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
            symbolToString = symbolProto ? symbolProto.toString : undefined;
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, '__wrapped__')) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        function baseLodash() {}
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined;
        }
        lodash.templateSettings = {
          'escape': reEscape,
          'evaluate': reEvaluate,
          'interpolate': reInterpolate,
          'variable': '',
          'imports': {'_': lodash}
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result = new LazyWrapper(this.__wrapped__);
          result.__actions__ = copyArray(this.__actions__);
          result.__dir__ = this.__dir__;
          result.__filtered__ = this.__filtered__;
          result.__iteratees__ = copyArray(this.__iteratees__);
          result.__takeCount__ = this.__takeCount__;
          result.__views__ = copyArray(this.__views__);
          return result;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result = new LazyWrapper(this);
            result.__dir__ = -1;
            result.__filtered__ = true;
          } else {
            result = this.clone();
            result.__dir__ *= -1;
          }
          return result;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(),
              dir = this.__dir__,
              isArr = isArray(array),
              isRight = dir < 0,
              arrLength = isArr ? array.length : 0,
              view = getView(0, arrLength, this.__views__),
              start = view.start,
              end = view.end,
              length = end - start,
              index = isRight ? end : (start - 1),
              iteratees = this.__iteratees__,
              iterLength = iteratees.length,
              resIndex = 0,
              takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || arrLength < LARGE_ARRAY_SIZE || (arrLength == length && takeCount == length)) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result = [];
          outer: while (length-- && resIndex < takeCount) {
            index += dir;
            var iterIndex = -1,
                value = array[index];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex],
                  iteratee = data.iteratee,
                  type = data.type,
                  computed = iteratee(value);
              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result[resIndex++] = value;
          }
          return result;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1,
              length = entries ? entries.length : 0;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
        }
        function hashDelete(key) {
          return this.has(key) && delete this.__data__[key];
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result = data[key];
            return result === HASH_UNDEFINED ? undefined : result;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype['delete'] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1,
              length = entries ? entries.length : 0;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
        }
        function listCacheDelete(key) {
          var data = this.__data__,
              index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__,
              index = assocIndexOf(data, key);
          return index < 0 ? undefined : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__,
              index = assocIndexOf(data, key);
          if (index < 0) {
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype['delete'] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1,
              length = entries ? entries.length : 0;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.__data__ = {
            'hash': new Hash,
            'map': new (Map || ListCache),
            'string': new Hash
          };
        }
        function mapCacheDelete(key) {
          return getMapData(this, key)['delete'](key);
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          getMapData(this, key).set(key, value);
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype['delete'] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values) {
          var index = -1,
              length = values ? values.length : 0;
          this.__data__ = new MapCache;
          while (++index < length) {
            this.add(values[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          this.__data__ = new ListCache(entries);
        }
        function stackClear() {
          this.__data__ = new ListCache;
        }
        function stackDelete(key) {
          return this.__data__['delete'](key);
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var cache = this.__data__;
          if (cache instanceof ListCache && cache.__data__.length == LARGE_ARRAY_SIZE) {
            cache = this.__data__ = new MapCache(cache.__data__);
          }
          cache.set(key, value);
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype['delete'] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function assignInDefaults(objValue, srcValue, key, object) {
          if (objValue === undefined || (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
            return srcValue;
          }
          return objValue;
        }
        function assignMergeValue(object, key, value) {
          if ((value !== undefined && !eq(object[key], value)) || (typeof key == 'number' && value === undefined && !(key in object))) {
            object[key] = value;
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || (value === undefined && !(key in object))) {
            object[key] = value;
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee, accumulator) {
          baseEach(collection, function(value, key, collection) {
            setter(accumulator, value, iteratee(value), collection);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAt(object, paths) {
          var index = -1,
              isNil = object == null,
              length = paths.length,
              result = Array(length);
          while (++index < length) {
            result[index] = isNil ? undefined : get(object, paths[index]);
          }
          return result;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
          var result;
          if (customizer) {
            result = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result !== undefined) {
            return result;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result);
            }
          } else {
            var tag = getTag(value),
                isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
              if (isHostObject(value)) {
                return object ? value : {};
              }
              result = initCloneObject(isFunc ? {} : value);
              if (!isDeep) {
                return copySymbols(value, baseAssign(result, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result = initCloneByTag(value, tag, baseClone, isDeep);
            }
          }
          stack || (stack = new Stack);
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result);
          if (!isArr) {
            var props = isFull ? getAllKeys(value) : keys(value);
          }
          arrayEach(props || value, function(subValue, key) {
            if (props) {
              key = subValue;
              subValue = value[key];
            }
            assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
          });
          return result;
        }
        function baseConforms(source) {
          var props = keys(source),
              length = props.length;
          return function(object) {
            if (object == null) {
              return !length;
            }
            var index = length;
            while (index--) {
              var key = props[index],
                  predicate = source[key],
                  value = object[key];
              if ((value === undefined && !(key in Object(object))) || !predicate(value)) {
                return false;
              }
            }
            return true;
          };
        }
        function baseCreate(proto) {
          return isObject(proto) ? objectCreate(proto) : {};
        }
        function baseDelay(func, wait, args) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return setTimeout(function() {
            func.apply(undefined, args);
          }, wait);
        }
        function baseDifference(array, values, iteratee, comparator) {
          var index = -1,
              includes = arrayIncludes,
              isCommon = true,
              length = array.length,
              result = [],
              valuesLength = values.length;
          if (!length) {
            return result;
          }
          if (iteratee) {
            values = arrayMap(values, baseUnary(iteratee));
          }
          if (comparator) {
            includes = arrayIncludesWith;
            isCommon = false;
          } else if (values.length >= LARGE_ARRAY_SIZE) {
            includes = cacheHas;
            isCommon = false;
            values = new SetCache(values);
          }
          outer: while (++index < length) {
            var value = array[index],
                computed = iteratee ? iteratee(value) : value;
            value = (comparator || value !== 0) ? value : 0;
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result.push(value);
            } else if (!includes(values, computed, comparator)) {
              result.push(value);
            }
          }
          return result;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result = true;
          baseEach(collection, function(value, index, collection) {
            result = !!predicate(value, index, collection);
            return result;
          });
          return result;
        }
        function baseExtremum(array, iteratee, comparator) {
          var index = -1,
              length = array.length;
          while (++index < length) {
            var value = array[index],
                current = iteratee(value);
            if (current != null && (computed === undefined ? (current === current && !isSymbol(current)) : comparator(current, computed))) {
              var computed = current,
                  result = value;
            }
          }
          return result;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : (length + start);
          }
          end = (end === undefined || end > length) ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result = [];
          baseEach(collection, function(value, index, collection) {
            if (predicate(value, index, collection)) {
              result.push(value);
            }
          });
          return result;
        }
        function baseFlatten(array, depth, predicate, isStrict, result) {
          var index = -1,
              length = array.length;
          predicate || (predicate = isFlattenable);
          result || (result = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result);
              } else {
                arrayPush(result, value);
              }
            } else if (!isStrict) {
              result[result.length] = value;
            }
          }
          return result;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee) {
          return object && baseFor(object, iteratee, keys);
        }
        function baseForOwnRight(object, iteratee) {
          return object && baseForRight(object, iteratee, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }
        function baseGet(object, path) {
          path = isKey(path, object) ? [path] : castPath(path);
          var index = 0,
              length = path.length;
          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }
          return (index && index == length) ? object : undefined;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result = keysFunc(object);
          return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && (hasOwnProperty.call(object, key) || (typeof object == 'object' && key in object && getPrototype(object) === null));
        }
        function baseHasIn(object, key) {
          return object != null && key in Object(object);
        }
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee, comparator) {
          var includes = comparator ? arrayIncludesWith : arrayIncludes,
              length = arrays[0].length,
              othLength = arrays.length,
              othIndex = othLength,
              caches = Array(othLength),
              maxLength = Infinity,
              result = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee) {
              array = arrayMap(array, baseUnary(iteratee));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120)) ? new SetCache(othIndex && array) : undefined;
          }
          array = arrays[0];
          var index = -1,
              seen = caches[0];
          outer: while (++index < length && result.length < maxLength) {
            var value = array[index],
                computed = iteratee ? iteratee(value) : value;
            value = (comparator || value !== 0) ? value : 0;
            if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed);
              }
              result.push(value);
            }
          }
          return result;
        }
        function baseInverter(object, setter, iteratee, accumulator) {
          baseForOwn(object, function(value, key, object) {
            setter(accumulator, iteratee(value), key, object);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          if (!isKey(path, object)) {
            path = castPath(path);
            object = parent(object, path);
            path = last(path);
          }
          var func = object == null ? object : object[toKey(path)];
          return func == null ? undefined : apply(func, object, args);
        }
        function baseIsEqual(value, other, customizer, bitmask, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
        }
        function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
          var objIsArr = isArray(object),
              othIsArr = isArray(other),
              objTag = arrayTag,
              othTag = arrayTag;
          if (!objIsArr) {
            objTag = getTag(object);
            objTag = objTag == argsTag ? objectTag : objTag;
          }
          if (!othIsArr) {
            othTag = getTag(other);
            othTag = othTag == argsTag ? objectTag : othTag;
          }
          var objIsObj = objTag == objectTag && !isHostObject(object),
              othIsObj = othTag == objectTag && !isHostObject(other),
              isSameTag = objTag == othTag;
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack);
            return (objIsArr || isTypedArray(object)) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
          }
          if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object,
                  othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack);
              return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack);
          return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length,
              length = index,
              noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object(object);
          while (index--) {
            var data = matchData[index];
            if ((noCustomizer && data[2]) ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0],
                objValue = object[key],
                srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack;
              if (customizer) {
                var result = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIteratee(value) {
          if (typeof value == 'function') {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == 'object') {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          return nativeKeys(Object(object));
        }
        function baseKeysIn(object) {
          object = object == null ? object : Object(object);
          var result = [];
          for (var key in object) {
            result.push(key);
          }
          return result;
        }
        if (enumerate && !propertyIsEnumerable.call({'valueOf': 1}, 'valueOf')) {
          baseKeysIn = function(object) {
            return iteratorToArray(enumerate(object));
          };
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee) {
          var index = -1,
              result = isArrayLike(collection) ? Array(collection.length) : [];
          baseEach(collection, function(value, key, collection) {
            result[++index] = iteratee(value, key, collection);
          });
          return result;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return (objValue === undefined && objValue === srcValue) ? hasIn(object, path) : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          if (!(isArray(source) || isTypedArray(source))) {
            var props = keysIn(source);
          }
          arrayEach(props || source, function(srcValue, key) {
            if (props) {
              key = srcValue;
              srcValue = source[key];
            }
            if (isObject(srcValue)) {
              stack || (stack = new Stack);
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(object[key], srcValue, (key + ''), object, source, stack) : undefined;
              if (newValue === undefined) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          });
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = object[key],
              srcValue = source[key],
              stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, (key + ''), object, source, stack) : undefined;
          var isCommon = newValue === undefined;
          if (isCommon) {
            newValue = srcValue;
            if (isArray(srcValue) || isTypedArray(srcValue)) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else {
                isCommon = false;
                newValue = baseClone(srcValue, true);
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {
                isCommon = false;
                newValue = baseClone(srcValue, true);
              } else {
                newValue = objValue;
              }
            } else {
              isCommon = false;
            }
          }
          stack.set(srcValue, newValue);
          if (isCommon) {
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          }
          stack['delete'](srcValue);
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array[n] : undefined;
        }
        function baseOrderBy(collection, iteratees, orders) {
          var index = -1;
          iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));
          var result = baseMap(collection, function(value, key, collection) {
            var criteria = arrayMap(iteratees, function(iteratee) {
              return iteratee(value);
            });
            return {
              'criteria': criteria,
              'index': ++index,
              'value': value
            };
          });
          return baseSortBy(result, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, props) {
          object = Object(object);
          return arrayReduce(props, function(result, key) {
            if (key in object) {
              result[key] = object[key];
            }
            return result;
          }, {});
        }
        function basePickBy(object, predicate) {
          var index = -1,
              props = getAllKeysIn(object),
              length = props.length,
              result = {};
          while (++index < length) {
            var key = props[index],
                value = object[key];
            if (predicate(value, key)) {
              result[key] = value;
            }
          }
          return result;
        }
        function baseProperty(key) {
          return function(object) {
            return object == null ? undefined : object[key];
          };
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values, iteratee, comparator) {
          var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
              index = -1,
              length = values.length,
              seen = array;
          if (array === values) {
            values = copyArray(values);
          }
          if (iteratee) {
            seen = arrayMap(array, baseUnary(iteratee));
          }
          while (++index < length) {
            var fromIndex = 0,
                value = values[index],
                computed = iteratee ? iteratee(value) : value;
            while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0,
              lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else if (!isKey(index, array)) {
                var path = castPath(index),
                    object = parent(array, path);
                if (object != null) {
                  delete object[toKey(last(path))];
                }
              } else {
                delete array[toKey(index)];
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index = -1,
              length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
              result = Array(length);
          while (length--) {
            result[fromRight ? length : ++index] = start;
            start += step;
          }
          return result;
        }
        function baseRepeat(string, n) {
          var result = '';
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result;
          }
          do {
            if (n % 2) {
              result += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);
          return result;
        }
        function baseSet(object, path, value, customizer) {
          path = isKey(path, object) ? [path] : castPath(path);
          var index = -1,
              length = path.length,
              lastIndex = length - 1,
              nested = object;
          while (nested != null && ++index < length) {
            var key = toKey(path[index]);
            if (isObject(nested)) {
              var newValue = value;
              if (index != lastIndex) {
                var objValue = nested[key];
                newValue = customizer ? customizer(objValue, key, nested) : undefined;
                if (newValue === undefined) {
                  newValue = objValue == null ? (isIndex(path[index + 1]) ? [] : {}) : objValue;
                }
              }
              assignValue(nested, key, newValue);
            }
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        function baseSlice(array, start, end) {
          var index = -1,
              length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : (length + start);
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : ((end - start) >>> 0);
          start >>>= 0;
          var result = Array(length);
          while (++index < length) {
            result[index] = array[index + start];
          }
          return result;
        }
        function baseSome(collection, predicate) {
          var result;
          baseEach(collection, function(value, index, collection) {
            result = predicate(value, index, collection);
            return !result;
          });
          return !!result;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0,
              high = array ? array.length : low;
          if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = (low + high) >>> 1,
                  computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? (computed <= value) : (computed < value))) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee, retHighest) {
          value = iteratee(value);
          var low = 0,
              high = array ? array.length : 0,
              valIsNaN = value !== value,
              valIsNull = value === null,
              valIsSymbol = isSymbol(value),
              valIsUndefined = value === undefined;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2),
                computed = iteratee(array[mid]),
                othIsDefined = computed !== undefined,
                othIsNull = computed === null,
                othIsReflexive = computed === computed,
                othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? (computed <= value) : (computed < value);
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee) {
          var index = -1,
              length = array.length,
              resIndex = 0,
              result = [];
          while (++index < length) {
            var value = array[index],
                computed = iteratee ? iteratee(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result;
        }
        function baseToNumber(value) {
          if (typeof value == 'number') {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == 'string') {
            return value;
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : '';
          }
          var result = (value + '');
          return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
        }
        function baseUniq(array, iteratee, comparator) {
          var index = -1,
              includes = arrayIncludes,
              length = array.length,
              isCommon = true,
              result = [],
              seen = result;
          if (comparator) {
            isCommon = false;
            includes = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set = iteratee ? null : createSet(array);
            if (set) {
              return setToArray(set);
            }
            isCommon = false;
            includes = cacheHas;
            seen = new SetCache;
          } else {
            seen = iteratee ? [] : result;
          }
          outer: while (++index < length) {
            var value = array[index],
                computed = iteratee ? iteratee(value) : value;
            value = (comparator || value !== 0) ? value : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee) {
                seen.push(computed);
              }
              result.push(value);
            } else if (!includes(seen, computed, comparator)) {
              if (seen !== result) {
                seen.push(computed);
              }
              result.push(value);
            }
          }
          return result;
        }
        function baseUnset(object, path) {
          path = isKey(path, object) ? [path] : castPath(path);
          object = parent(object, path);
          var key = toKey(last(path));
          return !(object != null && baseHas(object, key)) || delete object[key];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length,
              index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}
          return isDrop ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length)) : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
        }
        function baseWrapperValue(value, actions) {
          var result = value;
          if (result instanceof LazyWrapper) {
            result = result.value();
          }
          return arrayReduce(actions, function(result, action) {
            return action.func.apply(action.thisArg, arrayPush([result], action.args));
          }, result);
        }
        function baseXor(arrays, iteratee, comparator) {
          var index = -1,
              length = arrays.length;
          while (++index < length) {
            var result = result ? arrayPush(baseDifference(result, arrays[index], iteratee, comparator), baseDifference(arrays[index], result, iteratee, comparator)) : arrays[index];
          }
          return (result && result.length) ? baseUniq(result, iteratee, comparator) : [];
        }
        function baseZipObject(props, values, assignFunc) {
          var index = -1,
              length = props.length,
              valsLength = values.length,
              result = {};
          while (++index < length) {
            var value = index < valsLength ? values[index] : undefined;
            assignFunc(result, props[index], value);
          }
          return result;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == 'function' ? value : identity;
        }
        function castPath(value) {
          return isArray(value) ? value : stringToPath(value);
        }
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined ? length : end;
          return (!start && end >= length) ? array : baseSlice(array, start, end);
        }
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var result = new buffer.constructor(buffer.length);
          buffer.copy(result);
          return result;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array(result).set(new Uint8Array(arrayBuffer));
          return result;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneMap(map, isDeep, cloneFunc) {
          var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
          return arrayReduce(array, addMapEntry, new map.constructor);
        }
        function cloneRegExp(regexp) {
          var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result.lastIndex = regexp.lastIndex;
          return result;
        }
        function cloneSet(set, isDeep, cloneFunc) {
          var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
          return arrayReduce(array, addSetEntry, new set.constructor);
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined,
                valIsNull = value === null,
                valIsReflexive = value === value,
                valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined,
                othIsNull = other === null,
                othIsReflexive = other === other,
                othIsSymbol = isSymbol(other);
            if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) || (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) || (valIsNull && othIsDefined && othIsReflexive) || (!valIsDefined && othIsReflexive) || !valIsReflexive) {
              return 1;
            }
            if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) || (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) || (othIsNull && valIsDefined && valIsReflexive) || (!othIsDefined && valIsReflexive) || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index = -1,
              objCriteria = object.criteria,
              othCriteria = other.criteria,
              length = objCriteria.length,
              ordersLength = orders.length;
          while (++index < length) {
            var result = compareAscending(objCriteria[index], othCriteria[index]);
            if (result) {
              if (index >= ordersLength) {
                return result;
              }
              var order = orders[index];
              return result * (order == 'desc' ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1,
              argsLength = args.length,
              holdersLength = holders.length,
              leftIndex = -1,
              leftLength = partials.length,
              rangeLength = nativeMax(argsLength - holdersLength, 0),
              result = Array(leftLength + rangeLength),
              isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result[leftIndex++] = args[argsIndex++];
          }
          return result;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1,
              argsLength = args.length,
              holdersIndex = -1,
              holdersLength = holders.length,
              rightIndex = -1,
              rightLength = partials.length,
              rangeLength = nativeMax(argsLength - holdersLength, 0),
              result = Array(rangeLength + rightLength),
              isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result;
        }
        function copyArray(source, array) {
          var index = -1,
              length = source.length;
          array || (array = Array(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          object || (object = {});
          var index = -1,
              length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : source[key];
            assignValue(object, key, newValue);
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator,
                accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee), accumulator);
          };
        }
        function createAssigner(assigner) {
          return rest(function(object, sources) {
            var index = -1,
                length = sources.length,
                customizer = length > 1 ? sources[length - 1] : undefined,
                guard = length > 2 ? sources[2] : undefined;
            customizer = (assigner.length > 3 && typeof customizer == 'function') ? (length--, customizer) : undefined;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined : customizer;
              length = 1;
            }
            object = Object(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee);
            }
            var length = collection.length,
                index = fromRight ? length : -1,
                iterable = Object(collection);
            while ((fromRight ? index-- : ++index < length)) {
              if (iteratee(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee, keysFunc) {
            var index = -1,
                iterable = Object(object),
                props = keysFunc(object),
                length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBaseWrapper(func, bitmask, thisArg) {
          var isBind = bitmask & BIND_FLAG,
              Ctor = createCtorWrapper(func);
          function wrapper() {
            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
            var strSymbols = reHasComplexSymbol.test(string) ? stringToArray(string) : undefined;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join('') : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
          };
        }
        function createCtorWrapper(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor;
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype),
                result = Ctor.apply(thisBinding, args);
            return isObject(result) ? result : thisBinding;
          };
        }
        function createCurryWrapper(func, bitmask, arity) {
          var Ctor = createCtorWrapper(func);
          function wrapper() {
            var length = arguments.length,
                args = Array(length),
                index = length,
                placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder) ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurryWrapper(func, bitmask, createHybridWrapper, wrapper.placeholder, undefined, args, holders, undefined, undefined, arity - length);
            }
            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object(collection);
            predicate = getIteratee(predicate, 3);
            if (!isArrayLike(collection)) {
              var props = keys(collection);
            }
            var index = findIndexFunc(props || collection, function(value, key) {
              if (props) {
                key = value;
                value = iterable[key];
              }
              return predicate(value, key, iterable);
            }, fromIndex);
            return index > -1 ? collection[props ? props[index] : index] : undefined;
          };
        }
        function createFlow(fromRight) {
          return rest(function(funcs) {
            funcs = baseFlatten(funcs, 1);
            var length = funcs.length,
                index = length,
                prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func),
                  data = funcName == 'wrapper' ? getData(func) : undefined;
              if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments,
                  value = args[0];
              if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
                return wrapper.plant(value).value();
              }
              var index = 0,
                  result = length ? funcs[index].apply(this, args) : value;
              while (++index < length) {
                result = funcs[index].call(this, result);
              }
              return result;
            };
          });
        }
        function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
          var isAry = bitmask & ARY_FLAG,
              isBind = bitmask & BIND_FLAG,
              isBindKey = bitmask & BIND_KEY_FLAG,
              isCurried = bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG),
              isFlip = bitmask & FLIP_FLAG,
              Ctor = isBindKey ? undefined : createCtorWrapper(func);
          function wrapper() {
            var length = arguments.length,
                args = Array(length),
                index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper),
                  holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurryWrapper(func, bitmask, createHybridWrapper, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length);
            }
            var thisBinding = isBind ? thisArg : this,
                fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary < length) {
              args.length = ary;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtorWrapper(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee) {
            return baseInverter(object, setter, toIteratee(iteratee), {});
          };
        }
        function createMathOperation(operator) {
          return function(value, other) {
            var result;
            if (value === undefined && other === undefined) {
              return 0;
            }
            if (value !== undefined) {
              result = value;
            }
            if (other !== undefined) {
              if (result === undefined) {
                return other;
              }
              if (typeof value == 'string' || typeof other == 'string') {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result = operator(value, other);
            }
            return result;
          };
        }
        function createOver(arrayFunc) {
          return rest(function(iteratees) {
            iteratees = (iteratees.length == 1 && isArray(iteratees[0])) ? arrayMap(iteratees[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(iteratees, 1, isFlattenableIteratee), baseUnary(getIteratee()));
            return rest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee) {
                return apply(iteratee, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined ? ' ' : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return reHasComplexSymbol.test(chars) ? castSlice(stringToArray(result), 0, length).join('') : result.slice(0, length);
        }
        function createPartialWrapper(func, bitmask, thisArg, partials) {
          var isBind = bitmask & BIND_FLAG,
              Ctor = createCtorWrapper(func);
          function wrapper() {
            var argsIndex = -1,
                argsLength = arguments.length,
                leftIndex = -1,
                leftLength = partials.length,
                args = Array(leftLength + argsLength),
                fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
              end = step = undefined;
            }
            start = toNumber(start);
            start = start === start ? start : 0;
            if (end === undefined) {
              end = start;
              start = 0;
            } else {
              end = toNumber(end) || 0;
            }
            step = step === undefined ? (start < end ? 1 : -1) : (toNumber(step) || 0);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == 'string' && typeof other == 'string')) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurryWrapper(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
          var isCurry = bitmask & CURRY_FLAG,
              newHolders = isCurry ? holders : undefined,
              newHoldersRight = isCurry ? undefined : holders,
              newPartials = isCurry ? partials : undefined,
              newPartialsRight = isCurry ? undefined : partials;
          bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
          bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);
          if (!(bitmask & CURRY_BOUND_FLAG)) {
            bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
          }
          var newData = [func, bitmask, thisArg, newPartials, newHolders, newPartialsRight, newHoldersRight, argPos, ary, arity];
          var result = wrapFunc.apply(undefined, newData);
          if (isLaziable(func)) {
            setData(result, newData);
          }
          result.placeholder = placeholder;
          return result;
        }
        function createRound(methodName) {
          var func = Math[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = nativeMin(toInteger(precision), 292);
            if (precision) {
              var pair = (toString(number) + 'e').split('e'),
                  value = func(pair[0] + 'e' + (+pair[1] + precision));
              pair = (toString(value) + 'e').split('e');
              return +(pair[0] + 'e' + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set && (1 / setToArray(new Set([, -0]))[1]) == INFINITY) ? noop : function(values) {
          return new Set(values);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
          var isBindKey = bitmask & BIND_KEY_FLAG;
          if (!isBindKey && typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
            partials = holders = undefined;
          }
          ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
          arity = arity === undefined ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials,
                holdersRight = holders;
            partials = holders = undefined;
          }
          var data = isBindKey ? undefined : getData(func);
          var newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] == null ? (isBindKey ? 0 : func.length) : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG)) {
            bitmask &= ~(CURRY_FLAG | CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == BIND_FLAG) {
            var result = createBaseWrapper(func, bitmask, thisArg);
          } else if (bitmask == CURRY_FLAG || bitmask == CURRY_RIGHT_FLAG) {
            result = createCurryWrapper(func, bitmask, arity);
          } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !holders.length) {
            result = createPartialWrapper(func, bitmask, thisArg, partials);
          } else {
            result = createHybridWrapper.apply(undefined, newData);
          }
          var setter = data ? baseSetData : setData;
          return setter(result, newData);
        }
        function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
              arrLength = array.length,
              othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var stacked = stack.get(array);
          if (stacked) {
            return stacked == other;
          }
          var index = -1,
              result = true,
              seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;
          stack.set(array, other);
          while (++index < arrLength) {
            var arrValue = array[index],
                othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined) {
              if (compared) {
                continue;
              }
              result = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue, othIndex) {
                if (!seen.has(othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
                  return seen.add(othIndex);
                }
              })) {
                result = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
              result = false;
              break;
            }
          }
          stack['delete'](array);
          return result;
        }
        function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
          switch (tag) {
            case dataViewTag:
              if ((object.byteLength != other.byteLength) || (object.byteOffset != other.byteOffset)) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if ((object.byteLength != other.byteLength) || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
              return +object == +other;
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case numberTag:
              return (object != +object) ? other != +other : object == +other;
            case regexpTag:
            case stringTag:
              return object == (other + '');
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= UNORDERED_COMPARE_FLAG;
              stack.set(object, other);
              return equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
              objProps = keys(object),
              objLength = objProps.length,
              othProps = keys(other),
              othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : baseHas(other, key))) {
              return false;
            }
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          var result = true;
          stack.set(object, other);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key],
                othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack)) : compared)) {
              result = false;
              break;
            }
            skipCtor || (skipCtor = key == 'constructor');
          }
          if (result && !skipCtor) {
            var objCtor = object.constructor,
                othCtor = other.constructor;
            if (objCtor != othCtor && ('constructor' in object && 'constructor' in other) && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
              result = false;
            }
          }
          stack['delete'](object);
          return result;
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result = (func.name + ''),
              array = realNames[result],
              length = hasOwnProperty.call(realNames, result) ? array.length : 0;
          while (length--) {
            var data = array[length],
                otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result;
        }
        function getHolder(func) {
          var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result = lodash.iteratee || iteratee;
          result = result === iteratee ? baseIteratee : result;
          return arguments.length ? result(arguments[0], arguments[1]) : result;
        }
        var getLength = baseProperty('length');
        function getMapData(map, key) {
          var data = map.__data__;
          return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
        }
        function getMatchData(object) {
          var result = keys(object),
              length = result.length;
          while (length--) {
            var key = result[length],
                value = object[key];
            result[length] = [key, value, isStrictComparable(value)];
          }
          return result;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined;
        }
        function getPrototype(value) {
          return nativeGetPrototype(Object(value));
        }
        function getSymbols(object) {
          return getOwnPropertySymbols(Object(object));
        }
        if (!getOwnPropertySymbols) {
          getSymbols = stubArray;
        }
        var getSymbolsIn = !getOwnPropertySymbols ? getSymbols : function(object) {
          var result = [];
          while (object) {
            arrayPush(result, getSymbols(object));
            object = getPrototype(object);
          }
          return result;
        };
        function getTag(value) {
          return objectToString.call(value);
        }
        if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) || (Map && getTag(new Map) != mapTag) || (Promise && getTag(Promise.resolve()) != promiseTag) || (Set && getTag(new Set) != setTag) || (WeakMap && getTag(new WeakMap) != weakMapTag)) {
          getTag = function(value) {
            var result = objectToString.call(value),
                Ctor = result == objectTag ? value.constructor : undefined,
                ctorString = Ctor ? toSource(Ctor) : undefined;
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result;
          };
        }
        function getView(start, end, transforms) {
          var index = -1,
              length = transforms.length;
          while (++index < length) {
            var data = transforms[index],
                size = data.size;
            switch (data.type) {
              case 'drop':
                start += size;
                break;
              case 'dropRight':
                end -= size;
                break;
              case 'take':
                end = nativeMin(end, start + size);
                break;
              case 'takeRight':
                start = nativeMax(start, end - size);
                break;
            }
          }
          return {
            'start': start,
            'end': end
          };
        }
        function hasPath(object, path, hasFunc) {
          path = isKey(path, object) ? [path] : castPath(path);
          var result,
              index = -1,
              length = path.length;
          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result) {
            return result;
          }
          var length = object ? object.length : 0;
          return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isString(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length,
              result = array.constructor(length);
          if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
            result.index = array.index;
            result.input = array.input;
          }
          return result;
        }
        function initCloneObject(object) {
          return (typeof object.constructor == 'function' && !isPrototype(object)) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, cloneFunc, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return cloneMap(object, isDeep, cloneFunc);
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return cloneSet(object, isDeep, cloneFunc);
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function indexKeys(object) {
          var length = object ? object.length : undefined;
          if (isLength(length) && (isArray(object) || isString(object) || isArguments(object))) {
            return baseTimes(length, String);
          }
          return null;
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments(value);
        }
        function isFlattenableIteratee(value) {
          return isArray(value) && !(value.length == 2 && !isFunction(value[0]));
        }
        function isIndex(value, length) {
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (typeof value == 'number' || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == 'number' ? (isArrayLike(object) && isIndex(index, object.length)) : (type == 'string' && index in object)) {
            return eq(object[index], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || (object != null && value in Object(object));
        }
        function isKeyable(value) {
          var type = typeof value;
          return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean') ? (value !== '__proto__') : (value === null);
        }
        function isLaziable(func) {
          var funcName = getFuncName(func),
              other = lodash[funcName];
          if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && (maskSrcKey in func);
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor,
              proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined || (key in Object(object)));
          };
        }
        function mergeData(data, source) {
          var bitmask = data[1],
              srcBitmask = source[1],
              newBitmask = bitmask | srcBitmask,
              isCommon = newBitmask < (BIND_FLAG | BIND_KEY_FLAG | ARY_FLAG);
          var isCombo = ((srcBitmask == ARY_FLAG) && (bitmask == CURRY_FLAG)) || ((srcBitmask == ARY_FLAG) && (bitmask == REARG_FLAG) && (data[7].length <= source[8])) || ((srcBitmask == (ARY_FLAG | REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == CURRY_FLAG));
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & BIND_FLAG ? 0 : CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function mergeDefaults(objValue, srcValue, key, object, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            baseMerge(objValue, srcValue, undefined, mergeDefaults, stack.set(srcValue, objValue));
          }
          return objValue;
        }
        function parent(object, path) {
          return path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length,
              length = nativeMin(indexes.length, arrLength),
              oldArray = copyArray(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
          }
          return array;
        }
        var setData = (function() {
          var count = 0,
              lastCalled = 0;
          return function(key, value) {
            var stamp = now(),
                remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return key;
              }
            } else {
              count = 0;
            }
            return baseSetData(key, value);
          };
        }());
        var stringToPath = memoize(function(string) {
          var result = [];
          toString(string).replace(rePropName, function(match, number, quote, string) {
            result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
          });
          return result;
        });
        function toKey(value) {
          if (typeof value == 'string' || isSymbol(value)) {
            return value;
          }
          var result = (value + '');
          return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {}
            try {
              return (func + '');
            } catch (e) {}
          }
          return '';
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result.__actions__ = copyArray(wrapper.__actions__);
          result.__index__ = wrapper.__index__;
          result.__values__ = wrapper.__values__;
          return result;
        }
        function chunk(array, size, guard) {
          if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
            size = 1;
          } else {
            size = nativeMax(toInteger(size), 0);
          }
          var length = array ? array.length : 0;
          if (!length || size < 1) {
            return [];
          }
          var index = 0,
              resIndex = 0,
              result = Array(nativeCeil(length / size));
          while (index < length) {
            result[resIndex++] = baseSlice(array, index, (index += size));
          }
          return result;
        }
        function compact(array) {
          var index = -1,
              length = array ? array.length : 0,
              resIndex = 0,
              result = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result[resIndex++] = value;
            }
          }
          return result;
        }
        function concat() {
          var length = arguments.length,
              args = Array(length ? length - 1 : 0),
              array = arguments[0],
              index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return length ? arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1)) : [];
        }
        var difference = rest(function(array, values) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = rest(function(array, values) {
          var iteratee = last(values);
          if (isArrayLikeObject(iteratee)) {
            iteratee = undefined;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee)) : [];
        });
        var differenceWith = rest(function(array, values) {
          var comparator = last(values);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator) : [];
        });
        function drop(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          n = (guard || n === undefined) ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function dropRight(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          n = (guard || n === undefined) ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate) {
          return (array && array.length) ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return (array && array.length) ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length = array ? array.length : 0;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array ? array.length : 0;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        function flatten(array) {
          var length = array ? array.length : 0;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array ? array.length : 0;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          depth = depth === undefined ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index = -1,
              length = pairs ? pairs.length : 0,
              result = {};
          while (++index < length) {
            var pair = pairs[index];
            result[pair[0]] = pair[1];
          }
          return result;
        }
        function head(array) {
          return (array && array.length) ? array[0] : undefined;
        }
        function indexOf(array, value, fromIndex) {
          var length = array ? array.length : 0;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }
        function initial(array) {
          return dropRight(array, 1);
        }
        var intersection = rest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return (mapped.length && mapped[0] === arrays[0]) ? baseIntersection(mapped) : [];
        });
        var intersectionBy = rest(function(arrays) {
          var iteratee = last(arrays),
              mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee === last(mapped)) {
            iteratee = undefined;
          } else {
            mapped.pop();
          }
          return (mapped.length && mapped[0] === arrays[0]) ? baseIntersection(mapped, getIteratee(iteratee)) : [];
        });
        var intersectionWith = rest(function(arrays) {
          var comparator = last(arrays),
              mapped = arrayMap(arrays, castArrayLikeObject);
          if (comparator === last(mapped)) {
            comparator = undefined;
          } else {
            mapped.pop();
          }
          return (mapped.length && mapped[0] === arrays[0]) ? baseIntersection(mapped, undefined, comparator) : [];
        });
        function join(array, separator) {
          return array ? nativeJoin.call(array, separator) : '';
        }
        function last(array) {
          var length = array ? array.length : 0;
          return length ? array[length - 1] : undefined;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array ? array.length : 0;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined) {
            index = toInteger(fromIndex);
            index = (index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1)) + 1;
          }
          if (value !== value) {
            return indexOfNaN(array, index - 1, true);
          }
          while (index--) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }
        function nth(array, n) {
          return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
        }
        var pull = rest(pullAll);
        function pullAll(array, values) {
          return (array && array.length && values && values.length) ? basePullAll(array, values) : array;
        }
        function pullAllBy(array, values, iteratee) {
          return (array && array.length && values && values.length) ? basePullAll(array, values, getIteratee(iteratee)) : array;
        }
        function pullAllWith(array, values, comparator) {
          return (array && array.length && values && values.length) ? basePullAll(array, values, undefined, comparator) : array;
        }
        var pullAt = rest(function(array, indexes) {
          indexes = baseFlatten(indexes, 1);
          var length = array ? array.length : 0,
              result = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));
          return result;
        });
        function remove(array, predicate) {
          var result = [];
          if (!(array && array.length)) {
            return result;
          }
          var index = -1,
              indexes = [],
              length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result;
        }
        function reverse(array) {
          return array ? nativeReverse.call(array) : array;
        }
        function slice(array, start, end) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee));
        }
        function sortedIndexOf(array, value) {
          var length = array ? array.length : 0;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array ? array.length : 0;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return (array && array.length) ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee) {
          return (array && array.length) ? baseSortedUniq(array, getIteratee(iteratee)) : [];
        }
        function tail(array) {
          return drop(array, 1);
        }
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = (guard || n === undefined) ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          n = (guard || n === undefined) ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function takeRightWhile(array, predicate) {
          return (array && array.length) ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return (array && array.length) ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = rest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = rest(function(arrays) {
          var iteratee = last(arrays);
          if (isArrayLikeObject(iteratee)) {
            iteratee = undefined;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee));
        });
        var unionWith = rest(function(arrays) {
          var comparator = last(arrays);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
        });
        function uniq(array) {
          return (array && array.length) ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee) {
          return (array && array.length) ? baseUniq(array, getIteratee(iteratee)) : [];
        }
        function uniqWith(array, comparator) {
          return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        function unzipWith(array, iteratee) {
          if (!(array && array.length)) {
            return [];
          }
          var result = unzip(array);
          if (iteratee == null) {
            return result;
          }
          return arrayMap(result, function(group) {
            return apply(iteratee, undefined, group);
          });
        }
        var without = rest(function(array, values) {
          return isArrayLikeObject(array) ? baseDifference(array, values) : [];
        });
        var xor = rest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = rest(function(arrays) {
          var iteratee = last(arrays);
          if (isArrayLikeObject(iteratee)) {
            iteratee = undefined;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee));
        });
        var xorWith = rest(function(arrays) {
          var comparator = last(arrays);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
        });
        var zip = rest(unzip);
        function zipObject(props, values) {
          return baseZipObject(props || [], values || [], assignValue);
        }
        function zipObjectDeep(props, values) {
          return baseZipObject(props || [], values || [], baseSet);
        }
        var zipWith = rest(function(arrays) {
          var length = arrays.length,
              iteratee = length > 1 ? arrays[length - 1] : undefined;
          iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
          return unzipWith(arrays, iteratee);
        });
        function chain(value) {
          var result = lodash(value);
          result.__chain__ = true;
          return result;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = rest(function(paths) {
          paths = baseFlatten(paths, 1);
          var length = paths.length,
              start = length ? paths[0] : 0,
              value = this.__wrapped__,
              interceptor = function(object) {
                return baseAt(object, paths);
              };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            'func': thru,
            'args': [interceptor],
            'thisArg': undefined
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length,
              value = done ? undefined : this.__values__[this.__index__++];
          return {
            'done': done,
            'value': value
          };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result,
              parent = this;
          while (parent instanceof baseLodash) {
            var clone = wrapperClone(parent);
            clone.__index__ = 0;
            clone.__values__ = undefined;
            if (result) {
              previous.__wrapped__ = clone;
            } else {
              result = clone;
            }
            var previous = clone;
            parent = parent.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              'func': thru,
              'args': [reverse],
              'thisArg': undefined
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result, value, key) {
          hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
        });
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee) {
          return baseFlatten(map(collection, iteratee), 1);
        }
        function flatMapDeep(collection, iteratee) {
          return baseFlatten(map(collection, iteratee), INFINITY);
        }
        function flatMapDepth(collection, iteratee, depth) {
          depth = depth === undefined ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee), depth);
        }
        function forEach(collection, iteratee) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee, 3));
        }
        function forEachRight(collection, iteratee) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee, 3));
        }
        var groupBy = createAggregator(function(result, value, key) {
          if (hasOwnProperty.call(result, key)) {
            result[key].push(value);
          } else {
            result[key] = [value];
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection) ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1) : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
        }
        var invokeMap = rest(function(collection, path, args) {
          var index = -1,
              isFunc = typeof path == 'function',
              isProp = isKey(path),
              result = isArrayLike(collection) ? Array(collection.length) : [];
          baseEach(collection, function(value) {
            var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);
            result[++index] = func ? apply(func, value, args) : baseInvoke(value, path, args);
          });
          return result;
        });
        var keyBy = createAggregator(function(result, value, key) {
          result[key] = value;
        });
        function map(collection, iteratee) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result, value, key) {
          result[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce,
              initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce,
              initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          predicate = getIteratee(predicate, 3);
          return func(collection, function(value, index, collection) {
            return !predicate(value, index, collection);
          });
        }
        function sample(collection) {
          var array = isArrayLike(collection) ? collection : values(collection),
              length = array.length;
          return length > 0 ? array[baseRandom(0, length - 1)] : undefined;
        }
        function sampleSize(collection, n, guard) {
          var index = -1,
              result = toArray(collection),
              length = result.length,
              lastIndex = length - 1;
          if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
            n = 1;
          } else {
            n = baseClamp(toInteger(n), 0, length);
          }
          while (++index < n) {
            var rand = baseRandom(index, lastIndex),
                value = result[rand];
            result[rand] = result[index];
            result[index] = value;
          }
          result.length = n;
          return result;
        }
        function shuffle(collection) {
          return sampleSize(collection, MAX_ARRAY_LENGTH);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            var result = collection.length;
            return (result && isString(collection)) ? stringSize(collection) : result;
          }
          if (isObjectLike(collection)) {
            var tag = getTag(collection);
            if (tag == mapTag || tag == setTag) {
              return collection.size;
            }
          }
          return keys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = rest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          iteratees = (iteratees.length == 1 && isArray(iteratees[0])) ? iteratees[0] : baseFlatten(iteratees, 1, isFlattenableIteratee);
          return baseOrderBy(collection, iteratees, []);
        });
        function now() {
          return Date.now();
        }
        function after(n, func) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined : n;
          n = (func && n == null) ? func.length : n;
          return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
        }
        function before(n, func) {
          var result;
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined;
            }
            return result;
          };
        }
        var bind = rest(function(func, thisArg, partials) {
          var bitmask = BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= PARTIAL_FLAG;
          }
          return createWrapper(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = rest(function(object, key, partials) {
          var bitmask = BIND_FLAG | BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= PARTIAL_FLAG;
          }
          return createWrapper(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined : arity;
          var result = createWrapper(func, CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
          result.placeholder = curry.placeholder;
          return result;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined : arity;
          var result = createWrapper(func, CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
          result.placeholder = curryRight.placeholder;
          return result;
        }
        function debounce(func, wait, options) {
          var lastArgs,
              lastThis,
              maxWait,
              result,
              timerId,
              lastCallTime,
              lastInvokeTime = 0,
              leading = false,
              maxing = false,
              trailing = true;
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxing = 'maxWait' in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs,
                thisArg = lastThis;
            lastArgs = lastThis = undefined;
            lastInvokeTime = time;
            result = func.apply(thisArg, args);
            return result;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout(timerExpired, wait);
            return leading ? invokeFunc(time) : result;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime,
                timeSinceLastInvoke = time - lastInvokeTime,
                result = wait - timeSinceLastCall;
            return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime,
                timeSinceLastInvoke = time - lastInvokeTime;
            return (lastCallTime === undefined || (timeSinceLastCall >= wait) || (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined;
            return result;
          }
          function cancel() {
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined;
          }
          function flush() {
            return timerId === undefined ? result : trailingEdge(now());
          }
          function debounced() {
            var time = now(),
                isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                timerId = setTimeout(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined) {
              timerId = setTimeout(timerExpired, wait);
            }
            return result;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = rest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = rest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrapper(func, FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments,
                key = resolver ? resolver.apply(this, args) : args[0],
                cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result = func.apply(this, args);
            memoized.cache = cache.set(key, result);
            return result;
          };
          memoized.cache = new (memoize.Cache || MapCache);
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return function() {
            return !predicate.apply(this, arguments);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = rest(function(func, transforms) {
          transforms = (transforms.length == 1 && isArray(transforms[0])) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1, isFlattenableIteratee), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return rest(function(args) {
            var index = -1,
                length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial = rest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrapper(func, PARTIAL_FLAG, undefined, partials, holders);
        });
        var partialRight = rest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrapper(func, PARTIAL_RIGHT_FLAG, undefined, partials, holders);
        });
        var rearg = rest(function(func, indexes) {
          return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes, 1));
        });
        function rest(func, start) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          start = nativeMax(start === undefined ? (func.length - 1) : toInteger(start), 0);
          return function() {
            var args = arguments,
                index = -1,
                length = nativeMax(args.length - start, 0),
                array = Array(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            switch (start) {
              case 0:
                return func.call(this, array);
              case 1:
                return func.call(this, args[0], array);
              case 2:
                return func.call(this, args[0], args[1], array);
            }
            var otherArgs = Array(start + 1);
            index = -1;
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = array;
            return apply(func, this, otherArgs);
          };
        }
        function spread(func, start) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          start = start === undefined ? 0 : nativeMax(toInteger(start), 0);
          return rest(function(args) {
            var array = args[start],
                otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options) {
          var leading = true,
              trailing = true;
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (isObject(options)) {
            leading = 'leading' in options ? !!options.leading : leading;
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            'leading': leading,
            'maxWait': wait,
            'trailing': trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          wrapper = wrapper == null ? identity : wrapper;
          return partial(wrapper, value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, false, true);
        }
        function cloneWith(value, customizer) {
          return baseClone(value, false, true, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, true, true);
        }
        function cloneDeepWith(value, customizer) {
          return baseClone(value, true, true, customizer);
        }
        function eq(value, other) {
          return value === other || (value !== value && other !== other);
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        function isArguments(value) {
          return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
        }
        var isArray = Array.isArray;
        function isArrayBuffer(value) {
          return isObjectLike(value) && objectToString.call(value) == arrayBufferTag;
        }
        function isArrayLike(value) {
          return value != null && isLength(getLength(value)) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || (isObjectLike(value) && objectToString.call(value) == boolTag);
        }
        var isBuffer = !Buffer ? stubFalse : function(value) {
          return value instanceof Buffer;
        };
        function isDate(value) {
          return isObjectLike(value) && objectToString.call(value) == dateTag;
        }
        function isElement(value) {
          return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
        }
        function isEmpty(value) {
          if (isArrayLike(value) && (isArray(value) || isString(value) || isFunction(value.splice) || isArguments(value) || isBuffer(value))) {
            return !value.length;
          }
          if (isObjectLike(value)) {
            var tag = getTag(value);
            if (tag == mapTag || tag == setTag) {
              return !value.size;
            }
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return !(nonEnumShadows && keys(value).length);
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined;
          var result = customizer ? customizer(value, other) : undefined;
          return result === undefined ? baseIsEqual(value, other, customizer) : !!result;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          return (objectToString.call(value) == errorTag) || (typeof value.message == 'string' && typeof value.name == 'string');
        }
        function isFinite(value) {
          return typeof value == 'number' && nativeIsFinite(value);
        }
        function isFunction(value) {
          var tag = isObject(value) ? objectToString.call(value) : '';
          return tag == funcTag || tag == genTag;
        }
        function isInteger(value) {
          return typeof value == 'number' && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
          var type = typeof value;
          return !!value && (type == 'object' || type == 'function');
        }
        function isObjectLike(value) {
          return !!value && typeof value == 'object';
        }
        function isMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error('This method is not supported with `core-js`. Try https://github.com/es-shims.');
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber(value) {
          return typeof value == 'number' || (isObjectLike(value) && objectToString.call(value) == numberTag);
        }
        function isPlainObject(value) {
          if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
          return (typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
        }
        function isRegExp(value) {
          return isObject(value) && objectToString.call(value) == regexpTag;
        }
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        function isSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function isString(value) {
          return typeof value == 'string' || (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);
        }
        function isSymbol(value) {
          return typeof value == 'symbol' || (isObjectLike(value) && objectToString.call(value) == symbolTag);
        }
        function isTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
        }
        function isUndefined(value) {
          return value === undefined;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && objectToString.call(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (iteratorSymbol && value[iteratorSymbol]) {
            return iteratorToArray(value[iteratorSymbol]());
          }
          var tag = getTag(value),
              func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = (value < 0 ? -1 : 1);
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result = toFinite(value),
              remainder = result % 1;
          return result === result ? (remainder ? result - remainder : result) : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == 'number') {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = isFunction(value.valueOf) ? value.valueOf() : value;
            value = isObject(other) ? (other + '') : other;
          }
          if (typeof value != 'string') {
            return value === 0 ? value : +value;
          }
          value = value.replace(reTrim, '');
          var isBinary = reIsBinary.test(value);
          return (isBinary || reIsOctal.test(value)) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : (reIsBadHex.test(value) ? NAN : +value);
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
        }
        function toString(value) {
          return value == null ? '' : baseToString(value);
        }
        var assign = createAssigner(function(object, source) {
          if (nonEnumShadows || isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          if (nonEnumShadows || isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keysIn(source), object);
            return;
          }
          for (var key in source) {
            assignValue(object, key, source[key]);
          }
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = rest(function(object, paths) {
          return baseAt(object, baseFlatten(paths, 1));
        });
        function create(prototype, properties) {
          var result = baseCreate(prototype);
          return properties ? baseAssign(result, properties) : result;
        }
        var defaults = rest(function(args) {
          args.push(undefined, assignInDefaults);
          return apply(assignInWith, undefined, args);
        });
        var defaultsDeep = rest(function(args) {
          args.push(undefined, mergeDefaults);
          return apply(mergeWith, undefined, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee) {
          return object == null ? object : baseFor(object, getIteratee(iteratee, 3), keysIn);
        }
        function forInRight(object, iteratee) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee, 3), keysIn);
        }
        function forOwn(object, iteratee) {
          return object && baseForOwn(object, getIteratee(iteratee, 3));
        }
        function forOwnRight(object, iteratee) {
          return object && baseForOwnRight(object, getIteratee(iteratee, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result = object == null ? undefined : baseGet(object, path);
          return result === undefined ? defaultValue : result;
        }
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert = createInverter(function(result, value, key) {
          result[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result, value, key) {
          if (hasOwnProperty.call(result, value)) {
            result[value].push(key);
          } else {
            result[value] = [key];
          }
        }, getIteratee);
        var invoke = rest(baseInvoke);
        function keys(object) {
          var isProto = isPrototype(object);
          if (!(isProto || isArrayLike(object))) {
            return baseKeys(object);
          }
          var indexes = indexKeys(object),
              skipIndexes = !!indexes,
              result = indexes || [],
              length = result.length;
          for (var key in object) {
            if (baseHas(object, key) && !(skipIndexes && (key == 'length' || isIndex(key, length))) && !(isProto && key == 'constructor')) {
              result.push(key);
            }
          }
          return result;
        }
        function keysIn(object) {
          var index = -1,
              isProto = isPrototype(object),
              props = baseKeysIn(object),
              propsLength = props.length,
              indexes = indexKeys(object),
              skipIndexes = !!indexes,
              result = indexes || [],
              length = result.length;
          while (++index < propsLength) {
            var key = props[index];
            if (!(skipIndexes && (key == 'length' || isIndex(key, length))) && !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
              result.push(key);
            }
          }
          return result;
        }
        function mapKeys(object, iteratee) {
          var result = {};
          iteratee = getIteratee(iteratee, 3);
          baseForOwn(object, function(value, key, object) {
            result[iteratee(value, key, object)] = value;
          });
          return result;
        }
        function mapValues(object, iteratee) {
          var result = {};
          iteratee = getIteratee(iteratee, 3);
          baseForOwn(object, function(value, key, object) {
            result[key] = iteratee(value, key, object);
          });
          return result;
        }
        var merge = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = rest(function(object, props) {
          if (object == null) {
            return {};
          }
          props = arrayMap(baseFlatten(props, 1), toKey);
          return basePick(object, baseDifference(getAllKeysIn(object), props));
        });
        function omitBy(object, predicate) {
          predicate = getIteratee(predicate);
          return basePickBy(object, function(value, key) {
            return !predicate(value, key);
          });
        }
        var pick = rest(function(object, props) {
          return object == null ? {} : basePick(object, arrayMap(baseFlatten(props, 1), toKey));
        });
        function pickBy(object, predicate) {
          return object == null ? {} : basePickBy(object, getIteratee(predicate));
        }
        function result(object, path, defaultValue) {
          path = isKey(path, object) ? [path] : castPath(path);
          var index = -1,
              length = path.length;
          if (!length) {
            object = undefined;
            length = 1;
          }
          while (++index < length) {
            var value = object == null ? undefined : object[toKey(path[index])];
            if (value === undefined) {
              index = length;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee, accumulator) {
          var isArr = isArray(object) || isTypedArray(object);
          iteratee = getIteratee(iteratee, 4);
          if (accumulator == null) {
            if (isArr || isObject(object)) {
              var Ctor = object.constructor;
              if (isArr) {
                accumulator = isArray(object) ? new Ctor : [];
              } else {
                accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
              }
            } else {
              accumulator = {};
            }
          }
          (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
            return iteratee(accumulator, value, index, object);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object ? baseValues(object, keys(object)) : [];
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number, lower, upper) {
          if (upper === undefined) {
            upper = lower;
            lower = undefined;
          }
          if (upper !== undefined) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }
        function inRange(number, start, end) {
          start = toNumber(start) || 0;
          if (end === undefined) {
            end = start;
            start = 0;
          } else {
            end = toNumber(end) || 0;
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined;
          }
          if (floating === undefined) {
            if (typeof upper == 'boolean') {
              floating = upper;
              upper = undefined;
            } else if (typeof lower == 'boolean') {
              floating = lower;
              lower = undefined;
            }
          }
          if (lower === undefined && upper === undefined) {
            lower = 0;
            upper = 1;
          } else {
            lower = toNumber(lower) || 0;
            if (upper === undefined) {
              upper = lower;
              lower = 0;
            } else {
              upper = toNumber(upper) || 0;
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result, word, index) {
          word = word.toLowerCase();
          return result + (index ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
        }
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined ? length : baseClamp(toInteger(position), 0, length);
          position -= target.length;
          return position >= 0 && string.indexOf(target, position) == position;
        }
        function escape(string) {
          string = toString(string);
          return (string && reHasUnescapedHtml.test(string)) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString(string);
          return (string && reHasRegExpChar.test(string)) ? string.replace(reRegExpChar, '\\$&') : string;
        }
        var kebabCase = createCompounder(function(result, word, index) {
          return result + (index ? '-' : '') + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result, word, index) {
          return result + (index ? ' ' : '') + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst('toLowerCase');
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return (createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars));
        }
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return (length && strLength < length) ? (string + createPadding(length - strLength, chars)) : string;
        }
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return (length && strLength < length) ? (createPadding(length - strLength, chars) + string) : string;
        }
        function parseInt(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          string = toString(string).replace(reTrim, '');
          return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
        }
        function repeat(string, n, guard) {
          if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString(string), n);
        }
        function replace() {
          var args = arguments,
              string = toString(args[0]);
          return args.length < 3 ? string : nativeReplace.call(string, args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result, word, index) {
          return result + (index ? '_' : '') + word.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined;
          }
          limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (typeof separator == 'string' || (separator != null && !isRegExp(separator)))) {
            separator = baseToString(separator);
            if (separator == '' && reHasComplexSymbol.test(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return nativeSplit.call(string, separator, limit);
        }
        var startCase = createCompounder(function(result, word, index) {
          return result + (index ? ' ' : '') + upperFirst(word);
        });
        function startsWith(string, target, position) {
          string = toString(string);
          position = baseClamp(toInteger(position), 0, string.length);
          return string.lastIndexOf(baseToString(target), position) == position;
        }
        function template(string, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, assignInDefaults);
          var imports = assignInWith({}, options.imports, settings.imports, assignInDefaults),
              importsKeys = keys(imports),
              importsValues = baseValues(imports, importsKeys);
          var isEscaping,
              isEvaluating,
              index = 0,
              interpolate = options.interpolate || reNoMatch,
              source = "__p += '";
          var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g');
          var sourceURL = '//# sourceURL=' + ('sourceURL' in options ? options.sourceURL : ('lodash.templateSources[' + (++templateCounter) + ']')) + '\n';
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = options.variable;
          if (!variable) {
            source = 'with (obj) {\n' + source + '\n}\n';
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;');
          source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';
          var result = attempt(function() {
            return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
          });
          result.source = source;
          if (isError(result)) {
            throw result;
          }
          return result;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined)) {
            return string.replace(reTrim, '');
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string),
              chrSymbols = stringToArray(chars),
              start = charsStartIndex(strSymbols, chrSymbols),
              end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join('');
        }
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined)) {
            return string.replace(reTrimEnd, '');
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string),
              end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join('');
        }
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined)) {
            return string.replace(reTrimStart, '');
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string),
              start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join('');
        }
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH,
              omission = DEFAULT_TRUNC_OMISSION;
          if (isObject(options)) {
            var separator = 'separator' in options ? options.separator : separator;
            length = 'length' in options ? toInteger(options.length) : length;
            omission = 'omission' in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (reHasComplexSymbol.test(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result = strSymbols ? castSlice(strSymbols, 0, end).join('') : string.slice(0, end);
          if (separator === undefined) {
            return result + omission;
          }
          if (strSymbols) {
            end += (result.length - end);
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match,
                  substring = result;
              if (!separator.global) {
                separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
              }
              separator.lastIndex = 0;
              while ((match = separator.exec(substring))) {
                var newEnd = match.index;
              }
              result = result.slice(0, newEnd === undefined ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result.lastIndexOf(separator);
            if (index > -1) {
              result = result.slice(0, index);
            }
          }
          return result + omission;
        }
        function unescape(string) {
          string = toString(string);
          return (string && reHasEscapedHtml.test(string)) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result, word, index) {
          return result + (index ? ' ' : '') + word.toUpperCase();
        });
        var upperFirst = createCaseFirst('toUpperCase');
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined : pattern;
          if (pattern === undefined) {
            pattern = reHasComplexWord.test(string) ? reComplexWord : reBasicWord;
          }
          return string.match(pattern) || [];
        }
        var attempt = rest(function(func, args) {
          try {
            return apply(func, undefined, args);
          } catch (e) {
            return isError(e) ? e : new Error(e);
          }
        });
        var bindAll = rest(function(object, methodNames) {
          arrayEach(baseFlatten(methodNames, 1), function(key) {
            key = toKey(key);
            object[key] = bind(object[key], object);
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs ? pairs.length : 0,
              toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return rest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, true));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == 'function' ? func : baseClone(func, true));
        }
        function matches(source) {
          return baseMatches(baseClone(source, true));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, true));
        }
        var method = rest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = rest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source),
              methodNames = baseFunctions(source, props);
          if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
              isFunc = isFunction(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain || chainAll) {
                  var result = object(this.__wrapped__),
                      actions = result.__actions__ = copyArray(this.__actions__);
                  actions.push({
                    'func': func,
                    'args': arguments,
                    'thisArg': object
                  });
                  result.__chain__ = chainAll;
                  return result;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop() {}
        function nthArg(n) {
          n = toInteger(n);
          return rest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined : baseGet(object, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return '';
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH,
              length = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee = getIteratee(iteratee);
          n -= MAX_ARRAY_LENGTH;
          var result = baseTimes(length, iteratee);
          while (++index < n) {
            iteratee(index);
          }
          return result;
        }
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(value));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        });
        var ceil = createRound('ceil');
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        });
        var floor = createRound('floor');
        function max(array) {
          return (array && array.length) ? baseExtremum(array, identity, baseGt) : undefined;
        }
        function maxBy(array, iteratee) {
          return (array && array.length) ? baseExtremum(array, getIteratee(iteratee), baseGt) : undefined;
        }
        function mean(array) {
          return baseMean(array, identity);
        }
        function meanBy(array, iteratee) {
          return baseMean(array, getIteratee(iteratee));
        }
        function min(array) {
          return (array && array.length) ? baseExtremum(array, identity, baseLt) : undefined;
        }
        function minBy(array, iteratee) {
          return (array && array.length) ? baseExtremum(array, getIteratee(iteratee), baseLt) : undefined;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        });
        var round = createRound('round');
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        });
        function sum(array) {
          return (array && array.length) ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee) {
          return (array && array.length) ? baseSum(array, getIteratee(iteratee)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.deburr = deburr;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, (function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }()), {'chain': false});
        lodash.VERSION = VERSION;
        arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(['drop', 'take'], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            var filtered = this.__filtered__;
            if (filtered && !index) {
              return new LazyWrapper(this);
            }
            n = n === undefined ? 1 : nativeMax(toInteger(n), 0);
            var result = this.clone();
            if (filtered) {
              result.__takeCount__ = nativeMin(n, result.__takeCount__);
            } else {
              result.__views__.push({
                'size': nativeMin(n, MAX_ARRAY_LENGTH),
                'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
              });
            }
            return result;
          };
          LazyWrapper.prototype[methodName + 'Right'] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
          var type = index + 1,
              isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee) {
            var result = this.clone();
            result.__iteratees__.push({
              'iteratee': getIteratee(iteratee, 3),
              'type': type
            });
            result.__filtered__ = result.__filtered__ || isFilter;
            return result;
          };
        });
        arrayEach(['head', 'last'], function(methodName, index) {
          var takeName = 'take' + (index ? 'Right' : '');
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(['initial', 'tail'], function(methodName, index) {
          var dropName = 'drop' + (index ? '' : 'Right');
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = rest(function(path, args) {
          if (typeof path == 'function') {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          predicate = getIteratee(predicate, 3);
          return this.filter(function(value) {
            return !predicate(value);
          });
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result = this;
          if (result.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result);
          }
          if (start < 0) {
            result = result.takeRight(-start);
          } else if (start) {
            result = result.drop(start);
          }
          if (end !== undefined) {
            end = toInteger(end);
            result = end < 0 ? result.dropRight(-end) : result.take(end - start);
          }
          return result;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
              isTaker = /^(?:head|last)$/.test(methodName),
              lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
              retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__,
                args = isTaker ? [1] : arguments,
                isLazy = value instanceof LazyWrapper,
                iteratee = args[0],
                useLazy = isLazy || isArray(value);
            var interceptor = function(value) {
              var result = lodashFunc.apply(lodash, arrayPush([value], args));
              return (isTaker && chainAll) ? result[0] : result;
            };
            if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__,
                isHybrid = !!this.__actions__.length,
                isUnwrapped = retUnwrapped && !chainAll,
                onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result = func.apply(value, args);
              result.__actions__.push({
                'func': thru,
                'args': [interceptor],
                'thisArg': undefined
              });
              return new LodashWrapper(result, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result = this.thru(interceptor);
            return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
          };
        });
        arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
          var func = arrayProto[methodName],
              chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
              retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value) {
              return func.apply(isArray(value) ? value : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = (lodashFunc.name + ''),
                names = realNames[key] || (realNames[key] = []);
            names.push({
              'name': methodName,
              'func': lodashFunc
            });
          }
        });
        realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{
          'name': 'wrapper',
          'func': undefined
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        if (iteratorSymbol) {
          lodash.prototype[iteratorSymbol] = wrapperToIterator;
        }
        return lodash;
      }
      var _ = runInContext();
      (freeSelf || {})._ = _;
      if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        define(function() {
          return _;
        });
      } else if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _;
      } else {
        root._ = _;
      }
    }.call(this));
  })($__require('@empty').Buffer, $__require('@empty'));
  return module.exports;
});

$__System.registerDynamic("48", ["d1"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('d1');
  return module.exports;
});

$__System.registerDynamic("c2", ["84", "54", "cf", "4f", "48"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var _create = $__require('84');
  var _create2 = _interopRequireDefault(_create);
  var _dataModel = $__require('54');
  var _dataModel2 = _interopRequireDefault(_dataModel);
  var _eventListener = $__require('cf');
  var _eventListener2 = _interopRequireDefault(_eventListener);
  var _index = $__require('4f');
  var _index2 = _interopRequireDefault(_index);
  var _lodash = $__require('48');
  var _lodash2 = _interopRequireDefault(_lodash);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var ID_PROP;
  module.exports = function() {
    function Collection() {
      var collection = (0, _create2.default)(Array.prototype);
      collection = Array.apply(collection, arguments) || collection;
      Collection.injectClassMethods(collection);
      return collection;
    }
    Collection.injectClassMethods = function(collection) {
      for (var method in Collection.prototype) {
        if (Collection.prototype.hasOwnProperty(method)) {
          collection[method] = Collection.prototype[method];
        }
      }
      return collection;
    };
    Collection.prototype = {
      init: function init(Service, data, stateModel) {
        var _this = this,
            _arguments = arguments;
        ID_PROP = _index2.default.config.getIdPropertyName();
        this.setServerTotal(0);
        if (data) {
          if (_lodash2.default.has(data, "inlineCount")) {
            this.setServerTotal(data.inlineCount);
          }
          if (_lodash2.default.has(data, "results")) {
            data = data.results;
          }
        }
        if (!_lodash2.default.isArray(data)) {
          data = [];
        }
        this._service = Service;
        this._stateModel = stateModel;
        if (!stateModel) {
          throw new Error("Rest Collection doesn't have state model");
        }
        this._setSocketConnection();
        _lodash2.default.each(data, function(value) {
          _this.push(value);
        }, this);
        var that = this;
        this._events = new _eventListener2.default({
          bubble: function bubble() {
            that._events.bubble.apply(that._events, _arguments);
          },
          hasStatus: function hasStatus(search) {},
          get: function get(prop) {
            if (_lodash2.default.has(that, prop) && that[prop]) {
              return that[prop];
            }
          },
          set: function set(prop, value) {}
        });
        this._parentLink = null;
      },
      onCustom: function onCustom(event, fn) {
        this._events.on(event, fn);
      },
      onBubble: function onBubble(bubbleFn) {
        this._events.onBubble(bubbleFn);
      },
      onUpdate: function onUpdate(updateFn) {
        this._events.on("update", updateFn);
      },
      onCreate: function onCreate(createFn) {
        this._events.on("create", createFn);
      },
      onDelete: function onDelete(deleteFn) {
        this._events.on("delete", deleteFn);
      },
      updateData: function updateData(eventName, fetchedData) {
        var _this2 = this;
        if (_lodash2.default.has(fetchedData, "results")) {
          fetchedData = fetchedData.results;
        }
        if (!_lodash2.default.isArray(fetchedData)) {
          console.log(fetchedData);
          throw new Error("Trying to update collection with a non-array");
        }
        var currentIds = [];
        this.forEach(function(item, index, array) {
          currentIds.push(item[ID_PROP]);
        });
        var needToAdd = _lodash2.default.filter(fetchedData, function(checkModel) {
          return currentIds.indexOf(checkModel[ID_PROP]) === -1;
        });
        this.forEach(function(item, index, array) {
          var found = _lodash2.default.find(fetchedData, function(check) {
            return check[ID_PROP] === item[ID_PROP];
          });
          if (found) {
            item.updateData(eventName, found);
          }
        });
        _lodash2.default.each(needToAdd, function(model) {
          _this2.push(model);
        }, this);
      },
      _setSocketConnection: function _setSocketConnection() {
        var listener = "create:" + this._service.getPropertyName();
        if (this._hasBaseNamespace()) {
          listener += this._getBaseNamespace();
        }
        var that = this;
        this._stateModel.getSocket().on(listener, that._stateModel.getUpdateCallback(listener));
      },
      _getBaseNamespace: function _getBaseNamespace() {
        return this._baseNamespace;
      },
      _hasBaseNamespace: function _hasBaseNamespace() {
        return this._baseNamespace ? true : false;
      },
      _setBaseNamespace: function _setBaseNamespace(baseNamespace) {
        this._baseNamespace = baseNamespace;
      },
      _setParentLinkFunction: function _setParentLinkFunction(fn) {
        this._parentLink = fn;
      },
      filter: function filter(filterEvent) {
        if (filterEvent) {
          this._filterEvent = filterEvent;
        }
        if (this._filterEvent) {
          this.filtered = _lodash2.default.filter(this, this._filterEvent);
        }
      },
      getServerTotal: function getServerTotal() {
        return this._inlineCount;
      },
      setServerTotal: function setServerTotal(count) {
        this._inlineCount = count;
        if (this._inlineCount == 0) {
          this.length = 0;
        }
      },
      push: function push(data) {
        if (!_lodash2.default.isObject(data)) {
          data = {};
        }
        if (data instanceof _dataModel2.default) {
          data = data.export();
        }
        var model = new _dataModel2.default(this._service, data, this._stateModel);
        if (this._hasBaseNamespace()) {
          model._setBaseNamespace(this._getBaseNamespace());
        }
        if (_lodash2.default.isFunction(this._parentLink)) {
          this._parentLink(model);
        }
        var that = this;
        model.onDelete(function() {
          that.removeItem(model);
        });
        var modelFn = function modelFn() {
          var sendArgs = [];
          _lodash2.default.each(arguments, function(value, key) {
            sendArgs.push(value);
          });
          that._events.trigger.apply(that._events, sendArgs);
        };
        model.onUpdate(modelFn);
        model.onCreate(modelFn);
        model.onDelete(modelFn);
        model.onStateChange(modelFn);
        model.onBubble(function() {
          var sendArgs = [];
          _lodash2.default.each(arguments, function(value, key) {
            sendArgs.push(value);
          });
          that._events.triggerBubble.apply(that._events, sendArgs);
        });
        if (this._service) {
          this._service.configDataModel(model);
        }
        Array.prototype.push.call(this, model);
        return model;
      },
      removeItem: function removeItem(model) {
        var foundIndex = null;
        this.forEach(function(item, index) {
          if (item[ID_PROP] == model[ID_PROP]) {
            foundIndex = index;
          }
        });
        if (!_lodash2.default.isNull(foundIndex) && this.length > foundIndex) {
          Array.prototype.splice.call(this, foundIndex, 1);
        }
      },
      _export: function _export() {
        if (this.length === 0) {
          return [];
        }
        var data = Array.prototype.slice.call(this);
        _lodash2.default.each(data, function(value, key) {
          if (value instanceof _dataModel2.default) {
            data[key] = value.export();
          }
        }, this);
        return data;
      }
    };
    return Collection;
  }.call({});
  return module.exports;
});

$__System.registerDynamic("4f", ["4d", "4e", "88", "3a", "3d", "40", "43", "45", "48", "56", "46", "54", "49", "47", "c1", "4a", "53", "57", "58", "59", "5a", "55", "5b", "5d", "85", "86", "89", "8c", "90", "93", "96", "be", "cc", "c2"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.AbstractBootstrap = exports.AbstractMaterial = exports.Factory = exports.Directive = exports.Filter = exports.Service = exports.Config = exports.Run = exports.Inject = exports.RouteConfig = exports.View = exports.Component = exports.ResponseLogger = exports.ErrorLogger = exports.AbstractPage = exports.AbstractComponent = exports.MockHttpFallthrough = exports.AbstractStubPage = exports.AbstractService = exports.MockHttp = exports.StateModel = exports.ParserHelper = exports.EnvironmentHelper = exports.DataCollection = exports.DataModel = exports.ValidationGeneratorHelper = undefined;
  var _classCallCheck2 = $__require('4d');
  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
  var _createClass2 = $__require('4e');
  var _createClass3 = _interopRequireDefault(_createClass2);
  var _angular = $__require('88');
  var _angular2 = _interopRequireDefault(_angular);
  $__require('3a');
  $__require('3d');
  $__require('40');
  $__require('43');
  $__require('45');
  var _lodash = $__require('48');
  var _lodash2 = _interopRequireDefault(_lodash);
  var _ngDecorators = $__require('56');
  var _ngDecorators2 = _interopRequireDefault(_ngDecorators);
  var _validationGeneratorHelper = $__require('46');
  var _validationGeneratorHelper2 = _interopRequireDefault(_validationGeneratorHelper);
  var _dataModel = $__require('54');
  var _dataModel2 = _interopRequireDefault(_dataModel);
  var _environmentHelper = $__require('49');
  var _environmentHelper2 = _interopRequireDefault(_environmentHelper);
  var _parserHelper = $__require('47');
  var _parserHelper2 = _interopRequireDefault(_parserHelper);
  var _stateModel = $__require('c1');
  var _stateModel2 = _interopRequireDefault(_stateModel);
  var _mockHttp = $__require('4a');
  var _mockHttp2 = _interopRequireDefault(_mockHttp);
  var _abstractService = $__require('53');
  var _abstractService2 = _interopRequireDefault(_abstractService);
  var _abstractStubPage = $__require('57');
  var _abstractStubPage2 = _interopRequireDefault(_abstractStubPage);
  var _abstractPage = $__require('58');
  var _abstractPage2 = _interopRequireDefault(_abstractPage);
  var _abstractComponent = $__require('59');
  var _abstractComponent2 = _interopRequireDefault(_abstractComponent);
  var _mockHttpFallthrough = $__require('5a');
  var _mockHttpFallthrough2 = _interopRequireDefault(_mockHttpFallthrough);
  var _responseLogger = $__require('55');
  var _responseLogger2 = _interopRequireDefault(_responseLogger);
  var _errorLogger = $__require('5b');
  var _errorLogger2 = _interopRequireDefault(_errorLogger);
  var _abstractMaterial = $__require('5d');
  var _abstractMaterial2 = _interopRequireDefault(_abstractMaterial);
  var _abstractBootstrap = $__require('85');
  var _abstractBootstrap2 = _interopRequireDefault(_abstractBootstrap);
  $__require('86');
  $__require('89');
  $__require('8c');
  $__require('90');
  $__require('93');
  $__require('96');
  $__require('be');
  $__require('cc');
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var DataCollection = $__require('c2');
  var ENV_MODES = ["production", "development", "qa", "localhost", "prototype", "cli"];
  var CoreLoader = function() {
    function CoreLoader(args) {
      (0, _classCallCheck3.default)(this, CoreLoader);
      if (!args.config) {
        throw new Error("You must pass the scaffi-ui config in the library initialize function args");
      }
      if (!_lodash2.default.isObject(args.config)) {
        throw new Error("You must pass an object in the config args to initialize scaffi-ui");
      }
      if (!_lodash2.default.has(args, "theme")) {
        throw new Error("You must pass a theme args that extends AbstractTheme. You did not do that. Bad person");
      }
      this.theme = args.theme;
      if (args.private && (!_lodash2.default.isObject(args.private) || !_lodash2.default.isObject(args.private.config))) {
        throw new Error("You're providing a private config which is not an object structure. Bad Human");
      }
      this.config = args.config;
      if (args.private) {
        this.mergeConfigs(args.private);
      }
      if (!this.config.config.environment) {
        throw new Error("config.environment is not provided. Scaffi doesn't know to do prototype or not.");
      }
      if (ENV_MODES.indexOf(this.config.config.environment) === -1) {
        throw new Error("Invalid environment supplied: " + this.config.config.environment + ". Expect one of the following: " + ENV_MODES.join(", "));
      }
    }
    (0, _createClass3.default)(CoreLoader, [{
      key: 'initializeTheme',
      value: function initializeTheme(appModule) {
        this.theme = new this.theme({appModule: appModule});
      }
    }, {
      key: 'mergeConfigs',
      value: function mergeConfigs(privateConfig) {
        var _this = this;
        if (!this.config.config) {
          this.config.config = {};
        }
        _lodash2.default.forEach(privateConfig.config, function(item, name) {
          _this.config.config[name] = item;
        });
      }
    }, {
      key: 'getConfigProperty',
      value: function getConfigProperty(name) {
        if (_lodash2.default.has(this.config.config, name)) {
          return this.config.config[name];
        }
        return null;
      }
    }, {
      key: 'getConfig',
      value: function getConfig() {
        return this.config;
      }
    }, {
      key: 'getEnvironment',
      value: function getEnvironment() {
        return this.getConfigProperty("environment");
      }
    }]);
    return CoreLoader;
  }();
  var coreLoader,
      initialized;
  var returns = {
    initialize: function initialize(args) {
      coreLoader = new CoreLoader(args);
      var requires = ['ngAnimate', 'ngMessages', 'ngSanitize', 'ui.router'];
      _angular2.default.element(document).ready(function() {
        _angular2.default.bootstrap(document, [_ngDecorators2.default.name], {});
      });
      _ngDecorators2.default.requires = _ngDecorators2.default.requires.concat(requires);
      _ngDecorators2.default.config(function($provide) {
        $provide.decorator("$exceptionHandler", function($delegate) {
          return function(exception, cause) {
            _errorLogger2.default.fireError("ui", exception);
            $delegate(exception, cause);
          };
        });
      });
      _ngDecorators2.default.config(function($httpProvider) {
        if (!$httpProvider.defaults.headers.get) {
          $httpProvider.defaults.headers.get = {};
        }
        $httpProvider.defaults.headers.get['Cache-Control'] = 'no-cache';
        $httpProvider.defaults.headers.get['Pragma'] = 'no-cache';
      });
      initialized = true;
      coreLoader.initializeTheme(_ngDecorators2.default);
      return _ngDecorators2.default;
    },
    config: {
      _isLoaded: function _isLoaded() {
        return initialized ? true : false;
      },
      _throwLoadError: function _throwLoadError() {
        if (!this._isLoaded()) {
          throw new Error("Scaffi Core has not been loaded yet to be able to reference any of the config functions.");
        }
      },
      getLocalhostAddress: function getLocalhostAddress() {
        this._throwLoadError();
        return "localhost:" + coreLoader.getConfigProperty("uiLocalhostPort");
      },
      getIdPropertyName: function getIdPropertyName() {
        this._throwLoadError();
        return coreLoader.getConfigProperty("idName");
      },
      getParentIdName: function getParentIdName(parentName) {
        this._throwLoadError();
        return parentName + coreLoader.getConfigProperty("idName");
      },
      getApiBase: function getApiBase() {
        this._throwLoadError();
        var url = coreLoader.getConfigProperty("apiRoute");
        if (coreLoader.getEnvironment() == "localhost" || coreLoader.getEnvironment() == "prototype") {
          url = "http://localhost:" + coreLoader.getConfigProperty("serverLocalhostPort") + url;
        }
        return url;
      },
      isProductionMode: function isProductionMode() {
        return coreLoader.getEnvironment() === "production";
      },
      isDevelopmentMode: function isDevelopmentMode() {
        return coreLoader.getEnvironment() === "development";
      },
      isQaMode: function isQaMode() {
        return coreLoader.getEnvironment() === "qa";
      },
      isLocalhostMode: function isLocalhostMode() {
        return coreLoader.getEnvironment() === "localhost";
      },
      isPrototypeMode: function isPrototypeMode() {
        return coreLoader.getEnvironment() === "prototype";
      },
      isCliMode: function isCliMode() {
        return coreLoader.getEnvironment() === "cli";
      },
      getEnvironment: function getEnvironment() {
        return coreLoader.getEnvironment();
      }
    },
    transformColumnName: function transformColumnName(name) {}
  };
  exports.default = returns;
  exports.ValidationGeneratorHelper = _validationGeneratorHelper2.default;
  exports.DataModel = _dataModel2.default;
  exports.DataCollection = DataCollection;
  exports.EnvironmentHelper = _environmentHelper2.default;
  exports.ParserHelper = _parserHelper2.default;
  exports.StateModel = _stateModel2.default;
  exports.MockHttp = _mockHttp2.default;
  exports.AbstractService = _abstractService2.default;
  exports.AbstractStubPage = _abstractStubPage2.default;
  exports.MockHttpFallthrough = _mockHttpFallthrough2.default;
  exports.AbstractComponent = _abstractComponent2.default;
  exports.AbstractPage = _abstractPage2.default;
  exports.ErrorLogger = _errorLogger2.default;
  exports.ResponseLogger = _responseLogger2.default;
  exports.Component = _ngDecorators.Component;
  exports.View = _ngDecorators.View;
  exports.RouteConfig = _ngDecorators.RouteConfig;
  exports.Inject = _ngDecorators.Inject;
  exports.Run = _ngDecorators.Run;
  exports.Config = _ngDecorators.Config;
  exports.Service = _ngDecorators.Service;
  exports.Filter = _ngDecorators.Filter;
  exports.Directive = _ngDecorators.Directive;
  exports.Factory = _ngDecorators.Factory;
  exports.AbstractMaterial = _abstractMaterial2.default;
  exports.AbstractBootstrap = _abstractBootstrap2.default;
  return module.exports;
});

$__System.registerDynamic("d2", ["4f"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('4f');
  return module.exports;
});

$__System.registerDynamic("6", ["d2"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('d2');
  return module.exports;
});

$__System.register('d3', ['6', '7', '22', '23', 'a'], function (_export) {
	var AbstractService, Service, _classCallCheck, _get, _inherits, _createClass, ProductsService;

	return {
		setters: [function (_4) {
			AbstractService = _4.AbstractService;
			Service = _4.Service;
		}, function (_3) {
			_classCallCheck = _3['default'];
		}, function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_a) {
			_createClass = _a['default'];
		}],
		execute: function () {

			//start-non-standard
			'use strict';

			//end-non-standard

			ProductsService = (function (_AbstractService) {
				_inherits(ProductsService, _AbstractService);

				function ProductsService() {
					_classCallCheck(this, _ProductsService);

					_get(Object.getPrototypeOf(_ProductsService.prototype), 'constructor', this).apply(this, arguments);
				}

				_createClass(ProductsService, [{
					key: 'getApiRouteName',

					/*
      Tacked on to what the base route for any api request is
      */
					value: function getApiRouteName() {
						return 'products';
					}

					/*
      This lets me inject the service into the DataModel so that you can
      CRUD a json object without directly going through a service. 
      If you want to socket something to a subsequent DataCollection or DataModel, this is the namespace you send.
      */
				}, {
					key: 'getPropertyName',
					value: function getPropertyName() {
						return 'ProductsService';
					}
				}]);

				var _ProductsService = ProductsService;
				ProductsService = Service({
					serviceName: 'ProductsService'
				})(ProductsService) || ProductsService;
				return ProductsService;
			})(AbstractService);

			_export('default', ProductsService);
		}
	};
});
$__System.register('d4', ['d3'], function (_export) {
  'use strict';
  return {
    setters: [function (_d3) {}],
    execute: function () {}
  };
});
$__System.registerDynamic("d5", [], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    'use strict';
  })();
  return _retrieveGlobal();
});

$__System.register('1', ['2', '3', '6', '10', '21', '24', '31', '36', '2b', 'd4', 'd5'], function (_export) {
  'use strict';

  // js vendor files

  var ScaffiConfig, ScaffiConfigPrivate, ScaffiUi, _, theme, mainModule, requires;

  return {
    setters: [function (_2) {
      ScaffiConfig = _2['default'];
    }, function (_3) {
      ScaffiConfigPrivate = _3['default'];
    }, function (_4) {
      ScaffiUi = _4['default'];
    }, function (_5) {
      _ = _5['default'];
    }, function (_6) {
      theme = _6['default'];
    }, function (_7) {}, function (_8) {}, function (_9) {}, function (_b) {}, function (_d4) {}, function (_d5) {}],
    execute: function () {
      mainModule = ScaffiUi.initialize({
        config: ScaffiConfig,
        'private': ScaffiConfigPrivate,
        theme: theme
      });

      // js app files

      /*
       Add any angular modules here if you don't want to add them to the theme file.
       */
      requires = [];

      mainModule.requires = mainModule.requires.concat(requires);

      /*
       If you need to config something in angular
       */

      /*
       mainModule.config( ()=>{
       
       });
       */

      /*
       If you need to run something in angular
       */

      /*
       mainModule.run((ngTableDefaults) =>{
       
       });
       */
    }
  };
});
(function(c){if (typeof document == 'undefined') return; var d=document,a='appendChild',i='styleSheet',s=d.createElement('style');s.type='text/css';d.getElementsByTagName('head')[0][a](s);s[i]?s[i].cssText=c:s[a](d.createTextNode(c));})
("@charset \"UTF-8\";/*!\n * Copyright 2015 Drifty Co.\n * http://drifty.com/\n *\n * Ionic, v1.3.0\n * A powerful HTML5 mobile app framework.\n * http://ionicframework.com/\n *\n * By @maxlynch, @benjsperry, @adamdbradley <3\n *\n * Licensed under the MIT license. Please see LICENSE for more information.\n *\n *//*!\n  Ionicons, v2.0.1\n  Created by Ben Sperry for the Ionic Framework, http://ionicons.com/\n  https://twitter.com/benjsperry  https://twitter.com/ionicframework\n  MIT License: https://github.com/driftyco/ionicons\n\n  Android-style icons originally built by Google’s\n  Material Design Icons: https://github.com/google/material-design-icons\n  used under CC BY http://creativecommons.org/licenses/by/4.0/\n  Modified icons to fit ionicon’s grid from original.\n*/.badge,sub,sup{vertical-align:baseline}.content,sub,sup{position:relative}.ionic-body,.scroll-content,body{left:0;top:0;bottom:0;overflow:hidden}.action-sheet-up,.overflow-scroll .scroll,.pane{-webkit-transform:translate3d(0,0,0)}.backdrop,.ng-animate .scroll-bar,.popup-container{visibility:hidden}.bar .title,.button,.button-bar>.button,.loading-container .loading,.tab-item{text-overflow:ellipsis}.tabs,ion-infinite-scroll{-webkit-box-orient:horizontal;-webkit-box-direction:normal}.button-bar.button-bar-inline:after,.button-block:after{clear:both}.disable-user-behavior,.ionic-body,a,body{-webkit-tap-highlight-color:transparent;-webkit-user-drag:none}@font-face{font-family:Ionicons;src:url(jspm_packages/github/driftyco/ionic-bower@1.3.0/fonts/ionicons.eot?v=2.0.1);src:url(jspm_packages/github/driftyco/ionic-bower@1.3.0/fonts/ionicons.eot?v=2.0.1#iefix) format(\"embedded-opentype\"),url(jspm_packages/github/driftyco/ionic-bower@1.3.0/fonts/ionicons.ttf?v=2.0.1) format(\"truetype\"),url(jspm_packages/github/driftyco/ionic-bower@1.3.0/fonts/ionicons.woff?v=2.0.1) format(\"woff\"),url(jspm_packages/github/driftyco/ionic-bower@1.3.0/fonts/ionicons.woff) format(\"woff\"),url(jspm_packages/github/driftyco/ionic-bower@1.3.0/fonts/ionicons.svg?v=2.0.1#Ionicons) format(\"svg\");font-weight:400;font-style:normal}.ion,.ion-alert-circled:before,.ion-alert:before,.ion-android-add-circle:before,.ion-android-add:before,.ion-android-alarm-clock:before,.ion-android-alert:before,.ion-android-apps:before,.ion-android-archive:before,.ion-android-arrow-back:before,.ion-android-arrow-down:before,.ion-android-arrow-dropdown-circle:before,.ion-android-arrow-dropdown:before,.ion-android-arrow-dropleft-circle:before,.ion-android-arrow-dropleft:before,.ion-android-arrow-dropright-circle:before,.ion-android-arrow-dropright:before,.ion-android-arrow-dropup-circle:before,.ion-android-arrow-dropup:before,.ion-android-arrow-forward:before,.ion-android-arrow-up:before,.ion-android-attach:before,.ion-android-bar:before,.ion-android-bicycle:before,.ion-android-boat:before,.ion-android-bookmark:before,.ion-android-bulb:before,.ion-android-bus:before,.ion-android-calendar:before,.ion-android-call:before,.ion-android-camera:before,.ion-android-cancel:before,.ion-android-car:before,.ion-android-cart:before,.ion-android-chat:before,.ion-android-checkbox-blank:before,.ion-android-checkbox-outline-blank:before,.ion-android-checkbox-outline:before,.ion-android-checkbox:before,.ion-android-checkmark-circle:before,.ion-android-clipboard:before,.ion-android-close:before,.ion-android-cloud-circle:before,.ion-android-cloud-done:before,.ion-android-cloud-outline:before,.ion-android-cloud:before,.ion-android-color-palette:before,.ion-android-compass:before,.ion-android-contact:before,.ion-android-contacts:before,.ion-android-contract:before,.ion-android-create:before,.ion-android-delete:before,.ion-android-desktop:before,.ion-android-document:before,.ion-android-done-all:before,.ion-android-done:before,.ion-android-download:before,.ion-android-drafts:before,.ion-android-exit:before,.ion-android-expand:before,.ion-android-favorite-outline:before,.ion-android-favorite:before,.ion-android-film:before,.ion-android-folder-open:before,.ion-android-folder:before,.ion-android-funnel:before,.ion-android-globe:before,.ion-android-hand:before,.ion-android-hangout:before,.ion-android-happy:before,.ion-android-home:before,.ion-android-image:before,.ion-android-laptop:before,.ion-android-list:before,.ion-android-locate:before,.ion-android-lock:before,.ion-android-mail:before,.ion-android-map:before,.ion-android-menu:before,.ion-android-microphone-off:before,.ion-android-microphone:before,.ion-android-more-horizontal:before,.ion-android-more-vertical:before,.ion-android-navigate:before,.ion-android-notifications-none:before,.ion-android-notifications-off:before,.ion-android-notifications:before,.ion-android-open:before,.ion-android-options:before,.ion-android-people:before,.ion-android-person-add:before,.ion-android-person:before,.ion-android-phone-landscape:before,.ion-android-phone-portrait:before,.ion-android-pin:before,.ion-android-plane:before,.ion-android-playstore:before,.ion-android-print:before,.ion-android-radio-button-off:before,.ion-android-radio-button-on:before,.ion-android-refresh:before,.ion-android-remove-circle:before,.ion-android-remove:before,.ion-android-restaurant:before,.ion-android-sad:before,.ion-android-search:before,.ion-android-send:before,.ion-android-settings:before,.ion-android-share-alt:before,.ion-android-share:before,.ion-android-star-half:before,.ion-android-star-outline:before,.ion-android-star:before,.ion-android-stopwatch:before,.ion-android-subway:before,.ion-android-sunny:before,.ion-android-sync:before,.ion-android-textsms:before,.ion-android-time:before,.ion-android-train:before,.ion-android-unlock:before,.ion-android-upload:before,.ion-android-volume-down:before,.ion-android-volume-mute:before,.ion-android-volume-off:before,.ion-android-volume-up:before,.ion-android-walk:before,.ion-android-warning:before,.ion-android-watch:before,.ion-android-wifi:before,.ion-aperture:before,.ion-archive:before,.ion-arrow-down-a:before,.ion-arrow-down-b:before,.ion-arrow-down-c:before,.ion-arrow-expand:before,.ion-arrow-graph-down-left:before,.ion-arrow-graph-down-right:before,.ion-arrow-graph-up-left:before,.ion-arrow-graph-up-right:before,.ion-arrow-left-a:before,.ion-arrow-left-b:before,.ion-arrow-left-c:before,.ion-arrow-move:before,.ion-arrow-resize:before,.ion-arrow-return-left:before,.ion-arrow-return-right:before,.ion-arrow-right-a:before,.ion-arrow-right-b:before,.ion-arrow-right-c:before,.ion-arrow-shrink:before,.ion-arrow-swap:before,.ion-arrow-up-a:before,.ion-arrow-up-b:before,.ion-arrow-up-c:before,.ion-asterisk:before,.ion-at:before,.ion-backspace-outline:before,.ion-backspace:before,.ion-bag:before,.ion-battery-charging:before,.ion-battery-empty:before,.ion-battery-full:before,.ion-battery-half:before,.ion-battery-low:before,.ion-beaker:before,.ion-beer:before,.ion-bluetooth:before,.ion-bonfire:before,.ion-bookmark:before,.ion-bowtie:before,.ion-briefcase:before,.ion-bug:before,.ion-calculator:before,.ion-calendar:before,.ion-camera:before,.ion-card:before,.ion-cash:before,.ion-chatbox-working:before,.ion-chatbox:before,.ion-chatboxes:before,.ion-chatbubble-working:before,.ion-chatbubble:before,.ion-chatbubbles:before,.ion-checkmark-circled:before,.ion-checkmark-round:before,.ion-checkmark:before,.ion-chevron-down:before,.ion-chevron-left:before,.ion-chevron-right:before,.ion-chevron-up:before,.ion-clipboard:before,.ion-clock:before,.ion-close-circled:before,.ion-close-round:before,.ion-close:before,.ion-closed-captioning:before,.ion-cloud:before,.ion-code-download:before,.ion-code-working:before,.ion-code:before,.ion-coffee:before,.ion-compass:before,.ion-compose:before,.ion-connection-bars:before,.ion-contrast:before,.ion-crop:before,.ion-cube:before,.ion-disc:before,.ion-document-text:before,.ion-document:before,.ion-drag:before,.ion-earth:before,.ion-easel:before,.ion-edit:before,.ion-egg:before,.ion-eject:before,.ion-email-unread:before,.ion-email:before,.ion-erlenmeyer-flask-bubbles:before,.ion-erlenmeyer-flask:before,.ion-eye-disabled:before,.ion-eye:before,.ion-female:before,.ion-filing:before,.ion-film-marker:before,.ion-fireball:before,.ion-flag:before,.ion-flame:before,.ion-flash-off:before,.ion-flash:before,.ion-folder:before,.ion-fork-repo:before,.ion-fork:before,.ion-forward:before,.ion-funnel:before,.ion-gear-a:before,.ion-gear-b:before,.ion-grid:before,.ion-hammer:before,.ion-happy-outline:before,.ion-happy:before,.ion-headphone:before,.ion-heart-broken:before,.ion-heart:before,.ion-help-buoy:before,.ion-help-circled:before,.ion-help:before,.ion-home:before,.ion-icecream:before,.ion-image:before,.ion-images:before,.ion-information-circled:before,.ion-information:before,.ion-ionic:before,.ion-ios-alarm-outline:before,.ion-ios-alarm:before,.ion-ios-albums-outline:before,.ion-ios-albums:before,.ion-ios-americanfootball-outline:before,.ion-ios-americanfootball:before,.ion-ios-analytics-outline:before,.ion-ios-analytics:before,.ion-ios-arrow-back:before,.ion-ios-arrow-down:before,.ion-ios-arrow-forward:before,.ion-ios-arrow-left:before,.ion-ios-arrow-right:before,.ion-ios-arrow-thin-down:before,.ion-ios-arrow-thin-left:before,.ion-ios-arrow-thin-right:before,.ion-ios-arrow-thin-up:before,.ion-ios-arrow-up:before,.ion-ios-at-outline:before,.ion-ios-at:before,.ion-ios-barcode-outline:before,.ion-ios-barcode:before,.ion-ios-baseball-outline:before,.ion-ios-baseball:before,.ion-ios-basketball-outline:before,.ion-ios-basketball:before,.ion-ios-bell-outline:before,.ion-ios-bell:before,.ion-ios-body-outline:before,.ion-ios-body:before,.ion-ios-bolt-outline:before,.ion-ios-bolt:before,.ion-ios-book-outline:before,.ion-ios-book:before,.ion-ios-bookmarks-outline:before,.ion-ios-bookmarks:before,.ion-ios-box-outline:before,.ion-ios-box:before,.ion-ios-briefcase-outline:before,.ion-ios-briefcase:before,.ion-ios-browsers-outline:before,.ion-ios-browsers:before,.ion-ios-calculator-outline:before,.ion-ios-calculator:before,.ion-ios-calendar-outline:before,.ion-ios-calendar:before,.ion-ios-camera-outline:before,.ion-ios-camera:before,.ion-ios-cart-outline:before,.ion-ios-cart:before,.ion-ios-chatboxes-outline:before,.ion-ios-chatboxes:before,.ion-ios-chatbubble-outline:before,.ion-ios-chatbubble:before,.ion-ios-checkmark-empty:before,.ion-ios-checkmark-outline:before,.ion-ios-checkmark:before,.ion-ios-circle-filled:before,.ion-ios-circle-outline:before,.ion-ios-clock-outline:before,.ion-ios-clock:before,.ion-ios-close-empty:before,.ion-ios-close-outline:before,.ion-ios-close:before,.ion-ios-cloud-download-outline:before,.ion-ios-cloud-download:before,.ion-ios-cloud-outline:before,.ion-ios-cloud-upload-outline:before,.ion-ios-cloud-upload:before,.ion-ios-cloud:before,.ion-ios-cloudy-night-outline:before,.ion-ios-cloudy-night:before,.ion-ios-cloudy-outline:before,.ion-ios-cloudy:before,.ion-ios-cog-outline:before,.ion-ios-cog:before,.ion-ios-color-filter-outline:before,.ion-ios-color-filter:before,.ion-ios-color-wand-outline:before,.ion-ios-color-wand:before,.ion-ios-compose-outline:before,.ion-ios-compose:before,.ion-ios-contact-outline:before,.ion-ios-contact:before,.ion-ios-copy-outline:before,.ion-ios-copy:before,.ion-ios-crop-strong:before,.ion-ios-crop:before,.ion-ios-download-outline:before,.ion-ios-download:before,.ion-ios-drag:before,.ion-ios-email-outline:before,.ion-ios-email:before,.ion-ios-eye-outline:before,.ion-ios-eye:before,.ion-ios-fastforward-outline:before,.ion-ios-fastforward:before,.ion-ios-filing-outline:before,.ion-ios-filing:before,.ion-ios-film-outline:before,.ion-ios-film:before,.ion-ios-flag-outline:before,.ion-ios-flag:before,.ion-ios-flame-outline:before,.ion-ios-flame:before,.ion-ios-flask-outline:before,.ion-ios-flask:before,.ion-ios-flower-outline:before,.ion-ios-flower:before,.ion-ios-folder-outline:before,.ion-ios-folder:before,.ion-ios-football-outline:before,.ion-ios-football:before,.ion-ios-game-controller-a-outline:before,.ion-ios-game-controller-a:before,.ion-ios-game-controller-b-outline:before,.ion-ios-game-controller-b:before,.ion-ios-gear-outline:before,.ion-ios-gear:before,.ion-ios-glasses-outline:before,.ion-ios-glasses:before,.ion-ios-grid-view-outline:before,.ion-ios-grid-view:before,.ion-ios-heart-outline:before,.ion-ios-heart:before,.ion-ios-help-empty:before,.ion-ios-help-outline:before,.ion-ios-help:before,.ion-ios-home-outline:before,.ion-ios-home:before,.ion-ios-infinite-outline:before,.ion-ios-infinite:before,.ion-ios-information-empty:before,.ion-ios-information-outline:before,.ion-ios-information:before,.ion-ios-ionic-outline:before,.ion-ios-keypad-outline:before,.ion-ios-keypad:before,.ion-ios-lightbulb-outline:before,.ion-ios-lightbulb:before,.ion-ios-list-outline:before,.ion-ios-list:before,.ion-ios-location-outline:before,.ion-ios-location:before,.ion-ios-locked-outline:before,.ion-ios-locked:before,.ion-ios-loop-strong:before,.ion-ios-loop:before,.ion-ios-medical-outline:before,.ion-ios-medical:before,.ion-ios-medkit-outline:before,.ion-ios-medkit:before,.ion-ios-mic-off:before,.ion-ios-mic-outline:before,.ion-ios-mic:before,.ion-ios-minus-empty:before,.ion-ios-minus-outline:before,.ion-ios-minus:before,.ion-ios-monitor-outline:before,.ion-ios-monitor:before,.ion-ios-moon-outline:before,.ion-ios-moon:before,.ion-ios-more-outline:before,.ion-ios-more:before,.ion-ios-musical-note:before,.ion-ios-musical-notes:before,.ion-ios-navigate-outline:before,.ion-ios-navigate:before,.ion-ios-nutrition-outline:before,.ion-ios-nutrition:before,.ion-ios-paper-outline:before,.ion-ios-paper:before,.ion-ios-paperplane-outline:before,.ion-ios-paperplane:before,.ion-ios-partlysunny-outline:before,.ion-ios-partlysunny:before,.ion-ios-pause-outline:before,.ion-ios-pause:before,.ion-ios-paw-outline:before,.ion-ios-paw:before,.ion-ios-people-outline:before,.ion-ios-people:before,.ion-ios-person-outline:before,.ion-ios-person:before,.ion-ios-personadd-outline:before,.ion-ios-personadd:before,.ion-ios-photos-outline:before,.ion-ios-photos:before,.ion-ios-pie-outline:before,.ion-ios-pie:before,.ion-ios-pint-outline:before,.ion-ios-pint:before,.ion-ios-play-outline:before,.ion-ios-play:before,.ion-ios-plus-empty:before,.ion-ios-plus-outline:before,.ion-ios-plus:before,.ion-ios-pricetag-outline:before,.ion-ios-pricetag:before,.ion-ios-pricetags-outline:before,.ion-ios-pricetags:before,.ion-ios-printer-outline:before,.ion-ios-printer:before,.ion-ios-pulse-strong:before,.ion-ios-pulse:before,.ion-ios-rainy-outline:before,.ion-ios-rainy:before,.ion-ios-recording-outline:before,.ion-ios-recording:before,.ion-ios-redo-outline:before,.ion-ios-redo:before,.ion-ios-refresh-empty:before,.ion-ios-refresh-outline:before,.ion-ios-refresh:before,.ion-ios-reload:before,.ion-ios-reverse-camera-outline:before,.ion-ios-reverse-camera:before,.ion-ios-rewind-outline:before,.ion-ios-rewind:before,.ion-ios-rose-outline:before,.ion-ios-rose:before,.ion-ios-search-strong:before,.ion-ios-search:before,.ion-ios-settings-strong:before,.ion-ios-settings:before,.ion-ios-shuffle-strong:before,.ion-ios-shuffle:before,.ion-ios-skipbackward-outline:before,.ion-ios-skipbackward:before,.ion-ios-skipforward-outline:before,.ion-ios-skipforward:before,.ion-ios-snowy:before,.ion-ios-speedometer-outline:before,.ion-ios-speedometer:before,.ion-ios-star-half:before,.ion-ios-star-outline:before,.ion-ios-star:before,.ion-ios-stopwatch-outline:before,.ion-ios-stopwatch:before,.ion-ios-sunny-outline:before,.ion-ios-sunny:before,.ion-ios-telephone-outline:before,.ion-ios-telephone:before,.ion-ios-tennisball-outline:before,.ion-ios-tennisball:before,.ion-ios-thunderstorm-outline:before,.ion-ios-thunderstorm:before,.ion-ios-time-outline:before,.ion-ios-time:before,.ion-ios-timer-outline:before,.ion-ios-timer:before,.ion-ios-toggle-outline:before,.ion-ios-toggle:before,.ion-ios-trash-outline:before,.ion-ios-trash:before,.ion-ios-undo-outline:before,.ion-ios-undo:before,.ion-ios-unlocked-outline:before,.ion-ios-unlocked:before,.ion-ios-upload-outline:before,.ion-ios-upload:before,.ion-ios-videocam-outline:before,.ion-ios-videocam:before,.ion-ios-volume-high:before,.ion-ios-volume-low:before,.ion-ios-wineglass-outline:before,.ion-ios-wineglass:before,.ion-ios-world-outline:before,.ion-ios-world:before,.ion-ipad:before,.ion-iphone:before,.ion-ipod:before,.ion-jet:before,.ion-key:before,.ion-knife:before,.ion-laptop:before,.ion-leaf:before,.ion-levels:before,.ion-lightbulb:before,.ion-link:before,.ion-load-a:before,.ion-load-b:before,.ion-load-c:before,.ion-load-d:before,.ion-location:before,.ion-lock-combination:before,.ion-locked:before,.ion-log-in:before,.ion-log-out:before,.ion-loop:before,.ion-magnet:before,.ion-male:before,.ion-man:before,.ion-map:before,.ion-medkit:before,.ion-merge:before,.ion-mic-a:before,.ion-mic-b:before,.ion-mic-c:before,.ion-minus-circled:before,.ion-minus-round:before,.ion-minus:before,.ion-model-s:before,.ion-monitor:before,.ion-more:before,.ion-mouse:before,.ion-music-note:before,.ion-navicon-round:before,.ion-navicon:before,.ion-navigate:before,.ion-network:before,.ion-no-smoking:before,.ion-nuclear:before,.ion-outlet:before,.ion-paintbrush:before,.ion-paintbucket:before,.ion-paper-airplane:before,.ion-paperclip:before,.ion-pause:before,.ion-person-add:before,.ion-person-stalker:before,.ion-person:before,.ion-pie-graph:before,.ion-pin:before,.ion-pinpoint:before,.ion-pizza:before,.ion-plane:before,.ion-planet:before,.ion-play:before,.ion-playstation:before,.ion-plus-circled:before,.ion-plus-round:before,.ion-plus:before,.ion-podium:before,.ion-pound:before,.ion-power:before,.ion-pricetag:before,.ion-pricetags:before,.ion-printer:before,.ion-pull-request:before,.ion-qr-scanner:before,.ion-quote:before,.ion-radio-waves:before,.ion-record:before,.ion-refresh:before,.ion-reply-all:before,.ion-reply:before,.ion-ribbon-a:before,.ion-ribbon-b:before,.ion-sad-outline:before,.ion-sad:before,.ion-scissors:before,.ion-search:before,.ion-settings:before,.ion-share:before,.ion-shuffle:before,.ion-skip-backward:before,.ion-skip-forward:before,.ion-social-android-outline:before,.ion-social-android:before,.ion-social-angular-outline:before,.ion-social-angular:before,.ion-social-apple-outline:before,.ion-social-apple:before,.ion-social-bitcoin-outline:before,.ion-social-bitcoin:before,.ion-social-buffer-outline:before,.ion-social-buffer:before,.ion-social-chrome-outline:before,.ion-social-chrome:before,.ion-social-codepen-outline:before,.ion-social-codepen:before,.ion-social-css3-outline:before,.ion-social-css3:before,.ion-social-designernews-outline:before,.ion-social-designernews:before,.ion-social-dribbble-outline:before,.ion-social-dribbble:before,.ion-social-dropbox-outline:before,.ion-social-dropbox:before,.ion-social-euro-outline:before,.ion-social-euro:before,.ion-social-facebook-outline:before,.ion-social-facebook:before,.ion-social-foursquare-outline:before,.ion-social-foursquare:before,.ion-social-freebsd-devil:before,.ion-social-github-outline:before,.ion-social-github:before,.ion-social-google-outline:before,.ion-social-google:before,.ion-social-googleplus-outline:before,.ion-social-googleplus:before,.ion-social-hackernews-outline:before,.ion-social-hackernews:before,.ion-social-html5-outline:before,.ion-social-html5:before,.ion-social-instagram-outline:before,.ion-social-instagram:before,.ion-social-javascript-outline:before,.ion-social-javascript:before,.ion-social-linkedin-outline:before,.ion-social-linkedin:before,.ion-social-markdown:before,.ion-social-nodejs:before,.ion-social-octocat:before,.ion-social-pinterest-outline:before,.ion-social-pinterest:before,.ion-social-python:before,.ion-social-reddit-outline:before,.ion-social-reddit:before,.ion-social-rss-outline:before,.ion-social-rss:before,.ion-social-sass:before,.ion-social-skype-outline:before,.ion-social-skype:before,.ion-social-snapchat-outline:before,.ion-social-snapchat:before,.ion-social-tumblr-outline:before,.ion-social-tumblr:before,.ion-social-tux:before,.ion-social-twitch-outline:before,.ion-social-twitch:before,.ion-social-twitter-outline:before,.ion-social-twitter:before,.ion-social-usd-outline:before,.ion-social-usd:before,.ion-social-vimeo-outline:before,.ion-social-vimeo:before,.ion-social-whatsapp-outline:before,.ion-social-whatsapp:before,.ion-social-windows-outline:before,.ion-social-windows:before,.ion-social-wordpress-outline:before,.ion-social-wordpress:before,.ion-social-yahoo-outline:before,.ion-social-yahoo:before,.ion-social-yen-outline:before,.ion-social-yen:before,.ion-social-youtube-outline:before,.ion-social-youtube:before,.ion-soup-can-outline:before,.ion-soup-can:before,.ion-speakerphone:before,.ion-speedometer:before,.ion-spoon:before,.ion-star:before,.ion-stats-bars:before,.ion-steam:before,.ion-stop:before,.ion-thermometer:before,.ion-thumbsdown:before,.ion-thumbsup:before,.ion-toggle-filled:before,.ion-toggle:before,.ion-transgender:before,.ion-trash-a:before,.ion-trash-b:before,.ion-trophy:before,.ion-tshirt-outline:before,.ion-tshirt:before,.ion-umbrella:before,.ion-university:before,.ion-unlocked:before,.ion-upload:before,.ion-usb:before,.ion-videocamera:before,.ion-volume-high:before,.ion-volume-low:before,.ion-volume-medium:before,.ion-volume-mute:before,.ion-wand:before,.ion-waterdrop:before,.ion-wifi:before,.ion-wineglass:before,.ion-woman:before,.ion-wrench:before,.ion-xbox:before,.ionicons{display:inline-block;font-family:Ionicons;speak:none;font-style:normal;font-weight:400;font-variant:normal;text-transform:none;text-rendering:auto;line-height:1;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.ion-alert:before{content:\"\"}.ion-alert-circled:before{content:\"\"}.ion-android-add:before{content:\"\"}.ion-android-add-circle:before{content:\"\"}.ion-android-alarm-clock:before{content:\"\"}.ion-android-alert:before{content:\"\"}.ion-android-apps:before{content:\"\"}.ion-android-archive:before{content:\"\"}.ion-android-arrow-back:before{content:\"\"}.ion-android-arrow-down:before{content:\"\"}.ion-android-arrow-dropdown:before{content:\"\"}.ion-android-arrow-dropdown-circle:before{content:\"\"}.ion-android-arrow-dropleft:before{content:\"\"}.ion-android-arrow-dropleft-circle:before{content:\"\"}.ion-android-arrow-dropright:before{content:\"\"}.ion-android-arrow-dropright-circle:before{content:\"\"}.ion-android-arrow-dropup:before{content:\"\"}.ion-android-arrow-dropup-circle:before{content:\"\"}.ion-android-arrow-forward:before{content:\"\"}.ion-android-arrow-up:before{content:\"\"}.ion-android-attach:before{content:\"\"}.ion-android-bar:before{content:\"\"}.ion-android-bicycle:before{content:\"\"}.ion-android-boat:before{content:\"\"}.ion-android-bookmark:before{content:\"\"}.ion-android-bulb:before{content:\"\"}.ion-android-bus:before{content:\"\"}.ion-android-calendar:before{content:\"\"}.ion-android-call:before{content:\"\"}.ion-android-camera:before{content:\"\"}.ion-android-cancel:before{content:\"\"}.ion-android-car:before{content:\"\"}.ion-android-cart:before{content:\"\"}.ion-android-chat:before{content:\"\"}.ion-android-checkbox:before{content:\"\"}.ion-android-checkbox-blank:before{content:\"\"}.ion-android-checkbox-outline:before{content:\"\"}.ion-android-checkbox-outline-blank:before{content:\"\"}.ion-android-checkmark-circle:before{content:\"\"}.ion-android-clipboard:before{content:\"\"}.ion-android-close:before{content:\"\"}.ion-android-cloud:before{content:\"\"}.ion-android-cloud-circle:before{content:\"\"}.ion-android-cloud-done:before{content:\"\"}.ion-android-cloud-outline:before{content:\"\"}.ion-android-color-palette:before{content:\"\"}.ion-android-compass:before{content:\"\"}.ion-android-contact:before{content:\"\"}.ion-android-contacts:before{content:\"\"}.ion-android-contract:before{content:\"\"}.ion-android-create:before{content:\"\"}.ion-android-delete:before{content:\"\"}.ion-android-desktop:before{content:\"\"}.ion-android-document:before{content:\"\"}.ion-android-done:before{content:\"\"}.ion-android-done-all:before{content:\"\"}.ion-android-download:before{content:\"\"}.ion-android-drafts:before{content:\"\"}.ion-android-exit:before{content:\"\"}.ion-android-expand:before{content:\"\"}.ion-android-favorite:before{content:\"\"}.ion-android-favorite-outline:before{content:\"\"}.ion-android-film:before{content:\"\"}.ion-android-folder:before{content:\"\"}.ion-android-folder-open:before{content:\"\"}.ion-android-funnel:before{content:\"\"}.ion-android-globe:before{content:\"\"}.ion-android-hand:before{content:\"\"}.ion-android-hangout:before{content:\"\"}.ion-android-happy:before{content:\"\"}.ion-android-home:before{content:\"\"}.ion-android-image:before{content:\"\"}.ion-android-laptop:before{content:\"\"}.ion-android-list:before{content:\"\"}.ion-android-locate:before{content:\"\"}.ion-android-lock:before{content:\"\"}.ion-android-mail:before{content:\"\"}.ion-android-map:before{content:\"\"}.ion-android-menu:before{content:\"\"}.ion-android-microphone:before{content:\"\"}.ion-android-microphone-off:before{content:\"\"}.ion-android-more-horizontal:before{content:\"\"}.ion-android-more-vertical:before{content:\"\"}.ion-android-navigate:before{content:\"\"}.ion-android-notifications:before{content:\"\"}.ion-android-notifications-none:before{content:\"\"}.ion-android-notifications-off:before{content:\"\"}.ion-android-open:before{content:\"\"}.ion-android-options:before{content:\"\"}.ion-android-people:before{content:\"\"}.ion-android-person:before{content:\"\"}.ion-android-person-add:before{content:\"\"}.ion-android-phone-landscape:before{content:\"\"}.ion-android-phone-portrait:before{content:\"\"}.ion-android-pin:before{content:\"\"}.ion-android-plane:before{content:\"\"}.ion-android-playstore:before{content:\"\"}.ion-android-print:before{content:\"\"}.ion-android-radio-button-off:before{content:\"\"}.ion-android-radio-button-on:before{content:\"\"}.ion-android-refresh:before{content:\"\"}.ion-android-remove:before{content:\"\"}.ion-android-remove-circle:before{content:\"\"}.ion-android-restaurant:before{content:\"\"}.ion-android-sad:before{content:\"\"}.ion-android-search:before{content:\"\"}.ion-android-send:before{content:\"\"}.ion-android-settings:before{content:\"\"}.ion-android-share:before{content:\"\"}.ion-android-share-alt:before{content:\"\"}.ion-android-star:before{content:\"\"}.ion-android-star-half:before{content:\"\"}.ion-android-star-outline:before{content:\"\"}.ion-android-stopwatch:before{content:\"\"}.ion-android-subway:before{content:\"\"}.ion-android-sunny:before{content:\"\"}.ion-android-sync:before{content:\"\"}.ion-android-textsms:before{content:\"\"}.ion-android-time:before{content:\"\"}.ion-android-train:before{content:\"\"}.ion-android-unlock:before{content:\"\"}.ion-android-upload:before{content:\"\"}.ion-android-volume-down:before{content:\"\"}.ion-android-volume-mute:before{content:\"\"}.ion-android-volume-off:before{content:\"\"}.ion-android-volume-up:before{content:\"\"}.ion-android-walk:before{content:\"\"}.ion-android-warning:before{content:\"\"}.ion-android-watch:before{content:\"\"}.ion-android-wifi:before{content:\"\"}.ion-aperture:before{content:\"\"}.ion-archive:before{content:\"\"}.ion-arrow-down-a:before{content:\"\"}.ion-arrow-down-b:before{content:\"\"}.ion-arrow-down-c:before{content:\"\"}.ion-arrow-expand:before{content:\"\"}.ion-arrow-graph-down-left:before{content:\"\"}.ion-arrow-graph-down-right:before{content:\"\"}.ion-arrow-graph-up-left:before{content:\"\"}.ion-arrow-graph-up-right:before{content:\"\"}.ion-arrow-left-a:before{content:\"\"}.ion-arrow-left-b:before{content:\"\"}.ion-arrow-left-c:before{content:\"\"}.ion-arrow-move:before{content:\"\"}.ion-arrow-resize:before{content:\"\"}.ion-arrow-return-left:before{content:\"\"}.ion-arrow-return-right:before{content:\"\"}.ion-arrow-right-a:before{content:\"\"}.ion-arrow-right-b:before{content:\"\"}.ion-arrow-right-c:before{content:\"\"}.ion-arrow-shrink:before{content:\"\"}.ion-arrow-swap:before{content:\"\"}.ion-arrow-up-a:before{content:\"\"}.ion-arrow-up-b:before{content:\"\"}.ion-arrow-up-c:before{content:\"\"}.ion-asterisk:before{content:\"\"}.ion-at:before{content:\"\"}.ion-backspace:before{content:\"\"}.ion-backspace-outline:before{content:\"\"}.ion-bag:before{content:\"\"}.ion-battery-charging:before{content:\"\"}.ion-battery-empty:before{content:\"\"}.ion-battery-full:before{content:\"\"}.ion-battery-half:before{content:\"\"}.ion-battery-low:before{content:\"\"}.ion-beaker:before{content:\"\"}.ion-beer:before{content:\"\"}.ion-bluetooth:before{content:\"\"}.ion-bonfire:before{content:\"\"}.ion-bookmark:before{content:\"\"}.ion-bowtie:before{content:\"\"}.ion-briefcase:before{content:\"\"}.ion-bug:before{content:\"\"}.ion-calculator:before{content:\"\"}.ion-calendar:before{content:\"\"}.ion-camera:before{content:\"\"}.ion-card:before{content:\"\"}.ion-cash:before{content:\"\"}.ion-chatbox:before{content:\"\"}.ion-chatbox-working:before{content:\"\"}.ion-chatboxes:before{content:\"\"}.ion-chatbubble:before{content:\"\"}.ion-chatbubble-working:before{content:\"\"}.ion-chatbubbles:before{content:\"\"}.ion-checkmark:before{content:\"\"}.ion-checkmark-circled:before{content:\"\"}.ion-checkmark-round:before{content:\"\"}.ion-chevron-down:before{content:\"\"}.ion-chevron-left:before{content:\"\"}.ion-chevron-right:before{content:\"\"}.ion-chevron-up:before{content:\"\"}.ion-clipboard:before{content:\"\"}.ion-clock:before{content:\"\"}.ion-close:before{content:\"\"}.ion-close-circled:before{content:\"\"}.ion-close-round:before{content:\"\"}.ion-closed-captioning:before{content:\"\"}.ion-cloud:before{content:\"\"}.ion-code:before{content:\"\"}.ion-code-download:before{content:\"\"}.ion-code-working:before{content:\"\"}.ion-coffee:before{content:\"\"}.ion-compass:before{content:\"\"}.ion-compose:before{content:\"\"}.ion-connection-bars:before{content:\"\"}.ion-contrast:before{content:\"\"}.ion-crop:before{content:\"\"}.ion-cube:before{content:\"\"}.ion-disc:before{content:\"\"}.ion-document:before{content:\"\"}.ion-document-text:before{content:\"\"}.ion-drag:before{content:\"\"}.ion-earth:before{content:\"\"}.ion-easel:before{content:\"\"}.ion-edit:before{content:\"\"}.ion-egg:before{content:\"\"}.ion-eject:before{content:\"\"}.ion-email:before{content:\"\"}.ion-email-unread:before{content:\"\"}.ion-erlenmeyer-flask:before{content:\"\"}.ion-erlenmeyer-flask-bubbles:before{content:\"\"}.ion-eye:before{content:\"\"}.ion-eye-disabled:before{content:\"\"}.ion-female:before{content:\"\"}.ion-filing:before{content:\"\"}.ion-film-marker:before{content:\"\"}.ion-fireball:before{content:\"\"}.ion-flag:before{content:\"\"}.ion-flame:before{content:\"\"}.ion-flash:before{content:\"\"}.ion-flash-off:before{content:\"\"}.ion-folder:before{content:\"\"}.ion-fork:before{content:\"\"}.ion-fork-repo:before{content:\"\"}.ion-forward:before{content:\"\"}.ion-funnel:before{content:\"\"}.ion-gear-a:before{content:\"\"}.ion-gear-b:before{content:\"\"}.ion-grid:before{content:\"\"}.ion-hammer:before{content:\"\"}.ion-happy:before{content:\"\"}.ion-happy-outline:before{content:\"\"}.ion-headphone:before{content:\"\"}.ion-heart:before{content:\"\"}.ion-heart-broken:before{content:\"\"}.ion-help:before{content:\"\"}.ion-help-buoy:before{content:\"\"}.ion-help-circled:before{content:\"\"}.ion-home:before{content:\"\"}.ion-icecream:before{content:\"\"}.ion-image:before{content:\"\"}.ion-images:before{content:\"\"}.ion-information:before{content:\"\"}.ion-information-circled:before{content:\"\"}.ion-ionic:before{content:\"\"}.ion-ios-alarm:before{content:\"\"}.ion-ios-alarm-outline:before{content:\"\"}.ion-ios-albums:before{content:\"\"}.ion-ios-albums-outline:before{content:\"\"}.ion-ios-americanfootball:before{content:\"\"}.ion-ios-americanfootball-outline:before{content:\"\"}.ion-ios-analytics:before{content:\"\"}.ion-ios-analytics-outline:before{content:\"\"}.ion-ios-arrow-back:before{content:\"\"}.ion-ios-arrow-down:before{content:\"\"}.ion-ios-arrow-forward:before{content:\"\"}.ion-ios-arrow-left:before{content:\"\"}.ion-ios-arrow-right:before{content:\"\"}.ion-ios-arrow-thin-down:before{content:\"\"}.ion-ios-arrow-thin-left:before{content:\"\"}.ion-ios-arrow-thin-right:before{content:\"\"}.ion-ios-arrow-thin-up:before{content:\"\"}.ion-ios-arrow-up:before{content:\"\"}.ion-ios-at:before{content:\"\"}.ion-ios-at-outline:before{content:\"\"}.ion-ios-barcode:before{content:\"\"}.ion-ios-barcode-outline:before{content:\"\"}.ion-ios-baseball:before{content:\"\"}.ion-ios-baseball-outline:before{content:\"\"}.ion-ios-basketball:before{content:\"\"}.ion-ios-basketball-outline:before{content:\"\"}.ion-ios-bell:before{content:\"\"}.ion-ios-bell-outline:before{content:\"\"}.ion-ios-body:before{content:\"\"}.ion-ios-body-outline:before{content:\"\"}.ion-ios-bolt:before{content:\"\"}.ion-ios-bolt-outline:before{content:\"\"}.ion-ios-book:before{content:\"\"}.ion-ios-book-outline:before{content:\"\"}.ion-ios-bookmarks:before{content:\"\"}.ion-ios-bookmarks-outline:before{content:\"\"}.ion-ios-box:before{content:\"\"}.ion-ios-box-outline:before{content:\"\"}.ion-ios-briefcase:before{content:\"\"}.ion-ios-briefcase-outline:before{content:\"\"}.ion-ios-browsers:before{content:\"\"}.ion-ios-browsers-outline:before{content:\"\"}.ion-ios-calculator:before{content:\"\"}.ion-ios-calculator-outline:before{content:\"\"}.ion-ios-calendar:before{content:\"\"}.ion-ios-calendar-outline:before{content:\"\"}.ion-ios-camera:before{content:\"\"}.ion-ios-camera-outline:before{content:\"\"}.ion-ios-cart:before{content:\"\"}.ion-ios-cart-outline:before{content:\"\"}.ion-ios-chatboxes:before{content:\"\"}.ion-ios-chatboxes-outline:before{content:\"\"}.ion-ios-chatbubble:before{content:\"\"}.ion-ios-chatbubble-outline:before{content:\"\"}.ion-ios-checkmark:before{content:\"\"}.ion-ios-checkmark-empty:before{content:\"\"}.ion-ios-checkmark-outline:before{content:\"\"}.ion-ios-circle-filled:before{content:\"\"}.ion-ios-circle-outline:before{content:\"\"}.ion-ios-clock:before{content:\"\"}.ion-ios-clock-outline:before{content:\"\"}.ion-ios-close:before{content:\"\"}.ion-ios-close-empty:before{content:\"\"}.ion-ios-close-outline:before{content:\"\"}.ion-ios-cloud:before{content:\"\"}.ion-ios-cloud-download:before{content:\"\"}.ion-ios-cloud-download-outline:before{content:\"\"}.ion-ios-cloud-outline:before{content:\"\"}.ion-ios-cloud-upload:before{content:\"\"}.ion-ios-cloud-upload-outline:before{content:\"\"}.ion-ios-cloudy:before{content:\"\"}.ion-ios-cloudy-night:before{content:\"\"}.ion-ios-cloudy-night-outline:before{content:\"\"}.ion-ios-cloudy-outline:before{content:\"\"}.ion-ios-cog:before{content:\"\"}.ion-ios-cog-outline:before{content:\"\"}.ion-ios-color-filter:before{content:\"\"}.ion-ios-color-filter-outline:before{content:\"\"}.ion-ios-color-wand:before{content:\"\"}.ion-ios-color-wand-outline:before{content:\"\"}.ion-ios-compose:before{content:\"\"}.ion-ios-compose-outline:before{content:\"\"}.ion-ios-contact:before{content:\"\"}.ion-ios-contact-outline:before{content:\"\"}.ion-ios-copy:before{content:\"\"}.ion-ios-copy-outline:before{content:\"\"}.ion-ios-crop:before{content:\"\"}.ion-ios-crop-strong:before{content:\"\"}.ion-ios-download:before{content:\"\"}.ion-ios-download-outline:before{content:\"\"}.ion-ios-drag:before{content:\"\"}.ion-ios-email:before{content:\"\"}.ion-ios-email-outline:before{content:\"\"}.ion-ios-eye:before{content:\"\"}.ion-ios-eye-outline:before{content:\"\"}.ion-ios-fastforward:before{content:\"\"}.ion-ios-fastforward-outline:before{content:\"\"}.ion-ios-filing:before{content:\"\"}.ion-ios-filing-outline:before{content:\"\"}.ion-ios-film:before{content:\"\"}.ion-ios-film-outline:before{content:\"\"}.ion-ios-flag:before{content:\"\"}.ion-ios-flag-outline:before{content:\"\"}.ion-ios-flame:before{content:\"\"}.ion-ios-flame-outline:before{content:\"\"}.ion-ios-flask:before{content:\"\"}.ion-ios-flask-outline:before{content:\"\"}.ion-ios-flower:before{content:\"\"}.ion-ios-flower-outline:before{content:\"\"}.ion-ios-folder:before{content:\"\"}.ion-ios-folder-outline:before{content:\"\"}.ion-ios-football:before{content:\"\"}.ion-ios-football-outline:before{content:\"\"}.ion-ios-game-controller-a:before{content:\"\"}.ion-ios-game-controller-a-outline:before{content:\"\"}.ion-ios-game-controller-b:before{content:\"\"}.ion-ios-game-controller-b-outline:before{content:\"\"}.ion-ios-gear:before{content:\"\"}.ion-ios-gear-outline:before{content:\"\"}.ion-ios-glasses:before{content:\"\"}.ion-ios-glasses-outline:before{content:\"\"}.ion-ios-grid-view:before{content:\"\"}.ion-ios-grid-view-outline:before{content:\"\"}.ion-ios-heart:before{content:\"\"}.ion-ios-heart-outline:before{content:\"\"}.ion-ios-help:before{content:\"\"}.ion-ios-help-empty:before{content:\"\"}.ion-ios-help-outline:before{content:\"\"}.ion-ios-home:before{content:\"\"}.ion-ios-home-outline:before{content:\"\"}.ion-ios-infinite:before{content:\"\"}.ion-ios-infinite-outline:before{content:\"\"}.ion-ios-information:before{content:\"\"}.ion-ios-information-empty:before{content:\"\"}.ion-ios-information-outline:before{content:\"\"}.ion-ios-ionic-outline:before{content:\"\"}.ion-ios-keypad:before{content:\"\"}.ion-ios-keypad-outline:before{content:\"\"}.ion-ios-lightbulb:before{content:\"\"}.ion-ios-lightbulb-outline:before{content:\"\"}.ion-ios-list:before{content:\"\"}.ion-ios-list-outline:before{content:\"\"}.ion-ios-location:before{content:\"\"}.ion-ios-location-outline:before{content:\"\"}.ion-ios-locked:before{content:\"\"}.ion-ios-locked-outline:before{content:\"\"}.ion-ios-loop:before{content:\"\"}.ion-ios-loop-strong:before{content:\"\"}.ion-ios-medical:before{content:\"\"}.ion-ios-medical-outline:before{content:\"\"}.ion-ios-medkit:before{content:\"\"}.ion-ios-medkit-outline:before{content:\"\"}.ion-ios-mic:before{content:\"\"}.ion-ios-mic-off:before{content:\"\"}.ion-ios-mic-outline:before{content:\"\"}.ion-ios-minus:before{content:\"\"}.ion-ios-minus-empty:before{content:\"\"}.ion-ios-minus-outline:before{content:\"\"}.ion-ios-monitor:before{content:\"\"}.ion-ios-monitor-outline:before{content:\"\"}.ion-ios-moon:before{content:\"\"}.ion-ios-moon-outline:before{content:\"\"}.ion-ios-more:before{content:\"\"}.ion-ios-more-outline:before{content:\"\"}.ion-ios-musical-note:before{content:\"\"}.ion-ios-musical-notes:before{content:\"\"}.ion-ios-navigate:before{content:\"\"}.ion-ios-navigate-outline:before{content:\"\"}.ion-ios-nutrition:before{content:\"\"}.ion-ios-nutrition-outline:before{content:\"\"}.ion-ios-paper:before{content:\"\"}.ion-ios-paper-outline:before{content:\"\"}.ion-ios-paperplane:before{content:\"\"}.ion-ios-paperplane-outline:before{content:\"\"}.ion-ios-partlysunny:before{content:\"\"}.ion-ios-partlysunny-outline:before{content:\"\"}.ion-ios-pause:before{content:\"\"}.ion-ios-pause-outline:before{content:\"\"}.ion-ios-paw:before{content:\"\"}.ion-ios-paw-outline:before{content:\"\"}.ion-ios-people:before{content:\"\"}.ion-ios-people-outline:before{content:\"\"}.ion-ios-person:before{content:\"\"}.ion-ios-person-outline:before{content:\"\"}.ion-ios-personadd:before{content:\"\"}.ion-ios-personadd-outline:before{content:\"\"}.ion-ios-photos:before{content:\"\"}.ion-ios-photos-outline:before{content:\"\"}.ion-ios-pie:before{content:\"\"}.ion-ios-pie-outline:before{content:\"\"}.ion-ios-pint:before{content:\"\"}.ion-ios-pint-outline:before{content:\"\"}.ion-ios-play:before{content:\"\"}.ion-ios-play-outline:before{content:\"\"}.ion-ios-plus:before{content:\"\"}.ion-ios-plus-empty:before{content:\"\"}.ion-ios-plus-outline:before{content:\"\"}.ion-ios-pricetag:before{content:\"\"}.ion-ios-pricetag-outline:before{content:\"\"}.ion-ios-pricetags:before{content:\"\"}.ion-ios-pricetags-outline:before{content:\"\"}.ion-ios-printer:before{content:\"\"}.ion-ios-printer-outline:before{content:\"\"}.ion-ios-pulse:before{content:\"\"}.ion-ios-pulse-strong:before{content:\"\"}.ion-ios-rainy:before{content:\"\"}.ion-ios-rainy-outline:before{content:\"\"}.ion-ios-recording:before{content:\"\"}.ion-ios-recording-outline:before{content:\"\"}.ion-ios-redo:before{content:\"\"}.ion-ios-redo-outline:before{content:\"\"}.ion-ios-refresh:before{content:\"\"}.ion-ios-refresh-empty:before{content:\"\"}.ion-ios-refresh-outline:before{content:\"\"}.ion-ios-reload:before{content:\"\"}.ion-ios-reverse-camera:before{content:\"\"}.ion-ios-reverse-camera-outline:before{content:\"\"}.ion-ios-rewind:before{content:\"\"}.ion-ios-rewind-outline:before{content:\"\"}.ion-ios-rose:before{content:\"\"}.ion-ios-rose-outline:before{content:\"\"}.ion-ios-search:before{content:\"\"}.ion-ios-search-strong:before{content:\"\"}.ion-ios-settings:before{content:\"\"}.ion-ios-settings-strong:before{content:\"\"}.ion-ios-shuffle:before{content:\"\"}.ion-ios-shuffle-strong:before{content:\"\"}.ion-ios-skipbackward:before{content:\"\"}.ion-ios-skipbackward-outline:before{content:\"\"}.ion-ios-skipforward:before{content:\"\"}.ion-ios-skipforward-outline:before{content:\"\"}.ion-ios-snowy:before{content:\"\"}.ion-ios-speedometer:before{content:\"\"}.ion-ios-speedometer-outline:before{content:\"\"}.ion-ios-star:before{content:\"\"}.ion-ios-star-half:before{content:\"\"}.ion-ios-star-outline:before{content:\"\"}.ion-ios-stopwatch:before{content:\"\"}.ion-ios-stopwatch-outline:before{content:\"\"}.ion-ios-sunny:before{content:\"\"}.ion-ios-sunny-outline:before{content:\"\"}.ion-ios-telephone:before{content:\"\"}.ion-ios-telephone-outline:before{content:\"\"}.ion-ios-tennisball:before{content:\"\"}.ion-ios-tennisball-outline:before{content:\"\"}.ion-ios-thunderstorm:before{content:\"\"}.ion-ios-thunderstorm-outline:before{content:\"\"}.ion-ios-time:before{content:\"\"}.ion-ios-time-outline:before{content:\"\"}.ion-ios-timer:before{content:\"\"}.ion-ios-timer-outline:before{content:\"\"}.ion-ios-toggle:before{content:\"\"}.ion-ios-toggle-outline:before{content:\"\"}.ion-ios-trash:before{content:\"\"}.ion-ios-trash-outline:before{content:\"\"}.ion-ios-undo:before{content:\"\"}.ion-ios-undo-outline:before{content:\"\"}.ion-ios-unlocked:before{content:\"\"}.ion-ios-unlocked-outline:before{content:\"\"}.ion-ios-upload:before{content:\"\"}.ion-ios-upload-outline:before{content:\"\"}.ion-ios-videocam:before{content:\"\"}.ion-ios-videocam-outline:before{content:\"\"}.ion-ios-volume-high:before{content:\"\"}.ion-ios-volume-low:before{content:\"\"}.ion-ios-wineglass:before{content:\"\"}.ion-ios-wineglass-outline:before{content:\"\"}.ion-ios-world:before{content:\"\"}.ion-ios-world-outline:before{content:\"\"}.ion-ipad:before{content:\"\"}.ion-iphone:before{content:\"\"}.ion-ipod:before{content:\"\"}.ion-jet:before{content:\"\"}.ion-key:before{content:\"\"}.ion-knife:before{content:\"\"}.ion-laptop:before{content:\"\"}.ion-leaf:before{content:\"\"}.ion-levels:before{content:\"\"}.ion-lightbulb:before{content:\"\"}.ion-link:before{content:\"\"}.ion-load-a:before{content:\"\"}.ion-load-b:before{content:\"\"}.ion-load-c:before{content:\"\"}.ion-load-d:before{content:\"\"}.ion-location:before{content:\"\"}.ion-lock-combination:before{content:\"\"}.ion-locked:before{content:\"\"}.ion-log-in:before{content:\"\"}.ion-log-out:before{content:\"\"}.ion-loop:before{content:\"\"}.ion-magnet:before{content:\"\"}.ion-male:before{content:\"\"}.ion-man:before{content:\"\"}.ion-map:before{content:\"\"}.ion-medkit:before{content:\"\"}.ion-merge:before{content:\"\"}.ion-mic-a:before{content:\"\"}.ion-mic-b:before{content:\"\"}.ion-mic-c:before{content:\"\"}.ion-minus:before{content:\"\"}.ion-minus-circled:before{content:\"\"}.ion-minus-round:before{content:\"\"}.ion-model-s:before{content:\"\"}.ion-monitor:before{content:\"\"}.ion-more:before{content:\"\"}.ion-mouse:before{content:\"\"}.ion-music-note:before{content:\"\"}.ion-navicon:before{content:\"\"}.ion-navicon-round:before{content:\"\"}.ion-navigate:before{content:\"\"}.ion-network:before{content:\"\"}.ion-no-smoking:before{content:\"\"}.ion-nuclear:before{content:\"\"}.ion-outlet:before{content:\"\"}.ion-paintbrush:before{content:\"\"}.ion-paintbucket:before{content:\"\"}.ion-paper-airplane:before{content:\"\"}.ion-paperclip:before{content:\"\"}.ion-pause:before{content:\"\"}.ion-person:before{content:\"\"}.ion-person-add:before{content:\"\"}.ion-person-stalker:before{content:\"\"}.ion-pie-graph:before{content:\"\"}.ion-pin:before{content:\"\"}.ion-pinpoint:before{content:\"\"}.ion-pizza:before{content:\"\"}.ion-plane:before{content:\"\"}.ion-planet:before{content:\"\"}.ion-play:before{content:\"\"}.ion-playstation:before{content:\"\"}.ion-plus:before{content:\"\"}.ion-plus-circled:before{content:\"\"}.ion-plus-round:before{content:\"\"}.ion-podium:before{content:\"\"}.ion-pound:before{content:\"\"}.ion-power:before{content:\"\"}.ion-pricetag:before{content:\"\"}.ion-pricetags:before{content:\"\"}.ion-printer:before{content:\"\"}.ion-pull-request:before{content:\"\"}.ion-qr-scanner:before{content:\"\"}.ion-quote:before{content:\"\"}.ion-radio-waves:before{content:\"\"}.ion-record:before{content:\"\"}.ion-refresh:before{content:\"\"}.ion-reply:before{content:\"\"}.ion-reply-all:before{content:\"\"}.ion-ribbon-a:before{content:\"\"}.ion-ribbon-b:before{content:\"\"}.ion-sad:before{content:\"\"}.ion-sad-outline:before{content:\"\"}.ion-scissors:before{content:\"\"}.ion-search:before{content:\"\"}.ion-settings:before{content:\"\"}.ion-share:before{content:\"\"}.ion-shuffle:before{content:\"\"}.ion-skip-backward:before{content:\"\"}.ion-skip-forward:before{content:\"\"}.ion-social-android:before{content:\"\"}.ion-social-android-outline:before{content:\"\"}.ion-social-angular:before{content:\"\"}.ion-social-angular-outline:before{content:\"\"}.ion-social-apple:before{content:\"\"}.ion-social-apple-outline:before{content:\"\"}.ion-social-bitcoin:before{content:\"\"}.ion-social-bitcoin-outline:before{content:\"\"}.ion-social-buffer:before{content:\"\"}.ion-social-buffer-outline:before{content:\"\"}.ion-social-chrome:before{content:\"\"}.ion-social-chrome-outline:before{content:\"\"}.ion-social-codepen:before{content:\"\"}.ion-social-codepen-outline:before{content:\"\"}.ion-social-css3:before{content:\"\"}.ion-social-css3-outline:before{content:\"\"}.ion-social-designernews:before{content:\"\"}.ion-social-designernews-outline:before{content:\"\"}.ion-social-dribbble:before{content:\"\"}.ion-social-dribbble-outline:before{content:\"\"}.ion-social-dropbox:before{content:\"\"}.ion-social-dropbox-outline:before{content:\"\"}.ion-social-euro:before{content:\"\"}.ion-social-euro-outline:before{content:\"\"}.ion-social-facebook:before{content:\"\"}.ion-social-facebook-outline:before{content:\"\"}.ion-social-foursquare:before{content:\"\"}.ion-social-foursquare-outline:before{content:\"\"}.ion-social-freebsd-devil:before{content:\"\"}.ion-social-github:before{content:\"\"}.ion-social-github-outline:before{content:\"\"}.ion-social-google:before{content:\"\"}.ion-social-google-outline:before{content:\"\"}.ion-social-googleplus:before{content:\"\"}.ion-social-googleplus-outline:before{content:\"\"}.ion-social-hackernews:before{content:\"\"}.ion-social-hackernews-outline:before{content:\"\"}.ion-social-html5:before{content:\"\"}.ion-social-html5-outline:before{content:\"\"}.ion-social-instagram:before{content:\"\"}.ion-social-instagram-outline:before{content:\"\"}.ion-social-javascript:before{content:\"\"}.ion-social-javascript-outline:before{content:\"\"}.ion-social-linkedin:before{content:\"\"}.ion-social-linkedin-outline:before{content:\"\"}.ion-social-markdown:before{content:\"\"}.ion-social-nodejs:before{content:\"\"}.ion-social-octocat:before{content:\"\"}.ion-social-pinterest:before{content:\"\"}.ion-social-pinterest-outline:before{content:\"\"}.ion-social-python:before{content:\"\"}.ion-social-reddit:before{content:\"\"}.ion-social-reddit-outline:before{content:\"\"}.ion-social-rss:before{content:\"\"}.ion-social-rss-outline:before{content:\"\"}.ion-social-sass:before{content:\"\"}.ion-social-skype:before{content:\"\"}.ion-social-skype-outline:before{content:\"\"}.ion-social-snapchat:before{content:\"\"}.ion-social-snapchat-outline:before{content:\"\"}.ion-social-tumblr:before{content:\"\"}.ion-social-tumblr-outline:before{content:\"\"}.ion-social-tux:before{content:\"\"}.ion-social-twitch:before{content:\"\"}.ion-social-twitch-outline:before{content:\"\"}.ion-social-twitter:before{content:\"\"}.ion-social-twitter-outline:before{content:\"\"}.ion-social-usd:before{content:\"\"}.ion-social-usd-outline:before{content:\"\"}.ion-social-vimeo:before{content:\"\"}.ion-social-vimeo-outline:before{content:\"\"}.ion-social-whatsapp:before{content:\"\"}.ion-social-whatsapp-outline:before{content:\"\"}.ion-social-windows:before{content:\"\"}.ion-social-windows-outline:before{content:\"\"}.ion-social-wordpress:before{content:\"\"}.ion-social-wordpress-outline:before{content:\"\"}.ion-social-yahoo:before{content:\"\"}.ion-social-yahoo-outline:before{content:\"\"}.ion-social-yen:before{content:\"\"}.ion-social-yen-outline:before{content:\"\"}.ion-social-youtube:before{content:\"\"}.ion-social-youtube-outline:before{content:\"\"}.ion-soup-can:before{content:\"\"}.ion-soup-can-outline:before{content:\"\"}.ion-speakerphone:before{content:\"\"}.ion-speedometer:before{content:\"\"}.ion-spoon:before{content:\"\"}.ion-star:before{content:\"\"}.ion-stats-bars:before{content:\"\"}.ion-steam:before{content:\"\"}.ion-stop:before{content:\"\"}.ion-thermometer:before{content:\"\"}.ion-thumbsdown:before{content:\"\"}.ion-thumbsup:before{content:\"\"}.ion-toggle:before{content:\"\"}.ion-toggle-filled:before{content:\"\"}.ion-transgender:before{content:\"\"}.ion-trash-a:before{content:\"\"}.ion-trash-b:before{content:\"\"}.ion-trophy:before{content:\"\"}.ion-tshirt:before{content:\"\"}.ion-tshirt-outline:before{content:\"\"}.ion-umbrella:before{content:\"\"}.ion-university:before{content:\"\"}.ion-unlocked:before{content:\"\"}.ion-upload:before{content:\"\"}.ion-usb:before{content:\"\"}.ion-videocamera:before{content:\"\"}.ion-volume-high:before{content:\"\"}.ion-volume-low:before{content:\"\"}.ion-volume-medium:before{content:\"\"}.ion-volume-mute:before{content:\"\"}.ion-wand:before{content:\"\"}.ion-waterdrop:before{content:\"\"}.ion-wifi:before{content:\"\"}.ion-wineglass:before{content:\"\"}.ion-woman:before{content:\"\"}.ion-wrench:before{content:\"\"}.ion-xbox:before{content:\"\"}a,abbr,acronym,address,applet,article,aside,audio,b,big,blockquote,body,canvas,caption,center,cite,code,dd,del,details,dfn,div,dl,dt,em,embed,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hgroup,html,i,iframe,img,ins,kbd,label,legend,li,mark,menu,nav,object,ol,output,p,pre,q,ruby,s,samp,section,small,span,strike,strong,sub,summary,sup,table,tbody,td,tfoot,th,thead,time,tr,tt,u,ul,var,video{margin:0;padding:0;border:0;vertical-align:baseline;font:inherit;font-size:100%}ol,ul{list-style:none}blockquote,q{quotes:none}audio:not([controls]){display:none;height:0}[hidden],template{display:none}script{display:none!important}html{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;overflow:hidden;-ms-touch-action:pan-y;touch-action:pan-y}.ionic-body,.scroll,body{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-webkit-text-size-adjust:none;-moz-text-size-adjust:none;text-size-adjust:none;-webkit-touch-callout:none}:focus,a,a:active,a:focus,a:hover,button,button:focus{outline:0}a[href]:hover{cursor:pointer}b,strong{font-weight:700}dfn{font-style:italic}address,cite{font-style:normal}hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}code,kbd,pre,samp{font-size:1em;font-family:monospace,serif}pre{white-space:pre-wrap}q{quotes:\"\\201C\" \"\\201D\" \"\\2018\" \"\\2019\"}sub,sup{font-size:75%;line-height:0}sup{top:-.5em}sub{bottom:-.25em}fieldset{margin:0 2px;padding:.35em .625em .75em;border:1px solid silver}button,input,select,textarea{margin:0;outline-offset:0;outline-style:none;outline-width:0;-webkit-font-smoothing:inherit;background-image:none}button,select{text-transform:none}button,html input[type=button],input[type=reset],input[type=submit]{cursor:pointer;-webkit-appearance:button}button[disabled],html input[disabled]{cursor:default}input[type=search]{-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;-webkit-appearance:textfield}input[type=search]::-webkit-search-cancel-button,input[type=search]::-webkit-search-decoration{-webkit-appearance:none}button::-moz-focus-inner,input::-moz-focus-inner{padding:0;border:0}textarea{overflow:auto}img{-webkit-user-drag:none}table{border-spacing:0;border-collapse:collapse}*,:after,:before{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}.ionic-body,body{-webkit-font-smoothing:antialiased;font-smoothing:antialiased;user-select:none;right:0;margin:0;padding:0;color:#000;word-wrap:break-word;font-size:14px;font-family:-apple-system;font-family:\"-apple-system\",\"Helvetica Neue\",Roboto,\"Segoe UI\",sans-serif;line-height:20px;text-rendering:optimizeLegibility;-webkit-backface-visibility:hidden;-ms-content-zooming:none}.bar.item-input-inset .item-input-wrapper,.scroll-content,.scroll-view{margin-top:-1px}.h1,.h2,.h3,.h4,.h5,.h6,.tab-item,button,h1,h2,h3,h4,h5,h6,input,select,textarea{font-family:\"-apple-system\",\"Helvetica Neue\",Roboto,\"Segoe UI\",sans-serif}body.grade-b,body.grade-c{text-rendering:auto}.scroll-content{position:absolute;right:0;padding-top:1px;margin-bottom:-1px;width:auto;height:auto}.scroll-view,.scroll-view.overflow-scroll{position:relative}.menu .scroll-content.scroll-content-false{z-index:11}.scroll-view{display:block;overflow:hidden}.scroll-view.scroll-x{overflow-x:scroll;overflow-y:hidden}.scroll-view.scroll-y{overflow-x:hidden;overflow-y:scroll}.scroll-view.scroll-xy{overflow-x:scroll;overflow-y:scroll}.overflow-scroll,.overflow-scroll.pane{overflow-x:hidden;overflow-y:scroll}.scroll{user-select:none;-webkit-transform-origin:left top;transform-origin:left top}@-ms-viewport{width:device-width}.scroll-bar{position:absolute;z-index:9999}.pane,.view{z-index:1}.scroll-bar-h{right:2px;bottom:3px;left:2px;height:3px}.scroll-bar-h .scroll-bar-indicator{height:100%}.scroll-bar-v{top:2px;right:3px;bottom:2px;width:3px}.scroll-bar-v .scroll-bar-indicator{width:100%}.scroll-bar-indicator{position:absolute;border-radius:4px;background:rgba(0,0,0,.3);opacity:1;-webkit-transition:opacity .3s linear;transition:opacity .3s linear}.backdrop,.scroll-bar-indicator.scroll-bar-fade-out{opacity:0}.platform-android .scroll-bar-indicator{border-radius:0}.grade-b .scroll-bar-indicator,.grade-c .scroll-bar-indicator{background:#aaa}.grade-b .scroll-bar-indicator.scroll-bar-fade-out,.grade-c .scroll-bar-indicator.scroll-bar-fade-out{-webkit-transition:none;transition:none}ion-infinite-scroll{height:60px;width:100%;display:block;display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-moz-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;-moz-justify-content:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center}ion-infinite-scroll .icon{font-size:30px;color:#666}ion-infinite-scroll:not(.active) .icon:before,ion-infinite-scroll:not(.active) .spinner{display:none}.view-container,address,blockquote small{display:block}.overflow-scroll{-webkit-overflow-scrolling:touch;-ms-overflow-style:-ms-autohiding-scrollbar;top:0;right:0;bottom:0;left:0;position:absolute}.overflow-scroll .scroll{position:static;height:100%}.has-header{top:44px}.no-header{top:0}.has-subheader{top:88px}.has-tabs-top{top:93px}.has-header.has-subheader.has-tabs-top{top:137px}.has-footer{bottom:44px}.has-subfooter{bottom:88px}.bar-footer.has-tabs,.has-tabs{bottom:49px}.bar-footer.has-tabs.pane,.has-tabs.pane{bottom:49px;height:auto}.bar-subfooter.has-tabs,.has-footer.has-tabs{bottom:93px}.action-sheet-wrapper,.pane,.view{bottom:0;left:0;width:100%;right:0}.pane{transform:translate3d(0,0,0);-webkit-transition-duration:0;transition-duration:0}.pane,.view{position:absolute;top:0;height:100%;background-color:#fff;overflow:hidden}.view-container{position:absolute;width:100%;height:100%}p{margin:0 0 10px}small{font-size:85%}.text-left{text-align:left}.text-right{text-align:right}.text-center{text-align:center}.h1,.h2,.h3,.h4,.h5,.h6,h1,h2,h3,h4,h5,h6{color:#000;font-weight:500;line-height:1.2}.h1 small,.h2 small,.h3 small,.h4 small,.h5 small,.h6 small,h1 small,h2 small,h3 small,h4 small,h5 small,h6 small{font-weight:400;line-height:1}address,blockquote small,dd,dt{line-height:1.42857}.h1,.h2,.h3,h1,h2,h3{margin-top:20px;margin-bottom:10px}.h1:first-child,.h2:first-child,.h3:first-child,h1:first-child,h2:first-child,h3:first-child{margin-top:0}.h1+.h1,.h1+.h2,.h1+.h3,.h1+h1,.h1+h2,.h1+h3,.h2+.h1,.h2+.h2,.h2+.h3,.h2+h1,.h2+h2,.h2+h3,.h3+.h1,.h3+.h2,.h3+.h3,.h3+h1,.h3+h2,.h3+h3,h1+.h1,h1+.h2,h1+.h3,h1+h1,h1+h2,h1+h3,h2+.h1,h2+.h2,h2+.h3,h2+h1,h2+h2,h2+h3,h3+.h1,h3+.h2,h3+.h3,h3+h1,h3+h2,h3+h3{margin-top:10px}.h4,.h5,.h6,h4,h5,h6{margin-top:10px;margin-bottom:10px}address,dl{margin-bottom:20px}.h1,h1{font-size:36px}.h2,h2{font-size:30px}.h3,h3{font-size:24px}.h4,h4{font-size:18px}.h5,h5{font-size:14px}.h6,h6{font-size:12px}.h1 small,h1 small{font-size:24px}.h2 small,h2 small{font-size:18px}.h3 small,.h4 small,h3 small,h4 small{font-size:14px}dt{font-weight:700}blockquote{margin:0 0 20px;padding:10px 20px;border-left:5px solid gray}blockquote p{font-weight:300;font-size:17.5px;line-height:1.25}.action-sheet-cancel .button,.bar .title{font-weight:500}blockquote p:last-child{margin-bottom:0}blockquote small:before{content:'\\2014 \\00A0'}blockquote:after,blockquote:before,q:after,q:before{content:\"\"}a{color:#387ef5}a.subdued{padding-right:10px;color:#888;text-decoration:none}a.subdued:hover{text-decoration:none}a.subdued:last-child{padding-right:0}.action-sheet-backdrop{-webkit-transition:background-color 150ms ease-in-out;transition:background-color 150ms ease-in-out;position:fixed;top:0;left:0;z-index:11;width:100%;height:100%;background-color:transparent}.action-sheet-backdrop.active{background-color:rgba(0,0,0,.4)}.action-sheet-wrapper{-webkit-transform:translate3d(0,100%,0);transform:translate3d(0,100%,0);-webkit-transition:all cubic-bezier(.36,.66,.04,1) .5s;transition:all cubic-bezier(.36,.66,.04,1) .5s;position:absolute;max-width:500px;margin:auto}.action-sheet-up{transform:translate3d(0,0,0)}.action-sheet{margin-left:8px;margin-right:8px;width:auto;z-index:11;overflow:hidden}.action-sheet .button{display:block;padding:1px;width:100%;border-radius:0;border-color:#d1d3d6;background-color:transparent;color:#007aff;font-size:21px}.action-sheet .button:hover{color:#007aff}.action-sheet .button.destructive,.action-sheet .button.destructive:hover{color:#ff3b30}.action-sheet .button.activated,.action-sheet .button.active{box-shadow:none;border-color:#d1d3d6;color:#007aff;background:#e4e5e7}.action-sheet-has-icons .icon{position:absolute;left:16px}.action-sheet-title{padding:16px;color:#8f8f8f;text-align:center;font-size:13px}.action-sheet-group{margin-bottom:8px;border-radius:4px;background-color:#fff;overflow:hidden}.action-sheet-group .button{border-width:1px 0 0}.action-sheet-group .button:first-child:last-child,.bar{border-width:0}.action-sheet-options{background:#f1f2f3}.action-sheet-open,.action-sheet-open.modal-open .modal{pointer-events:none}.action-sheet-open .action-sheet-backdrop{pointer-events:auto}.menu-open .menu-content .pane,.menu-open .menu-content .scroll-content,.menu-open .menu-content .scroll-content .scroll,.modal-backdrop-bg,.modal-open{pointer-events:none}.platform-android .action-sheet-backdrop.active{background-color:rgba(0,0,0,.2)}.platform-android .action-sheet{margin:0}.platform-android .action-sheet .action-sheet-title,.platform-android .action-sheet .button{text-align:left;border-color:transparent;font-size:16px;color:inherit}.platform-android .action-sheet .action-sheet-title{font-size:14px;padding:16px;color:#666}.platform-android .action-sheet .button.activated,.platform-android .action-sheet .button.active{background:#e8e8e8}.platform-android .action-sheet-group{margin:0;border-radius:0;background-color:#fafafa}.platform-android .action-sheet-cancel{display:none}.platform-android .action-sheet-has-icons .button{padding-left:56px}.backdrop{position:fixed;top:0;left:0;z-index:11;width:100%;height:100%;background-color:rgba(0,0,0,.4);-webkit-transition:.1s opacity linear;transition:.1s opacity linear}.bar,.bar .title,.bar-footer.item-input-inset,.nav-bar-block,.tabs{position:absolute}.backdrop.visible{visibility:visible}.backdrop.active{opacity:1}.bar{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;right:0;left:0;z-index:9;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:5px;width:100%;height:44px;border-style:solid;border-top:1px solid transparent;border-bottom:1px solid #ddd;background-color:#fff;background-size:0}@media (min--moz-device-pixel-ratio:1.5),(-webkit-min-device-pixel-ratio:1.5),(min-device-pixel-ratio:1.5),(min-resolution:144dpi),(min-resolution:1.5dppx){.bar{border:none;background-image:linear-gradient(0deg,#ddd,#ddd 50%,transparent 50%);background-position:bottom;background-size:100% 1px;background-repeat:no-repeat}}.bar.bar-clear{border:none;background:0 0;color:#fff}.bar.bar-clear .button,.bar.bar-clear .title{color:#fff}.bar.bar-light,.bar.bar-light .title,.bar.bar-stable .title{color:#444}.bar.item-input-inset .item-input-wrapper input{padding-left:8px;width:94%;height:28px;background:0 0}.bar.bar-light{border-color:#ddd;background-color:#fff;background-image:linear-gradient(0deg,#ddd,#ddd 50%,transparent 50%)}.bar.bar-light.bar-footer{background-image:linear-gradient(180deg,#ddd,#ddd 50%,transparent 50%)}.bar.bar-stable{border-color:#b2b2b2;background-color:#f8f8f8;background-image:linear-gradient(0deg,#b2b2b2,#b2b2b2 50%,transparent 50%);color:#444}.bar.bar-assertive,.bar.bar-assertive .title,.bar.bar-balanced .title,.bar.bar-calm,.bar.bar-calm .title,.bar.bar-dark,.bar.bar-dark .title,.bar.bar-energized,.bar.bar-energized .title,.bar.bar-positive,.bar.bar-positive .title,.bar.bar-royal,.bar.bar-royal .title{color:#fff}.bar.bar-stable.bar-footer{background-image:linear-gradient(180deg,#b2b2b2,#b2b2b2 50%,transparent 50%)}.bar.bar-positive{border-color:#0c60ee;background-color:#387ef5;background-image:linear-gradient(0deg,#0c60ee,#0c60ee 50%,transparent 50%)}.bar.bar-positive.bar-footer{background-image:linear-gradient(180deg,#0c60ee,#0c60ee 50%,transparent 50%)}.bar.bar-calm{border-color:#0a9dc7;background-color:#11c1f3;background-image:linear-gradient(0deg,#0a9dc7,#0a9dc7 50%,transparent 50%)}.bar.bar-calm.bar-footer{background-image:linear-gradient(180deg,#0a9dc7,#0a9dc7 50%,transparent 50%)}.bar.bar-assertive{border-color:#e42112;background-color:#ef473a;background-image:linear-gradient(0deg,#e42112,#e42112 50%,transparent 50%)}.bar.bar-assertive.bar-footer{background-image:linear-gradient(180deg,#e42112,#e42112 50%,transparent 50%)}.bar.bar-balanced{border-color:#28a54c;background-color:#33cd5f;background-image:linear-gradient(0deg,#28a54c,#28a54c 50%,transparent 50%);color:#fff}.bar.bar-balanced.bar-footer{background-image:linear-gradient(180deg,#28a54c,#0c60ee 50%,transparent 50%)}.bar.bar-energized{border-color:#e6b500;background-color:#ffc900;background-image:linear-gradient(0deg,#e6b500,#e6b500 50%,transparent 50%)}.bar.bar-energized.bar-footer{background-image:linear-gradient(180deg,#e6b500,#e6b500 50%,transparent 50%)}.bar.bar-royal{border-color:#6b46e5;background-color:#886aea;background-image:linear-gradient(0deg,#6b46e5,#6b46e5 50%,transparent 50%)}.bar.bar-royal.bar-footer{background-image:linear-gradient(180deg,#6b46e5,#6b46e5 50%,transparent 50%)}.bar.bar-dark{border-color:#111;background-color:#444;background-image:linear-gradient(0deg,#111,#111 50%,transparent 50%)}.bar.bar-dark.bar-footer{background-image:linear-gradient(180deg,#111,#111 50%,transparent 50%)}.bar .title{display:block;top:0;right:0;left:0;z-index:0;overflow:hidden;margin:0 10px;min-width:30px;height:43px;text-align:center;white-space:nowrap;font-size:17px;line-height:44px}.bar .title.title-left{text-align:left}.bar .title.title-right{text-align:right}.bar .title a{color:inherit}.bar .button,.bar button{z-index:1;padding:0 8px;min-width:initial;min-height:31px;font-weight:400;font-size:13px;line-height:32px}.bar .button .icon:before,.bar .button.button-icon:before,.bar .button.icon-left:before,.bar .button.icon-right:before,.bar .button.icon:before,.bar button .icon:before,.bar button.button-icon:before,.bar button.icon-left:before,.bar button.icon-right:before,.bar button.icon:before{padding-right:2px;padding-left:2px;font-size:20px;line-height:32px}.bar .button.button-icon,.bar button.button-icon{font-size:17px}.bar .button.button-icon .icon:before,.bar .button.button-icon.icon-left:before,.bar .button.button-icon.icon-right:before,.bar .button.button-icon:before,.bar button.button-icon .icon:before,.bar button.button-icon.icon-left:before,.bar button.button-icon.icon-right:before,.bar button.button-icon:before{vertical-align:top;font-size:32px;line-height:32px}.bar .button.button-clear,.bar button.button-clear{padding-right:2px;padding-left:2px;font-weight:300;font-size:17px}.bar .button.button-clear .icon:before,.bar .button.button-clear.icon-left:before,.bar .button.button-clear.icon-right:before,.bar .button.button-clear.icon:before,.bar button.button-clear .icon:before,.bar button.button-clear.icon-left:before,.bar button.button-clear.icon-right:before,.bar button.button-clear.icon:before{font-size:32px;line-height:32px}.bar .button.back-button,.bar button.back-button{display:block;margin-right:5px;padding:0;white-space:nowrap;font-weight:400}.bar .button.back-button.activated,.bar .button.back-button.active,.bar button.back-button.activated,.bar button.back-button.active{opacity:.2}.bar .button-bar>.button,.bar .buttons>.button{min-height:31px;line-height:32px}.bar .button+.button-bar,.bar .button-bar+.button{margin-left:5px}.bar .buttons,.bar .buttons.primary-buttons,.bar .buttons.secondary-buttons{display:inherit}.bar .buttons span{display:inline-block}.bar .buttons-left span{margin-right:5px;display:inherit}.bar .buttons-right span{margin-left:5px;display:inherit}.bar .buttons.pull-right,.bar .title+.button:last-child,.bar .title+.buttons,.bar>.button+.button:last-child,.bar>.button.pull-right{position:absolute;top:5px;right:5px;bottom:5px}.platform-android .nav-bar-has-subheader .bar{background-image:none}.platform-android .bar .back-button .icon:before{font-size:24px}.platform-android .bar .title{font-size:19px;line-height:44px}.bar-light .button{border-color:transparent;background-color:#fff;color:#444}.bar-light .button:hover{color:#444;text-decoration:none}.bar-light .button.activated,.bar-light .button.active{background-color:#fafafa}.bar-light .button.button-clear,.bar-light .button.button-icon{background:0 0;border-color:transparent}.bar-light .button.button-clear{box-shadow:none;color:#444;font-size:17px}.bar-stable .button{border-color:transparent;background-color:#f8f8f8;color:#444}.bar-stable .button:hover{color:#444;text-decoration:none}.bar-stable .button.activated,.bar-stable .button.active{background-color:#e5e5e5}.bar-stable .button.button-clear,.bar-stable .button.button-icon{background:0 0;border-color:transparent}.bar-stable .button.button-clear{box-shadow:none;color:#444;font-size:17px}.bar-positive .button{border-color:transparent;background-color:#387ef5;color:#fff}.bar-positive .button:hover{color:#fff;text-decoration:none}.bar-positive .button.activated,.bar-positive .button.active{background-color:#0c60ee}.bar-positive .button.button-clear,.bar-positive .button.button-icon{background:0 0;border-color:transparent}.bar-positive .button.button-clear{box-shadow:none;color:#fff;font-size:17px}.bar-calm .button{border-color:transparent;background-color:#11c1f3;color:#fff}.bar-calm .button:hover{color:#fff;text-decoration:none}.bar-calm .button.activated,.bar-calm .button.active{background-color:#0a9dc7}.bar-calm .button.button-clear,.bar-calm .button.button-icon{background:0 0;border-color:transparent}.bar-calm .button.button-clear{box-shadow:none;color:#fff;font-size:17px}.bar-assertive .button{border-color:transparent;background-color:#ef473a;color:#fff}.bar-assertive .button:hover{color:#fff;text-decoration:none}.bar-assertive .button.activated,.bar-assertive .button.active{background-color:#e42112}.bar-assertive .button.button-clear,.bar-assertive .button.button-icon{background:0 0;border-color:transparent}.bar-assertive .button.button-clear{box-shadow:none;color:#fff;font-size:17px}.bar-balanced .button{border-color:transparent;background-color:#33cd5f;color:#fff}.bar-balanced .button:hover{color:#fff;text-decoration:none}.bar-balanced .button.activated,.bar-balanced .button.active{background-color:#28a54c}.bar-balanced .button.button-clear,.bar-balanced .button.button-icon{background:0 0;border-color:transparent}.bar-balanced .button.button-clear{box-shadow:none;color:#fff;font-size:17px}.bar-energized .button{border-color:transparent;background-color:#ffc900;color:#fff}.bar-energized .button:hover{color:#fff;text-decoration:none}.bar-energized .button.activated,.bar-energized .button.active{background-color:#e6b500}.bar-energized .button.button-clear,.bar-energized .button.button-icon{background:0 0;border-color:transparent}.bar-energized .button.button-clear{box-shadow:none;color:#fff;font-size:17px}.bar-royal .button{border-color:transparent;background-color:#886aea;color:#fff}.bar-royal .button:hover{color:#fff;text-decoration:none}.bar-royal .button.activated,.bar-royal .button.active{background-color:#6b46e5}.bar-royal .button.button-clear,.bar-royal .button.button-icon{background:0 0;border-color:transparent}.bar-royal .button.button-clear{box-shadow:none;color:#fff;font-size:17px}.bar-dark .button{border-color:transparent;background-color:#444;color:#fff}.bar-dark .button:hover{color:#fff;text-decoration:none}.bar-dark .button.activated,.bar-dark .button.active{background-color:#262626}.bar-dark .button.button-clear,.bar-dark .button.button-icon{border-color:transparent;background:0 0}.bar-dark .button.button-clear{box-shadow:none;color:#fff;font-size:17px}.bar-header{top:0;border-top-width:0;border-bottom-width:1px}.bar-footer,.tabs{border-top-width:1px;bottom:0}.bar-header.has-tabs-top,.tabs-top .bar-header{border-bottom-width:0;background-image:none}.bar-footer{border-bottom-width:0;background-position:top;height:44px}.bar-tabs{padding:0}.bar-subheader{top:44px;display:block;height:44px}.bar-subfooter{bottom:44px;display:block;height:44px}.nav-bar-block{top:0;right:0;left:0;z-index:9}.bar .back-button.hide,.bar .buttons .hide{display:none}.nav-bar-tabs-top .bar{background-image:none}.tabs{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:horizontal;-moz-flex-direction:horizontal;-ms-flex-direction:horizontal;flex-direction:horizontal;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;-moz-justify-content:center;justify-content:center;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0);border-color:#b2b2b2;background-color:#f8f8f8;background-image:linear-gradient(0deg,#b2b2b2,#b2b2b2 50%,transparent 50%);color:#444;z-index:5;width:100%;height:49px;border-style:solid;background-size:0;line-height:49px}.tabs .tab-item .badge{background-color:#444;color:#f8f8f8}@media (min--moz-device-pixel-ratio:1.5),(-webkit-min-device-pixel-ratio:1.5),(min-device-pixel-ratio:1.5),(min-resolution:144dpi),(min-resolution:1.5dppx){.tabs{padding-top:2px;border-top:none!important;border-bottom:none;background-position:top;background-size:100% 1px;background-repeat:no-repeat}}.tabs-light>.tabs,.tabs.tabs-light{border-color:#ddd;background-color:#fff;background-image:linear-gradient(0deg,#ddd,#ddd 50%,transparent 50%);color:#444}.tabs-light>.tabs .tab-item .badge,.tabs.tabs-light .tab-item .badge{background-color:#444;color:#fff}.tabs-stable>.tabs,.tabs.tabs-stable{border-color:#b2b2b2;background-color:#f8f8f8;background-image:linear-gradient(0deg,#b2b2b2,#b2b2b2 50%,transparent 50%);color:#444}.tabs-stable>.tabs .tab-item .badge,.tabs.tabs-stable .tab-item .badge{background-color:#444;color:#f8f8f8}.tabs-positive>.tabs,.tabs.tabs-positive{border-color:#0c60ee;background-color:#387ef5;background-image:linear-gradient(0deg,#0c60ee,#0c60ee 50%,transparent 50%);color:#fff}.tabs-positive>.tabs .tab-item .badge,.tabs.tabs-positive .tab-item .badge{background-color:#fff;color:#387ef5}.tabs-calm>.tabs,.tabs.tabs-calm{border-color:#0a9dc7;background-color:#11c1f3;background-image:linear-gradient(0deg,#0a9dc7,#0a9dc7 50%,transparent 50%);color:#fff}.tabs-calm>.tabs .tab-item .badge,.tabs.tabs-calm .tab-item .badge{background-color:#fff;color:#11c1f3}.tabs-assertive>.tabs,.tabs.tabs-assertive{border-color:#e42112;background-color:#ef473a;background-image:linear-gradient(0deg,#e42112,#e42112 50%,transparent 50%);color:#fff}.tabs-assertive>.tabs .tab-item .badge,.tabs.tabs-assertive .tab-item .badge{background-color:#fff;color:#ef473a}.tabs-balanced>.tabs,.tabs.tabs-balanced{border-color:#28a54c;background-color:#33cd5f;background-image:linear-gradient(0deg,#28a54c,#28a54c 50%,transparent 50%);color:#fff}.tabs-balanced>.tabs .tab-item .badge,.tabs.tabs-balanced .tab-item .badge{background-color:#fff;color:#33cd5f}.tabs-energized>.tabs,.tabs.tabs-energized{border-color:#e6b500;background-color:#ffc900;background-image:linear-gradient(0deg,#e6b500,#e6b500 50%,transparent 50%);color:#fff}.tabs-energized>.tabs .tab-item .badge,.tabs.tabs-energized .tab-item .badge{background-color:#fff;color:#ffc900}.tabs-royal>.tabs,.tabs.tabs-royal{border-color:#6b46e5;background-color:#886aea;background-image:linear-gradient(0deg,#6b46e5,#6b46e5 50%,transparent 50%);color:#fff}.tabs-royal>.tabs .tab-item .badge,.tabs.tabs-royal .tab-item .badge{background-color:#fff;color:#886aea}.tabs-dark>.tabs,.tabs.tabs-dark{border-color:#111;background-color:#444;background-image:linear-gradient(0deg,#111,#111 50%,transparent 50%);color:#fff}.tabs-striped .tabs,.tabs-striped.tabs-light .tabs{background-color:#fff}.tabs-dark>.tabs .tab-item .badge,.tabs.tabs-dark .tab-item .badge{background-color:#fff;color:#444}.tabs-striped .tabs{background-image:none;border:none;border-bottom:1px solid #ddd;padding-top:2px}.tabs-striped .tab-item.activated,.tabs-striped .tab-item.active,.tabs-striped .tab-item.tab-item-active{margin-top:-2px;border-style:solid;border-width:2px 0 0;border-color:#444}.tabs-striped .tab-item.activated .badge,.tabs-striped .tab-item.active .badge,.tabs-striped .tab-item.tab-item-active .badge{top:2px;opacity:1}.tabs-striped.tabs-light .tab-item{color:rgba(68,68,68,.4);opacity:1}.tabs-striped.tabs-light .tab-item .badge{opacity:.4}.tabs-striped.tabs-light .tab-item.activated,.tabs-striped.tabs-light .tab-item.active,.tabs-striped.tabs-light .tab-item.tab-item-active{margin-top:-2px;color:#444;border-style:solid;border-width:2px 0 0;border-color:#444}.tabs-striped.tabs-stable .tabs{background-color:#f8f8f8}.tabs-striped.tabs-stable .tab-item{color:rgba(68,68,68,.4);opacity:1}.tabs-striped.tabs-stable .tab-item .badge{opacity:.4}.tabs-striped.tabs-stable .tab-item.activated,.tabs-striped.tabs-stable .tab-item.active,.tabs-striped.tabs-stable .tab-item.tab-item-active{margin-top:-2px;color:#444;border-style:solid;border-width:2px 0 0;border-color:#444}.tabs-striped.tabs-positive .tabs{background-color:#387ef5}.tabs-striped.tabs-positive .tab-item{color:rgba(255,255,255,.4);opacity:1}.tabs-striped.tabs-positive .tab-item .badge{opacity:.4}.tabs-striped.tabs-positive .tab-item.activated,.tabs-striped.tabs-positive .tab-item.active,.tabs-striped.tabs-positive .tab-item.tab-item-active{margin-top:-2px;color:#fff;border-style:solid;border-width:2px 0 0;border-color:#fff}.tabs-striped.tabs-calm .tabs{background-color:#11c1f3}.tabs-striped.tabs-calm .tab-item{color:rgba(255,255,255,.4);opacity:1}.tabs-striped.tabs-calm .tab-item .badge{opacity:.4}.tabs-striped.tabs-calm .tab-item.activated,.tabs-striped.tabs-calm .tab-item.active,.tabs-striped.tabs-calm .tab-item.tab-item-active{margin-top:-2px;color:#fff;border-style:solid;border-width:2px 0 0;border-color:#fff}.tabs-striped.tabs-assertive .tabs{background-color:#ef473a}.tabs-striped.tabs-assertive .tab-item{color:rgba(255,255,255,.4);opacity:1}.tabs-striped.tabs-assertive .tab-item .badge{opacity:.4}.tabs-striped.tabs-assertive .tab-item.activated,.tabs-striped.tabs-assertive .tab-item.active,.tabs-striped.tabs-assertive .tab-item.tab-item-active{margin-top:-2px;color:#fff;border-style:solid;border-width:2px 0 0;border-color:#fff}.tabs-striped.tabs-balanced .tabs{background-color:#33cd5f}.tabs-striped.tabs-balanced .tab-item{color:rgba(255,255,255,.4);opacity:1}.tabs-striped.tabs-balanced .tab-item .badge{opacity:.4}.tabs-striped.tabs-balanced .tab-item.activated,.tabs-striped.tabs-balanced .tab-item.active,.tabs-striped.tabs-balanced .tab-item.tab-item-active{margin-top:-2px;color:#fff;border-style:solid;border-width:2px 0 0;border-color:#fff}.tabs-striped.tabs-energized .tabs{background-color:#ffc900}.tabs-striped.tabs-energized .tab-item{color:rgba(255,255,255,.4);opacity:1}.tabs-striped.tabs-energized .tab-item .badge{opacity:.4}.tabs-striped.tabs-energized .tab-item.activated,.tabs-striped.tabs-energized .tab-item.active,.tabs-striped.tabs-energized .tab-item.tab-item-active{margin-top:-2px;color:#fff;border-style:solid;border-width:2px 0 0;border-color:#fff}.tabs-striped.tabs-royal .tabs{background-color:#886aea}.tabs-striped.tabs-royal .tab-item{color:rgba(255,255,255,.4);opacity:1}.tabs-striped.tabs-royal .tab-item .badge{opacity:.4}.tabs-striped.tabs-royal .tab-item.activated,.tabs-striped.tabs-royal .tab-item.active,.tabs-striped.tabs-royal .tab-item.tab-item-active{margin-top:-2px;color:#fff;border-style:solid;border-width:2px 0 0;border-color:#fff}.tabs-striped.tabs-dark .tabs{background-color:#444}.tabs-striped.tabs-dark .tab-item{color:rgba(255,255,255,.4);opacity:1}.tabs-striped.tabs-dark .tab-item .badge{opacity:.4}.tabs-striped.tabs-dark .tab-item.activated,.tabs-striped.tabs-dark .tab-item.active,.tabs-striped.tabs-dark .tab-item.tab-item-active{margin-top:-2px;color:#fff;border-style:solid;border-width:2px 0 0;border-color:#fff}.tabs-striped.tabs-top .tab-item.activated .badge,.tabs-striped.tabs-top .tab-item.active .badge,.tabs-striped.tabs-top .tab-item.tab-item-active .badge{top:4%}.tabs-striped.tabs-background-light .tabs{background-color:#fff;background-image:none}.tabs-striped.tabs-background-stable .tabs{background-color:#f8f8f8;background-image:none}.tabs-striped.tabs-background-positive .tabs{background-color:#387ef5;background-image:none}.tabs-striped.tabs-background-calm .tabs{background-color:#11c1f3;background-image:none}.tabs-striped.tabs-background-assertive .tabs{background-color:#ef473a;background-image:none}.tabs-striped.tabs-background-balanced .tabs{background-color:#33cd5f;background-image:none}.tabs-striped.tabs-background-energized .tabs{background-color:#ffc900;background-image:none}.tabs-striped.tabs-background-royal .tabs{background-color:#886aea;background-image:none}.tabs-striped.tabs-background-dark .tabs{background-color:#444;background-image:none}.tabs-striped.tabs-color-light .tab-item{color:rgba(255,255,255,.4);opacity:1}.tabs-striped.tabs-color-light .tab-item .badge{opacity:.4}.tabs-striped.tabs-color-light .tab-item.activated,.tabs-striped.tabs-color-light .tab-item.active,.tabs-striped.tabs-color-light .tab-item.tab-item-active{margin-top:-2px;color:#fff;border:0 solid #fff;border-top-width:2px}.tabs-striped.tabs-color-light .tab-item.activated .badge,.tabs-striped.tabs-color-light .tab-item.active .badge,.tabs-striped.tabs-color-light .tab-item.tab-item-active .badge{top:2px;opacity:1}.tabs-striped.tabs-color-stable .tab-item{color:rgba(248,248,248,.4);opacity:1}.tabs-striped.tabs-color-stable .tab-item .badge{opacity:.4}.tabs-striped.tabs-color-stable .tab-item.activated,.tabs-striped.tabs-color-stable .tab-item.active,.tabs-striped.tabs-color-stable .tab-item.tab-item-active{margin-top:-2px;color:#f8f8f8;border:0 solid #f8f8f8;border-top-width:2px}.tabs-striped.tabs-color-stable .tab-item.activated .badge,.tabs-striped.tabs-color-stable .tab-item.active .badge,.tabs-striped.tabs-color-stable .tab-item.tab-item-active .badge{top:2px;opacity:1}.tabs-striped.tabs-color-positive .tab-item{color:rgba(56,126,245,.4);opacity:1}.tabs-striped.tabs-color-positive .tab-item .badge{opacity:.4}.tabs-striped.tabs-color-positive .tab-item.activated,.tabs-striped.tabs-color-positive .tab-item.active,.tabs-striped.tabs-color-positive .tab-item.tab-item-active{margin-top:-2px;color:#387ef5;border:0 solid #387ef5;border-top-width:2px}.tabs-striped.tabs-color-positive .tab-item.activated .badge,.tabs-striped.tabs-color-positive .tab-item.active .badge,.tabs-striped.tabs-color-positive .tab-item.tab-item-active .badge{top:2px;opacity:1}.tabs-striped.tabs-color-calm .tab-item{color:rgba(17,193,243,.4);opacity:1}.tabs-striped.tabs-color-calm .tab-item .badge{opacity:.4}.tabs-striped.tabs-color-calm .tab-item.activated,.tabs-striped.tabs-color-calm .tab-item.active,.tabs-striped.tabs-color-calm .tab-item.tab-item-active{margin-top:-2px;color:#11c1f3;border:0 solid #11c1f3;border-top-width:2px}.tabs-striped.tabs-color-calm .tab-item.activated .badge,.tabs-striped.tabs-color-calm .tab-item.active .badge,.tabs-striped.tabs-color-calm .tab-item.tab-item-active .badge{top:2px;opacity:1}.tabs-striped.tabs-color-assertive .tab-item{color:rgba(239,71,58,.4);opacity:1}.tabs-striped.tabs-color-assertive .tab-item .badge{opacity:.4}.tabs-striped.tabs-color-assertive .tab-item.activated,.tabs-striped.tabs-color-assertive .tab-item.active,.tabs-striped.tabs-color-assertive .tab-item.tab-item-active{margin-top:-2px;color:#ef473a;border:0 solid #ef473a;border-top-width:2px}.tabs-striped.tabs-color-assertive .tab-item.activated .badge,.tabs-striped.tabs-color-assertive .tab-item.active .badge,.tabs-striped.tabs-color-assertive .tab-item.tab-item-active .badge{top:2px;opacity:1}.tabs-striped.tabs-color-balanced .tab-item{color:rgba(51,205,95,.4);opacity:1}.tabs-striped.tabs-color-balanced .tab-item .badge{opacity:.4}.tabs-striped.tabs-color-balanced .tab-item.activated,.tabs-striped.tabs-color-balanced .tab-item.active,.tabs-striped.tabs-color-balanced .tab-item.tab-item-active{margin-top:-2px;color:#33cd5f;border:0 solid #33cd5f;border-top-width:2px}.tabs-striped.tabs-color-balanced .tab-item.activated .badge,.tabs-striped.tabs-color-balanced .tab-item.active .badge,.tabs-striped.tabs-color-balanced .tab-item.tab-item-active .badge{top:2px;opacity:1}.tabs-striped.tabs-color-energized .tab-item{color:rgba(255,201,0,.4);opacity:1}.tabs-striped.tabs-color-energized .tab-item .badge{opacity:.4}.tabs-striped.tabs-color-energized .tab-item.activated,.tabs-striped.tabs-color-energized .tab-item.active,.tabs-striped.tabs-color-energized .tab-item.tab-item-active{margin-top:-2px;color:#ffc900;border:0 solid #ffc900;border-top-width:2px}.tabs-striped.tabs-color-energized .tab-item.activated .badge,.tabs-striped.tabs-color-energized .tab-item.active .badge,.tabs-striped.tabs-color-energized .tab-item.tab-item-active .badge{top:2px;opacity:1}.tabs-striped.tabs-color-royal .tab-item{color:rgba(136,106,234,.4);opacity:1}.tabs-striped.tabs-color-royal .tab-item .badge{opacity:.4}.tabs-striped.tabs-color-royal .tab-item.activated,.tabs-striped.tabs-color-royal .tab-item.active,.tabs-striped.tabs-color-royal .tab-item.tab-item-active{margin-top:-2px;color:#886aea;border:0 solid #886aea;border-top-width:2px}.tabs-striped.tabs-color-royal .tab-item.activated .badge,.tabs-striped.tabs-color-royal .tab-item.active .badge,.tabs-striped.tabs-color-royal .tab-item.tab-item-active .badge{top:2px;opacity:1}.tabs-striped.tabs-color-dark .tab-item{color:rgba(68,68,68,.4);opacity:1}.tabs-striped.tabs-color-dark .tab-item .badge{opacity:.4}.tabs-striped.tabs-color-dark .tab-item.activated,.tabs-striped.tabs-color-dark .tab-item.active,.tabs-striped.tabs-color-dark .tab-item.tab-item-active{margin-top:-2px;color:#444;border:0 solid #444;border-top-width:2px}.tabs-striped.tabs-color-dark .tab-item.activated .badge,.tabs-striped.tabs-color-dark .tab-item.active .badge,.tabs-striped.tabs-color-dark .tab-item.tab-item-active .badge{top:2px;opacity:1}.tabs-background-light .tabs,.tabs-background-light>.tabs{background-color:#fff;background-image:linear-gradient(0deg,#ddd,#ddd 50%,transparent 50%);border-color:#ddd}.tabs-background-stable .tabs,.tabs-background-stable>.tabs{background-color:#f8f8f8;background-image:linear-gradient(0deg,#b2b2b2,#b2b2b2 50%,transparent 50%);border-color:#b2b2b2}.tabs-background-positive .tabs,.tabs-background-positive>.tabs{background-color:#387ef5;background-image:linear-gradient(0deg,#0c60ee,#0c60ee 50%,transparent 50%);border-color:#0c60ee}.tabs-background-calm .tabs,.tabs-background-calm>.tabs{background-color:#11c1f3;background-image:linear-gradient(0deg,#0a9dc7,#0a9dc7 50%,transparent 50%);border-color:#0a9dc7}.tabs-background-assertive .tabs,.tabs-background-assertive>.tabs{background-color:#ef473a;background-image:linear-gradient(0deg,#e42112,#e42112 50%,transparent 50%);border-color:#e42112}.tabs-background-balanced .tabs,.tabs-background-balanced>.tabs{background-color:#33cd5f;background-image:linear-gradient(0deg,#28a54c,#28a54c 50%,transparent 50%);border-color:#28a54c}.tabs-background-energized .tabs,.tabs-background-energized>.tabs{background-color:#ffc900;background-image:linear-gradient(0deg,#e6b500,#e6b500 50%,transparent 50%);border-color:#e6b500}.tabs-background-royal .tabs,.tabs-background-royal>.tabs{background-color:#886aea;background-image:linear-gradient(0deg,#6b46e5,#6b46e5 50%,transparent 50%);border-color:#6b46e5}.tabs-background-dark .tabs,.tabs-background-dark>.tabs{background-color:#444;background-image:linear-gradient(0deg,#111,#111 50%,transparent 50%);border-color:#111}.tabs-color-light .tab-item{color:rgba(255,255,255,.4);opacity:1}.tabs-color-light .tab-item .badge{opacity:.4}.tabs-color-light .tab-item.activated,.tabs-color-light .tab-item.active,.tabs-color-light .tab-item.tab-item-active{color:#fff;border:0 solid #fff}.tabs-color-light .tab-item.activated .badge,.tabs-color-light .tab-item.active .badge,.tabs-color-light .tab-item.tab-item-active .badge{opacity:1}.tabs-color-stable .tab-item{color:rgba(248,248,248,.4);opacity:1}.tabs-color-stable .tab-item .badge{opacity:.4}.tabs-color-stable .tab-item.activated,.tabs-color-stable .tab-item.active,.tabs-color-stable .tab-item.tab-item-active{color:#f8f8f8;border:0 solid #f8f8f8}.tabs-color-stable .tab-item.activated .badge,.tabs-color-stable .tab-item.active .badge,.tabs-color-stable .tab-item.tab-item-active .badge{opacity:1}.tabs-color-positive .tab-item{color:rgba(56,126,245,.4);opacity:1}.tabs-color-positive .tab-item .badge{opacity:.4}.tabs-color-positive .tab-item.activated,.tabs-color-positive .tab-item.active,.tabs-color-positive .tab-item.tab-item-active{color:#387ef5;border:0 solid #387ef5}.tabs-color-positive .tab-item.activated .badge,.tabs-color-positive .tab-item.active .badge,.tabs-color-positive .tab-item.tab-item-active .badge{opacity:1}.tabs-color-calm .tab-item{color:rgba(17,193,243,.4);opacity:1}.tabs-color-calm .tab-item .badge{opacity:.4}.tabs-color-calm .tab-item.activated,.tabs-color-calm .tab-item.active,.tabs-color-calm .tab-item.tab-item-active{color:#11c1f3;border:0 solid #11c1f3}.tabs-color-calm .tab-item.activated .badge,.tabs-color-calm .tab-item.active .badge,.tabs-color-calm .tab-item.tab-item-active .badge{opacity:1}.tabs-color-assertive .tab-item{color:rgba(239,71,58,.4);opacity:1}.tabs-color-assertive .tab-item .badge{opacity:.4}.tabs-color-assertive .tab-item.activated,.tabs-color-assertive .tab-item.active,.tabs-color-assertive .tab-item.tab-item-active{color:#ef473a;border:0 solid #ef473a}.tabs-color-assertive .tab-item.activated .badge,.tabs-color-assertive .tab-item.active .badge,.tabs-color-assertive .tab-item.tab-item-active .badge{opacity:1}.tabs-color-balanced .tab-item{color:rgba(51,205,95,.4);opacity:1}.tabs-color-balanced .tab-item .badge{opacity:.4}.tabs-color-balanced .tab-item.activated,.tabs-color-balanced .tab-item.active,.tabs-color-balanced .tab-item.tab-item-active{color:#33cd5f;border:0 solid #33cd5f}.tabs-color-balanced .tab-item.activated .badge,.tabs-color-balanced .tab-item.active .badge,.tabs-color-balanced .tab-item.tab-item-active .badge{opacity:1}.tabs-color-energized .tab-item{color:rgba(255,201,0,.4);opacity:1}.tabs-color-energized .tab-item .badge{opacity:.4}.tabs-color-energized .tab-item.activated,.tabs-color-energized .tab-item.active,.tabs-color-energized .tab-item.tab-item-active{color:#ffc900;border:0 solid #ffc900}.tabs-color-energized .tab-item.activated .badge,.tabs-color-energized .tab-item.active .badge,.tabs-color-energized .tab-item.tab-item-active .badge{opacity:1}.tabs-color-royal .tab-item{color:rgba(136,106,234,.4);opacity:1}.tabs-color-royal .tab-item .badge{opacity:.4}.tabs-color-royal .tab-item.activated,.tabs-color-royal .tab-item.active,.tabs-color-royal .tab-item.tab-item-active{color:#886aea;border:0 solid #886aea}.tabs-color-royal .tab-item.activated .badge,.tabs-color-royal .tab-item.active .badge,.tabs-color-royal .tab-item.tab-item-active .badge{opacity:1}.tabs-color-dark .tab-item{color:rgba(68,68,68,.4);opacity:1}.tabs-color-dark .tab-item .badge{opacity:.4}.tabs-color-dark .tab-item.activated,.tabs-color-dark .tab-item.active,.tabs-color-dark .tab-item.tab-item-active{color:#444;border:0 solid #444}.tabs-color-dark .tab-item.activated .badge,.tabs-color-dark .tab-item.active .badge,.tabs-color-dark .tab-item.tab-item-active .badge{opacity:1}ion-tabs.tabs-color-active-light .tab-item{color:#444}ion-tabs.tabs-color-active-light .tab-item.activated,ion-tabs.tabs-color-active-light .tab-item.active,ion-tabs.tabs-color-active-light .tab-item.tab-item-active{color:#fff}ion-tabs.tabs-striped.tabs-color-active-light .tab-item.activated,ion-tabs.tabs-striped.tabs-color-active-light .tab-item.active,ion-tabs.tabs-striped.tabs-color-active-light .tab-item.tab-item-active{border-color:#fff;color:#fff}ion-tabs.tabs-color-active-stable .tab-item{color:#444}ion-tabs.tabs-color-active-stable .tab-item.activated,ion-tabs.tabs-color-active-stable .tab-item.active,ion-tabs.tabs-color-active-stable .tab-item.tab-item-active{color:#f8f8f8}ion-tabs.tabs-striped.tabs-color-active-stable .tab-item.activated,ion-tabs.tabs-striped.tabs-color-active-stable .tab-item.active,ion-tabs.tabs-striped.tabs-color-active-stable .tab-item.tab-item-active{border-color:#f8f8f8;color:#f8f8f8}ion-tabs.tabs-color-active-positive .tab-item{color:#444}ion-tabs.tabs-color-active-positive .tab-item.activated,ion-tabs.tabs-color-active-positive .tab-item.active,ion-tabs.tabs-color-active-positive .tab-item.tab-item-active{color:#387ef5}ion-tabs.tabs-striped.tabs-color-active-positive .tab-item.activated,ion-tabs.tabs-striped.tabs-color-active-positive .tab-item.active,ion-tabs.tabs-striped.tabs-color-active-positive .tab-item.tab-item-active{border-color:#387ef5;color:#387ef5}ion-tabs.tabs-color-active-calm .tab-item{color:#444}ion-tabs.tabs-color-active-calm .tab-item.activated,ion-tabs.tabs-color-active-calm .tab-item.active,ion-tabs.tabs-color-active-calm .tab-item.tab-item-active{color:#11c1f3}ion-tabs.tabs-striped.tabs-color-active-calm .tab-item.activated,ion-tabs.tabs-striped.tabs-color-active-calm .tab-item.active,ion-tabs.tabs-striped.tabs-color-active-calm .tab-item.tab-item-active{border-color:#11c1f3;color:#11c1f3}ion-tabs.tabs-color-active-assertive .tab-item{color:#444}ion-tabs.tabs-color-active-assertive .tab-item.activated,ion-tabs.tabs-color-active-assertive .tab-item.active,ion-tabs.tabs-color-active-assertive .tab-item.tab-item-active{color:#ef473a}ion-tabs.tabs-striped.tabs-color-active-assertive .tab-item.activated,ion-tabs.tabs-striped.tabs-color-active-assertive .tab-item.active,ion-tabs.tabs-striped.tabs-color-active-assertive .tab-item.tab-item-active{border-color:#ef473a;color:#ef473a}ion-tabs.tabs-color-active-balanced .tab-item{color:#444}ion-tabs.tabs-color-active-balanced .tab-item.activated,ion-tabs.tabs-color-active-balanced .tab-item.active,ion-tabs.tabs-color-active-balanced .tab-item.tab-item-active{color:#33cd5f}ion-tabs.tabs-striped.tabs-color-active-balanced .tab-item.activated,ion-tabs.tabs-striped.tabs-color-active-balanced .tab-item.active,ion-tabs.tabs-striped.tabs-color-active-balanced .tab-item.tab-item-active{border-color:#33cd5f;color:#33cd5f}ion-tabs.tabs-color-active-energized .tab-item{color:#444}ion-tabs.tabs-color-active-energized .tab-item.activated,ion-tabs.tabs-color-active-energized .tab-item.active,ion-tabs.tabs-color-active-energized .tab-item.tab-item-active{color:#ffc900}ion-tabs.tabs-striped.tabs-color-active-energized .tab-item.activated,ion-tabs.tabs-striped.tabs-color-active-energized .tab-item.active,ion-tabs.tabs-striped.tabs-color-active-energized .tab-item.tab-item-active{border-color:#ffc900;color:#ffc900}ion-tabs.tabs-color-active-royal .tab-item{color:#444}ion-tabs.tabs-color-active-royal .tab-item.activated,ion-tabs.tabs-color-active-royal .tab-item.active,ion-tabs.tabs-color-active-royal .tab-item.tab-item-active{color:#886aea}ion-tabs.tabs-striped.tabs-color-active-royal .tab-item.activated,ion-tabs.tabs-striped.tabs-color-active-royal .tab-item.active,ion-tabs.tabs-striped.tabs-color-active-royal .tab-item.tab-item-active{border-color:#886aea;color:#886aea}ion-tabs.tabs-color-active-dark .tab-item{color:#fff}ion-tabs.tabs-color-active-dark .tab-item.activated,ion-tabs.tabs-color-active-dark .tab-item.active,ion-tabs.tabs-color-active-dark .tab-item.tab-item-active{color:#444}ion-tabs.tabs-striped.tabs-color-active-dark .tab-item.activated,ion-tabs.tabs-striped.tabs-color-active-dark .tab-item.active,ion-tabs.tabs-striped.tabs-color-active-dark .tab-item.tab-item-active{border-color:#444;color:#444}.tabs-top.tabs-striped{padding-bottom:0}.tabs-top.tabs-striped .tab-item{background:0 0;-webkit-transition:color .1s ease;-moz-transition:color .1s ease;-ms-transition:color .1s ease;-o-transition:color .1s ease;transition:color .1s ease}.menu,.modal{min-height:100%;background-color:#fff;overflow:hidden}.tabs-top.tabs-striped .tab-item.activated,.tabs-top.tabs-striped .tab-item.active,.tabs-top.tabs-striped .tab-item.tab-item-active{margin-top:1px;border-width:0 0 2px!important;border-style:solid}.tabs-top.tabs-striped .tab-item.activated>.badge,.tabs-top.tabs-striped .tab-item.activated>i,.tabs-top.tabs-striped .tab-item.active>.badge,.tabs-top.tabs-striped .tab-item.active>i,.tabs-top.tabs-striped .tab-item.tab-item-active>.badge,.tabs-top.tabs-striped .tab-item.tab-item-active>i{margin-top:-1px}.tabs-top.tabs-striped .tab-item .badge{-webkit-transition:color .2s ease;-moz-transition:color .2s ease;-ms-transition:color .2s ease;-o-transition:color .2s ease;transition:color .2s ease}.tabs-top.tabs-striped:not(.tabs-icon-left):not(.tabs-icon-top) .tab-item.activated .tab-title,.tabs-top.tabs-striped:not(.tabs-icon-left):not(.tabs-icon-top) .tab-item.activated i,.tabs-top.tabs-striped:not(.tabs-icon-left):not(.tabs-icon-top) .tab-item.active .tab-title,.tabs-top.tabs-striped:not(.tabs-icon-left):not(.tabs-icon-top) .tab-item.active i,.tabs-top.tabs-striped:not(.tabs-icon-left):not(.tabs-icon-top) .tab-item.tab-item-active .tab-title,.tabs-top.tabs-striped:not(.tabs-icon-left):not(.tabs-icon-top) .tab-item.tab-item-active i{display:block;margin-top:-1px}.tabs-top.tabs-striped.tabs-icon-left .tab-item{margin-top:1px}.tabs-top.tabs-striped.tabs-icon-left .tab-item.activated .tab-title,.tabs-top.tabs-striped.tabs-icon-left .tab-item.activated i,.tabs-top.tabs-striped.tabs-icon-left .tab-item.active .tab-title,.tabs-top.tabs-striped.tabs-icon-left .tab-item.active i,.tabs-top.tabs-striped.tabs-icon-left .tab-item.tab-item-active .tab-title,.tabs-top.tabs-striped.tabs-icon-left .tab-item.tab-item-active i{margin-top:-.1em}.tabs-top>.tabs,.tabs.tabs-top{top:44px;padding-top:0;background-position:bottom;border-top-width:0;border-bottom-width:1px}.tabs-top>.tabs .tab-item.activated .badge,.tabs-top>.tabs .tab-item.active .badge,.tabs-top>.tabs .tab-item.tab-item-active .badge,.tabs.tabs-top .tab-item.activated .badge,.tabs.tabs-top .tab-item.active .badge,.tabs.tabs-top .tab-item.tab-item-active .badge{top:4%}.tabs-top~.bar-header{border-bottom-width:0}.tab-item{-webkit-box-flex:1;-webkit-flex:1;-moz-box-flex:1;-moz-flex:1;-ms-flex:1;flex:1;display:block;overflow:hidden;max-width:150px;height:100%;color:inherit;text-align:center;text-decoration:none;white-space:nowrap;font-weight:400;font-size:14px;opacity:.7}.tab-item:hover{cursor:pointer}.tab-item.tab-hidden,.tabs-item-hide>.tabs,.tabs.tabs-item-hide{display:none}.tabs-icon-bottom.tabs .tab-item,.tabs-icon-bottom>.tabs .tab-item,.tabs-icon-top.tabs .tab-item,.tabs-icon-top>.tabs .tab-item{font-size:10px;line-height:14px}.tab-item .icon{display:block;margin:0 auto;height:32px;font-size:32px}.tabs-icon-left.tabs .tab-item,.tabs-icon-left>.tabs .tab-item,.tabs-icon-right.tabs .tab-item,.tabs-icon-right>.tabs .tab-item{font-size:10px}.tabs-icon-left.tabs .tab-item .icon,.tabs-icon-left.tabs .tab-item .tab-title,.tabs-icon-left>.tabs .tab-item .icon,.tabs-icon-left>.tabs .tab-item .tab-title,.tabs-icon-right.tabs .tab-item .icon,.tabs-icon-right.tabs .tab-item .tab-title,.tabs-icon-right>.tabs .tab-item .icon,.tabs-icon-right>.tabs .tab-item .tab-title{display:inline-block;vertical-align:top;margin-top:-.1em}.tabs-icon-left.tabs .tab-item .icon:before,.tabs-icon-left.tabs .tab-item .tab-title:before,.tabs-icon-left>.tabs .tab-item .icon:before,.tabs-icon-left>.tabs .tab-item .tab-title:before,.tabs-icon-right.tabs .tab-item .icon:before,.tabs-icon-right.tabs .tab-item .tab-title:before,.tabs-icon-right>.tabs .tab-item .icon:before,.tabs-icon-right>.tabs .tab-item .tab-title:before{font-size:24px;line-height:49px}.tabs-icon-left.tabs .tab-item .icon,.tabs-icon-left>.tabs .tab-item .icon{padding-right:3px}.tabs-icon-right.tabs .tab-item .icon,.tabs-icon-right>.tabs .tab-item .icon{padding-left:3px}.tabs-icon-only.tabs .icon,.tabs-icon-only>.tabs .icon{line-height:inherit}.tab-item.has-badge{position:relative}.tab-item .badge{position:absolute;top:4%;right:33%;right:calc(50% - 26px);padding:1px 6px;height:auto;font-size:12px;line-height:16px}.tab-item.activated,.tab-item.active,.tab-item.tab-item-active{opacity:1}.tab-item.activated.tab-item-light,.tab-item.active.tab-item-light,.tab-item.tab-item-active.tab-item-light{color:#fff}.tab-item.activated.tab-item-stable,.tab-item.active.tab-item-stable,.tab-item.tab-item-active.tab-item-stable{color:#f8f8f8}.tab-item.activated.tab-item-positive,.tab-item.active.tab-item-positive,.tab-item.tab-item-active.tab-item-positive{color:#387ef5}.tab-item.activated.tab-item-calm,.tab-item.active.tab-item-calm,.tab-item.tab-item-active.tab-item-calm{color:#11c1f3}.tab-item.activated.tab-item-assertive,.tab-item.active.tab-item-assertive,.tab-item.tab-item-active.tab-item-assertive{color:#ef473a}.tab-item.activated.tab-item-balanced,.tab-item.active.tab-item-balanced,.tab-item.tab-item-active.tab-item-balanced{color:#33cd5f}.tab-item.activated.tab-item-energized,.tab-item.active.tab-item-energized,.tab-item.tab-item-active.tab-item-energized{color:#ffc900}.tab-item.activated.tab-item-royal,.tab-item.active.tab-item-royal,.tab-item.tab-item-active.tab-item-royal{color:#886aea}.tab-item.activated.tab-item-dark,.tab-item.active.tab-item-dark,.tab-item.tab-item-active.tab-item-dark{color:#444}.item.tabs{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;padding:0}.item.tabs .icon:before{position:relative}.tab-item.disabled,.tab-item[disabled]{opacity:.4;cursor:default;pointer-events:none}.nav-bar-tabs-top.hide~.view-container .tabs-top .tabs{top:0}.pane[hide-nav-bar=true] .has-tabs-top{top:49px}.menu{position:absolute;top:0;bottom:0;z-index:0;max-height:100%;width:275px}.menu .scroll-content{z-index:10}.menu .bar-header{z-index:11}.menu-content{-webkit-transform:none;transform:none;box-shadow:-1px 0 2px rgba(0,0,0,.2),1px 0 2px rgba(0,0,0,.2)}.menu-open .menu-content .scroll-content:not(.overflow-scroll){overflow:hidden}.grade-b .menu-content,.grade-c .menu-content{-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;right:-1px;left:-1px;border-right:1px solid #ccc;border-left:1px solid #ccc;box-shadow:none}.menu-left{left:0}.menu-right{right:0}.aside-open.aside-resizing .menu-right{display:none}.modal,.popover{z-index:10;display:block}.menu-animated{-webkit-transition:-webkit-transform .2s ease;transition:transform .2s ease}.modal-backdrop,.modal-backdrop-bg{position:fixed;top:0;left:0;z-index:10;width:100%;height:100%}.modal{position:absolute;top:0;width:100%}@media (min-width:680px){.modal{top:20%;right:20%;bottom:20%;left:20%;min-height:240px;width:60%}.modal.ng-leave-active{bottom:0}.platform-ios.platform-cordova .modal-wrapper .modal .bar-header:not(.bar-subheader){height:44px}.platform-ios.platform-cordova .modal-wrapper .modal .bar-header:not(.bar-subheader)>*{margin-top:0}.platform-ios.platform-cordova .modal-wrapper .modal .bar-subheader,.platform-ios.platform-cordova .modal-wrapper .modal .has-header,.platform-ios.platform-cordova .modal-wrapper .modal .tabs-top>.tabs,.platform-ios.platform-cordova .modal-wrapper .modal .tabs.tabs-top{top:44px}.platform-ios.platform-cordova .modal-wrapper .modal .has-subheader{top:88px}.platform-ios.platform-cordova .modal-wrapper .modal .has-header.has-tabs-top{top:93px}.platform-ios.platform-cordova .modal-wrapper .modal .has-header.has-subheader.has-tabs-top{top:137px}.modal-backdrop-bg{-webkit-transition:opacity .3s ease-in-out;transition:opacity .3s ease-in-out;background-color:#000;opacity:0}.active .modal-backdrop-bg{opacity:.5}}.modal-open .modal,.modal-open .modal-backdrop{pointer-events:auto}.modal-open.loading-active .modal,.modal-open.loading-active .modal-backdrop,.popover-open{pointer-events:none}.popover-backdrop{position:fixed;top:0;left:0;z-index:10;width:100%;height:100%;background-color:transparent}.popover-backdrop.active{background-color:rgba(0,0,0,.1)}.popover{position:absolute;top:25%;left:50%;margin-top:12px;margin-left:-110px;height:280px;width:220px;background-color:#fff;box-shadow:0 1px 3px rgba(0,0,0,.4);opacity:0}.popover .item:first-child{border-top:0}.popover .item:last-child{border-bottom:0}.popover.popover-bottom{margin-top:-12px}.popover,.popover .bar-header{border-radius:2px}.popover .scroll-content{z-index:1;margin:2px 0}.popover .bar-header{border-bottom-right-radius:0;border-bottom-left-radius:0}.popover .has-header{border-top-right-radius:0;border-top-left-radius:0}.popover-arrow{display:none}.platform-ios .popover{box-shadow:0 0 40px rgba(0,0,0,.08);border-radius:10px}.platform-ios .popover .bar-header{-webkit-border-top-right-radius:10px;border-top-right-radius:10px;-webkit-border-top-left-radius:10px;border-top-left-radius:10px}.platform-ios .popover .scroll-content{margin:8px 0;border-radius:10px}.platform-ios .popover .scroll-content.has-header{margin-top:0}.platform-ios .popover-arrow{position:absolute;display:block;top:-17px;width:30px;height:19px;overflow:hidden}.popup-container,.popup-container .popup{display:-webkit-box;display:-moz-box;display:-moz-flex;display:-ms-flexbox}.platform-ios .popover-arrow:after{position:absolute;top:12px;left:5px;width:20px;height:20px;background-color:#fff;border-radius:3px;content:'';-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}.platform-ios .popover-bottom .popover-arrow{top:auto;bottom:-10px}.platform-ios .popover-bottom .popover-arrow:after{top:-6px}.loading-container,.popup-container{position:absolute;left:0;top:0;right:0;bottom:0}.platform-android .popover{margin-top:-32px;background-color:#fafafa;box-shadow:0 2px 6px rgba(0,0,0,.35)}.platform-android .popover .item{border-color:#fafafa;background-color:#fafafa;color:#4d4d4d}.platform-android .popover.popover-bottom{margin-top:32px}.platform-android .popover-backdrop,.platform-android .popover-backdrop.active{background-color:transparent}.popover-open .popover,.popover-open .popover-backdrop{pointer-events:auto}.popover-open.loading-active .popover,.popover-open.loading-active .popover-backdrop,.popup-open,.popup-open.modal-open .modal{pointer-events:none}@media (min-width:680px){.popover{width:360px;margin-left:-180px}}.popup-container{background:0 0;display:-webkit-flex;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;-moz-justify-content:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center;z-index:12}.popup-container.popup-showing{visibility:visible}.popup-container.popup-hidden .popup{-webkit-animation-name:scaleOut;animation-name:scaleOut;-webkit-animation-duration:.1s;animation-duration:.1s;-webkit-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out;-webkit-animation-fill-mode:both;animation-fill-mode:both}.popup-container.active .popup{-webkit-animation-name:superScaleIn;animation-name:superScaleIn;-webkit-animation-duration:.2s;animation-duration:.2s;-webkit-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out;-webkit-animation-fill-mode:both;animation-fill-mode:both}.popup-container .popup{width:250px;max-width:100%;max-height:90%;border-radius:0;background-color:rgba(255,255,255,.9);display:-webkit-flex;display:flex;-webkit-box-direction:normal;-webkit-box-orient:vertical;-webkit-flex-direction:column;-moz-flex-direction:column;-ms-flex-direction:column;flex-direction:column}.popup-container input,.popup-container textarea{width:100%}.popup-head{padding:15px 10px;border-bottom:1px solid #eee;text-align:center}.popup-title{margin:0;padding:0;font-size:15px}.popup-sub-title{margin:5px 0 0;padding:0;font-weight:400;font-size:11px}.popup-body{padding:10px;overflow:auto}.popup-buttons{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-box-direction:normal;-webkit-box-orient:horizontal;-webkit-flex-direction:row;-moz-flex-direction:row;-ms-flex-direction:row;flex-direction:row;padding:10px;min-height:65px}.popup-buttons .button{-webkit-box-flex:1;-webkit-flex:1;-moz-box-flex:1;-moz-flex:1;-ms-flex:1;flex:1;display:block;min-height:45px;border-radius:2px;line-height:20px;margin-right:5px}.popup-buttons .button:last-child{margin-right:0}.popup-open .popup,.popup-open .popup-backdrop{pointer-events:auto}.loading-container{z-index:13;display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;-moz-justify-content:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center;-webkit-transition:.2s opacity linear;transition:.2s opacity linear;visibility:hidden;opacity:0}.loading-container:not(.visible) .icon,.loading-container:not(.visible) .spinner{display:none}.loading-container.visible{visibility:visible}.loading-container.active{opacity:1}.loading-container .loading{padding:20px;border-radius:5px;background-color:rgba(0,0,0,.7);color:#fff;text-align:center;font-size:15px}.item,.item.item-light{border-color:#ddd;background-color:#fff}.item,.item h2{font-size:16px}.loading-container .loading h1,.loading-container .loading h2,.loading-container .loading h3,.loading-container .loading h4,.loading-container .loading h5,.loading-container .loading h6{color:#fff}.item{color:#444;position:relative;z-index:2;display:block;margin:-1px;padding:16px;border-width:1px;border-style:solid}.item h2{margin:0 0 2px;font-weight:400}.item h3{margin:0 0 4px;font-size:14px}.item h4{margin:0 0 4px;font-size:12px}.item h5,.item h6{margin:0 0 3px;font-size:10px}.item p{color:#666;font-size:14px;margin-bottom:2px}.item h1:last-child,.item h2:last-child,.item h3:last-child,.item h4:last-child,.item h5:last-child,.item h6:last-child,.item p:last-child{margin-bottom:0}.item .badge{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;position:absolute;top:16px;right:32px}.item.item-button-right .badge{right:67px}.item.item-divider .badge{top:8px}.item .badge+.badge{margin-right:5px}.item.item-light{color:#444}.item.item-stable{border-color:#b2b2b2;background-color:#f8f8f8;color:#444}.item.item-positive{border-color:#0c60ee;background-color:#387ef5;color:#fff}.item.item-calm{border-color:#0a9dc7;background-color:#11c1f3;color:#fff}.item.item-assertive{border-color:#e42112;background-color:#ef473a;color:#fff}.item.item-balanced{border-color:#28a54c;background-color:#33cd5f;color:#fff}.item.item-energized{border-color:#e6b500;background-color:#ffc900;color:#fff}.item.item-royal{border-color:#6b46e5;background-color:#886aea;color:#fff}.item.item-dark{border-color:#111;background-color:#444;color:#fff}a.item,a.item-content{color:inherit;text-decoration:none}.item[ng-click]:hover{cursor:pointer}.item-borderless,.list-borderless .item{border-width:0}.item .item-content.activated,.item .item-content.activated.item-complex>.item-content,.item .item-content.active,.item .item-content.active.item-complex>.item-content,.item-complex.activated .item-content,.item-complex.activated .item-content.item-complex>.item-content,.item-complex.active .item-content,.item-complex.active .item-content.item-complex>.item-content,.item.activated,.item.activated.item-complex>.item-content,.item.active,.item.active.item-complex>.item-content{border-color:#ccc;background-color:#D9D9D9}.item .item-content.activated.item-light,.item .item-content.activated.item-light.item-complex>.item-content,.item .item-content.active.item-light,.item .item-content.active.item-light.item-complex>.item-content,.item-complex.activated .item-content.item-light,.item-complex.activated .item-content.item-light.item-complex>.item-content,.item-complex.active .item-content.item-light,.item-complex.active .item-content.item-light.item-complex>.item-content,.item.activated.item-light,.item.activated.item-light.item-complex>.item-content,.item.active.item-light,.item.active.item-light.item-complex>.item-content{border-color:#ccc;background-color:#fafafa}.item .item-content.activated.item-stable,.item .item-content.activated.item-stable.item-complex>.item-content,.item .item-content.active.item-stable,.item .item-content.active.item-stable.item-complex>.item-content,.item-complex.activated .item-content.item-stable,.item-complex.activated .item-content.item-stable.item-complex>.item-content,.item-complex.active .item-content.item-stable,.item-complex.active .item-content.item-stable.item-complex>.item-content,.item.activated.item-stable,.item.activated.item-stable.item-complex>.item-content,.item.active.item-stable,.item.active.item-stable.item-complex>.item-content{border-color:#a2a2a2;background-color:#e5e5e5}.item .item-content.activated.item-positive,.item .item-content.activated.item-positive.item-complex>.item-content,.item .item-content.active.item-positive,.item .item-content.active.item-positive.item-complex>.item-content,.item-complex.activated .item-content.item-positive,.item-complex.activated .item-content.item-positive.item-complex>.item-content,.item-complex.active .item-content.item-positive,.item-complex.active .item-content.item-positive.item-complex>.item-content,.item.activated.item-positive,.item.activated.item-positive.item-complex>.item-content,.item.active.item-positive,.item.active.item-positive.item-complex>.item-content{border-color:#0c60ee;background-color:#0c60ee}.item .item-content.activated.item-calm,.item .item-content.activated.item-calm.item-complex>.item-content,.item .item-content.active.item-calm,.item .item-content.active.item-calm.item-complex>.item-content,.item-complex.activated .item-content.item-calm,.item-complex.activated .item-content.item-calm.item-complex>.item-content,.item-complex.active .item-content.item-calm,.item-complex.active .item-content.item-calm.item-complex>.item-content,.item.activated.item-calm,.item.activated.item-calm.item-complex>.item-content,.item.active.item-calm,.item.active.item-calm.item-complex>.item-content{border-color:#0a9dc7;background-color:#0a9dc7}.item .item-content.activated.item-assertive,.item .item-content.activated.item-assertive.item-complex>.item-content,.item .item-content.active.item-assertive,.item .item-content.active.item-assertive.item-complex>.item-content,.item-complex.activated .item-content.item-assertive,.item-complex.activated .item-content.item-assertive.item-complex>.item-content,.item-complex.active .item-content.item-assertive,.item-complex.active .item-content.item-assertive.item-complex>.item-content,.item.activated.item-assertive,.item.activated.item-assertive.item-complex>.item-content,.item.active.item-assertive,.item.active.item-assertive.item-complex>.item-content{border-color:#e42112;background-color:#e42112}.item .item-content.activated.item-balanced,.item .item-content.activated.item-balanced.item-complex>.item-content,.item .item-content.active.item-balanced,.item .item-content.active.item-balanced.item-complex>.item-content,.item-complex.activated .item-content.item-balanced,.item-complex.activated .item-content.item-balanced.item-complex>.item-content,.item-complex.active .item-content.item-balanced,.item-complex.active .item-content.item-balanced.item-complex>.item-content,.item.activated.item-balanced,.item.activated.item-balanced.item-complex>.item-content,.item.active.item-balanced,.item.active.item-balanced.item-complex>.item-content{border-color:#28a54c;background-color:#28a54c}.item .item-content.activated.item-energized,.item .item-content.activated.item-energized.item-complex>.item-content,.item .item-content.active.item-energized,.item .item-content.active.item-energized.item-complex>.item-content,.item-complex.activated .item-content.item-energized,.item-complex.activated .item-content.item-energized.item-complex>.item-content,.item-complex.active .item-content.item-energized,.item-complex.active .item-content.item-energized.item-complex>.item-content,.item.activated.item-energized,.item.activated.item-energized.item-complex>.item-content,.item.active.item-energized,.item.active.item-energized.item-complex>.item-content{border-color:#e6b500;background-color:#e6b500}.item .item-content.activated.item-royal,.item .item-content.activated.item-royal.item-complex>.item-content,.item .item-content.active.item-royal,.item .item-content.active.item-royal.item-complex>.item-content,.item-complex.activated .item-content.item-royal,.item-complex.activated .item-content.item-royal.item-complex>.item-content,.item-complex.active .item-content.item-royal,.item-complex.active .item-content.item-royal.item-complex>.item-content,.item.activated.item-royal,.item.activated.item-royal.item-complex>.item-content,.item.active.item-royal,.item.active.item-royal.item-complex>.item-content{border-color:#6b46e5;background-color:#6b46e5}.item .item-content.activated.item-dark,.item .item-content.activated.item-dark.item-complex>.item-content,.item .item-content.active.item-dark,.item .item-content.active.item-dark.item-complex>.item-content,.item-complex.activated .item-content.item-dark,.item-complex.activated .item-content.item-dark.item-complex>.item-content,.item-complex.active .item-content.item-dark,.item-complex.active .item-content.item-dark.item-complex>.item-content,.item.activated.item-dark,.item.activated.item-dark.item-complex>.item-content,.item.active.item-dark,.item.active.item-dark.item-complex>.item-content{border-color:#000;background-color:#262626}.item,.item h1,.item h2,.item h3,.item h4,.item h5,.item h6,.item p,.item-content,.item-content h1,.item-content h2,.item-content h3,.item-content h4,.item-content h5,.item-content h6,.item-content p{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}a.item:focus,a.item:hover{text-decoration:none}.item-complex,a.item.item-complex,button.item.item-complex{padding:0}.item-complex .item-content,.item-radio .item-content{position:relative;z-index:2;padding:16px 49px 16px 16px;border:none;background-color:#fff}a.item-content{display:block}.item-button-left .item-content>.button,.item-button-left>.button,.item-icon-left .icon,.item-icon-right .icon{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;position:absolute}.item-body h1,.item-body h2,.item-body h3,.item-body h4,.item-body h5,.item-body h6,.item-body p,.item-complex.item-text-wrap,.item-complex.item-text-wrap .item-content,.item-complex.item-text-wrap h1,.item-complex.item-text-wrap h2,.item-complex.item-text-wrap h3,.item-complex.item-text-wrap h4,.item-complex.item-text-wrap h5,.item-complex.item-text-wrap h6,.item-complex.item-text-wrap p,.item-text-wrap,.item-text-wrap .item,.item-text-wrap .item-content,.item-text-wrap h1,.item-text-wrap h2,.item-text-wrap h3,.item-text-wrap h4,.item-text-wrap h5,.item-text-wrap h6,.item-text-wrap p{overflow:visible;white-space:normal}.item-complex.item-light>.item-content{border-color:#ddd;background-color:#fff;color:#444}.item-complex.item-light>.item-content.active,.item-complex.item-light>.item-content.active.item-complex>.item-content,.item-complex.item-light>.item-content:active,.item-complex.item-light>.item-content:active.item-complex>.item-content{border-color:#ccc;background-color:#fafafa}.item-complex.item-stable>.item-content{border-color:#b2b2b2;background-color:#f8f8f8;color:#444}.item-complex.item-stable>.item-content.active,.item-complex.item-stable>.item-content.active.item-complex>.item-content,.item-complex.item-stable>.item-content:active,.item-complex.item-stable>.item-content:active.item-complex>.item-content{border-color:#a2a2a2;background-color:#e5e5e5}.item-complex.item-positive>.item-content{border-color:#0c60ee;background-color:#387ef5;color:#fff}.item-complex.item-positive>.item-content.active,.item-complex.item-positive>.item-content.active.item-complex>.item-content,.item-complex.item-positive>.item-content:active,.item-complex.item-positive>.item-content:active.item-complex>.item-content{border-color:#0c60ee;background-color:#0c60ee}.item-complex.item-calm>.item-content{border-color:#0a9dc7;background-color:#11c1f3;color:#fff}.item-complex.item-calm>.item-content.active,.item-complex.item-calm>.item-content.active.item-complex>.item-content,.item-complex.item-calm>.item-content:active,.item-complex.item-calm>.item-content:active.item-complex>.item-content{border-color:#0a9dc7;background-color:#0a9dc7}.item-complex.item-assertive>.item-content{border-color:#e42112;background-color:#ef473a;color:#fff}.item-complex.item-assertive>.item-content.active,.item-complex.item-assertive>.item-content.active.item-complex>.item-content,.item-complex.item-assertive>.item-content:active,.item-complex.item-assertive>.item-content:active.item-complex>.item-content{border-color:#e42112;background-color:#e42112}.item-complex.item-balanced>.item-content{border-color:#28a54c;background-color:#33cd5f;color:#fff}.item-complex.item-balanced>.item-content.active,.item-complex.item-balanced>.item-content.active.item-complex>.item-content,.item-complex.item-balanced>.item-content:active,.item-complex.item-balanced>.item-content:active.item-complex>.item-content{border-color:#28a54c;background-color:#28a54c}.item-complex.item-energized>.item-content{border-color:#e6b500;background-color:#ffc900;color:#fff}.item-complex.item-energized>.item-content.active,.item-complex.item-energized>.item-content.active.item-complex>.item-content,.item-complex.item-energized>.item-content:active,.item-complex.item-energized>.item-content:active.item-complex>.item-content{border-color:#e6b500;background-color:#e6b500}.item-complex.item-royal>.item-content{border-color:#6b46e5;background-color:#886aea;color:#fff}.item-complex.item-royal>.item-content.active,.item-complex.item-royal>.item-content.active.item-complex>.item-content,.item-complex.item-royal>.item-content:active,.item-complex.item-royal>.item-content:active.item-complex>.item-content{border-color:#6b46e5;background-color:#6b46e5}.item-complex.item-dark>.item-content{border-color:#111;background-color:#444;color:#fff}.item-complex.item-dark>.item-content.active,.item-complex.item-dark>.item-content.active.item-complex>.item-content,.item-complex.item-dark>.item-content:active,.item-complex.item-dark>.item-content:active.item-complex>.item-content{border-color:#000;background-color:#262626}.item-icon-left .icon,.item-icon-right .icon{display:flex;-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center;top:0;height:100%;font-size:32px}.item-icon-left .icon:before,.item-icon-right .icon:before{display:block;width:32px;text-align:center}.item .fill-icon{min-width:30px;min-height:30px;font-size:28px}.item-icon-left{padding-left:54px}.item-icon-left .icon{left:11px}.item-complex.item-icon-left{padding-left:0}.item-complex.item-icon-left .item-content{padding-left:54px}.item-icon-right{padding-right:54px}.item-icon-right .icon{right:11px}.item-complex.item-icon-right{padding-right:0}.item-complex.item-icon-right .item-content{padding-right:54px}.item-icon-left.item-icon-right .icon:first-child{right:auto}.item-icon-left .item-delete .icon,.item-icon-left.item-icon-right .icon:last-child{left:auto}.item-icon-left .icon-accessory,.item-icon-right .icon-accessory{color:#ccc;font-size:16px}.item-icon-left .icon-accessory{left:3px}.item-icon-right .icon-accessory{right:3px}.item-button-left{padding-left:72px}.item-button-left .item-content>.button,.item-button-left>.button{display:flex;-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center;top:8px;left:11px;min-width:34px;min-height:34px;font-size:18px;line-height:32px}.item-button-left .item-content>.button .icon:before,.item-button-left>.button .icon:before{position:relative;left:auto;width:auto;line-height:31px}.item-button-left .item-content>.button>.button,.item-button-left>.button>.button{margin:0 2px;min-height:34px;font-size:18px;line-height:32px}.item-button-right,a.item.item-button-right,button.item.item-button-right{padding-right:80px}.item-button-right .item-content>.button,.item-button-right .item-content>.buttons,.item-button-right>.button,.item-button-right>.buttons{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center;position:absolute;top:8px;right:16px;min-width:34px;min-height:34px;font-size:18px;line-height:32px}.item-button-right .item-content>.button .icon:before,.item-button-right .item-content>.buttons .icon:before,.item-button-right>.button .icon:before,.item-button-right>.buttons .icon:before{position:relative;left:auto;width:auto;line-height:31px}.item-button-right .item-content>.button>.button,.item-button-right .item-content>.buttons>.button,.item-button-right>.button>.button,.item-button-right>.buttons>.button{margin:0 2px;min-width:34px;min-height:34px;font-size:18px;line-height:32px}.item-button-left.item-button-right .button:first-child{right:auto}.item-button-left.item-button-right .button:last-child{left:auto}.item-avatar,.item-avatar .item-content,.item-avatar-left,.item-avatar-left .item-content{padding-left:72px;min-height:72px}.item-avatar .item-content .item-image,.item-avatar .item-content>img:first-child,.item-avatar .item-image,.item-avatar-left .item-content .item-image,.item-avatar-left .item-content>img:first-child,.item-avatar-left .item-image,.item-avatar-left>img:first-child,.item-avatar>img:first-child{position:absolute;top:16px;left:16px;max-width:40px;max-height:40px;width:100%;height:100%;border-radius:50%}.item-avatar-right,.item-avatar-right .item-content{padding-right:72px;min-height:72px}.item-avatar-right .item-content .item-image,.item-avatar-right .item-content>img:first-child,.item-avatar-right .item-image,.item-avatar-right>img:first-child{position:absolute;top:16px;right:16px;max-width:40px;max-height:40px;width:100%;height:100%;border-radius:50%}.item-thumbnail-left,.item-thumbnail-left .item-content{padding-top:8px;padding-left:106px;min-height:100px}.item-thumbnail-left .item-content .item-image,.item-thumbnail-left .item-content>img:first-child,.item-thumbnail-left .item-image,.item-thumbnail-left>img:first-child{position:absolute;top:10px;left:10px;max-width:80px;max-height:80px;width:100%;height:100%}.item-avatar-left.item-complex,.item-avatar.item-complex,.item-thumbnail-left.item-complex{padding-top:0;padding-left:0}.item-thumbnail-right,.item-thumbnail-right .item-content{padding-top:8px;padding-right:106px;min-height:100px}.item-thumbnail-right .item-content .item-image,.item-thumbnail-right .item-content>img:first-child,.item-thumbnail-right .item-image,.item-thumbnail-right>img:first-child{position:absolute;top:10px;right:10px;max-width:80px;max-height:80px;width:100%;height:100%}.item-options,.item-right-edit{position:absolute;top:0;right:0;height:100%}.item-avatar-right.item-complex,.item-thumbnail-right.item-complex{padding-top:0;padding-right:0}.item-image{padding:0;text-align:center}.item-image .list-img,.item-image img:first-child{width:100%;vertical-align:middle}.item-body{overflow:auto;padding:16px;text-overflow:inherit;white-space:normal}.item-body h1,.item-body h2,.item-body h3,.item-body h4,.item-body h5,.item-body h6,.item-body p{margin-top:16px;margin-bottom:16px}.item-divider{padding-top:8px;padding-bottom:8px;min-height:30px;background-color:#f5f5f5;color:#222;font-weight:500}.item-divider-ios,.platform-ios .item-divider-platform{padding-top:26px;text-transform:uppercase;font-weight:300;font-size:13px;background-color:#efeff4;color:#555}.item-divider-android,.platform-android .item-divider-platform{font-weight:300;font-size:13px}.item-note{float:right;color:#aaa;font-size:14px}.item-left-editable .item-content,.item-right-editable .item-content{-webkit-transition-duration:250ms;transition-duration:250ms;-webkit-transition-timing-function:ease-in-out;transition-timing-function:ease-in-out;-webkit-transition-property:-webkit-transform;-moz-transition-property:-moz-transform;transition-property:transform}.item-left-editing.item-left-editable .item-content,.list-left-editing .item-left-editable .item-content{-webkit-transform:translate3d(50px,0,0);transform:translate3d(50px,0,0)}.item-remove-animate.ng-leave{-webkit-transition-duration:.3s;transition-duration:.3s}.item-remove-animate.ng-leave .item-content,.item-remove-animate.ng-leave:last-of-type{-webkit-transition-duration:.3s;transition-duration:.3s;-webkit-transition-timing-function:ease-in;transition-timing-function:ease-in;-webkit-transition-property:all;transition-property:all}.item-remove-animate.ng-leave.ng-leave-active .item-content{opacity:0;-webkit-transform:translate3d(-100%,0,0)!important;transform:translate3d(-100%,0,0)!important}.item-remove-animate.ng-leave.ng-leave-active:last-of-type{opacity:0}.item-remove-animate.ng-leave.ng-leave-active~ion-item:not(.ng-leave){-webkit-transform:translate3d(0,-webkit-calc(-100% + 1px),0);transform:translate3d(0,calc(-100% + 1px),0);-webkit-transition-duration:.3s;transition-duration:.3s;-webkit-transition-timing-function:cubic-bezier(.25,.81,.24,1);transition-timing-function:cubic-bezier(.25,.81,.24,1);-webkit-transition-property:all;transition-property:all}.item-left-edit{-webkit-transition:all ease-in-out 125ms;transition:all ease-in-out 125ms;position:absolute;top:0;left:0;z-index:0;width:50px;height:100%;line-height:100%;display:none;opacity:0;-webkit-transform:translate3d(-21px,0,0);transform:translate3d(-21px,0,0)}.item-left-edit .button{height:100%}.item-left-edit .button.icon{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center;position:absolute;top:0;height:100%}.item-left-edit.visible{display:block}.item-left-edit.visible.active{opacity:1;-webkit-transform:translate3d(8px,0,0);transform:translate3d(8px,0,0)}.list-left-editing .item-left-edit{-webkit-transition-delay:125ms;transition-delay:125ms}.item-delete .button.icon{color:#ef473a;font-size:24px}.item-delete .button.icon:hover{opacity:.7}.item-right-edit{-webkit-transition:all ease-in-out 250ms;transition:all ease-in-out 250ms;z-index:3;width:75px;background:inherit;padding-left:20px;display:block;opacity:0;-webkit-transform:translate3d(75px,0,0);transform:translate3d(75px,0,0)}.item-right-edit .button{min-width:50px;height:100%}.item-right-edit .button.icon{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center;position:absolute;top:0;height:100%;font-size:32px}.item-right-edit.visible{display:block}.item-right-edit.visible.active{opacity:1;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}.item-reorder .button.icon{color:#444;font-size:32px}.item-reordering{position:absolute;left:0;top:0;z-index:9;width:100%;box-shadow:0 0 10px 0 #aaa}.item-reordering .item-reorder{z-index:9}.item-placeholder{opacity:.7}.item-options{z-index:1}.button .badge,.list,.slider,.slider-slide,.slider-slides{position:relative}.item-options .button{height:100%;border:none;border-radius:0;display:-webkit-inline-box;display:-webkit-inline-flex;display:-moz-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center}.item-options .button:before{margin:0 auto}.list{padding-top:1px;padding-bottom:1px;padding-left:0;margin-bottom:20px}.list:last-child{margin-bottom:0}.list:last-child.card{margin-bottom:40px}.list-header{margin-top:20px;padding:5px 15px;background-color:transparent;color:#222;font-weight:700}.card.list .list-item{padding-right:1px;padding-left:1px}.card,.list-inset{overflow:hidden;margin:20px 10px;border-radius:2px;background-color:#fff}.card .item,.list-inset .item,.padding .card,.padding .list-inset,.padding-horizontal>.list .item,.padding>.list .item{margin-left:0;margin-right:0}.card{padding-top:1px;padding-bottom:1px;box-shadow:0 1px 3px rgba(0,0,0,.3)}.card .item{border-left:0;border-right:0}.card .item:first-child{border-top:0}.card .item:last-child{border-bottom:0}.card .item:first-child,.card .item:first-child .item-content,.list-inset .item:first-child,.list-inset .item:first-child .item-content,.padding>.list .item:first-child,.padding>.list .item:first-child .item-content{border-top-left-radius:2px;border-top-right-radius:2px}.card .item:last-child,.card .item:last-child .item-content,.list-inset .item:last-child,.list-inset .item:last-child .item-content,.padding>.list .item:last-child,.padding>.list .item:last-child .item-content{border-bottom-right-radius:2px;border-bottom-left-radius:2px}.card .item:last-child,.list-inset .item:last-child{margin-bottom:-1px}.card .item.item-input input,.list-inset .item.item-input input,.padding-horizontal>.list .item.item-input input,.padding>.list .item.item-input input{padding-right:44px}.padding-left>.list .item{margin-left:0}.padding-right>.list .item{margin-right:0}.badge{background-color:transparent;color:#AAA;z-index:1;display:inline-block;padding:3px 8px;min-width:10px;border-radius:10px;text-align:center;white-space:nowrap;font-weight:700;font-size:14px;line-height:16px}.badge:empty{display:none}.badge.badge-light,.tabs .tab-item .badge.badge-light{background-color:#fff;color:#444}.badge.badge-stable,.tabs .tab-item .badge.badge-stable{background-color:#f8f8f8;color:#444}.badge.badge-positive,.tabs .tab-item .badge.badge-positive{background-color:#387ef5;color:#fff}.badge.badge-calm,.tabs .tab-item .badge.badge-calm{background-color:#11c1f3;color:#fff}.badge.badge-assertive,.tabs .tab-item .badge.badge-assertive{background-color:#ef473a;color:#fff}.badge.badge-balanced,.tabs .tab-item .badge.badge-balanced{background-color:#33cd5f;color:#fff}.badge.badge-energized,.tabs .tab-item .badge.badge-energized{background-color:#ffc900;color:#fff}.badge.badge-royal,.tabs .tab-item .badge.badge-royal{background-color:#886aea;color:#fff}.badge.badge-dark,.tabs .tab-item .badge.badge-dark{background-color:#444;color:#fff}.button .badge{top:-1px}.slider{visibility:hidden;overflow:hidden}.slider-slides{height:100%}.slider-slide{display:block;float:left;width:100%;height:100%;vertical-align:top}.slider-slide-image>img{width:100%}.slider-pager{position:absolute;bottom:20px;z-index:1;width:100%;height:15px;text-align:center}.slider-pager .slider-pager-page{display:inline-block;margin:0 3px;width:15px;color:#000;text-decoration:none;opacity:.3}.slider-pager .slider-pager-page.active{-webkit-transition:opacity .4s ease-in;transition:opacity .4s ease-in;opacity:1}.slider-pager-page.ng-animate,.slider-pager-page.ng-enter,.slider-pager-page.ng-leave,.slider-slide.ng-animate,.slider-slide.ng-enter,.slider-slide.ng-leave{-webkit-transition:none!important;transition:none!important}.slider-pager-page.ng-animate,.slider-slide.ng-animate{-webkit-animation:none 0s;animation:none 0s}.swiper-container{margin:0 auto;position:relative;z-index:1}.swiper-container-no-flexbox .swiper-slide{float:left}.swiper-container-vertical>.swiper-wrapper{-webkit-box-orient:vertical;-moz-box-orient:vertical;-ms-flex-direction:column;-webkit-flex-direction:column;flex-direction:column}.swiper-wrapper{z-index:1;display:-webkit-box;display:-moz-box;display:-ms-flexbox;display:-webkit-flex;display:flex;-webkit-transition-property:-webkit-transform;-moz-transition-property:-moz-transform;-o-transition-property:-o-transform;-ms-transition-property:-ms-transform;transition-property:transform;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box}.swiper-slide,.toggle .track{box-sizing:border-box}.swiper-container-android .swiper-slide,.swiper-wrapper{-webkit-transform:translate3d(0,0,0);-moz-transform:translate3d(0,0,0);-o-transform:translate(0,0);-ms-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}.click-block,.swiper-pagination{-webkit-transform:translate3d(0,0,0)}.swiper-container-multirow>.swiper-wrapper{-webkit-box-lines:multiple;-moz-box-lines:multiple;-ms-flex-wrap:wrap;-webkit-flex-wrap:wrap;flex-wrap:wrap}.swiper-container-free-mode>.swiper-wrapper{-webkit-transition-timing-function:ease-out;-moz-transition-timing-function:ease-out;-ms-transition-timing-function:ease-out;-o-transition-timing-function:ease-out;transition-timing-function:ease-out;margin:0 auto}.swiper-slide{display:block;-webkit-flex-shrink:0;-ms-flex:0 0 auto;flex-shrink:0;position:relative}.swiper-container-autoheight,.swiper-container-autoheight .swiper-slide{height:auto}.swiper-container-autoheight .swiper-wrapper{-webkit-box-align:start;-ms-flex-align:start;-webkit-align-items:flex-start;align-items:flex-start;-webkit-transition-property:-webkit-transform,height;-moz-transition-property:-moz-transform;-o-transition-property:-o-transform;-ms-transition-property:-ms-transform;transition-property:transform,height}.swiper-container .swiper-notification{position:absolute;left:0;top:0;pointer-events:none;opacity:0;z-index:-1000}.swiper-wp8-horizontal{-ms-touch-action:pan-y;touch-action:pan-y}.swiper-wp8-vertical{-ms-touch-action:pan-x;touch-action:pan-x}.swiper-button-next,.swiper-button-prev{position:absolute;top:50%;width:27px;height:44px;margin-top:-22px;z-index:10;cursor:pointer;-moz-background-size:27px 44px;-webkit-background-size:27px 44px;background-size:27px 44px;background-position:center;background-repeat:no-repeat}.swiper-button-next.swiper-button-disabled,.swiper-button-prev.swiper-button-disabled{opacity:.35;cursor:auto;pointer-events:none}.swiper-button-prev,.swiper-container-rtl .swiper-button-next{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M0%2C22L22%2C0l2.1%2C2.1L4.2%2C22l19.9%2C19.9L22%2C44L0%2C22L0%2C22L0%2C22z'%20fill%3D'%23007aff'%2F%3E%3C%2Fsvg%3E\");left:10px;right:auto}.swiper-button-prev.swiper-button-black,.swiper-container-rtl .swiper-button-next.swiper-button-black{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M0%2C22L22%2C0l2.1%2C2.1L4.2%2C22l19.9%2C19.9L22%2C44L0%2C22L0%2C22L0%2C22z'%20fill%3D'%23000000'%2F%3E%3C%2Fsvg%3E\")}.swiper-button-prev.swiper-button-white,.swiper-container-rtl .swiper-button-next.swiper-button-white{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M0%2C22L22%2C0l2.1%2C2.1L4.2%2C22l19.9%2C19.9L22%2C44L0%2C22L0%2C22L0%2C22z'%20fill%3D'%23ffffff'%2F%3E%3C%2Fsvg%3E\")}.swiper-button-next,.swiper-container-rtl .swiper-button-prev{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M27%2C22L27%2C22L5%2C44l-2.1-2.1L22.8%2C22L2.9%2C2.1L5%2C0L27%2C22L27%2C22z'%20fill%3D'%23007aff'%2F%3E%3C%2Fsvg%3E\");right:10px;left:auto}.swiper-button-next.swiper-button-black,.swiper-container-rtl .swiper-button-prev.swiper-button-black{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M27%2C22L27%2C22L5%2C44l-2.1-2.1L22.8%2C22L2.9%2C2.1L5%2C0L27%2C22L27%2C22z'%20fill%3D'%23000000'%2F%3E%3C%2Fsvg%3E\")}.swiper-button-next.swiper-button-white,.swiper-container-rtl .swiper-button-prev.swiper-button-white{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M27%2C22L27%2C22L5%2C44l-2.1-2.1L22.8%2C22L2.9%2C2.1L5%2C0L27%2C22L27%2C22z'%20fill%3D'%23ffffff'%2F%3E%3C%2Fsvg%3E\")}.swiper-pagination{position:absolute;text-align:center;-webkit-transition:.3s;-moz-transition:.3s;-o-transition:.3s;transition:.3s;-ms-transform:translate3d(0,0,0);-o-transform:translate3d(0,0,0);transform:translate3d(0,0,0);z-index:10}.swiper-pagination.swiper-pagination-hidden{opacity:0}.swiper-pagination-bullet{width:8px;height:8px;display:inline-block;border-radius:100%;background:#000;opacity:.2}.swiper-pagination-white .swiper-pagination-bullet,.swiper-pagination-white .swiper-pagination-bullet-active{background:#fff}button.swiper-pagination-bullet{border:none;margin:0;padding:0;box-shadow:none;-moz-appearance:none;-ms-appearance:none;-webkit-appearance:none;appearance:none}.item-input .button-bar,.item-input input{-webkit-appearance:none;-moz-appearance:none}.swiper-pagination-clickable .swiper-pagination-bullet{cursor:pointer}.swiper-pagination-bullet-active{opacity:1}.swiper-pagination-black .swiper-pagination-bullet-active{background:#000}.swiper-container-vertical>.swiper-pagination{right:10px;top:50%;-webkit-transform:translate3d(0,-50%,0);-moz-transform:translate3d(0,-50%,0);-o-transform:translate(0,-50%);-ms-transform:translate3d(0,-50%,0);transform:translate3d(0,-50%,0)}.swiper-container-vertical>.swiper-pagination .swiper-pagination-bullet{margin:5px 0;display:block}.swiper-container-horizontal>.swiper-pagination{bottom:10px;left:0;width:100%}.swiper-container-horizontal>.swiper-pagination .swiper-pagination-bullet{margin:0 5px}.swiper-container-3d{-webkit-perspective:1200px;-moz-perspective:1200px;-o-perspective:1200px;perspective:1200px}.swiper-container-3d .swiper-cube-shadow,.swiper-container-3d .swiper-slide,.swiper-container-3d .swiper-slide-shadow-bottom,.swiper-container-3d .swiper-slide-shadow-left,.swiper-container-3d .swiper-slide-shadow-right,.swiper-container-3d .swiper-slide-shadow-top,.swiper-container-3d .swiper-wrapper{-webkit-transform-style:preserve-3d;-moz-transform-style:preserve-3d;-ms-transform-style:preserve-3d;transform-style:preserve-3d}.swiper-container-3d .swiper-slide-shadow-bottom,.swiper-container-3d .swiper-slide-shadow-left,.swiper-container-3d .swiper-slide-shadow-right,.swiper-container-3d .swiper-slide-shadow-top{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:10}.swiper-container-3d .swiper-slide-shadow-left{background-image:-webkit-gradient(linear,left top,right top,from(rgba(0,0,0,.5)),to(transparent));background-image:-webkit-linear-gradient(right,rgba(0,0,0,.5),transparent);background-image:-moz-linear-gradient(right,rgba(0,0,0,.5),transparent);background-image:-o-linear-gradient(right,rgba(0,0,0,.5),transparent);background-image:linear-gradient(to left,rgba(0,0,0,.5),transparent)}.swiper-container-3d .swiper-slide-shadow-right{background-image:-webkit-gradient(linear,right top,left top,from(rgba(0,0,0,.5)),to(transparent));background-image:-webkit-linear-gradient(left,rgba(0,0,0,.5),transparent);background-image:-moz-linear-gradient(left,rgba(0,0,0,.5),transparent);background-image:-o-linear-gradient(left,rgba(0,0,0,.5),transparent);background-image:linear-gradient(to right,rgba(0,0,0,.5),transparent)}.swiper-container-3d .swiper-slide-shadow-top{background-image:-webkit-gradient(linear,left top,left bottom,from(rgba(0,0,0,.5)),to(transparent));background-image:-webkit-linear-gradient(bottom,rgba(0,0,0,.5),transparent);background-image:-moz-linear-gradient(bottom,rgba(0,0,0,.5),transparent);background-image:-o-linear-gradient(bottom,rgba(0,0,0,.5),transparent);background-image:linear-gradient(to top,rgba(0,0,0,.5),transparent)}.swiper-container-3d .swiper-slide-shadow-bottom{background-image:-webkit-gradient(linear,left bottom,left top,from(rgba(0,0,0,.5)),to(transparent));background-image:-webkit-linear-gradient(top,rgba(0,0,0,.5),transparent);background-image:-moz-linear-gradient(top,rgba(0,0,0,.5),transparent);background-image:-o-linear-gradient(top,rgba(0,0,0,.5),transparent);background-image:linear-gradient(to bottom,rgba(0,0,0,.5),transparent)}.swiper-container-coverflow .swiper-wrapper{-ms-perspective:1200px}.swiper-container-fade.swiper-container-free-mode .swiper-slide{-webkit-transition-timing-function:ease-out;-moz-transition-timing-function:ease-out;-ms-transition-timing-function:ease-out;-o-transition-timing-function:ease-out;transition-timing-function:ease-out}.swiper-container-fade .swiper-slide,.swiper-container-fade .swiper-slide .swiper-slide{pointer-events:none}.swiper-container-fade .swiper-slide-active,.swiper-container-fade .swiper-slide-active .swiper-slide-active{pointer-events:auto}.swiper-container-cube{overflow:visible}.swiper-container-cube .swiper-slide{pointer-events:none;visibility:hidden;-webkit-transform-origin:0 0;-moz-transform-origin:0 0;-ms-transform-origin:0 0;transform-origin:0 0;-webkit-backface-visibility:hidden;-moz-backface-visibility:hidden;-ms-backface-visibility:hidden;backface-visibility:hidden;width:100%;height:100%;z-index:1}.swiper-container-cube.swiper-container-rtl .swiper-slide{-webkit-transform-origin:100% 0;-moz-transform-origin:100% 0;-ms-transform-origin:100% 0;transform-origin:100% 0}.swiper-container-cube .swiper-slide-active,.swiper-container-cube .swiper-slide-next,.swiper-container-cube .swiper-slide-next+.swiper-slide,.swiper-container-cube .swiper-slide-prev{pointer-events:auto;visibility:visible}.swiper-container-cube .swiper-slide-shadow-bottom,.swiper-container-cube .swiper-slide-shadow-left,.swiper-container-cube .swiper-slide-shadow-right,.swiper-container-cube .swiper-slide-shadow-top{z-index:0;-webkit-backface-visibility:hidden;-moz-backface-visibility:hidden;-ms-backface-visibility:hidden;backface-visibility:hidden}.swiper-container-cube .swiper-cube-shadow{position:absolute;left:0;bottom:0;width:100%;height:100%;background:#000;opacity:.6;-webkit-filter:blur(50px);filter:blur(50px);z-index:0}.swiper-scrollbar{border-radius:10px;position:relative;-ms-touch-action:none;background:rgba(0,0,0,.1)}.swiper-container-horizontal>.swiper-scrollbar{position:absolute;left:1%;bottom:3px;z-index:50;height:5px;width:98%}.swiper-container-vertical>.swiper-scrollbar{position:absolute;right:3px;top:1%;z-index:50;width:5px;height:98%}.swiper-scrollbar-drag{height:100%;width:100%;position:relative;background:rgba(0,0,0,.5);border-radius:10px;left:0;top:0}.swiper-scrollbar-cursor-drag{cursor:move}.swiper-lazy-preloader{width:42px;height:42px;position:absolute;left:50%;top:50%;margin-left:-21px;margin-top:-21px;z-index:10;-webkit-transform-origin:50%;-moz-transform-origin:50%;transform-origin:50%;-webkit-animation:swiper-preloader-spin 1s steps(12,end) infinite;-moz-animation:swiper-preloader-spin 1s steps(12,end) infinite;animation:swiper-preloader-spin 1s steps(12,end) infinite}.swiper-container,.swiper-slide,.swiper-wrapper,ion-slides{width:100%;height:100%}.swiper-lazy-preloader:after{display:block;content:\"\";width:100%;height:100%;background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20viewBox%3D'0%200%20120%20120'%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20xmlns%3Axlink%3D'http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink'%3E%3Cdefs%3E%3Cline%20id%3D'l'%20x1%3D'60'%20x2%3D'60'%20y1%3D'7'%20y2%3D'27'%20stroke%3D'%236c6c6c'%20stroke-width%3D'11'%20stroke-linecap%3D'round'%2F%3E%3C%2Fdefs%3E%3Cg%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(30%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(60%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(90%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(120%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(150%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.37'%20transform%3D'rotate(180%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.46'%20transform%3D'rotate(210%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.56'%20transform%3D'rotate(240%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.66'%20transform%3D'rotate(270%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.75'%20transform%3D'rotate(300%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.85'%20transform%3D'rotate(330%2060%2C60)'%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E\");background-position:50%;-webkit-background-size:100%;background-size:100%;background-repeat:no-repeat}.swiper-lazy-preloader-white:after{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20viewBox%3D'0%200%20120%20120'%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20xmlns%3Axlink%3D'http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink'%3E%3Cdefs%3E%3Cline%20id%3D'l'%20x1%3D'60'%20x2%3D'60'%20y1%3D'7'%20y2%3D'27'%20stroke%3D'%23fff'%20stroke-width%3D'11'%20stroke-linecap%3D'round'%2F%3E%3C%2Fdefs%3E%3Cg%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(30%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(60%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(90%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(120%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(150%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.37'%20transform%3D'rotate(180%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.46'%20transform%3D'rotate(210%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.56'%20transform%3D'rotate(240%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.66'%20transform%3D'rotate(270%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.75'%20transform%3D'rotate(300%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.85'%20transform%3D'rotate(330%2060%2C60)'%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E\")}@-webkit-keyframes swiper-preloader-spin{100%{-webkit-transform:rotate(360deg)}}@keyframes swiper-preloader-spin{100%{transform:rotate(360deg)}}ion-slides{display:block}.slide-zoom{display:block;width:100%;text-align:center}.scroll-refresher .icon-refreshing,.scroll-refresher .text-refreshing,.scroll-refresher.active.refreshing .icon-pulling,.scroll-refresher.active.refreshing .text-pulling{display:none}.swiper-container{padding:0;overflow:hidden}.swiper-wrapper{position:absolute;left:0;top:0;padding:0}.swiper-slide img{width:auto;height:auto;max-width:100%;max-height:100%}.scroll-refresher{position:absolute;top:-60px;right:0;left:0;overflow:hidden;margin:auto;height:60px}.scroll-refresher .ionic-refresher-content{position:absolute;bottom:15px;left:0;width:100%;color:#666;text-align:center;font-size:30px}.scroll-refresher .ionic-refresher-content .text-pulling,.scroll-refresher .ionic-refresher-content .text-refreshing{font-size:16px;line-height:16px}.scroll-refresher .ionic-refresher-content.ionic-refresher-with-text{bottom:10px}.scroll-refresher .icon-pulling,.scroll-refresher .icon-refreshing{width:100%;-webkit-backface-visibility:hidden;backface-visibility:hidden;-webkit-transform-style:preserve-3d;transform-style:preserve-3d}.scroll-refresher .icon-pulling{-webkit-animation-name:refresh-spin-back;animation-name:refresh-spin-back;-webkit-animation-duration:.2s;animation-duration:.2s;-webkit-animation-timing-function:linear;animation-timing-function:linear;-webkit-animation-fill-mode:none;animation-fill-mode:none;-webkit-transform:translate3d(0,0,0) rotate(0);transform:translate3d(0,0,0) rotate(0)}.scroll-refresher .icon-refreshing{-webkit-animation-duration:1.5s;animation-duration:1.5s}.scroll-refresher.active .icon-pulling:not(.pulling-rotation-disabled){-webkit-animation-name:refresh-spin;animation-name:refresh-spin;-webkit-transform:translate3d(0,0,0) rotate(-180deg);transform:translate3d(0,0,0) rotate(-180deg)}.scroll-refresher.active.refreshing{-webkit-transition:transform .2s;transition:transform .2s;-webkit-transform:scale(1,1);transform:scale(1,1)}.scroll-refresher.active.refreshing .icon-refreshing,.scroll-refresher.active.refreshing .text-refreshing,legend{display:block}.scroll-refresher.active.refreshing.refreshing-tail{-webkit-transform:scale(0,0);transform:scale(0,0)}.overflow-scroll>.scroll{-webkit-overflow-scrolling:touch;width:100%}.overflow-scroll>.scroll.overscroll{position:fixed;right:0;left:0}.overflow-scroll.padding>.scroll.overscroll{padding:10px}@-webkit-keyframes refresh-spin{0%{-webkit-transform:translate3d(0,0,0) rotate(0)}100%{-webkit-transform:translate3d(0,0,0) rotate(180deg)}}@keyframes refresh-spin{0%{transform:translate3d(0,0,0) rotate(0)}100%{transform:translate3d(0,0,0) rotate(180deg)}}@-webkit-keyframes refresh-spin-back{0%{-webkit-transform:translate3d(0,0,0) rotate(180deg)}100%{-webkit-transform:translate3d(0,0,0) rotate(0)}}@keyframes refresh-spin-back{0%{transform:translate3d(0,0,0) rotate(180deg)}100%{transform:translate3d(0,0,0) rotate(0)}}.spinner{stroke:#444;fill:#444}.spinner svg{width:28px;height:28px}.spinner.spinner-light{stroke:#fff;fill:#fff}.spinner.spinner-stable{stroke:#f8f8f8;fill:#f8f8f8}.spinner.spinner-positive{stroke:#387ef5;fill:#387ef5}.spinner.spinner-calm{stroke:#11c1f3;fill:#11c1f3}.spinner.spinner-balanced{stroke:#33cd5f;fill:#33cd5f}.spinner.spinner-assertive{stroke:#ef473a;fill:#ef473a}.spinner.spinner-energized{stroke:#ffc900;fill:#ffc900}.spinner.spinner-royal{stroke:#886aea;fill:#886aea}.spinner.spinner-dark{stroke:#444;fill:#444}.spinner-android{stroke:#4b8bf4}.spinner-ios,.spinner-ios-small{stroke:#69717d}.spinner-spiral .stop1{stop-color:#fff;stop-opacity:0}.spinner-spiral.spinner-light .stop1{stop-color:#444}.spinner-spiral.spinner-light .stop2{stop-color:#fff}.spinner-spiral.spinner-stable .stop2{stop-color:#f8f8f8}.spinner-spiral.spinner-positive .stop2{stop-color:#387ef5}.spinner-spiral.spinner-calm .stop2{stop-color:#11c1f3}.spinner-spiral.spinner-balanced .stop2{stop-color:#33cd5f}.spinner-spiral.spinner-assertive .stop2{stop-color:#ef473a}.spinner-spiral.spinner-energized .stop2{stop-color:#ffc900}.spinner-spiral.spinner-royal .stop2{stop-color:#886aea}.spinner-spiral.spinner-dark .stop2{stop-color:#444}form{margin:0 0 1.42857}legend{margin-bottom:1.42857;padding:0;width:100%;border:1px solid #ddd;color:#444;font-size:21px;line-height:2.85714}.item-input,.item-input-inset{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;overflow:hidden}legend small{color:#f8f8f8;font-size:1.07143}button,input,label,select,textarea{font-weight:400;font-size:14px;line-height:1.42857}.item-input{display:flex;-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center;position:relative;padding:6px 0 5px 16px}.item-input input{-webkit-border-radius:0;border-radius:0;-webkit-box-flex:1;-webkit-flex:1 220px;-moz-box-flex:1;-moz-flex:1 220px;-ms-flex:1 220px;flex:1 220px;appearance:none;margin:0;padding-right:24px;background-color:transparent}.item-input .button .icon{-webkit-box-flex:0;-webkit-flex:0 0 24px;-moz-box-flex:0;-moz-flex:0 0 24px;-ms-flex:0 0 24px;flex:0 0 24px;position:static;display:inline-block;height:auto;text-align:center;font-size:16px}.item-input .button-bar{-webkit-border-radius:0;border-radius:0;-webkit-box-flex:1;-webkit-flex:1 0 220px;-moz-box-flex:1;-moz-flex:1 0 220px;-ms-flex:1 0 220px;flex:1 0 220px;appearance:none}.item-input .icon{min-width:14px}.platform-windowsphone .item-input input{flex-shrink:1}.item-input-inset,.range{-webkit-box-align:center}.item-input-inset{display:flex;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center;position:relative;padding:10.67px}.item-input-wrapper{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-box-flex:1;-webkit-flex:1 0;-moz-box-flex:1;-moz-flex:1 0;-ms-flex:1 0;flex:1 0;-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center;-webkit-border-radius:4px;border-radius:4px;padding-right:8px;padding-left:8px;background:#eee}.item-input-inset .item-input-wrapper input{padding-left:4px;height:29px;background:0 0;line-height:18px}.item-input-wrapper~.button{margin-left:10.67px}.input-label{display:table;padding:7px 10px 7px 0;max-width:200px;width:35%;color:#444;font-size:16px}.placeholder-icon{color:#aaa}.placeholder-icon:first-child{padding-right:6px}.placeholder-icon:last-child{padding-left:6px}.item-stacked-label{display:block;background-color:transparent;box-shadow:none}.item-stacked-label .icon,.item-stacked-label .input-label{display:inline-block;padding:4px 0 0;vertical-align:middle}.item-stacked-label input,.item-stacked-label textarea{-webkit-border-radius:2px;border-radius:2px;padding:4px 8px 3px 0;border:none;background-color:#fff}.item-stacked-label input{overflow:hidden;height:46px}.item-select.item-stacked-label select{position:relative;padding:0;max-width:90%;direction:ltr;white-space:pre-wrap;margin:-3px}.item-floating-label{display:block;background-color:transparent;box-shadow:none}.item-floating-label .input-label{position:relative;padding:5px 0 0;opacity:0;top:10px;-webkit-transition:opacity .15s ease-in,top .2s linear;transition:opacity .15s ease-in,top .2s linear}.item-floating-label .input-label.has-input{opacity:1;top:0;-webkit-transition:opacity .15s ease-in,top .2s linear;transition:opacity .15s ease-in,top .2s linear}input[type=search],input[type=text],input[type=password],input[type=datetime],input[type=datetime-local],input[type=date],input[type=month],input[type=time],input[type=week],input[type=number],input[type=email],input[type=url],input[type=tel],input[type=color],textarea{display:block;padding-top:2px;padding-left:0;height:34px;color:#111;vertical-align:middle;font-size:14px;line-height:16px;border:0}.platform-android input[type=datetime-local],.platform-android input[type=date],.platform-android input[type=month],.platform-android input[type=time],.platform-android input[type=week],.platform-ios input[type=datetime-local],.platform-ios input[type=date],.platform-ios input[type=month],.platform-ios input[type=time],.platform-ios input[type=week]{padding-top:8px}.item-input input,.item-input textarea{width:100%}textarea{padding-left:0;height:auto}textarea::-moz-placeholder{color:#aaa}textarea:-ms-input-placeholder{color:#aaa}textarea::-webkit-input-placeholder{color:#aaa;text-indent:-3px}input[type=radio],input[type=checkbox]{margin:0;line-height:normal}.item-input input[type=button],.item-input input[type=reset],.item-input input[type=submit],.item-input input[type=radio],.item-input input[type=checkbox],.item-input input[type=file],.item-input input[type=image]{width:auto}input[type=file]{line-height:34px}.cloned-text-input+input,.cloned-text-input+textarea,.previous-input-focus{position:absolute!important;left:-9999px;width:200px}input::-moz-placeholder,textarea::-moz-placeholder{color:#aaa}input:-ms-input-placeholder,textarea:-ms-input-placeholder{color:#aaa}input::-webkit-input-placeholder,textarea::-webkit-input-placeholder{color:#aaa;text-indent:0}input[disabled],input[readonly]:not(.cloned-text-input),select[disabled],select[readonly],textarea[disabled],textarea[readonly]:not(.cloned-text-input){background-color:#f8f8f8;cursor:not-allowed}.button,.checkbox,.item-radio:hover,.item-select select,.toggle .track{cursor:pointer}input[type=radio][disabled],input[type=radio][readonly],input[type=checkbox][disabled],input[type=checkbox][readonly]{background-color:transparent}.checkbox{position:relative;display:inline-block;padding:7px}.checkbox .checkbox-icon:before,.checkbox input:before{border-color:#ddd}.checkbox input:checked+.checkbox-icon:before,.checkbox input:checked:before{background:#387ef5;border-color:#387ef5}.checkbox-light .checkbox-icon:before,.checkbox-light input:before{border-color:#ddd}.checkbox-light input:checked+.checkbox-icon:before,.checkbox-light input:checked:before{background:#ddd;border-color:#ddd}.checkbox-stable .checkbox-icon:before,.checkbox-stable input:before{border-color:#b2b2b2}.checkbox-stable input:checked+.checkbox-icon:before,.checkbox-stable input:checked:before{background:#b2b2b2;border-color:#b2b2b2}.checkbox-positive .checkbox-icon:before,.checkbox-positive input:before{border-color:#387ef5}.checkbox-positive input:checked+.checkbox-icon:before,.checkbox-positive input:checked:before{background:#387ef5;border-color:#387ef5}.checkbox-calm .checkbox-icon:before,.checkbox-calm input:before{border-color:#11c1f3}.checkbox-calm input:checked+.checkbox-icon:before,.checkbox-calm input:checked:before{background:#11c1f3;border-color:#11c1f3}.checkbox-assertive .checkbox-icon:before,.checkbox-assertive input:before{border-color:#ef473a}.checkbox-assertive input:checked+.checkbox-icon:before,.checkbox-assertive input:checked:before{background:#ef473a;border-color:#ef473a}.checkbox-balanced .checkbox-icon:before,.checkbox-balanced input:before{border-color:#33cd5f}.checkbox-balanced input:checked+.checkbox-icon:before,.checkbox-balanced input:checked:before{background:#33cd5f;border-color:#33cd5f}.checkbox-energized .checkbox-icon:before,.checkbox-energized input:before{border-color:#ffc900}.checkbox-energized input:checked+.checkbox-icon:before,.checkbox-energized input:checked:before{background:#ffc900;border-color:#ffc900}.checkbox-royal .checkbox-icon:before,.checkbox-royal input:before{border-color:#886aea}.checkbox-royal input:checked+.checkbox-icon:before,.checkbox-royal input:checked:before{background:#886aea;border-color:#886aea}.checkbox-dark .checkbox-icon:before,.checkbox-dark input:before{border-color:#444}.checkbox-dark input:checked+.checkbox-icon:before,.checkbox-dark input:checked:before{background:#444;border-color:#444}.checkbox input:disabled+.checkbox-icon:before,.checkbox input:disabled:before{border-color:#ddd}.checkbox input:disabled:checked+.checkbox-icon:before,.checkbox input:disabled:checked:before{background:#ddd}.checkbox.checkbox-input-hidden input{display:none!important}.checkbox input,.checkbox-icon{position:relative;width:28px;height:28px;display:block;border:0;background:0 0;cursor:pointer;-webkit-appearance:none}.checkbox input:before,.checkbox-icon:before{display:table;width:100%;height:100%;border-width:1px;border-style:solid;border-radius:28px;background:#fff;content:' ';-webkit-transition:background-color 20ms ease-in-out;transition:background-color 20ms ease-in-out}.checkbox input:checked:before,input:checked+.checkbox-icon:before{border-width:2px}.checkbox input:after,.checkbox-icon:after{-webkit-transition:opacity 50ms ease-in-out;transition:opacity 50ms ease-in-out;-webkit-transform:rotate(-45deg);transform:rotate(-45deg);position:absolute;top:33%;left:25%;display:table;width:14px;height:6px;border:1px solid #fff;border-top:0;border-right:0;content:' ';opacity:0}.checkbox-square .checkbox-icon:before,.checkbox-square input:before,.platform-android .checkbox-platform .checkbox-icon:before,.platform-android .checkbox-platform input:before{border-radius:2px;width:72%;height:72%;margin-top:14%;margin-left:14%;border-width:2px}.checkbox-square .checkbox-icon:after,.checkbox-square input:after,.platform-android .checkbox-platform .checkbox-icon:after,.platform-android .checkbox-platform input:after{border-width:2px;top:19%;left:25%;width:13px;height:7px}.platform-android .item-checkbox-right .checkbox-square .checkbox-icon::after{top:31%}.grade-c .checkbox input:after,.grade-c .checkbox-icon:after{-webkit-transform:rotate(0);transform:rotate(0);top:3px;left:4px;border:none;color:#fff;content:'\\2713';font-weight:700;font-size:20px}.checkbox input:checked:after,input:checked+.checkbox-icon:after{opacity:1}.item-checkbox{padding-left:60px}.item-checkbox.active{box-shadow:none}.item-checkbox .checkbox{position:absolute;top:50%;right:8px;left:8px;z-index:3;margin-top:-21px}.item-checkbox.item-checkbox-right{padding-right:60px;padding-left:16px}.item-checkbox-right .checkbox input,.item-checkbox-right .checkbox-icon{float:right}.item-toggle{pointer-events:none}.toggle{position:relative;display:inline-block;pointer-events:auto;margin:-5px;padding:5px}.toggle input:checked+.track{border-color:#4cd964;background-color:#4cd964}.toggle.dragging .handle{background-color:#f2f2f2!important}.toggle.toggle-light input:checked+.track{border-color:#ddd;background-color:#ddd}.toggle.toggle-stable input:checked+.track{border-color:#b2b2b2;background-color:#b2b2b2}.toggle.toggle-positive input:checked+.track{border-color:#387ef5;background-color:#387ef5}.toggle.toggle-calm input:checked+.track{border-color:#11c1f3;background-color:#11c1f3}.toggle.toggle-assertive input:checked+.track{border-color:#ef473a;background-color:#ef473a}.toggle.toggle-balanced input:checked+.track{border-color:#33cd5f;background-color:#33cd5f}.toggle.toggle-energized input:checked+.track{border-color:#ffc900;background-color:#ffc900}.toggle.toggle-royal input:checked+.track{border-color:#886aea;background-color:#886aea}.toggle.toggle-dark input:checked+.track{border-color:#444;background-color:#444}.toggle input{display:none}.toggle .track{-webkit-transition-timing-function:ease-in-out;transition-timing-function:ease-in-out;-webkit-transition-duration:.3s;transition-duration:.3s;-webkit-transition-property:background-color,border;transition-property:background-color,border;display:inline-block;width:51px;height:31px;border:2px solid #e6e6e6;border-radius:20px;background-color:#fff;content:' ';pointer-events:none}.platform-android4_2 .toggle .track{-webkit-background-clip:padding-box}.toggle .handle{-webkit-transition:.3s cubic-bezier(0,1.1,1,1.1);transition:.3s cubic-bezier(0,1.1,1,1.1);-webkit-transition-property:background-color,transform;transition-property:background-color,transform;position:absolute;display:block;width:27px;height:27px;border-radius:27px;background-color:#fff;top:7px;left:7px;box-shadow:0 2px 7px rgba(0,0,0,.35),0 1px 1px rgba(0,0,0,.15)}.toggle .handle:before{position:absolute;top:-4px;left:-21.5px;padding:18.5px 34px;content:\" \"}.toggle input:checked+.track .handle{-webkit-transform:translate3d(20px,0,0);transform:translate3d(20px,0,0);background-color:#fff}.item-toggle.active{box-shadow:none}.item-toggle,.item-toggle.item-complex .item-content{padding-right:99px}.item-toggle.item-complex{padding-right:0}.item-toggle .toggle{position:absolute;top:10px;right:16px;z-index:3}.toggle input:disabled+.track{opacity:.6}.toggle-small .track{border:0;width:34px;height:15px;background:#9e9e9e}.toggle-small input:checked+.track{background:rgba(0,150,137,.5)}.toggle-small .handle{top:2px;left:4px;width:21px;height:21px;box-shadow:0 2px 5px rgba(0,0,0,.25)}.toggle-small input:checked+.track .handle{-webkit-transform:translate3d(16px,0,0);transform:translate3d(16px,0,0);background:#009689}.toggle-small.item-toggle .toggle{top:19px}.toggle-small .toggle-light input:checked+.track{background-color:rgba(221,221,221,.5)}.toggle-small .toggle-light input:checked+.track .handle{background-color:#ddd}.toggle-small .toggle-stable input:checked+.track{background-color:rgba(178,178,178,.5)}.toggle-small .toggle-stable input:checked+.track .handle{background-color:#b2b2b2}.toggle-small .toggle-positive input:checked+.track{background-color:rgba(56,126,245,.5)}.toggle-small .toggle-positive input:checked+.track .handle{background-color:#387ef5}.toggle-small .toggle-calm input:checked+.track{background-color:rgba(17,193,243,.5)}.toggle-small .toggle-calm input:checked+.track .handle{background-color:#11c1f3}.toggle-small .toggle-assertive input:checked+.track{background-color:rgba(239,71,58,.5)}.toggle-small .toggle-assertive input:checked+.track .handle{background-color:#ef473a}.toggle-small .toggle-balanced input:checked+.track{background-color:rgba(51,205,95,.5)}.toggle-small .toggle-balanced input:checked+.track .handle{background-color:#33cd5f}.toggle-small .toggle-energized input:checked+.track{background-color:rgba(255,201,0,.5)}.toggle-small .toggle-energized input:checked+.track .handle{background-color:#ffc900}.toggle-small .toggle-royal input:checked+.track{background-color:rgba(136,106,234,.5)}.toggle-small .toggle-royal input:checked+.track .handle{background-color:#886aea}.toggle-small .toggle-dark input:checked+.track{background-color:rgba(68,68,68,.5)}.toggle-small .toggle-dark input:checked+.track .handle{background-color:#444}.item-radio{padding:0}.item-radio .item-content{padding-right:64px}.item-radio .radio-icon{position:absolute;top:0;right:0;z-index:3;visibility:hidden;padding:14px;height:100%;font-size:24px}.item-radio input{position:absolute;left:-9999px}.item-radio input:checked+.radio-content .item-content{background:#f7f7f7}.item-radio input:checked+.radio-content .radio-icon{visibility:visible}.block:after,.invisible{visibility:hidden}.range input{overflow:hidden;margin-top:5px;margin-bottom:5px;padding-right:2px;padding-left:1px;width:auto;height:43px;outline:0;background:-webkit-gradient(linear,50% 0,50% 100%,color-stop(0,#ccc),color-stop(100%,#ccc));background:linear-gradient(to right,#ccc 0,#ccc 100%);background-position:center;background-size:99% 2px;background-repeat:no-repeat;-webkit-appearance:none}.range input::-moz-focus-outer{border:0}.range input::-webkit-slider-thumb{position:relative;width:28px;height:28px;border-radius:50%;background-color:#fff;box-shadow:0 0 2px rgba(0,0,0,.3),0 3px 5px rgba(0,0,0,.2);cursor:pointer;-webkit-appearance:none;border:0}.range input::-webkit-slider-thumb:before{position:absolute;top:13px;left:-2001px;width:2000px;height:2px;background:#444;content:' '}.range input::-webkit-slider-thumb:after{position:absolute;top:-15px;left:-15px;padding:30px;content:' '}.range input::-ms-fill-lower{height:2px;background:#444}.range{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center;padding:2px 11px}.range.range-light input::-webkit-slider-thumb:before{background:#ddd}.range.range-light input::-ms-fill-lower{background:#ddd}.range.range-stable input::-webkit-slider-thumb:before{background:#b2b2b2}.range.range-stable input::-ms-fill-lower{background:#b2b2b2}.range.range-positive input::-webkit-slider-thumb:before{background:#387ef5}.range.range-positive input::-ms-fill-lower{background:#387ef5}.range.range-calm input::-webkit-slider-thumb:before{background:#11c1f3}.range.range-calm input::-ms-fill-lower{background:#11c1f3}.range.range-balanced input::-webkit-slider-thumb:before{background:#33cd5f}.range.range-balanced input::-ms-fill-lower{background:#33cd5f}.range.range-assertive input::-webkit-slider-thumb:before{background:#ef473a}.range.range-assertive input::-ms-fill-lower{background:#ef473a}.range.range-energized input::-webkit-slider-thumb:before{background:#ffc900}.range.range-energized input::-ms-fill-lower{background:#ffc900}.range.range-royal input::-webkit-slider-thumb:before{background:#886aea}.range.range-royal input::-ms-fill-lower{background:#886aea}.range.range-dark input::-webkit-slider-thumb:before{background:#444}.range.range-dark input::-ms-fill-lower{background:#444}.range .icon{-webkit-box-flex:0;-webkit-flex:0;-moz-box-flex:0;-moz-flex:0;-ms-flex:0;flex:0;display:block;min-width:24px;text-align:center;font-size:24px}.range input{-webkit-box-flex:1;-webkit-flex:1;-moz-box-flex:1;-moz-flex:1;-ms-flex:1;flex:1;display:block;margin-right:10px;margin-left:10px}.range-label{-webkit-box-flex:0;-webkit-flex:0 0 auto;-moz-box-flex:0;-moz-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;display:block;white-space:nowrap}.range-label:first-child{padding-left:5px}.range input+.range-label{padding-right:5px;padding-left:0}.platform-windowsphone .range input{height:auto}.item-select{position:relative}.item-select select{-webkit-appearance:none;-moz-appearance:none;appearance:none;position:absolute;top:0;bottom:0;right:0;padding:0 48px 0 16px;max-width:65%;border:none;background:#fff;color:#333;text-indent:.01px;text-overflow:'';white-space:nowrap;font-size:14px;direction:rtl}.item-select select::-ms-expand{display:none}.item-select option{direction:ltr}.item-select:after{position:absolute;top:50%;right:16px;margin-top:-3px;width:0;height:0;border-top:5px solid;border-right:5px solid transparent;border-left:5px solid transparent;color:#999;content:\"\";pointer-events:none}.button-full>button.button,button.button-block,button.button-full,input.button.button-block,progress{width:100%}.item-select.item-light select{background:#fff;color:#444}.item-select.item-stable select{background:#f8f8f8;color:#444}.item-select.item-stable .input-label,.item-select.item-stable:after{color:#666}.item-select.item-positive select{background:#387ef5;color:#fff}.item-select.item-positive .input-label,.item-select.item-positive:after{color:#fff}.item-select.item-calm select{background:#11c1f3;color:#fff}.item-select.item-calm .input-label,.item-select.item-calm:after{color:#fff}.item-select.item-assertive select{background:#ef473a;color:#fff}.item-select.item-assertive .input-label,.item-select.item-assertive:after{color:#fff}.item-select.item-balanced select{background:#33cd5f;color:#fff}.item-select.item-balanced .input-label,.item-select.item-balanced:after{color:#fff}.item-select.item-energized select{background:#ffc900;color:#fff}.item-select.item-energized .input-label,.item-select.item-energized:after{color:#fff}.item-select.item-royal select{background:#886aea;color:#fff}.item-select.item-royal .input-label,.item-select.item-royal:after{color:#fff}.item-select.item-dark select{background:#444;color:#fff}.item-select.item-dark .input-label,.item-select.item-dark:after{color:#fff}select[multiple],select[size]{height:auto}progress{display:block;margin:15px auto}.button{border-color:transparent;background-color:#f8f8f8;color:#444;position:relative;display:inline-block;margin:0;padding:0 12px;min-width:52px;min-height:47px;border-width:1px;border-style:solid;border-radius:4px;vertical-align:top;text-align:center;font-size:16px;line-height:42px}.button:hover{color:#444;text-decoration:none}.button.activated,.button.active{background-color:#e5e5e5}.button:after{position:absolute;top:-6px;right:-6px;bottom:-6px;left:-6px;content:' '}.button .icon{vertical-align:top;pointer-events:none}.button .icon:before,.button.icon-left:before,.button.icon-right:before,.button.icon:before{display:inline-block;padding:0 0 1px;vertical-align:inherit;font-size:24px;line-height:41px;pointer-events:none}.button.icon-left:before{float:left;padding-right:.2em;padding-left:0}.button.icon-right:before{float:right;padding-right:0;padding-left:.2em}.button.button-block,.button.button-full{margin-top:10px;margin-bottom:10px}.button.button-light{border-color:transparent;background-color:#fff;color:#444}.button.button-light:hover{color:#444;text-decoration:none}.button.button-light.activated,.button.button-light.active{background-color:#fafafa}.button.button-light.button-clear{border-color:transparent;background:0 0;box-shadow:none;color:#ddd}.button.button-light.button-icon{border-color:transparent;background:0 0}.button.button-light.button-outline{border-color:#ddd;background:0 0;color:#ddd}.button.button-light.button-outline.activated,.button.button-light.button-outline.active{background-color:#ddd;box-shadow:none;color:#fff}.button.button-stable{border-color:transparent;background-color:#f8f8f8;color:#444}.button.button-stable:hover{color:#444;text-decoration:none}.button.button-stable.activated,.button.button-stable.active{background-color:#e5e5e5}.button.button-stable.button-clear,.button.button-stable.button-icon{border-color:transparent;background:0 0}.button.button-stable.button-clear{box-shadow:none;color:#b2b2b2}.button.button-stable.button-outline{border-color:#b2b2b2;background:0 0;color:#b2b2b2}.button.button-positive.button-clear,.button.button-positive.button-icon{border-color:transparent;background:0 0}.button.button-stable.button-outline.activated,.button.button-stable.button-outline.active{background-color:#b2b2b2;box-shadow:none;color:#fff}.button.button-positive{border-color:transparent;background-color:#387ef5;color:#fff}.button.button-positive:hover{color:#fff;text-decoration:none}.button.button-positive.activated,.button.button-positive.active{background-color:#0c60ee}.button.button-positive.button-clear{box-shadow:none;color:#387ef5}.button.button-positive.button-outline{border-color:#387ef5;background:0 0;color:#387ef5}.button.button-positive.button-outline.activated,.button.button-positive.button-outline.active{background-color:#387ef5;box-shadow:none;color:#fff}.button.button-calm{border-color:transparent;background-color:#11c1f3;color:#fff}.button.button-calm:hover{color:#fff;text-decoration:none}.button.button-calm.activated,.button.button-calm.active{background-color:#0a9dc7}.button.button-calm.button-clear,.button.button-calm.button-icon{border-color:transparent;background:0 0}.button.button-calm.button-clear{box-shadow:none;color:#11c1f3}.button.button-calm.button-outline{border-color:#11c1f3;background:0 0;color:#11c1f3}.button.button-assertive.button-clear,.button.button-assertive.button-icon{border-color:transparent;background:0 0}.button.button-calm.button-outline.activated,.button.button-calm.button-outline.active{background-color:#11c1f3;box-shadow:none;color:#fff}.button.button-assertive{border-color:transparent;background-color:#ef473a;color:#fff}.button.button-assertive:hover{color:#fff;text-decoration:none}.button.button-assertive.activated,.button.button-assertive.active{background-color:#e42112}.button.button-assertive.button-clear{box-shadow:none;color:#ef473a}.button.button-assertive.button-outline{border-color:#ef473a;background:0 0;color:#ef473a}.button.button-assertive.button-outline.activated,.button.button-assertive.button-outline.active{background-color:#ef473a;box-shadow:none;color:#fff}.button.button-balanced{border-color:transparent;background-color:#33cd5f;color:#fff}.button.button-balanced:hover{color:#fff;text-decoration:none}.button.button-balanced.activated,.button.button-balanced.active{background-color:#28a54c}.button.button-balanced.button-clear,.button.button-balanced.button-icon{border-color:transparent;background:0 0}.button.button-balanced.button-clear{box-shadow:none;color:#33cd5f}.button.button-balanced.button-outline{border-color:#33cd5f;background:0 0;color:#33cd5f}.button.button-energized.button-clear,.button.button-energized.button-icon{border-color:transparent;background:0 0}.button.button-balanced.button-outline.activated,.button.button-balanced.button-outline.active{background-color:#33cd5f;box-shadow:none;color:#fff}.button.button-energized{border-color:transparent;background-color:#ffc900;color:#fff}.button.button-energized:hover{color:#fff;text-decoration:none}.button.button-energized.activated,.button.button-energized.active{background-color:#e6b500}.button.button-energized.button-clear{box-shadow:none;color:#ffc900}.button.button-energized.button-outline{border-color:#ffc900;background:0 0;color:#ffc900}.button.button-energized.button-outline.activated,.button.button-energized.button-outline.active{background-color:#ffc900;box-shadow:none;color:#fff}.button.button-royal{border-color:transparent;background-color:#886aea;color:#fff}.button.button-royal:hover{color:#fff;text-decoration:none}.button.button-royal.activated,.button.button-royal.active{background-color:#6b46e5}.button.button-royal.button-clear,.button.button-royal.button-icon{border-color:transparent;background:0 0}.button.button-royal.button-clear{box-shadow:none;color:#886aea}.button.button-royal.button-outline{border-color:#886aea;background:0 0;color:#886aea}.button.button-dark.button-clear,.button.button-dark.button-icon{border-color:transparent;background:0 0}.button.button-royal.button-outline.activated,.button.button-royal.button-outline.active{background-color:#886aea;box-shadow:none;color:#fff}.button.button-dark{border-color:transparent;background-color:#444;color:#fff}.button.button-dark:hover{color:#fff;text-decoration:none}.button.button-dark.activated,.button.button-dark.active{background-color:#262626}.button.button-dark.button-clear{box-shadow:none;color:#444}.button.button-dark.button-outline{border-color:#444;background:0 0;color:#444}.button.button-dark.button-outline.activated,.button.button-dark.button-outline.active{background-color:#444;box-shadow:none;color:#fff}.button-small{padding:2px 4px 1px;min-width:28px;min-height:30px;font-size:12px;line-height:26px}.button-small .icon:before,.button-small.icon-left:before,.button-small.icon-right:before,.button-small.icon:before{font-size:16px;line-height:19px;margin-top:3px}.button-large{padding:0 16px;min-width:68px;min-height:59px;font-size:20px;line-height:53px}.button-large .icon:before,.button-large.icon-left:before,.button-large.icon-right:before,.button-large.icon:before{padding-bottom:2px;font-size:32px;line-height:51px}.button-clear,.button-icon{-webkit-transition:opacity .1s;padding:0 6px;border-color:transparent;background:0 0}.button-icon{transition:opacity .1s;min-width:initial}.button-icon.button.activated,.button-icon.button.active{border-color:transparent;background:0 0;box-shadow:none;opacity:.3}.button-icon .icon:before,.button-icon.icon:before{font-size:32px}.button-clear{transition:opacity .1s;max-height:42px;box-shadow:none}.button-clear.button-clear{border-color:transparent;background:0 0;box-shadow:none;color:#b2b2b2}.button-clear.button-icon{border-color:transparent;background:0 0}.button-clear.activated,.button-clear.active{opacity:.3}.button-outline{-webkit-transition:opacity .1s;transition:opacity .1s;background:0 0;box-shadow:none}.button-outline.button-outline{border-color:#b2b2b2;background:0 0;color:#b2b2b2}.button-outline.button-outline.activated,.button-outline.button-outline.active{background-color:#b2b2b2;box-shadow:none;color:#fff}.padding>.button.button-block:first-child{margin-top:0}.button-block{display:block;clear:both}.button-full,.button-full>.button{display:block;margin-right:0;margin-left:0;border-right-width:0;border-left-width:0;border-radius:0}a.button{text-decoration:none}a.button .icon:before,a.button.icon-left:before,a.button.icon-right:before,a.button.icon:before{margin-top:2px}.button.disabled,.button[disabled]{opacity:.4;cursor:default!important;pointer-events:none}.button-bar{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-box-flex:1;-webkit-flex:1;-moz-box-flex:1;-moz-flex:1;-ms-flex:1;flex:1;width:100%}.button-bar.button-bar-inline{display:block;width:auto}.button-bar.button-bar-inline:after,.button-bar.button-bar-inline:before{display:table;content:\"\";line-height:0}.button-bar.button-bar-inline>.button{width:auto;display:inline-block;float:left}.button-bar.bar-light>.button{border-color:#ddd}.button-bar.bar-stable>.button{border-color:#b2b2b2}.button-bar.bar-positive>.button{border-color:#0c60ee}.button-bar.bar-calm>.button{border-color:#0a9dc7}.button-bar.bar-assertive>.button{border-color:#e42112}.button-bar.bar-balanced>.button{border-color:#28a54c}.button-bar.bar-energized>.button{border-color:#e6b500}.button-bar.bar-royal>.button{border-color:#6b46e5}.button-bar.bar-dark>.button{border-color:#111}.button-bar>.button{-webkit-box-flex:1;-webkit-flex:1;-moz-box-flex:1;-moz-flex:1;-ms-flex:1;flex:1;display:block;overflow:hidden;padding:0 16px;width:0;border-width:1px 0 1px 1px;border-radius:0;text-align:center;white-space:nowrap}.col,.full-image,.row{width:100%}.button-bar>.button .icon:before,.button-bar>.button:before{line-height:44px}.button-bar>.button:first-child{border-radius:4px 0 0 4px}.button-bar>.button:last-child{border-right-width:1px;border-radius:0 4px 4px 0}.button-bar>.button:only-child,.rounded{border-radius:4px}.button-bar>.button-small .icon:before,.button-bar>.button-small:before{line-height:28px}.row{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;padding:5px}.row-wrap{-webkit-flex-wrap:wrap;-moz-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap}.row-no-padding,.row-no-padding>.col{padding:0}.row+.row{margin-top:-5px;padding-top:0}.col{-webkit-box-flex:1;-webkit-flex:1;-moz-box-flex:1;-moz-flex:1;-ms-flex:1;flex:1;display:block;padding:5px}.row-top{-webkit-box-align:start;-ms-flex-align:start;-webkit-align-items:flex-start;-moz-align-items:flex-start;align-items:flex-start}.row-bottom{-webkit-box-align:end;-ms-flex-align:end;-webkit-align-items:flex-end;-moz-align-items:flex-end;align-items:flex-end}.row-center{-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center}.row-stretch{-webkit-box-align:stretch;-ms-flex-align:stretch;-webkit-align-items:stretch;-moz-align-items:stretch;align-items:stretch}.row-baseline{-webkit-box-align:baseline;-ms-flex-align:baseline;-webkit-align-items:baseline;-moz-align-items:baseline;align-items:baseline}.col-top{-webkit-align-self:flex-start;-moz-align-self:flex-start;-ms-flex-item-align:start;align-self:flex-start}.col-bottom{-webkit-align-self:flex-end;-moz-align-self:flex-end;-ms-flex-item-align:end;align-self:flex-end}.col-center{-webkit-align-self:center;-moz-align-self:center;-ms-flex-item-align:center;align-self:center}.col-10,.col-20{-webkit-box-flex:0}.col-offset-10{margin-left:10%}.col-offset-20{margin-left:20%}.col-offset-25{margin-left:25%}.col-offset-33,.col-offset-34{margin-left:33.3333%}.col-offset-50{margin-left:50%}.col-offset-66,.col-offset-67{margin-left:66.6666%}.col-offset-75{margin-left:75%}.col-offset-80{margin-left:80%}.col-offset-90{margin-left:90%}.col-10{-webkit-flex:0 0 10%;-moz-box-flex:0;-moz-flex:0 0 10%;-ms-flex:0 0 10%;flex:0 0 10%;max-width:10%}.col-20{-webkit-flex:0 0 20%;-moz-box-flex:0;-moz-flex:0 0 20%;-ms-flex:0 0 20%;flex:0 0 20%;max-width:20%}.col-25{-webkit-box-flex:0;-webkit-flex:0 0 25%;-moz-box-flex:0;-moz-flex:0 0 25%;-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%}.col-33,.col-34{-webkit-box-flex:0;-webkit-flex:0 0 33.3333%;-moz-box-flex:0;-moz-flex:0 0 33.3333%;-ms-flex:0 0 33.3333%;flex:0 0 33.3333%;max-width:33.3333%}.col-40,.col-50{-webkit-box-flex:0}.col-40{-webkit-flex:0 0 40%;-moz-box-flex:0;-moz-flex:0 0 40%;-ms-flex:0 0 40%;flex:0 0 40%;max-width:40%}.col-50{-webkit-flex:0 0 50%;-moz-box-flex:0;-moz-flex:0 0 50%;-ms-flex:0 0 50%;flex:0 0 50%;max-width:50%}.col-60{-webkit-box-flex:0;-webkit-flex:0 0 60%;-moz-box-flex:0;-moz-flex:0 0 60%;-ms-flex:0 0 60%;flex:0 0 60%;max-width:60%}.col-66,.col-67{-webkit-box-flex:0;-webkit-flex:0 0 66.6666%;-moz-box-flex:0;-moz-flex:0 0 66.6666%;-ms-flex:0 0 66.6666%;flex:0 0 66.6666%;max-width:66.6666%}.col-75,.col-80{-webkit-box-flex:0}.col-75{-webkit-flex:0 0 75%;-moz-box-flex:0;-moz-flex:0 0 75%;-ms-flex:0 0 75%;flex:0 0 75%;max-width:75%}.col-80{-webkit-flex:0 0 80%;-moz-box-flex:0;-moz-flex:0 0 80%;-ms-flex:0 0 80%;flex:0 0 80%;max-width:80%}.col-90{-webkit-box-flex:0;-webkit-flex:0 0 90%;-moz-box-flex:0;-moz-flex:0 0 90%;-ms-flex:0 0 90%;flex:0 0 90%;max-width:90%}@media (max-width:567px){.responsive-sm{-webkit-box-direction:normal;-moz-box-direction:normal;-webkit-box-orient:vertical;-moz-box-orient:vertical;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}.responsive-sm .col,.responsive-sm .col-10,.responsive-sm .col-20,.responsive-sm .col-25,.responsive-sm .col-33,.responsive-sm .col-34,.responsive-sm .col-50,.responsive-sm .col-66,.responsive-sm .col-67,.responsive-sm .col-75,.responsive-sm .col-80,.responsive-sm .col-90{-webkit-box-flex:1;-webkit-flex:1;-moz-box-flex:1;-moz-flex:1;-ms-flex:1;flex:1;margin-bottom:15px;margin-left:0;max-width:100%;width:100%}}@media (max-width:767px){.responsive-md{-webkit-box-direction:normal;-moz-box-direction:normal;-webkit-box-orient:vertical;-moz-box-orient:vertical;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}.responsive-md .col,.responsive-md .col-10,.responsive-md .col-20,.responsive-md .col-25,.responsive-md .col-33,.responsive-md .col-34,.responsive-md .col-50,.responsive-md .col-66,.responsive-md .col-67,.responsive-md .col-75,.responsive-md .col-80,.responsive-md .col-90{-webkit-box-flex:1;-webkit-flex:1;-moz-box-flex:1;-moz-flex:1;-ms-flex:1;flex:1;margin-bottom:15px;margin-left:0;max-width:100%;width:100%}}@media (max-width:1023px){.responsive-lg{-webkit-box-direction:normal;-moz-box-direction:normal;-webkit-box-orient:vertical;-moz-box-orient:vertical;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}.responsive-lg .col,.responsive-lg .col-10,.responsive-lg .col-20,.responsive-lg .col-25,.responsive-lg .col-33,.responsive-lg .col-34,.responsive-lg .col-50,.responsive-lg .col-66,.responsive-lg .col-67,.responsive-lg .col-75,.responsive-lg .col-80,.responsive-lg .col-90{-webkit-box-flex:1;-webkit-flex:1;-moz-box-flex:1;-moz-flex:1;-ms-flex:1;flex:1;margin-bottom:15px;margin-left:0;max-width:100%;width:100%}}.hide{display:none}.opacity-hide{opacity:0}.grade-b .opacity-hide,.grade-c .opacity-hide{opacity:1;display:none}.show{display:block}.opacity-show{opacity:1}.keyboard-open .hide-on-keyboard-open{display:none}.keyboard-open .bar-footer.hide-on-keyboard-open+.pane .has-footer,.keyboard-open .tabs.hide-on-keyboard-open+.pane .has-tabs{bottom:0}.inline{display:inline-block}.block,.block:after{display:block;clear:both}.disable-pointer-events{pointer-events:none}.enable-pointer-events{pointer-events:auto}.disable-user-behavior{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-touch-callout:none;-ms-touch-action:none;-ms-content-zooming:none}.click-block{position:absolute;top:0;right:0;bottom:0;left:0;opacity:0;z-index:99999;transform:translate3d(0,0,0);overflow:hidden}.click-block-hide{-webkit-transform:translate3d(-9999px,0,0);transform:translate3d(-9999px,0,0)}.no-resize{resize:none}.block:after{height:0;content:\".\"}.clearfix:after,.clearfix:before{display:table;content:\"\";line-height:0}.clearfix:after{clear:both}.padding{padding:10px}.padding-top,.padding-vertical{padding-top:10px}.padding-horizontal,.padding-right{padding-right:10px}.padding-bottom,.padding-vertical{padding-bottom:10px}.padding-horizontal,.padding-left{padding-left:10px}.iframe-wrapper{position:fixed;-webkit-overflow-scrolling:touch;overflow:scroll}.iframe-wrapper iframe{height:100%;width:100%}.light,a.light{color:#fff}.light-bg{background-color:#fff}.light-border{border-color:#ddd}.stable,a.stable{color:#f8f8f8}.stable-bg{background-color:#f8f8f8}.stable-border{border-color:#b2b2b2}.positive,a.positive{color:#387ef5}.positive-bg{background-color:#387ef5}.positive-border{border-color:#0c60ee}.calm,a.calm{color:#11c1f3}.calm-bg{background-color:#11c1f3}.calm-border{border-color:#0a9dc7}.assertive,a.assertive{color:#ef473a}.assertive-bg{background-color:#ef473a}.assertive-border{border-color:#e42112}.balanced,a.balanced{color:#33cd5f}.balanced-bg{background-color:#33cd5f}.balanced-border{border-color:#28a54c}.energized,a.energized{color:#ffc900}.energized-bg{background-color:#ffc900}.energized-border{border-color:#e6b500}.royal,a.royal{color:#886aea}.royal-bg{background-color:#886aea}.royal-border{border-color:#6b46e5}.dark,a.dark{color:#444}.dark-bg{background-color:#444}.dark-border{border-color:#111}[collection-repeat]{left:0!important;top:0!important;position:absolute!important;z-index:1}.collection-repeat-container{position:relative;z-index:1}.collection-repeat-after-container{z-index:0;display:block}[nav-view-transition=ios] [nav-view=active],[nav-view-transition=ios][nav-view-direction=forward] [nav-view=entering],[nav-view-transition=ios][nav-view-direction=back] [nav-view=leaving],[nav-view-transition=android] [nav-view=active],[nav-view-transition=android][nav-view-direction=forward] [nav-view=entering],[nav-view-transition=android][nav-view-direction=back] [nav-view=leaving]{z-index:3}[nav-view-transition=ios][nav-view-direction=forward] [nav-view=leaving],[nav-view-transition=ios][nav-view-direction=back] [nav-view=entering],[nav-view-transition=android][nav-view-direction=forward] [nav-view=leaving],[nav-view-transition=android][nav-view-direction=back] [nav-view=entering]{z-index:2}[nav-bar-transition=ios] [nav-bar=entering],[nav-bar-transition=ios] [nav-bar=active],[nav-bar-transition=android] [nav-bar=entering],[nav-bar-transition=android] [nav-bar=active]{z-index:10}.collection-repeat-after-container.horizontal{display:inline-block}.ng-cloak,.ng-hide:not(.ng-hide-animate),.x-ng-cloak,[data-ng-cloak],[ng-cloak],[ng\\:cloak],[x-ng-cloak]{display:none!important}[nav-bar-transition=ios] [nav-bar=cached] .header-item,[nav-bar-transition=android] [nav-bar=cached] .header-item,[nav-bar=cached],[nav-view=cached]{display:none}.platform-ios.platform-cordova:not(.fullscreen) .bar-header:not(.bar-subheader){height:64px}.platform-ios.platform-cordova:not(.fullscreen) .bar-header:not(.bar-subheader).item-input-inset .item-input-wrapper{margin-top:19px!important}.platform-ios.platform-cordova:not(.fullscreen) .bar-header:not(.bar-subheader)>*{margin-top:20px}.platform-ios.platform-cordova:not(.fullscreen) .bar-subheader,.platform-ios.platform-cordova:not(.fullscreen) .has-header,.platform-ios.platform-cordova:not(.fullscreen) .tabs-top>.tabs,.platform-ios.platform-cordova:not(.fullscreen) .tabs.tabs-top{top:64px}.platform-ios.platform-cordova:not(.fullscreen) .has-subheader{top:108px}.platform-ios.platform-cordova:not(.fullscreen) .has-header.has-tabs-top{top:113px}.platform-ios.platform-cordova:not(.fullscreen) .has-header.has-subheader.has-tabs-top{top:157px}.platform-ios.platform-cordova .popover .bar-header:not(.bar-subheader){height:44px}.platform-ios.platform-cordova .popover .bar-header:not(.bar-subheader).item-input-inset .item-input-wrapper{margin-top:-1px}.platform-ios.platform-cordova .popover .bar-header:not(.bar-subheader)>*{margin-top:0}.platform-ios.platform-cordova .popover .bar-subheader,.platform-ios.platform-cordova .popover .has-header{top:44px}.platform-ios.platform-cordova .popover .has-subheader{top:88px}.platform-ios.platform-cordova.status-bar-hide{margin-bottom:20px}@media (orientation:landscape){.platform-ios.platform-browser.platform-ipad{position:fixed}}.platform-c:not(.enable-transitions) *{-webkit-transition:none!important;transition:none!important}.slide-in-up{-webkit-transform:translate3d(0,100%,0);transform:translate3d(0,100%,0)}.slide-in-up.ng-enter,.slide-in-up>.ng-enter{-webkit-transition:all cubic-bezier(.1,.7,.1,1) .4s;transition:all cubic-bezier(.1,.7,.1,1) .4s}.slide-in-up.ng-enter-active,.slide-in-up>.ng-enter-active{-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}.slide-in-up.ng-leave,.slide-in-up>.ng-leave{-webkit-transition:all ease-in-out 250ms;transition:all ease-in-out 250ms}@-webkit-keyframes scaleOut{from{-webkit-transform:scale(1);opacity:1}to{-webkit-transform:scale(.8);opacity:0}}@keyframes scaleOut{from{transform:scale(1);opacity:1}to{transform:scale(.8);opacity:0}}@-webkit-keyframes superScaleIn{from{-webkit-transform:scale(1.2);opacity:0}to{-webkit-transform:scale(1);opacity:1}}@keyframes superScaleIn{from{transform:scale(1.2);opacity:0}to{transform:scale(1);opacity:1}}[nav-view-transition=ios] [nav-view=entering],[nav-view-transition=ios] [nav-view=leaving]{-webkit-transition-duration:.5s;transition-duration:.5s;-webkit-transition-timing-function:cubic-bezier(.36,.66,.04,1);transition-timing-function:cubic-bezier(.36,.66,.04,1);-webkit-transition-property:opacity,-webkit-transform,box-shadow;transition-property:opacity,transform,box-shadow}[nav-view-transition=ios][nav-view-direction=forward],[nav-view-transition=ios][nav-view-direction=back]{background-color:#000}[nav-bar-transition=ios] [nav-bar=entering] .bar,[nav-bar-transition=ios] [nav-bar=active] .bar,[nav-bar-transition=android] [nav-bar=entering] .bar,[nav-bar-transition=android] [nav-bar=active] .bar{background:0 0}[nav-bar-transition=ios] .back-text,[nav-bar-transition=ios] .buttons,[nav-bar-transition=ios] .title{-webkit-transition-duration:.5s;transition-duration:.5s;-webkit-transition-timing-function:cubic-bezier(.36,.66,.04,1);transition-timing-function:cubic-bezier(.36,.66,.04,1);-webkit-transition-property:opacity,-webkit-transform;transition-property:opacity,transform}[nav-bar-transition=ios] [nav-bar=cached]{display:block}[nav-view-transition=android] [nav-view=entering],[nav-view-transition=android] [nav-view=leaving]{-webkit-transition-duration:.2s;transition-duration:.2s;-webkit-transition-timing-function:cubic-bezier(.4,.6,.2,1);transition-timing-function:cubic-bezier(.4,.6,.2,1);-webkit-transition-property:-webkit-transform;transition-property:transform}[nav-bar-transition=android] .buttons,[nav-bar-transition=android] .title{-webkit-transition-duration:.2s;transition-duration:.2s;-webkit-transition-timing-function:cubic-bezier(.4,.6,.2,1);transition-timing-function:cubic-bezier(.4,.6,.2,1);-webkit-transition-property:opacity;transition-property:opacity}[nav-bar-transition=android] [nav-bar=cached]{display:block}[nav-swipe=fast] .back-text,[nav-swipe=fast] .buttons,[nav-swipe=fast] .title,[nav-swipe=fast] [nav-view]{-webkit-transition-duration:50ms;transition-duration:50ms;-webkit-transition-timing-function:linear;transition-timing-function:linear}[nav-swipe=slow] .back-text,[nav-swipe=slow] .buttons,[nav-swipe=slow] .title,[nav-swipe=slow] [nav-view]{-webkit-transition-duration:160ms;transition-duration:160ms;-webkit-transition-timing-function:linear;transition-timing-function:linear}[nav-view=stage]{opacity:0;-webkit-transition-duration:0;transition-duration:0}[nav-bar=stage] .back-text,[nav-bar=stage] .buttons,[nav-bar=stage] .title{position:absolute;opacity:0;-webkit-transition-duration:0s;transition-duration:0s}");
})
(function(factory) {
  if (typeof define == 'function' && define.amd)
    define([], factory);
  else if (typeof module == 'object' && module.exports && typeof require == 'function')
    module.exports = factory();
  else
    factory();
});
//# sourceMappingURL=build.js.map